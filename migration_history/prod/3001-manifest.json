{
  "contracts": {
    "AddyRegistry": {
      "address": "0x49B08551e452cA99da7dE9B3a60E39e5f10C13CD",
      "abi": [
        {
          "name": "NewAddyRegistered",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyIdUpdated",
          "inputs": [
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyIdDisabled",
          "inputs": [
            {
              "name": "prevAddy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyRegistryGovernorSet",
          "inputs": [
            {
              "name": "governor",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddy",
          "inputs": [
            {
              "name": "_addy",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewAddy",
          "inputs": [
            {
              "name": "_addy",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyUpdate",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            },
            {
              "name": "_newAddy",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAddy",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            },
            {
              "name": "_newAddy",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyDisable",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableAddy",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddy",
          "inputs": [
            {
              "name": "_addy",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyId",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyId",
          "inputs": [
            {
              "name": "_addy",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddy",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyInfo",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyDescription",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddyId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyToId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_governor",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/core/AddyRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nstruct AddyInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nevent NewAddyRegistered:\n    addr: indexed(address)\n    addyId: uint256\n    description: String[64]\n\nevent AddyIdUpdated:\n    newAddr: indexed(address)\n    prevAddy: indexed(address)\n    addyId: uint256\n    version: uint256\n    description: String[64]\n\nevent AddyIdDisabled:\n    prevAddy: indexed(address)\n    addyId: uint256\n    version: uint256\n    description: String[64]\n\nevent AddyRegistryGovernorSet:\n    governor: indexed(address)\n\n# core\naddyInfo: public(HashMap[uint256, AddyInfo])\naddyToId: public(HashMap[address, uint256])\nnumAddys: public(uint256)\n\n# config\ngovernor: public(address)\n\n\n@deploy\ndef __init__(_governor: address):\n    assert _governor != empty(address) # dev: invalid governor\n    self.governor = _governor\n\n    # start at 1 index\n    self.numAddys = 1\n\n\n#################\n# Register Addy #\n#################\n\n\n@view\n@external\ndef isValidNewAddy(_addy: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be registered as a new core contract\n    @dev Validates address is non-zero, is a contract, and hasn't been registered before\n    @param _addy The address to validate\n    @return True if address can be registered as new core contract, False otherwise\n    \"\"\"\n    return self._isValidNewAddy(_addy)\n\n\n@view\n@internal\ndef _isValidNewAddy(_addy: address) -> bool:\n    if _addy == empty(address) or not _addy.is_contract:\n        return False\n    return self.addyToId[_addy] == 0\n\n\n@external\ndef registerNewAddy(_addy: address, _description: String[64]) -> uint256:\n    \"\"\"\n    @notice Register a new core contract address in the registry\n    @dev Only callable by governor\n    @param _addy The address of the contract to register\n    @param _description A brief description of the contract's functionality\n    @return The assigned ID if registration successful, 0 if failed\n    \"\"\"\n    assert msg.sender == self.governor # dev: no perms\n\n    if not self._isValidNewAddy(_addy):\n        return 0\n\n    data: AddyInfo = AddyInfo(\n        addr=_addy,\n        version=1,\n        lastModified=block.timestamp,\n        description=_description,\n    )\n\n    addyId: uint256 = self.numAddys\n    self.addyToId[_addy] = addyId\n    self.numAddys = addyId + 1\n    self.addyInfo[addyId] = data\n\n    log NewAddyRegistered(addr=_addy, addyId=addyId, description=_description)\n    return addyId\n\n\n###############\n# Update Addy #\n###############\n\n\n@view\n@external\ndef isValidAddyUpdate(_addyId: uint256, _newAddy: address) -> bool:\n    \"\"\"\n    @notice Check if a core contract update operation would be valid\n    @dev Validates ID exists and new address is valid\n    @param _addyId The ID of the contract to update\n    @param _newAddy The proposed new address for the contract\n    @return True if update would be valid, False otherwise\n    \"\"\"\n    return self._isValidAddyUpdate(_addyId, _newAddy, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyUpdate(_addyId: uint256, _newAddy: address, _prevAddy: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    if not self._isValidNewAddy(_newAddy):\n        return False\n    return _newAddy != _prevAddy\n\n\n@external\ndef updateAddy(_addyId: uint256, _newAddy: address) -> bool:\n    \"\"\"\n    @notice Update the address of an existing core contract\n    @dev Only callable by governor. Updates version and timestamp.\n    @param _addyId The ID of the contract to update\n    @param _newAddy The new address for the contract\n    @return True if update successful, False otherwise\n    \"\"\"\n    assert msg.sender == self.governor # dev: no perms\n\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddy: address = data.addr # needed for later\n\n    if not self._isValidAddyUpdate(_addyId, _newAddy, prevAddy):\n        return False\n\n    # save new data\n    data.addr = _newAddy\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[_newAddy] = _addyId\n\n    # handle previous addr\n    if prevAddy != empty(address):\n        self.addyToId[prevAddy] = 0\n\n    log AddyIdUpdated(newAddr=_newAddy, prevAddy=prevAddy, addyId=_addyId, version=data.version, description=data.description)\n    return True\n\n\n################\n# Disable Addy #\n################\n\n\n@view\n@external\ndef isValidAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Check if a core contract can be disabled\n    @dev Validates ID exists and has a non-empty address\n    @param _addyId The ID of the contract to check\n    @return True if contract can be disabled, False otherwise\n    \"\"\"\n    return self._isValidAddyDisable(_addyId, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyDisable(_addyId: uint256, _prevAddy: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    return _prevAddy != empty(address)\n\n\n@external\ndef disableAddy(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Disable a core contract by setting its address to empty\n    @dev Only callable by governor. Updates version and timestamp.\n    @param _addyId The ID of the contract to disable\n    @return True if disable successful, False otherwise\n    \"\"\"\n    assert msg.sender == self.governor # dev: no perms\n\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddy: address = data.addr # needed for later\n\n    if not self._isValidAddyDisable(_addyId, prevAddy):\n        return False\n\n    # save new data\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[prevAddy] = 0\n\n    log AddyIdDisabled(prevAddy=prevAddy, addyId=_addyId, version=data.version, description=data.description)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidAddy(_addy: address) -> bool:\n    \"\"\"\n    @notice Check if an address is a registered core contract\n    @dev Returns true if address has a non-zero ID\n    @param _addy The address to check\n    @return True if address is a registered core contract, False otherwise\n    \"\"\"\n    return self.addyToId[_addy] != 0\n\n\n@view\n@external\ndef isValidAddyId(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Check if a core contract ID is valid\n    @dev ID must be non-zero and less than total number of contracts\n    @param _addyId The ID to check\n    @return True if ID is valid, False otherwise\n    \"\"\"\n    return self._isValidAddyId(_addyId)\n\n\n@view\n@internal\ndef _isValidAddyId(_addyId: uint256) -> bool:\n    return _addyId != 0 and _addyId < self.numAddys\n\n\n# addy getters\n\n\n@view\n@external\ndef getAddyId(_addy: address) -> uint256:\n    \"\"\"\n    @notice Get the ID of a core contract from its address\n    @dev Returns 0 if address is not registered\n    @param _addy The address to query\n    @return The ID associated with the address\n    \"\"\"\n    return self.addyToId[_addy]\n\n\n@view\n@external\ndef getAddy(_addyId: uint256) -> address:\n    \"\"\"\n    @notice Get the address of a core contract from its ID\n    @dev Returns empty address if ID is invalid or contract is disabled\n    @param _addyId The ID to query\n    @return The address associated with the ID\n    \"\"\"\n    return self.addyInfo[_addyId].addr\n\n\n@view\n@external\ndef getAddyInfo(_addyId: uint256) -> AddyInfo:\n    \"\"\"\n    @notice Get all information about a core contract\n    @dev Returns complete AddyInfo struct including address, version, timestamp and description\n    @param _addyId The ID to query\n    @return AddyInfo struct containing all contract information\n    \"\"\"\n    return self.addyInfo[_addyId]\n\n\n@view\n@external\ndef getAddyDescription(_addyId: uint256) -> String[64]:\n    \"\"\"\n    @notice Get the description of a core contract\n    @dev Returns empty string if ID is invalid\n    @param _addyId The ID to query\n    @return The description associated with the ID\n    \"\"\"\n    return self.addyInfo[_addyId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumAddys() -> uint256:\n    \"\"\"\n    @notice Get the total number of registered core contracts\n    @dev Returns number of contracts minus 1 since indexing starts at 1\n    @return The total number of registered core contracts\n    \"\"\"\n    return self.numAddys - 1\n\n\n@view\n@external\ndef getLastAddy() -> address:\n    \"\"\"\n    @notice Get the address of the most recently registered core contract\n    @dev Returns the address at index (numAddys - 1)\n    @return The address of the last registered contract\n    \"\"\"\n    lastIndex: uint256 = self.numAddys - 1\n    return self.addyInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastAddyId() -> uint256:\n    \"\"\"\n    @notice Get the ID of the most recently registered core contract\n    @dev Returns numAddys - 1 since indexing starts at 1\n    @return The ID of the last registered contract\n    \"\"\"\n    return self.numAddys - 1\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidGovernor(_newGovernor: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be set as the new governor\n    @dev Address must be a contract and different from current governor\n    @param _newGovernor The address to validate\n    @return True if address can be set as governor, False otherwise\n    \"\"\"\n    return self._isValidGovernor(_newGovernor)\n\n\n@view\n@internal \ndef _isValidGovernor(_newGovernor: address) -> bool:\n    if not _newGovernor.is_contract or _newGovernor == empty(address):\n        return False\n    return _newGovernor != self.governor\n\n\n@external\ndef setGovernor(_newGovernor: address) -> bool:\n    \"\"\"\n    @notice Set a new governor address\n    @dev Only callable by current governor\n    @param _newGovernor The address to set as governor\n    @return True if governor was set successfully, False otherwise\n    \"\"\"\n    assert msg.sender == self.governor # dev: no perms\n    if not self._isValidGovernor(_newGovernor):\n        return False\n    self.governor = _newGovernor\n    log AddyRegistryGovernorSet(governor=_newGovernor)\n    return True\n",
            "sha256sum": "3a96b5fd118694a0e1f2c141faa5bb0f6fa6cb1320f5e4401b2ff064a00f1848"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AddyRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "49d726d6ff01eea4ad00f2a10f6a684326bf28cc29dcc3b90cef375bea420226"
      },
      "args": "0000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7"
    },
    "WalletFunds": {
      "address": "0x6A5263B0645c7dFd2788eF46f95f210E947e0743",
      "abi": [
        {
          "name": "UserWalletDeposit",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletWithdrawal",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundVaultTokenAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletSwap",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "swapAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "toAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletBorrow",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "borrowAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "borrowAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletRepayDebt",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "paymentAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "paymentAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "remainingDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletLiquidityAdded",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "liqAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletLiquidityRemoved",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": false
            },
            {
              "name": "removedAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "removedAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "refundedLpAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletFundsTransferred",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletRewardsClaimed",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": false
            },
            {
              "name": "market",
              "type": "address",
              "indexed": false
            },
            {
              "name": "rewardToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "rewardAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "proof",
              "type": "bytes32",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletEthConvertedToWeth",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "paidEth",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "weth",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletWethConvertedToEth",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "weth",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletSubscriptionPaid",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "paidThroughBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTransactionFeePaid",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "fee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "action",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTrialFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountRecovered",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "remainingAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletNftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initialize",
          "inputs": [
            {
              "name": "_walletConfig",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_trialFundsAsset",
              "type": "address"
            },
            {
              "name": "_trialFundsInitialAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverTrialFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverTrialFunds",
          "inputs": [
            {
              "name": "_opportunities",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "walletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsAsset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsInitialAmount",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyRegistry",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "wethAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "initialized",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "interfaces/LegoCredit.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (address, uint256, uint256):\n    ...\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (address, uint256, uint256, uint256):\n    ...\n",
            "sha256sum": "d7579ab6500e6022fa9cb561479c40d062438d29e002dcc5f66036eea7dc0856"
          },
          "interfaces/UserWalletInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n# struct SwapInstruction:\n#     legoId: uint256\n#     amountIn: uint256\n#     minAmountOut: uint256\n#     tokenPath: DynArray[address, 5]\n#     poolPath: DynArray[address, 5 - 1]\n\n\n# @external\n# def swapTokens(_swapInstructions: DynArray[SwapInstruction, 5]) -> (uint256, uint256, uint256):\n#     ...\n\n\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    ...\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    ...\n\n\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    ...\n\n\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    ...\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    ...\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    ...\n",
            "sha256sum": "b6f85ddff061e77069cceb9d110c05c679a6ea34b68f3ff69c95c1b07d83c453"
          },
          "contracts/core/WalletFunds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n# pragma optimize codesize\n\nimplements: UserWalletInterface\nfrom interfaces import LegoDex\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\nfrom interfaces import LegoCredit\nfrom interfaces import UserWalletInterface\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC721\n\ninterface WalletConfig:\n    def handleSubscriptionsAndPermissions(_agent: address, _action: ActionType, _assets: DynArray[address, MAX_ASSETS], _legoIds: DynArray[uint256, MAX_LEGOS], _cd: CoreData) -> (SubPaymentInfo, SubPaymentInfo): nonpayable\n    def getAvailableTxAmount(_asset: address, _wantedAmount: uint256, _shouldCheckTrialFunds: bool, _cd: CoreData = empty(CoreData)) -> uint256: view\n    def canTransferToRecipient(_recipient: address) -> bool: view\n    def owner() -> address: view\n\ninterface LegoRegistry:\n    def getUnderlyingForUser(_user: address, _asset: address) -> uint256: view\n    def getUnderlyingAsset(_vaultToken: address) -> address: view\n    def getLegoAddr(_legoId: uint256) -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getEthUsdValue(_amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface WethContract:\n    def withdraw(_amount: uint256): nonpayable\n    def deposit(): payable\n\ninterface PriceSheets:\n    def getTransactionFeeData(_user: address, _action: ActionType) -> (uint256, address): view\n\ninterface AgentFactory:\n    def agentBlacklist(_agentAddr: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct CoreData:\n    owner: address\n    wallet: address\n    walletConfig: address\n    addyRegistry: address\n    legoRegistry: address\n    priceSheets: address\n    oracleRegistry: address\n    trialFundsAsset: address\n    trialFundsInitialAmount: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct TrialFundsOpp:\n    legoId: uint256\n    vaultToken: address\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nevent UserWalletDeposit:\n    signer: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    vaultTokenAmountReceived: uint256\n    refundAssetAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletWithdrawal:\n    signer: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    vaultTokenAmountBurned: uint256\n    refundVaultTokenAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletSwap:\n    signer: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    swapAmount: uint256\n    toAmount: uint256\n    refundAssetAmount: uint256\n    usdValue: uint256\n    numTokens: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletBorrow:\n    signer: indexed(address)\n    borrowAsset: indexed(address)\n    borrowAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletRepayDebt:\n    signer: indexed(address)\n    paymentAsset: indexed(address)\n    paymentAmount: uint256\n    usdValue: uint256\n    remainingDebt: uint256\n    legoId: uint256\n    legoAddr: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletLiquidityAdded:\n    signer: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    liqAmountA: uint256\n    liqAmountB: uint256\n    liquidityAdded: uint256\n    pool: address\n    usdValue: uint256\n    refundAssetAmountA: uint256\n    refundAssetAmountB: uint256\n    nftTokenId: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletLiquidityRemoved:\n    signer: indexed(address)\n    tokenA: indexed(address)\n    tokenB: address\n    removedAmountA: uint256\n    removedAmountB: uint256\n    usdValue: uint256\n    isDepleted: bool\n    liquidityRemoved: uint256\n    lpToken: indexed(address)\n    refundedLpAmount: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletFundsTransferred:\n    signer: indexed(address)\n    recipient: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    usdValue: uint256\n    isSignerAgent: bool\n\nevent UserWalletRewardsClaimed:\n    signer: address\n    market: address\n    rewardToken: address\n    rewardAmount: uint256\n    usdValue: uint256\n    proof: bytes32\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletEthConvertedToWeth:\n    signer: indexed(address)\n    amount: uint256\n    paidEth: uint256\n    weth: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletWethConvertedToEth:\n    signer: indexed(address)\n    amount: uint256\n    weth: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletSubscriptionPaid:\n    recipient: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    isAgent: bool\n\nevent UserWalletTransactionFeePaid:\n    recipient: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    fee: uint256\n    action: ActionType\n\nevent UserWalletTrialFundsRecovered:\n    asset: indexed(address)\n    amountRecovered: uint256\n    remainingAmount: uint256\n\nevent UserWalletNftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    owner: indexed(address)\n\n# core\nwalletConfig: public(address)\n\n# trial funds info\ntrialFundsAsset: public(address)\ntrialFundsInitialAmount: public(uint256)\n\n# config\naddyRegistry: public(address)\nwethAddr: public(address)\ninitialized: public(bool)\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\nLEGO_REGISTRY_ID: constant(uint256) = 2\nPRICE_SHEETS_ID: constant(uint256) = 3\nORACLE_REGISTRY_ID: constant(uint256) = 4\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_ASSETS: constant(uint256) = 25\nMAX_LEGOS: constant(uint256) = 20\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UnderscoreErc721\"\nAPI_VERSION: constant(String[28]) = \"0.0.1\"\n\n\n@deploy\ndef __init__():\n    # make sure original reference contract can't be initialized\n    self.initialized = True\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@external\ndef initialize(\n    _walletConfig: address,\n    _addyRegistry: address,\n    _wethAddr: address,\n    _trialFundsAsset: address,\n    _trialFundsInitialAmount: uint256,\n) -> bool:\n    \"\"\"\n    @notice Sets up the initial state of the wallet template\n    @dev Can only be called once and sets core contract parameters\n    @param _walletConfig The address of the wallet config contract\n    @param _addyRegistry The address of the core registry contract\n    @param _wethAddr The address of the WETH contract\n    @param _trialFundsAsset The address of the gift asset\n    @param _trialFundsInitialAmount The amount of the gift asset\n    @return bool True if initialization was successful\n    \"\"\"\n    assert not self.initialized # dev: can only initialize once\n    self.initialized = True\n\n    assert empty(address) not in [_walletConfig, _addyRegistry, _wethAddr] # dev: invalid addrs\n    self.walletConfig = _walletConfig\n    self.addyRegistry = _addyRegistry\n    self.wethAddr = _wethAddr\n\n    # trial funds info\n    if _trialFundsAsset != empty(address) and _trialFundsInitialAmount != 0:   \n        self.trialFundsAsset = _trialFundsAsset\n        self.trialFundsInitialAmount = _trialFundsInitialAmount\n\n    return True\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    \"\"\"\n    @notice Returns the current API version of the contract\n    @dev Returns a constant string representing the contract version\n    @return String[28] The API version string\n    \"\"\"\n    return API_VERSION\n\n\n###########\n# Deposit #\n###########\n\n\n@nonreentrant\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    \"\"\"\n    @notice Deposits tokens into a specified lego integration and vault\n    @param _legoId The ID of the lego to use for deposit\n    @param _asset The address of the token to deposit\n    @param _vault The target vault address\n    @param _amount The amount to deposit (defaults to max)\n    @return uint256 The amount of assets deposited\n    @return address The vault token address\n    @return uint256 The amount of vault tokens received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.DEPOSIT, [_asset], [_legoId], cd)\n    return self._depositTokens(msg.sender, _legoId, _asset, _vault, _amount, isSignerAgent, True, cd)\n\n\n@internal\ndef _depositTokens(\n    _signer: address,\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256,\n    _isSignerAgent: bool,\n    _shouldChargeFees: bool,\n    _cd: CoreData,\n) -> (uint256, address, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # finalize amount\n    amount: uint256 = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_asset, _amount, False, _cd)\n    assert extcall IERC20(_asset).approve(legoAddr, amount, default_return_value=True) # dev: approval failed\n\n    # deposit into lego partner\n    assetAmountDeposited: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    refundAssetAmount: uint256 = 0\n    usdValue: uint256 = 0\n    assetAmountDeposited, vaultToken, vaultTokenAmountReceived, refundAssetAmount, usdValue = extcall LegoYield(legoAddr).depositTokens(_asset, amount, _vault, self)\n    assert extcall IERC20(_asset).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # handle tx fees\n    if _shouldChargeFees:\n        self._handleTransactionFees(_signer, _isSignerAgent, ActionType.DEPOSIT, vaultToken, vaultTokenAmountReceived, _cd.priceSheets)\n\n    log UserWalletDeposit(signer=_signer, asset=_asset, vaultToken=vaultToken, assetAmountDeposited=assetAmountDeposited, vaultTokenAmountReceived=vaultTokenAmountReceived, refundAssetAmount=refundAssetAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return assetAmountDeposited, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@nonreentrant\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    \"\"\"\n    @notice Withdraws tokens from a specified lego integration and vault\n    @param _legoId The ID of the lego to use for withdrawal\n    @param _asset The address of the token to withdraw\n    @param _vaultToken The vault token address\n    @param _vaultTokenAmount The amount of vault tokens to withdraw (defaults to max)\n    @return uint256 The amount of assets received\n    @return uint256 The amount of vault tokens burned\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.WITHDRAWAL, [_asset], [_legoId], cd)\n    return self._withdrawTokens(msg.sender, _legoId, _asset, _vaultToken, _vaultTokenAmount, isSignerAgent, True, cd)\n\n\n@internal\ndef _withdrawTokens(\n    _signer: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256,\n    _isSignerAgent: bool,\n    _shouldChargeFees: bool,\n    _cd: CoreData,\n) -> (uint256, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # finalize amount, this will look at vault token balance (not always 1:1 with underlying asset)\n    withdrawAmount: uint256 = _vaultTokenAmount\n    if _vaultToken != empty(address):\n        withdrawAmount = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_vaultToken, _vaultTokenAmount, False, _cd)\n\n        # some vault tokens require max value approval (comp v3)\n        assert extcall IERC20(_vaultToken).approve(legoAddr, max_value(uint256), default_return_value=True) # dev: approval failed\n\n    assert withdrawAmount != 0 # dev: nothing to withdraw\n\n    # withdraw from lego partner\n    assetAmountReceived: uint256 = 0\n    vaultTokenAmountBurned: uint256 = 0\n    refundVaultTokenAmount: uint256 = 0\n    usdValue: uint256 = 0\n    assetAmountReceived, vaultTokenAmountBurned, refundVaultTokenAmount, usdValue = extcall LegoYield(legoAddr).withdrawTokens(_asset, withdrawAmount, _vaultToken, self)\n\n    # zero out approvals\n    if _vaultToken != empty(address):\n        assert extcall IERC20(_vaultToken).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # handle tx fees\n    if _shouldChargeFees:\n        self._handleTransactionFees(_signer, _isSignerAgent, ActionType.WITHDRAWAL, _asset, assetAmountReceived, _cd.priceSheets)\n\n    log UserWalletWithdrawal(signer=_signer, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, vaultTokenAmountBurned=vaultTokenAmountBurned, refundVaultTokenAmount=refundVaultTokenAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return assetAmountReceived, vaultTokenAmountBurned, usdValue\n\n\n#############\n# Rebalance #\n#############\n\n\n@nonreentrant\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    \"\"\"\n    @notice Withdraws tokens from one lego and deposits them into another (always same asset)\n    @param _fromLegoId The ID of the source lego\n    @param _fromAsset The address of the token to rebalance\n    @param _fromVaultToken The source vault token address\n    @param _toLegoId The ID of the destination lego\n    @param _toVault The destination vault address\n    @param _fromVaultTokenAmount The vault token amount to rebalance (defaults to max)\n    @return uint256 The amount of assets deposited in the destination vault\n    @return address The destination vault token address\n    @return uint256 The amount of destination vault tokens received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REBALANCE, [_fromAsset], [_fromLegoId, _toLegoId], cd)\n\n    # withdraw from the first lego\n    assetAmountReceived: uint256 = 0\n    na: uint256 = 0\n    withdrawUsdValue: uint256 = 0\n    assetAmountReceived, na, withdrawUsdValue = self._withdrawTokens(msg.sender, _fromLegoId, _fromAsset, _fromVaultToken, _fromVaultTokenAmount, isSignerAgent, False, cd)\n\n    # deposit the received assets into the second lego\n    assetAmountDeposited: uint256 = 0\n    newVaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    depositUsdValue: uint256 = 0\n    assetAmountDeposited, newVaultToken, vaultTokenAmountReceived, depositUsdValue = self._depositTokens(msg.sender, _toLegoId, _fromAsset, _toVault, assetAmountReceived, isSignerAgent, False, cd)\n\n    # handle tx fees\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.REBALANCE, newVaultToken, vaultTokenAmountReceived, cd.priceSheets)\n\n    usdValue: uint256 = max(withdrawUsdValue, depositUsdValue)\n    return assetAmountDeposited, newVaultToken, vaultTokenAmountReceived, usdValue\n\n\n########\n# Swap #\n########\n\n\n@nonreentrant\n@external\ndef swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256):\n    \"\"\"\n    @notice Swaps tokens between lego integrations\n    @param _swapInstructions The instructions for the swaps\n    @return uint256 The amount of assets deposited\n    @return uint256 The amount of assets received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    numSwapInstructions: uint256 = len(_swapInstructions)\n    assert numSwapInstructions != 0 # dev: no swaps\n\n    cd: CoreData = self._getCoreData()\n\n    # get high level swap info to check permissions\n    tokenIn: address = empty(address)\n    tokenOut: address = empty(address)\n    initialAmountIn: uint256 = 0\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    tokenIn, tokenOut, initialAmountIn, legoIds = self._getHighLevelSwapInfo(numSwapInstructions, _swapInstructions, cd)\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.SWAP, [tokenIn, tokenOut], legoIds, cd)\n\n    # check if swap token is trial funds asset\n    isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(tokenIn, cd.trialFundsAsset, cd.legoRegistry)\n\n    # perform swap instructions\n    amountIn: uint256 = initialAmountIn\n    lastTokenOut: address = empty(address)\n    lastTokenOutAmount: uint256 = 0\n    lastUsdValue: uint256 = 0\n    for j: uint256 in range(numSwapInstructions, bound=MAX_SWAP_INSTRUCTIONS):\n        i: SwapInstruction = _swapInstructions[j]\n\n        # from lego to lego, must follow the same token path\n        if lastTokenOut != empty(address):\n            newTokenIn: address = i.tokenPath[0]\n            assert lastTokenOut == newTokenIn # dev: invalid token path\n            amountIn = min(lastTokenOutAmount, staticcall IERC20(newTokenIn).balanceOf(self))\n\n        lastTokenOut, lastTokenOutAmount, lastUsdValue = self._performSwapInstruction(i.legoId, amountIn, i.minAmountOut, i.tokenPath, i.poolPath, msg.sender, isSignerAgent, cd.legoRegistry, cd.oracleRegistry)\n\n    # make sure they still have enough trial funds\n    self._checkTrialFundsPostTx(isTrialFundsVaultToken, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n\n    # handle tx fees\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.SWAP, lastTokenOut, lastTokenOutAmount, cd.priceSheets)\n    return initialAmountIn, lastTokenOutAmount, lastUsdValue\n\n\n@internal\ndef _performSwapInstruction(\n    _legoId: uint256,\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _signer: address,\n    _isSignerAgent: bool,\n    _legoRegistry: address,\n    _oracleRegistry: address,\n) -> (address, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # get token in and token out\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[len(_tokenPath) - 1]\n\n    # approve token in\n    assert extcall IERC20(tokenIn).approve(legoAddr, _amountIn, default_return_value=True) # dev: approval failed\n\n    # swap assets via lego partner\n    tokenInAmount: uint256 = 0\n    tokenOutAmount: uint256 = 0\n    refundTokenInAmount: uint256 = 0\n    usdValue: uint256 = 0\n    tokenInAmount, tokenOutAmount, refundTokenInAmount, usdValue = extcall LegoDex(legoAddr).swapTokens(_amountIn, _minAmountOut, _tokenPath, _poolPath, self, _oracleRegistry)\n\n    # reset approvals\n    assert extcall IERC20(tokenIn).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log UserWalletSwap(signer=_signer, tokenIn=tokenIn, tokenOut=tokenOut, swapAmount=tokenInAmount, toAmount=tokenOutAmount, refundAssetAmount=refundTokenInAmount, usdValue=usdValue, numTokens=len(_tokenPath), legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return tokenOut, tokenOutAmount, usdValue\n\n\n@view\n@internal\ndef _getHighLevelSwapInfo(\n    _numSwapInstructions: uint256,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _cd: CoreData,\n) -> (address, address, uint256, DynArray[uint256, MAX_LEGOS]):   \n    firstRoutePath: DynArray[address, MAX_TOKEN_PATH] = _swapInstructions[0].tokenPath\n    firstRouteNumTokens: uint256 = len(firstRoutePath)\n    assert firstRouteNumTokens >= 2 # dev: invalid token path\n\n    # finalize token in and token out\n    tokenIn: address = firstRoutePath[0]\n    tokenOut: address = empty(address)\n    if _numSwapInstructions == 1:\n        tokenOut = firstRoutePath[firstRouteNumTokens - 1]\n\n    else:\n        lastRoutePath: DynArray[address, MAX_TOKEN_PATH] = _swapInstructions[_numSwapInstructions - 1].tokenPath\n        lastRouteNumTokens: uint256 = len(lastRoutePath)\n        assert lastRouteNumTokens >= 2 # dev: invalid token path\n        tokenOut = lastRoutePath[lastRouteNumTokens - 1]\n\n    assert empty(address) not in [tokenIn, tokenOut] # dev: invalid token path\n\n    # get lego ids\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    for i: uint256 in range(_numSwapInstructions, bound=MAX_SWAP_INSTRUCTIONS):\n        legoId: uint256 = _swapInstructions[i].legoId\n        if legoId not in legoIds:\n            legoIds.append(legoId)\n\n    # finalize amount in\n    amountIn: uint256 = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(tokenIn, _swapInstructions[0].amountIn, True, _cd)\n\n    return tokenIn, tokenOut, amountIn, legoIds\n\n\n##################\n# Borrow + Repay #\n##################\n\n\n# borrow\n\n\n@nonreentrant\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    \"\"\"\n    @notice Borrows an asset from a lego integration\n    @param _legoId The ID of the lego to borrow from\n    @param _borrowAsset The address of the asset to borrow\n    @param _amount The amount of the asset to borrow\n    @return address The address of the asset borrowed\n    @return uint256 The amount of the asset borrowed\n    @return uint256 The usd value of the borrowing\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.BORROW, [_borrowAsset], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego can perform this action\n    self._checkLegoAccessForAction(legoAddr)\n\n    # borrow via lego partner\n    borrowAsset: address = empty(address)\n    borrowAmount: uint256 = 0\n    usdValue: uint256 = 0\n    borrowAsset, borrowAmount, usdValue = extcall LegoCredit(legoAddr).borrow(_borrowAsset, _amount, self, cd.oracleRegistry)\n\n    # handle tx fees\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.BORROW, borrowAsset, borrowAmount, cd.priceSheets)\n\n    log UserWalletBorrow(signer=msg.sender, borrowAsset=borrowAsset, borrowAmount=borrowAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return borrowAsset, borrowAmount, usdValue\n\n\n# repay debt\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    \"\"\"\n    @notice Repays debt for a lego integration\n    @param _legoId The ID of the lego to repay debt for\n    @param _paymentAsset The address of the asset to use for repayment\n    @param _paymentAmount The amount of the asset to use for repayment\n    @return address The address of the asset used for repayment\n    @return uint256 The amount of the asset used for repayment\n    @return uint256 The usd value of the repayment\n    @return uint256 The remaining debt\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REPAY, [_paymentAsset], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego can perform this action\n    self._checkLegoAccessForAction(legoAddr)\n\n    # finalize amount\n    paymentAmount: uint256 = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_paymentAsset, _paymentAmount, True, cd)\n\n    # handle tx fees (before actual repayment)\n    txFee: uint256 = self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.REPAY, _paymentAsset, paymentAmount, cd.priceSheets)\n    paymentAmount -= txFee\n\n    # check if payment asset is trial funds asset\n    isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(_paymentAsset, cd.trialFundsAsset, cd.legoRegistry)\n\n    # repay debt via lego partner\n    paymentAsset: address = empty(address)\n    usdValue: uint256 = 0\n    remainingDebt: uint256 = 0\n    assert extcall IERC20(_paymentAsset).approve(legoAddr, paymentAmount, default_return_value=True) # dev: approval failed\n    paymentAsset, paymentAmount, usdValue, remainingDebt = extcall LegoCredit(legoAddr).repayDebt(_paymentAsset, paymentAmount, self, cd.oracleRegistry)\n    assert extcall IERC20(_paymentAsset).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # make sure they still have enough trial funds\n    self._checkTrialFundsPostTx(isTrialFundsVaultToken, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n\n    log UserWalletRepayDebt(signer=msg.sender, paymentAsset=paymentAsset, paymentAmount=paymentAmount, usdValue=usdValue, remainingDebt=remainingDebt, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return paymentAsset, paymentAmount, usdValue, remainingDebt\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    \"\"\"\n    @notice Claims rewards from a lego integration\n    @param _legoId The lego ID to claim rewards from\n    @param _market The market to claim rewards from\n    @param _rewardToken The reward token to claim\n    @param _rewardAmount The reward amount to claim\n    @param _proof The proof to verify the rewards\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # pass in empty action, lego ids, and assets here\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CLAIM_REWARDS, [_rewardToken], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego has access to claim rewards\n    self._checkLegoAccessForAction(legoAddr)\n\n    # pre reward balance\n    preRewardBalance: uint256 = 0\n    if _rewardToken != empty(address):\n        preRewardBalance = staticcall IERC20(_rewardToken).balanceOf(self)\n\n    # claim rewards\n    extcall LegoCommon(legoAddr).claimRewards(self, _market, _rewardToken, _rewardAmount, _proof)\n\n    # post reward balance\n    postRewardBalance: uint256 = 0\n    if _rewardToken != empty(address):\n        postRewardBalance = staticcall IERC20(_rewardToken).balanceOf(self)\n    rewardAmount: uint256 = postRewardBalance - preRewardBalance\n\n    usdValue: uint256 = 0\n    if rewardAmount != 0:\n        usdValue = staticcall OracleRegistry(cd.oracleRegistry).getUsdValue(_rewardToken, rewardAmount)\n\n    # handle tx fees\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.CLAIM_REWARDS, _rewardToken, rewardAmount, cd.priceSheets)\n\n    log UserWalletRewardsClaimed(signer=msg.sender, market=_market, rewardToken=_rewardToken, rewardAmount=rewardAmount, usdValue=usdValue, proof=_proof, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    \"\"\"\n    @notice Adds liquidity to a pool\n    @param _legoId The ID of the lego to use for adding liquidity\n    @param _nftAddr The address of the NFT token contract\n    @param _nftTokenId The ID of the NFT token to use for adding liquidity\n    @param _pool The address of the pool to add liquidity to\n    @param _tokenA The address of the first token to add liquidity\n    @param _tokenB The address of the second token to add liquidity\n    @param _amountA The amount of the first token to add liquidity\n    @param _amountB The amount of the second token to add liquidity\n    @param _tickLower The lower tick of the liquidity range\n    @param _tickUpper The upper tick of the liquidity range\n    @param _minAmountA The minimum amount of the first token to add liquidity\n    @param _minAmountB The minimum amount of the second token to add liquidity\n    @param _minLpAmount The minimum amount of lp token amount to receive\n    @return uint256 The amount of liquidity added\n    @return uint256 The amount of the first token added\n    @return uint256 The amount of the second token added\n    @return uint256 The usd value of the liquidity added\n    @return uint256 The ID of the NFT token used for adding liquidity\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.ADD_LIQ, [_tokenA, _tokenB], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # token a\n    amountA: uint256 = 0\n    isTrialFundsVaultTokenA: bool = False\n    if _amountA != 0:\n        amountA = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_tokenA, _amountA, True, cd)\n\n        # handle tx fee (pre add liquidity)\n        amountAFee: uint256 = self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.ADD_LIQ, _tokenA, amountA, cd.priceSheets)\n        amountA -= amountAFee\n\n        assert extcall IERC20(_tokenA).approve(legoAddr, amountA, default_return_value=True) # dev: approval failed\n        isTrialFundsVaultTokenA = self._isTrialFundsVaultToken(_tokenA, cd.trialFundsAsset, cd.legoRegistry)\n\n    # token b\n    amountB: uint256 = 0\n    isTrialFundsVaultTokenB: bool = False\n    if _amountB != 0:\n        amountB = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_tokenB, _amountB, True, cd)\n\n        # handle tx fee (pre add liquidity)\n        amountBFee: uint256 = self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.ADD_LIQ, _tokenB, amountB, cd.priceSheets)\n        amountB -= amountBFee\n\n        assert extcall IERC20(_tokenB).approve(legoAddr, amountB, default_return_value=True) # dev: approval failed\n        isTrialFundsVaultTokenB = self._isTrialFundsVaultToken(_tokenB, cd.trialFundsAsset, cd.legoRegistry)\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # add liquidity via lego partner\n    liquidityAdded: uint256 = 0\n    liqAmountA: uint256 = 0\n    liqAmountB: uint256 = 0\n    usdValue: uint256 = 0\n    refundAssetAmountA: uint256 = 0\n    refundAssetAmountB: uint256 = 0\n    nftTokenId: uint256 = 0\n    liquidityAdded, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, nftTokenId = extcall LegoDex(legoAddr).addLiquidity(_nftTokenId, _pool, _tokenA, _tokenB, _tickLower, _tickUpper, amountA, amountB, _minAmountA, _minAmountB, _minLpAmount, self, cd.oracleRegistry)\n\n    # validate the nft came back\n    if hasNftLiqPosition:\n        assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n\n    # token a\n    self._checkTrialFundsPostTx(isTrialFundsVaultTokenA, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n    if amountA != 0:\n        assert extcall IERC20(_tokenA).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # token b\n    self._checkTrialFundsPostTx(isTrialFundsVaultTokenB, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n    if amountB != 0:\n        assert extcall IERC20(_tokenB).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log UserWalletLiquidityAdded(signer=msg.sender, tokenA=_tokenA, tokenB=_tokenB, liqAmountA=liqAmountA, liqAmountB=liqAmountB, liquidityAdded=liquidityAdded, pool=_pool, usdValue=usdValue, refundAssetAmountA=refundAssetAmountA, refundAssetAmountB=refundAssetAmountB, nftTokenId=nftTokenId, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return liquidityAdded, liqAmountA, liqAmountB, usdValue, nftTokenId\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    \"\"\"\n    @notice Removes liquidity from a pool\n    @param _legoId The ID of the lego to use for removing liquidity\n    @param _nftAddr The address of the NFT token contract\n    @param _nftTokenId The ID of the NFT token to use for removing liquidity\n    @param _pool The address of the pool to remove liquidity from\n    @param _tokenA The address of the first token to remove liquidity\n    @param _tokenB The address of the second token to remove liquidity\n    @param _liqToRemove The amount of liquidity to remove\n    @param _minAmountA The minimum amount of the first token to remove liquidity\n    @param _minAmountB The minimum amount of the second token to remove liquidity\n    @return uint256 The amount of the first token removed\n    @return uint256 The amount of the second token removed\n    @return uint256 The usd value of the liquidity removed\n    @return bool True if the liquidity moved to lego contract was depleted, false otherwise\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REMOVE_LIQ, [_tokenA, _tokenB], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    lpToken: address = empty(address)\n    liqToRemove: uint256 = _liqToRemove\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # handle lp token\n    else:\n        lpToken = staticcall LegoDex(legoAddr).getLpToken(_pool)\n        liqToRemove = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(lpToken, liqToRemove, False, cd)\n        assert extcall IERC20(lpToken).approve(legoAddr, liqToRemove, default_return_value=True) # dev: approval failed\n\n    # remove liquidity via lego partner\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    usdValue: uint256 = 0\n    liquidityRemoved: uint256 = 0\n    refundedLpAmount: uint256 = 0\n    isDepleted: bool = False\n    amountA, amountB, usdValue, liquidityRemoved, refundedLpAmount, isDepleted = extcall LegoDex(legoAddr).removeLiquidity(_nftTokenId, _pool, _tokenA, _tokenB, lpToken, liqToRemove, _minAmountA, _minAmountB, self, cd.oracleRegistry)\n\n    # validate the nft came back, reset lp token approvals\n    if hasNftLiqPosition:\n        if not isDepleted:\n            assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n    else:\n        assert extcall IERC20(lpToken).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # handle tx fees\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.REMOVE_LIQ, _tokenA, amountA, cd.priceSheets)\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.REMOVE_LIQ, _tokenB, amountB, cd.priceSheets)\n\n    log UserWalletLiquidityRemoved(signer=msg.sender, tokenA=_tokenA, tokenB=_tokenB, removedAmountA=amountA, removedAmountB=amountB, usdValue=usdValue, isDepleted=isDepleted, liquidityRemoved=liquidityRemoved, lpToken=lpToken, refundedLpAmount=refundedLpAmount, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return amountA, amountB, usdValue, isDepleted\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    \"\"\"\n    @notice Transfers funds to a specified recipient\n    @dev Handles both ETH and token transfers with optional amount specification\n    @param _recipient The address to receive the funds\n    @param _amount The amount to transfer (defaults to max)\n    @param _asset The token address (empty for ETH)\n    @return uint256 The amount of funds transferred\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.TRANSFER, [_asset], [], cd)\n    return self._transferFunds(msg.sender, _recipient, _amount, _asset, isSignerAgent, cd)\n\n\n@internal\ndef _transferFunds(\n    _signer: address,\n    _recipient: address,\n    _amount: uint256,\n    _asset: address,\n    _isSignerAgent: bool,\n    _cd: CoreData,\n) -> (uint256, uint256):\n    transferAmount: uint256 = 0\n    usdValue: uint256 = 0\n\n    # validate recipient\n    if _recipient != _cd.owner:\n        assert staticcall WalletConfig(_cd.walletConfig).canTransferToRecipient(_recipient) # dev: recipient not allowed\n\n    # handle eth\n    if _asset == empty(address):\n        transferAmount = min(_amount, self.balance)\n        assert transferAmount != 0 # dev: nothing to transfer\n        send(_recipient, transferAmount)\n        usdValue = staticcall OracleRegistry(_cd.oracleRegistry).getEthUsdValue(transferAmount)\n\n    # erc20 tokens\n    else:\n\n        # check if vault token of trial funds asset\n        isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(_asset, _cd.trialFundsAsset, _cd.legoRegistry)\n        transferAmount = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_asset, _amount, True, _cd)\n\n        # handle tx fees (pre transfer)\n        txFee: uint256 = self._handleTransactionFees(_signer, _isSignerAgent, ActionType.TRANSFER, _asset, transferAmount, _cd.priceSheets)\n        transferAmount -= txFee\n\n        assert extcall IERC20(_asset).transfer(_recipient, transferAmount, default_return_value=True) # dev: transfer failed\n        usdValue = staticcall OracleRegistry(_cd.oracleRegistry).getUsdValue(_asset, transferAmount)\n\n        # make sure they still have enough trial funds\n        self._checkTrialFundsPostTx(isTrialFundsVaultToken, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, _cd.legoRegistry)\n\n    log UserWalletFundsTransferred(signer=_signer, recipient=_recipient, asset=_asset, amount=transferAmount, usdValue=usdValue, isSignerAgent=_isSignerAgent)\n    return transferAmount, usdValue\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@nonreentrant\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    \"\"\"\n    @notice Converts ETH to WETH and optionally deposits into a lego integration and vault\n    @param _amount The amount of ETH to convert (defaults to max)\n    @param _depositLegoId The lego ID to use for deposit (optional)\n    @param _depositVault The vault address for deposit (optional)\n    @return uint256 The amount of assets deposited (if deposit performed)\n    @return address The vault token address (if deposit performed)\n    @return uint256 The amount of vault tokens received (if deposit performed)\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    weth: address = self.wethAddr\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CONVERSION, [weth], [_depositLegoId], cd)\n\n    # convert eth to weth\n    amount: uint256 = min(_amount, self.balance)\n    assert amount != 0 # dev: nothing to convert\n    extcall WethContract(weth).deposit(value=amount)\n    log UserWalletEthConvertedToWeth(signer=msg.sender, amount=amount, paidEth=msg.value, weth=weth, isSignerAgent=isSignerAgent)\n\n    # deposit weth into lego partner\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    if _depositLegoId != 0:\n        depositUsdValue: uint256 = 0\n        amount, vaultToken, vaultTokenAmountReceived, depositUsdValue = self._depositTokens(msg.sender, _depositLegoId, weth, _depositVault, amount, isSignerAgent, True, cd)\n\n    return amount, vaultToken, vaultTokenAmountReceived\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    \"\"\"\n    @notice Converts WETH to ETH and optionally withdraws from a vault first\n    @param _amount The amount of WETH to convert (defaults to max)\n    @param _recipient The address to receive the ETH (optional)\n    @param _withdrawLegoId The lego ID to withdraw from (optional)\n    @param _withdrawVaultToken The vault token to withdraw (optional)\n    @return uint256 The amount of ETH received\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    weth: address = self.wethAddr\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CONVERSION, [weth], [_withdrawLegoId], cd)\n\n    # withdraw weth from lego partner (if applicable)\n    amount: uint256 = _amount\n    usdValue: uint256 = 0\n    if _withdrawLegoId != 0:\n        _na: uint256 = 0\n        amount, _na, usdValue = self._withdrawTokens(msg.sender, _withdrawLegoId, weth, _withdrawVaultToken, _amount, isSignerAgent, True, cd)\n\n    # convert weth to eth\n    amount = min(amount, staticcall IERC20(weth).balanceOf(self))\n    assert amount != 0 # dev: nothing to convert\n    extcall WethContract(weth).withdraw(amount)\n    log UserWalletWethConvertedToEth(signer=msg.sender, amount=amount, weth=weth, isSignerAgent=isSignerAgent)\n\n    # transfer eth to recipient (if applicable)\n    if _recipient != empty(address):\n        amount, usdValue = self._transferFunds(msg.sender, _recipient, amount, empty(address), isSignerAgent, cd)\n\n    return amount\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@internal\ndef _getCoreData() -> CoreData:\n    addyRegistry: address = self.addyRegistry\n    walletConfig: address = self.walletConfig\n    return CoreData(\n        owner=staticcall WalletConfig(walletConfig).owner(),\n        wallet=self,\n        walletConfig=walletConfig,\n        addyRegistry=addyRegistry,\n        legoRegistry=staticcall AddyRegistry(addyRegistry).getAddy(LEGO_REGISTRY_ID),\n        priceSheets=staticcall AddyRegistry(addyRegistry).getAddy(PRICE_SHEETS_ID),\n        oracleRegistry=staticcall AddyRegistry(addyRegistry).getAddy(ORACLE_REGISTRY_ID),\n        trialFundsAsset=self.trialFundsAsset,\n        trialFundsInitialAmount=self.trialFundsInitialAmount,\n    )\n\n\n# payments (subscriptions, transaction fees)\n\n\n@internal\ndef _checkPermsAndHandleSubs(\n    _signer: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n    _cd: CoreData,\n) -> bool:\n    agent: address = _signer\n    if _signer == _cd.owner:\n        agent = empty(address)\n\n    # check if agent is blacklisted\n    if agent != empty(address):\n        agentFactory: address = staticcall AddyRegistry(_cd.addyRegistry).getAddy(AGENT_FACTORY_ID)\n        assert not staticcall AgentFactory(agentFactory).agentBlacklist(agent) # dev: agent is blacklisted\n\n    # handle subscriptions and permissions\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = extcall WalletConfig(_cd.walletConfig).handleSubscriptionsAndPermissions(agent, _action, _assets, _legoIds, _cd)\n\n    # handle protocol subscription payment\n    if protocolSub.amount != 0:\n        assert extcall IERC20(protocolSub.asset).transfer(protocolSub.recipient, protocolSub.amount, default_return_value=True) # dev: protocol subscription payment failed\n        log UserWalletSubscriptionPaid(recipient=protocolSub.recipient, asset=protocolSub.asset, amount=protocolSub.amount, usdValue=protocolSub.usdValue, paidThroughBlock=protocolSub.paidThroughBlock, isAgent=False)\n\n    # handle agent subscription payment\n    if agentSub.amount != 0:\n        assert extcall IERC20(agentSub.asset).transfer(agentSub.recipient, agentSub.amount, default_return_value=True) # dev: agent subscription payment failed\n        log UserWalletSubscriptionPaid(recipient=agent, asset=agentSub.asset, amount=agentSub.amount, usdValue=agentSub.usdValue, paidThroughBlock=agentSub.paidThroughBlock, isAgent=True)\n\n    return agent != empty(address)\n\n\n@internal\ndef _handleTransactionFees(\n    _agent: address,\n    _isSignerAgent: bool,\n    _action: ActionType,\n    _asset: address,\n    _amount: uint256,\n    _priceSheets: address,\n) -> uint256:\n    if not _isSignerAgent or _amount == 0 or _asset == empty(address):\n        return 0\n\n    fee: uint256 = 0\n    recipient: address = empty(address)\n    fee, recipient = staticcall PriceSheets(_priceSheets).getTransactionFeeData(self, _action)\n    if fee == 0 or recipient == empty(address):\n        return 0\n\n    amount: uint256 = min(_amount * fee // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if amount != 0:\n        assert extcall IERC20(_asset).transfer(recipient, amount, default_return_value=True) # dev: protocol tx fee payment failed\n        log UserWalletTransactionFeePaid(recipient=recipient, asset=_asset, amount=amount, fee=fee, action=_action)\n\n    return amount\n\n\n# allow lego to perform action\n\n\n@internal\ndef _checkLegoAccessForAction(_legoAddr: address):\n    targetAddr: address = empty(address)\n    accessAbi: String[64] = empty(String[64])\n    numInputs: uint256 = 0\n    targetAddr, accessAbi, numInputs = staticcall LegoCommon(_legoAddr).getAccessForLego(self)\n\n    # nothing to do here\n    if targetAddr == empty(address):\n        return\n\n    method_abi: bytes4 = convert(slice(keccak256(accessAbi), 0, 4), bytes4)\n    success: bool = False\n    response: Bytes[32] = b\"\"\n\n    # assumes input is: lego addr (operator)\n    if numInputs == 1:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    # assumes input (and order) is: user addr (owner), lego addr (operator)\n    elif numInputs == 2:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    # assumes input (and order) is: user addr (owner), lego addr (operator), allowed bool\n    elif numInputs == 3:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n                convert(True, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    assert success # dev: failed to set operator\n\n\n# trial funds\n\n\n@view\n@internal\ndef _isTrialFundsVaultToken(_asset: address, _trialFundsAsset: address, _legoRegistry: address) -> bool:\n    if _trialFundsAsset == empty(address) or _asset == _trialFundsAsset:\n        return False\n    return _trialFundsAsset == staticcall LegoRegistry(_legoRegistry).getUnderlyingAsset(_asset)\n\n\n@view\n@internal\ndef _checkTrialFundsPostTx(_isTrialFundsVaultToken: bool, _trialFundsAsset: address, _trialFundsInitialAmount: uint256, _legoRegistry: address):\n    if not _isTrialFundsVaultToken:\n        return\n    postUnderlying: uint256 = staticcall LegoRegistry(_legoRegistry).getUnderlyingForUser(self, _trialFundsAsset)\n    assert postUnderlying >= _trialFundsInitialAmount # dev: cannot transfer trial funds vault token\n\n\n@external\ndef recoverTrialFunds(_opportunities: DynArray[TrialFundsOpp, MAX_LEGOS] = []) -> bool:\n    \"\"\"\n    @notice Recovers trial funds from the wallet\n    @param _opportunities Array of trial funds opportunities\n    @return bool True if trial funds were recovered successfully\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    agentFactory: address = staticcall AddyRegistry(cd.addyRegistry).getAddy(AGENT_FACTORY_ID)\n    assert msg.sender == agentFactory # dev: no perms\n\n    # validation\n    assert cd.trialFundsAsset != empty(address) # dev: no trial funds asset\n    assert cd.trialFundsInitialAmount != 0 # dev: no trial funds amount\n\n    # iterate through clawback data\n    balanceAvail: uint256 = staticcall IERC20(cd.trialFundsAsset).balanceOf(self)\n    for i: uint256 in range(len(_opportunities), bound=MAX_LEGOS):\n        if balanceAvail >= cd.trialFundsInitialAmount:\n            break\n\n        # get vault token data\n        opp: TrialFundsOpp = _opportunities[i]\n        vaultTokenBal: uint256 = staticcall IERC20(opp.vaultToken).balanceOf(self)\n        if vaultTokenBal == 0:\n            continue\n\n        # withdraw from lego partner\n        assetAmountReceived: uint256 = 0\n        na1: uint256 = 0\n        na2: uint256 = 0\n        assetAmountReceived, na1, na2 = self._withdrawTokens(agentFactory, opp.legoId, cd.trialFundsAsset, opp.vaultToken, vaultTokenBal, False, False, cd)\n        balanceAvail += assetAmountReceived\n\n        # deposit any extra balance back lego\n        if balanceAvail > cd.trialFundsInitialAmount:\n            self._depositTokens(agentFactory, opp.legoId, cd.trialFundsAsset, opp.vaultToken, balanceAvail - cd.trialFundsInitialAmount, False, False, cd)\n            break\n\n    # transfer back to agent factory\n    amountRecovered: uint256 = min(cd.trialFundsInitialAmount, staticcall IERC20(cd.trialFundsAsset).balanceOf(self))\n    assert amountRecovered != 0 # dev: no funds to transfer\n    assert extcall IERC20(cd.trialFundsAsset).transfer(agentFactory, amountRecovered, default_return_value=True) # dev: trial funds transfer failed\n\n    # update trial funds data\n    remainingTrialFunds: uint256 = cd.trialFundsInitialAmount - amountRecovered\n    self.trialFundsInitialAmount = remainingTrialFunds\n    if remainingTrialFunds == 0:\n        self.trialFundsAsset = empty(address)\n\n    log UserWalletTrialFundsRecovered(asset=cd.trialFundsAsset, amountRecovered=amountRecovered, remainingAmount=remainingTrialFunds)\n    return True\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256) -> bool:\n    \"\"\"\n    @notice Recovers an NFT from the wallet\n    @param _collection The collection address\n    @param _nftTokenId The token ID of the NFT\n    @return bool True if the NFT was recovered successfully\n    \"\"\"\n    owner: address = staticcall WalletConfig(self.walletConfig).owner()\n    assert msg.sender == owner # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, owner, _nftTokenId)\n    log UserWalletNftRecovered(collection=_collection, nftTokenId=_nftTokenId, owner=owner)\n    return True",
            "sha256sum": "2dc1977d0c193329419e80c83266a8efddfb209b5c60d99e1777b857ea27e127"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/WalletFunds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "bb3953917698f009367b8a15aecd9323260652ed56c8a9795a931d1b9696fe82"
      },
      "args": ""
    },
    "WalletConfig": {
      "address": "0x45D1a9429Fd603c13Cdab685dc2540f4F57Df464",
      "abi": [
        {
          "name": "AgentAdded",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "allowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "allowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentModified",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "allowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "allowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentDisabled",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAllowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevAllowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoIdAddedToAgent",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetAddedToAgent",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AllowedActionsModified",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRebalance",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canTransfer",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSwap",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canConvert",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canAddLiq",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRemoveLiq",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canClaimRewards",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canBorrow",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRepay",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrCancelled",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrRemoved",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ReserveAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeInitiated",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeConfirmed",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeCancelled",
          "inputs": [
            {
              "name": "cancelledOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initialize",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_initialAgent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgentActive",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canAgentAccess",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            },
            {
              "name": "_legoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentSubscriptionStatus",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getProtocolSubscriptionStatus",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMakeSubscriptionPayments",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "handleSubscriptionsAndPermissions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            },
            {
              "name": "_legoIds",
              "type": "uint256[]"
            },
            {
              "name": "_cd",
              "type": "tuple",
              "components": [
                {
                  "name": "owner",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "addyRegistry",
                  "type": "address"
                },
                {
                  "name": "legoRegistry",
                  "type": "address"
                },
                {
                  "name": "priceSheets",
                  "type": "address"
                },
                {
                  "name": "oracleRegistry",
                  "type": "address"
                },
                {
                  "name": "trialFundsAsset",
                  "type": "address"
                },
                {
                  "name": "trialFundsInitialAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailableTxAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_wantedAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldCheckTrialFunds",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailableTxAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_wantedAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldCheckTrialFunds",
              "type": "bool"
            },
            {
              "name": "_cd",
              "type": "tuple",
              "components": [
                {
                  "name": "owner",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "addyRegistry",
                  "type": "address"
                },
                {
                  "name": "legoRegistry",
                  "type": "address"
                },
                {
                  "name": "priceSheets",
                  "type": "address"
                },
                {
                  "name": "oracleRegistry",
                  "type": "address"
                },
                {
                  "name": "trialFundsAsset",
                  "type": "address"
                },
                {
                  "name": "trialFundsInitialAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            },
            {
              "name": "_allowedLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            },
            {
              "name": "_allowedLegoIds",
              "type": "uint256[]"
            },
            {
              "name": "_allowedActions",
              "type": "tuple",
              "components": [
                {
                  "name": "isSet",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRebalance",
                  "type": "bool"
                },
                {
                  "name": "canTransfer",
                  "type": "bool"
                },
                {
                  "name": "canSwap",
                  "type": "bool"
                },
                {
                  "name": "canConvert",
                  "type": "bool"
                },
                {
                  "name": "canAddLiq",
                  "type": "bool"
                },
                {
                  "name": "canRemoveLiq",
                  "type": "bool"
                },
                {
                  "name": "canClaimRewards",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLegoIdForAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetForAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "modifyAllowedActions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "modifyAllowedActions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedActions",
              "type": "tuple",
              "components": [
                {
                  "name": "isSet",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRebalance",
                  "type": "bool"
                },
                {
                  "name": "canTransfer",
                  "type": "bool"
                },
                {
                  "name": "canSwap",
                  "type": "bool"
                },
                {
                  "name": "canConvert",
                  "type": "bool"
                },
                {
                  "name": "canAddLiq",
                  "type": "bool"
                },
                {
                  "name": "canRemoveLiq",
                  "type": "bool"
                },
                {
                  "name": "canClaimRewards",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canTransferToRecipient",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setReserveAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManyReserveAssets",
          "inputs": [
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingOwnerChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeOwnership",
          "inputs": [
            {
              "name": "_newOwner",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOwnershipChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "wallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "owner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingOwner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newOwner",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ownershipChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolSub",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "installBlock",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "reserveAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentSettings",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "isActive",
                  "type": "bool"
                },
                {
                  "name": "installBlock",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "allowedLegoIds",
                  "type": "uint256[]"
                },
                {
                  "name": "allowedActions",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "isSet",
                      "type": "bool"
                    },
                    {
                      "name": "canDeposit",
                      "type": "bool"
                    },
                    {
                      "name": "canWithdraw",
                      "type": "bool"
                    },
                    {
                      "name": "canRebalance",
                      "type": "bool"
                    },
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canSwap",
                      "type": "bool"
                    },
                    {
                      "name": "canConvert",
                      "type": "bool"
                    },
                    {
                      "name": "canAddLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canRemoveLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "canBorrow",
                      "type": "bool"
                    },
                    {
                      "name": "canRepay",
                      "type": "bool"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRecipientAllowed",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingWhitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyRegistry",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "initialized",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_minOwnerChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxOwnerChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/core/WalletConfig.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n# pragma optimize codesize\n\nfrom ethereum.ercs import IERC20\n\ninterface PriceSheets:\n    def getCombinedSubData(_user: address, _agent: address, _agentPaidThru: uint256, _protocolPaidThru: uint256, _oracleRegistry: address) -> (SubPaymentInfo, SubPaymentInfo): view\n    def getAgentSubPriceData(_agent: address) -> SubscriptionInfo: view\n    def protocolSubPriceData() -> SubscriptionInfo: view\n\ninterface LegoRegistry:\n    def getUnderlyingForUser(_user: address, _asset: address) -> uint256: view\n    def isValidLegoId(_legoId: uint256) -> bool: view\n\ninterface UserWallet:\n    def trialFundsInitialAmount() -> uint256: view\n    def trialFundsAsset() -> address: view\n    def walletConfig() -> address: view\n\ninterface WalletConfig:\n    def hasPendingOwnerChange() -> bool: view\n    def owner() -> address: view\n\ninterface AgentFactory:\n    def isUserWallet(_wallet: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct AgentInfo:\n    isActive: bool\n    installBlock: uint256\n    paidThroughBlock: uint256\n    allowedAssets: DynArray[address, MAX_ASSETS]\n    allowedLegoIds: DynArray[uint256, MAX_LEGOS]\n    allowedActions: AllowedActions\n\nstruct PendingWhitelist:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct CoreData:\n    owner: address\n    wallet: address\n    walletConfig: address\n    addyRegistry: address\n    legoRegistry: address\n    priceSheets: address\n    oracleRegistry: address\n    trialFundsAsset: address\n    trialFundsInitialAmount: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct ProtocolSub:\n    installBlock: uint256\n    paidThroughBlock: uint256\n\nstruct AllowedActions:\n    isSet: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRebalance: bool\n    canTransfer: bool\n    canSwap: bool\n    canConvert: bool\n    canAddLiq: bool\n    canRemoveLiq: bool\n    canClaimRewards: bool\n    canBorrow: bool\n    canRepay: bool\n\nstruct ReserveAsset:\n    asset: address\n    amount: uint256\n\nstruct SubscriptionInfo:\n    asset: address\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nstruct PendingOwner:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentAdded:\n    agent: indexed(address)\n    allowedAssets: uint256\n    allowedLegoIds: uint256\n\nevent AgentModified:\n    agent: indexed(address)\n    allowedAssets: uint256\n    allowedLegoIds: uint256\n\nevent AgentDisabled:\n    agent: indexed(address)\n    prevAllowedAssets: uint256\n    prevAllowedLegoIds: uint256\n\nevent LegoIdAddedToAgent:\n    agent: indexed(address)\n    legoId: indexed(uint256)\n\nevent AssetAddedToAgent:\n    agent: indexed(address)\n    asset: indexed(address)\n\nevent AllowedActionsModified:\n    agent: indexed(address)\n    canDeposit: bool\n    canWithdraw: bool\n    canRebalance: bool\n    canTransfer: bool\n    canSwap: bool\n    canConvert: bool\n    canAddLiq: bool\n    canRemoveLiq: bool\n    canClaimRewards: bool\n    canBorrow: bool\n    canRepay: bool\n\nevent WhitelistAddrPending:\n    addr: indexed(address)\n    confirmBlock: uint256\n\nevent WhitelistAddrConfirmed:\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent WhitelistAddrCancelled:\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent WhitelistAddrRemoved:\n    addr: indexed(address)\n\nevent ReserveAssetSet:\n    asset: indexed(address)\n    amount: uint256\n\nevent OwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent OwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeDelaySet:\n    delayBlocks: uint256\n\nevent FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# core\nwallet: public(address)\n\n# owner\nowner: public(address) # owner of the wallet\npendingOwner: public(PendingOwner) # pending owner of the wallet\nownershipChangeDelay: public(uint256) # num blocks to wait before owner can be changed\n\n# user settings\nprotocolSub: public(ProtocolSub) # subscription info\nreserveAssets: public(HashMap[address, uint256]) # asset -> reserve amount\nagentSettings: public(HashMap[address, AgentInfo]) # agent -> agent info\n\n# transfer whitelist\nisRecipientAllowed: public(HashMap[address, bool]) # recipient -> is allowed\npendingWhitelist: public(HashMap[address, PendingWhitelist]) # addr -> pending whitelist\n\n# config\naddyRegistry: public(address)\ninitialized: public(bool)\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\nLEGO_REGISTRY_ID: constant(uint256) = 2\nPRICE_SHEETS_ID: constant(uint256) = 3\nORACLE_REGISTRY_ID: constant(uint256) = 4\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\n\nMAX_ASSETS: constant(uint256) = 25\nMAX_LEGOS: constant(uint256) = 20\nAPI_VERSION: constant(String[28]) = \"0.0.1\"\n\n\n@deploy\ndef __init__(_minOwnerChangeDelay: uint256, _maxOwnerChangeDelay: uint256):\n    MIN_OWNER_CHANGE_DELAY = _minOwnerChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxOwnerChangeDelay\n\n    # make sure original reference contract can't be initialized\n    self.initialized = True\n\n\n@external\ndef initialize(\n    _wallet: address,\n    _addyRegistry: address,\n    _owner: address,\n    _initialAgent: address,\n) -> bool:\n    \"\"\"\n    @notice Sets up the initial state of the wallet template\n    @dev Can only be called once and sets core contract parameters\n    @param _wallet The address of the wallet contract\n    @param _addyRegistry The address of the core registry contract\n    @param _owner The address that will own this wallet\n    @param _initialAgent The address of the initial AI agent (if any)\n    @return bool True if initialization was successful\n    \"\"\"\n    assert not self.initialized # dev: can only initialize once\n    self.initialized = True\n\n    assert empty(address) not in [_wallet, _addyRegistry, _owner] # dev: invalid addrs\n    assert _initialAgent != _owner # dev: agent cannot be owner\n    self.wallet = _wallet\n    self.addyRegistry = _addyRegistry\n    self.owner = _owner\n    self.ownershipChangeDelay = MIN_OWNER_CHANGE_DELAY\n\n    priceSheets: address = staticcall AddyRegistry(_addyRegistry).getAddy(PRICE_SHEETS_ID)\n\n    # initial agent setup\n    if _initialAgent != empty(address):\n        subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).getAgentSubPriceData(_initialAgent)\n        paidThroughBlock: uint256 = 0\n        if subInfo.usdValue != 0:\n            paidThroughBlock = block.number + subInfo.trialPeriod\n        self.agentSettings[_initialAgent] = AgentInfo(\n            isActive=True,\n            installBlock=block.number,\n            paidThroughBlock=paidThroughBlock,\n            allowedAssets=[],\n            allowedLegoIds=[],\n            allowedActions=empty(AllowedActions),\n        )\n        log AgentAdded(agent=_initialAgent, allowedAssets=0, allowedLegoIds=0)\n\n    # protocol subscription\n    protocolSub: ProtocolSub = empty(ProtocolSub)\n    protocolSub.installBlock = block.number\n    subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).protocolSubPriceData()\n    if subInfo.usdValue != 0:\n        protocolSub.paidThroughBlock = block.number + subInfo.trialPeriod\n    self.protocolSub = protocolSub\n\n    return True\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    \"\"\"\n    @notice Returns the current API version of the contract\n    @dev Returns a constant string representing the contract version\n    @return String[28] The API version string\n    \"\"\"\n    return API_VERSION\n\n\n#####################\n# Agent Permissions #\n#####################\n\n\n@view\n@external\ndef isAgentActive(_agent: address) -> bool:\n    return self.agentSettings[_agent].isActive\n\n\n@view\n@external\ndef canAgentAccess(\n    _agent: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n) -> bool:\n    return self._canAgentAccess(self.agentSettings[_agent], _action, _assets, _legoIds)\n\n\n@view\n@internal\ndef _canAgentAccess(\n    _agent: AgentInfo,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n) -> bool:\n    if not _agent.isActive:\n        return False\n\n    # check allowed actions\n    if not self._canAgentPerformAction(_action, _agent.allowedActions):\n        return False\n\n    # check allowed assets\n    if len(_agent.allowedAssets) != 0:\n        for i: uint256 in range(len(_assets), bound=MAX_ASSETS):\n            asset: address = _assets[i]\n            if asset != empty(address) and asset not in _agent.allowedAssets:\n                return False\n\n    # check allowed lego ids\n    if len(_agent.allowedLegoIds) != 0:\n        for i: uint256 in range(len(_legoIds), bound=MAX_LEGOS):\n            legoId: uint256 = _legoIds[i]\n            if legoId != 0 and legoId not in _agent.allowedLegoIds:\n                return False\n\n    return True\n\n\n@view\n@internal\ndef _canAgentPerformAction(_action: ActionType, _allowedActions: AllowedActions) -> bool:\n    if not _allowedActions.isSet or _action == empty(ActionType):\n        return True\n    if _action == ActionType.DEPOSIT:\n        return _allowedActions.canDeposit\n    elif _action == ActionType.WITHDRAWAL:\n        return _allowedActions.canWithdraw\n    elif _action == ActionType.REBALANCE:\n        return _allowedActions.canRebalance\n    elif _action == ActionType.TRANSFER:\n        return _allowedActions.canTransfer\n    elif _action == ActionType.SWAP:\n        return _allowedActions.canSwap\n    elif _action == ActionType.CONVERSION:\n        return _allowedActions.canConvert\n    elif _action == ActionType.ADD_LIQ:\n        return _allowedActions.canAddLiq\n    elif _action == ActionType.REMOVE_LIQ:\n        return _allowedActions.canRemoveLiq\n    elif _action == ActionType.CLAIM_REWARDS:\n        return _allowedActions.canClaimRewards\n    elif _action == ActionType.BORROW:\n        return _allowedActions.canBorrow\n    elif _action == ActionType.REPAY:\n        return _allowedActions.canRepay\n    else:\n        return True # no action specified\n\n\n##########################\n# Subscription + Tx Fees #\n##########################\n\n\n# subscriptions\n\n\n@view\n@external\ndef getAgentSubscriptionStatus(_agent: address) -> SubPaymentInfo:\n    cd: CoreData = self._getCoreData()\n    na: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    na, agentSub = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, _agent, self.agentSettings[_agent].paidThroughBlock, 0, cd.oracleRegistry)\n    return agentSub\n\n\n@view\n@external\ndef getProtocolSubscriptionStatus() -> SubPaymentInfo:\n    cd: CoreData = self._getCoreData()\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    na: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, na = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, empty(address), 0, self.protocolSub.paidThroughBlock, cd.oracleRegistry)\n    return protocolSub\n\n\n@view\n@external\ndef canMakeSubscriptionPayments(_agent: address) -> (bool, bool):\n    cd: CoreData = self._getCoreData()\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, _agent, self.agentSettings[_agent].paidThroughBlock, self.protocolSub.paidThroughBlock, cd.oracleRegistry)\n    return self._checkIfSufficientFunds(protocolSub.asset, protocolSub.amount, agentSub.asset, agentSub.amount, cd)\n\n\n@external\ndef handleSubscriptionsAndPermissions(\n    _agent: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n    _cd: CoreData,\n) -> (SubPaymentInfo, SubPaymentInfo):\n    \"\"\"\n    @notice Handles the subscription and permission data for the given agent and action\n    @param _agent The address of the agent\n    @param _action The action to handle\n    @param _assets The assets to check\n    @param _legoIds The legos to check\n    @param _cd The core data\n    @return protocolSub The protocol subscription data\n    @return agentSub The agent subscription data\n    \"\"\"\n    assert msg.sender == self.wallet # dev: no perms\n\n    # check if agent can perform action with assets and legos\n    userAgentData: AgentInfo = empty(AgentInfo)\n    if _agent != empty(address):\n        userAgentData = self.agentSettings[_agent]\n        assert self._canAgentAccess(userAgentData, _action, _assets, _legoIds) # dev: agent not allowed\n\n    userProtocolData: ProtocolSub = self.protocolSub\n\n    # get latest sub data for agent and protocol\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = staticcall PriceSheets(_cd.priceSheets).getCombinedSubData(_cd.wallet, _agent, userAgentData.paidThroughBlock, userProtocolData.paidThroughBlock, _cd.oracleRegistry)\n\n    # check if sufficient funds\n    canPayProtocol: bool = False\n    canPayAgent: bool = False\n    canPayProtocol, canPayAgent = self._checkIfSufficientFunds(protocolSub.asset, protocolSub.amount, agentSub.asset, agentSub.amount, _cd)\n    assert canPayProtocol # dev: insufficient balance for protocol subscription payment\n    assert canPayAgent # dev: insufficient balance for agent subscription payment\n\n    # update and save new data\n    if protocolSub.didChange:\n        userProtocolData.paidThroughBlock = protocolSub.paidThroughBlock\n        self.protocolSub = userProtocolData\n    if agentSub.didChange:\n        userAgentData.paidThroughBlock = agentSub.paidThroughBlock\n        self.agentSettings[_agent] = userAgentData\n\n    # actual payments will happen from wallet\n    return protocolSub, agentSub\n\n\n####################\n# Random Utilities #\n####################\n\n\n@view\n@internal\ndef _getCoreData() -> CoreData:\n    addyRegistry: address = self.addyRegistry\n    wallet: address = self.wallet\n    return CoreData(\n        owner=self.owner,\n        wallet=wallet,\n        walletConfig=self,\n        addyRegistry=addyRegistry,\n        legoRegistry=staticcall AddyRegistry(addyRegistry).getAddy(LEGO_REGISTRY_ID),\n        priceSheets=staticcall AddyRegistry(addyRegistry).getAddy(PRICE_SHEETS_ID),\n        oracleRegistry=staticcall AddyRegistry(addyRegistry).getAddy(ORACLE_REGISTRY_ID),\n        trialFundsAsset=staticcall UserWallet(wallet).trialFundsAsset(),\n        trialFundsInitialAmount=staticcall UserWallet(wallet).trialFundsInitialAmount(),\n    )\n\n\n@view\n@internal\ndef _checkIfSufficientFunds(_protocolAsset: address, _protocolAmount: uint256, _agentAsset: address, _agentAmount: uint256, _cd: CoreData) -> (bool, bool):\n    canPayProtocol: bool = True\n    canPayAgent: bool = True\n\n    # check if any of these assets are also trial funds asset\n    trialFundsCurrentBal: uint256 = 0\n    trialFundsDeployed: uint256 = 0\n    if (_protocolAsset != empty(address) and _protocolAsset == _cd.trialFundsAsset) or (_agentAsset != empty(address) and _agentAsset == _cd.trialFundsAsset):\n        trialFundsCurrentBal = staticcall IERC20(_cd.trialFundsAsset).balanceOf(_cd.wallet)\n        trialFundsDeployed = staticcall LegoRegistry(_cd.legoRegistry).getUnderlyingForUser(_cd.wallet, _cd.trialFundsAsset)\n\n    # check if can make protocol payment\n    if _protocolAmount != 0:\n        availBalForProtocol: uint256 = self._getAvailBalAfterTrialFunds(_protocolAsset, _cd.wallet, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, trialFundsCurrentBal, trialFundsDeployed)\n        canPayProtocol = availBalForProtocol >= _protocolAmount\n\n        # update trial funds balance\n        if _protocolAsset != empty(address) and _protocolAsset == _cd.trialFundsAsset:\n            trialFundsCurrentBal -= _protocolAmount\n\n    # check if can make agent payment\n    if _agentAmount != 0:\n        availBalForAgent: uint256 = self._getAvailBalAfterTrialFunds(_agentAsset, _cd.wallet, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, trialFundsCurrentBal, trialFundsDeployed)\n        canPayAgent = availBalForAgent >= _agentAmount\n\n    return canPayProtocol, canPayAgent\n\n\n@view\n@external\ndef getAvailableTxAmount(\n    _asset: address,\n    _wantedAmount: uint256,\n    _shouldCheckTrialFunds: bool,\n    _cd: CoreData = empty(CoreData),\n) -> uint256:\n    \"\"\"\n    @notice Returns the maximum amount that can be sent from the wallet\n    @param _asset The address of the asset to check\n    @param _wantedAmount The amount of the asset to send\n    @param _shouldCheckTrialFunds Whether to check if the asset is a trial funds asset\n    @param _cd The core data\n    @return amount The maximum amount that can be sent\n    \"\"\"\n    cd: CoreData = _cd\n    if cd.wallet == empty(address):\n        cd = self._getCoreData()\n\n    availableAmount: uint256 = staticcall IERC20(_asset).balanceOf(cd.wallet)\n\n    # check if asset is trial funds asset\n    if _shouldCheckTrialFunds and _asset == cd.trialFundsAsset:\n        trialFundsDeployed: uint256 = staticcall LegoRegistry(cd.legoRegistry).getUnderlyingForUser(cd.wallet, _asset)\n        availableAmount = self._getAvailBalAfterTrialFunds(_asset, cd.wallet, cd.trialFundsAsset, cd.trialFundsInitialAmount, availableAmount, trialFundsDeployed)\n\n    # check if any reserve is set\n    reservedAmount: uint256 = self.reserveAssets[_asset]\n    if reservedAmount != 0:\n        assert availableAmount > reservedAmount # dev: insufficient balance after reserve\n        availableAmount -= reservedAmount\n\n    # return min of wanted amount and available amount\n    availableAmount = min(_wantedAmount, availableAmount)\n    assert availableAmount != 0 # dev: no funds available\n\n    return availableAmount\n\n\n@view\n@internal\ndef _getAvailBalAfterTrialFunds(\n    _asset: address,\n    _wallet: address,\n    _trialFundsAsset: address,\n    _trialFundsInitialAmount: uint256,\n    _trialFundsCurrentBal: uint256,\n    _trialFundsDeployed: uint256,\n) -> uint256:\n    if _asset != _trialFundsAsset:\n        return staticcall IERC20(_asset).balanceOf(_wallet)\n\n    # sufficient trial funds already deployed\n    if _trialFundsDeployed >= _trialFundsInitialAmount:\n        return _trialFundsCurrentBal\n\n    lockedAmount: uint256 = _trialFundsInitialAmount - _trialFundsDeployed\n    availAmount: uint256 = 0\n    if _trialFundsCurrentBal > lockedAmount:\n        availAmount = _trialFundsCurrentBal - lockedAmount\n\n    return availAmount\n\n\n##################\n# Agent Settings #\n##################\n\n\n# add or modify agent settings\n\n\n@nonreentrant\n@external\ndef addOrModifyAgent(\n    _agent: address,\n    _allowedAssets: DynArray[address, MAX_ASSETS] = [],\n    _allowedLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n    _allowedActions: AllowedActions = empty(AllowedActions),\n) -> bool:\n    \"\"\"\n    @notice Adds a new agent or modifies an existing agent's permissions\n        If empty arrays are provided, the agent has access to all assets and lego ids\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to add or modify\n    @param _allowedAssets List of assets the agent can interact with\n    @param _allowedLegoIds List of lego IDs the agent can use\n    @param _allowedActions The actions the agent can perform\n    @return bool True if the agent was successfully added or modified\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner # dev: no perms\n    assert _agent != owner # dev: agent cannot be owner\n    assert _agent != empty(address) # dev: invalid agent\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    agentInfo.isActive = True\n\n    # allowed actions\n    agentInfo.allowedActions = _allowedActions\n    agentInfo.allowedActions.isSet = self._hasAllowedActionsSet(_allowedActions)\n\n    # sanitize other input data\n    agentInfo.allowedAssets, agentInfo.allowedLegoIds = self._sanitizeAgentInputData(_allowedAssets, _allowedLegoIds)\n\n    # get subscription info\n    priceSheets: address = staticcall AddyRegistry(self.addyRegistry).getAddy(PRICE_SHEETS_ID)\n    subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).getAgentSubPriceData(_agent)\n\n    isNewAgent: bool = (agentInfo.installBlock == 0)\n    if isNewAgent:\n        agentInfo.installBlock = block.number\n        if subInfo.usdValue != 0:\n            agentInfo.paidThroughBlock = block.number + subInfo.trialPeriod\n\n    # may not have had sub setup before\n    elif subInfo.usdValue != 0:\n        agentInfo.paidThroughBlock = max(agentInfo.paidThroughBlock, agentInfo.installBlock + subInfo.trialPeriod)\n\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    if isNewAgent:\n        log AgentAdded(agent=_agent, allowedAssets=len(agentInfo.allowedAssets), allowedLegoIds=len(agentInfo.allowedLegoIds))\n    else:\n        log AgentModified(agent=_agent, allowedAssets=len(agentInfo.allowedAssets), allowedLegoIds=len(agentInfo.allowedLegoIds))\n    return True\n\n\n@view\n@internal\ndef _sanitizeAgentInputData(\n    _allowedAssets: DynArray[address, MAX_ASSETS],\n    _allowedLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (DynArray[address, MAX_ASSETS], DynArray[uint256, MAX_LEGOS]):\n\n    # nothing to do here\n    if len(_allowedAssets) == 0 and len(_allowedLegoIds) == 0:\n        return _allowedAssets, _allowedLegoIds\n\n    # sanitize and dedupe assets\n    cleanAssets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(len(_allowedAssets), bound=MAX_ASSETS):\n        asset: address = _allowedAssets[i]\n        if asset == empty(address):\n            continue\n        if asset not in cleanAssets:\n            cleanAssets.append(asset)\n\n    # validate and dedupe lego ids\n    cleanLegoIds: DynArray[uint256, MAX_LEGOS] = []\n    if len(_allowedLegoIds) != 0:\n        legoRegistry: address = staticcall AddyRegistry(self.addyRegistry).getAddy(LEGO_REGISTRY_ID)\n        for i: uint256 in range(len(_allowedLegoIds), bound=MAX_LEGOS):\n            legoId: uint256 = _allowedLegoIds[i]\n            if not staticcall LegoRegistry(legoRegistry).isValidLegoId(legoId):\n                continue\n            if legoId not in cleanLegoIds:\n                cleanLegoIds.append(legoId)\n\n    return cleanAssets, cleanLegoIds\n\n\n# disable agent\n\n\n@nonreentrant\n@external\ndef disableAgent(_agent: address) -> bool:\n    \"\"\"\n    @notice Disables an existing agent\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to disable\n    @return bool True if the agent was successfully disabled\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n    agentInfo.isActive = False\n    self.agentSettings[_agent] = agentInfo\n\n    log AgentDisabled(agent=_agent, prevAllowedAssets=len(agentInfo.allowedAssets), prevAllowedLegoIds=len(agentInfo.allowedLegoIds))\n    return True\n\n\n# add lego id for agent\n\n\n@nonreentrant\n@external\ndef addLegoIdForAgent(_agent: address, _legoId: uint256) -> bool:\n    \"\"\"\n    @notice Adds a lego ID to an agent's allowed legos\n    @dev Can only be called by the owner\n    @param _agent The address of the agent\n    @param _legoId The lego ID to add\n    @return bool True if the lego ID was successfully added\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    legoRegistry: address = staticcall AddyRegistry(self.addyRegistry).getAddy(LEGO_REGISTRY_ID)\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_legoId)\n    assert _legoId not in agentInfo.allowedLegoIds # dev: lego id already saved\n\n    # save data\n    agentInfo.allowedLegoIds.append(_legoId)\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    log LegoIdAddedToAgent(agent=_agent, legoId=_legoId)\n    return True\n\n\n# add asset for agent\n\n\n@nonreentrant\n@external\ndef addAssetForAgent(_agent: address, _asset: address) -> bool:\n    \"\"\"\n    @notice Adds an asset to an agent's allowed assets\n    @dev Can only be called by the owner\n    @param _agent The address of the agent\n    @param _asset The asset address to add\n    @return bool True if the asset was successfully added\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    assert _asset != empty(address) # dev: invalid asset\n    assert _asset not in agentInfo.allowedAssets # dev: asset already saved\n\n    # save data\n    agentInfo.allowedAssets.append(_asset)\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    log AssetAddedToAgent(agent=_agent, asset=_asset)\n    return True\n\n\n# modify allowed actions\n\n\n@nonreentrant\n@external\ndef modifyAllowedActions(_agent: address, _allowedActions: AllowedActions = empty(AllowedActions)) -> bool:\n    \"\"\"\n    @notice Modifies the allowed actions for an agent\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to modify\n    @param _allowedActions The new allowed actions\n    @return bool True if the allowed actions were successfully modified\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    agentInfo.allowedActions = _allowedActions\n    agentInfo.allowedActions.isSet = self._hasAllowedActionsSet(_allowedActions)\n    self.agentSettings[_agent] = agentInfo\n\n    log AllowedActionsModified(agent=_agent, canDeposit=_allowedActions.canDeposit, canWithdraw=_allowedActions.canWithdraw, canRebalance=_allowedActions.canRebalance, canTransfer=_allowedActions.canTransfer, canSwap=_allowedActions.canSwap, canConvert=_allowedActions.canConvert, canAddLiq=_allowedActions.canAddLiq, canRemoveLiq=_allowedActions.canRemoveLiq, canClaimRewards=_allowedActions.canClaimRewards, canBorrow=_allowedActions.canBorrow, canRepay=_allowedActions.canRepay)\n    return True\n\n\n@view\n@internal\ndef _hasAllowedActionsSet(_actions: AllowedActions) -> bool:\n    return _actions.canDeposit or _actions.canWithdraw or _actions.canRebalance or _actions.canTransfer or _actions.canSwap or _actions.canConvert\n\n\n######################\n# Transfer Whitelist #\n######################\n\n\n@view\n@external\ndef canTransferToRecipient(_recipient: address) -> bool:\n    \"\"\"\n    @notice Checks if a transfer to a recipient is allowed\n    @param _recipient The address of the recipient\n    @return bool True if the transfer is allowed, false otherwise\n    \"\"\"\n    isAllowed: bool = self.isRecipientAllowed[_recipient]\n    if isAllowed:\n        return True\n\n    # pending ownership change, don't even check if recipient is Underscore wallet\n    if self.pendingOwner.initiatedBlock != 0:\n        return False\n\n    # check if recipient is Underscore wallet, if owner is same (no pending ownership changes), transfer is allowed\n    agentFactory: address = staticcall AddyRegistry(self.addyRegistry).getAddy(AGENT_FACTORY_ID)\n    if staticcall AgentFactory(agentFactory).isUserWallet(_recipient):\n        walletConfig: address = staticcall UserWallet(_recipient).walletConfig()\n        if not staticcall WalletConfig(walletConfig).hasPendingOwnerChange():\n            isAllowed = self.owner == staticcall WalletConfig(walletConfig).owner()\n\n    return isAllowed\n\n\n@nonreentrant\n@external\ndef addWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Adds an address to the whitelist\n    @dev Can only be called by the owner\n    @param _addr The address to add to the whitelist\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner # dev: only owner can add whitelist\n\n    assert _addr != empty(address) # dev: invalid addr\n    assert _addr != owner # dev: owner cannot be whitelisted\n    assert _addr != self # dev: wallet cannot be whitelisted\n    assert not self.isRecipientAllowed[_addr] # dev: already whitelisted\n    assert self.pendingWhitelist[_addr].initiatedBlock == 0 # dev: pending whitelist already exists\n\n    # this uses same delay as ownership change\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingWhitelist[_addr] = PendingWhitelist(\n        initiatedBlock = block.number,\n        confirmBlock = confirmBlock,\n    )\n    log WhitelistAddrPending(addr=_addr, confirmBlock=confirmBlock)\n\n\n@nonreentrant\n@external\ndef confirmWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Confirms a whitelist address\n    @dev Can only be called by the owner\n    @param _addr The address to confirm\n    \"\"\"\n    assert msg.sender == self.owner # dev: only owner can confirm\n\n    data: PendingWhitelist = self.pendingWhitelist[_addr]\n    assert data.initiatedBlock != 0 # dev: no pending whitelist\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n\n    self.pendingWhitelist[_addr] = empty(PendingWhitelist)\n    self.isRecipientAllowed[_addr] = True\n    log WhitelistAddrConfirmed(addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@nonreentrant\n@external\ndef cancelPendingWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Cancels a pending whitelist address\n    @dev Can only be called by the owner\n    @param _addr The address to cancel\n    \"\"\"\n    assert msg.sender == self.owner # dev: only owner can cancel\n    data: PendingWhitelist = self.pendingWhitelist[_addr]\n    assert data.initiatedBlock != 0 # dev: no pending whitelist\n    self.pendingWhitelist[_addr] = empty(PendingWhitelist)\n    log WhitelistAddrCancelled(addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@nonreentrant\n@external\ndef removeWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Removes an address from the whitelist\n    @dev Can only be called by the owner\n    @param _addr The address to remove from the whitelist\n    \"\"\"\n    assert msg.sender == self.owner # dev: only owner can remove whitelist\n    assert self.isRecipientAllowed[_addr] # dev: not on whitelist\n\n    self.isRecipientAllowed[_addr] = False\n    log WhitelistAddrRemoved(addr=_addr)\n\n\n##################\n# Reserve Assets #\n##################\n\n\n@nonreentrant\n@external\ndef setReserveAsset(_asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Sets a reserve asset\n    @dev Can only be called by the owner\n    @param _asset The address of the asset to set\n    @param _amount The amount of the asset to set\n    @return bool True if the reserve asset was successfully set\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _asset != empty(address) # dev: invalid asset\n    self.reserveAssets[_asset] = _amount\n    log ReserveAssetSet(asset=_asset, amount=_amount)\n    return True\n\n\n@nonreentrant\n@external\ndef setManyReserveAssets(_assets: DynArray[ReserveAsset, MAX_ASSETS]) -> bool:\n    \"\"\"\n    @notice Sets multiple reserve assets\n    @dev Can only be called by the owner\n    @param _assets The array of reserve assets to set\n    @return bool True if the reserve assets were successfully set\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert len(_assets) != 0 # dev: invalid array length\n    for i: uint256 in range(len(_assets), bound=MAX_ASSETS):\n        asset: address = _assets[i].asset\n        amount: uint256 = _assets[i].amount\n        assert asset != empty(address) # dev: invalid asset\n        self.reserveAssets[asset] = amount\n        log ReserveAssetSet(asset=asset, amount=amount)\n\n    return True\n\n\n####################\n# Ownership Change #\n####################\n\n\n@view\n@external\ndef hasPendingOwnerChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending ownership change\n    @return bool True if there is a pending ownership change, false otherwise\n    \"\"\"\n    return self.pendingOwner.initiatedBlock != 0\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    \"\"\"\n    @notice Initiates a new ownership change\n    @dev Can only be called by the current owner\n    @param _newOwner The address of the new owner\n    \"\"\"\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingOwner = PendingOwner(\n        newOwner= _newOwner,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log OwnershipChangeInitiated(prevOwner=currentOwner, newOwner=_newOwner, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmOwnershipChange():\n    \"\"\"\n    @notice Confirms the ownership change\n    @dev Can only be called by the new owner\n    \"\"\"\n    data: PendingOwner = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeConfirmed(prevOwner=prevOwner, newOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelOwnershipChange():\n    \"\"\"\n    @notice Cancels the ownership change\n    @dev Can only be called by the current owner\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    data: PendingOwner = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeCancelled(cancelledOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setOwnershipChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the ownership change delay\n    @dev Can only be called by the owner\n    @param _numBlocks The number of blocks to wait before ownership can be changed\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNER_CHANGE_DELAY and _numBlocks <= MAX_OWNER_CHANGE_DELAY # dev: invalid delay\n    self.ownershipChangeDelay = _numBlocks\n    log OwnershipChangeDelaySet(delayBlocks=_numBlocks)\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address) -> bool:\n    \"\"\"\n    @notice transfers funds from the config contract to the main wallet\n    @dev anyone can call this!\n    @param _asset The address of the asset to recover\n    @return bool True if the funds were recovered successfully\n    \"\"\"\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    wallet: address = self.wallet\n    if empty(address) in [wallet, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(wallet, balance, default_return_value=True) # dev: recovery failed\n    log FundsRecovered(asset=_asset, recipient=wallet, balance=balance)\n    return True\n",
            "sha256sum": "dffad8508f6474d96201ab1cb4641fb1960f588ce574ccbf66b3e7370508edab"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/WalletConfig.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "be1ccb61a75e9aa7e8bda3d9bcad4bf22afdf613dba0bef8d46064b34bf3421a"
      },
      "args": "00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "AgentTemplate": {
      "address": "0x70418b3AAa1044eC8bFF6a461B4E43460bb5699E",
      "abi": [
        {
          "name": "AgentOwnershipChangeInitiated",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentOwnershipChangeConfirmed",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentOwnershipChangeCancelled",
          "inputs": [
            {
              "name": "cancelledOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentOwnershipChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initialize",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapActionHash",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            },
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performBatchActions",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performBatchActions",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBatchActionHash",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeOwnership",
          "inputs": [
            {
              "name": "_newOwner",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOwnershipChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "initialized",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "usedSignatures",
          "inputs": [
            {
              "name": "arg0",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "owner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingOwner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newOwner",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ownershipChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_minOwnerChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxOwnerChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/UserWalletInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n# struct SwapInstruction:\n#     legoId: uint256\n#     amountIn: uint256\n#     minAmountOut: uint256\n#     tokenPath: DynArray[address, 5]\n#     poolPath: DynArray[address, 5 - 1]\n\n\n# @external\n# def swapTokens(_swapInstructions: DynArray[SwapInstruction, 5]) -> (uint256, uint256, uint256):\n#     ...\n\n\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    ...\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    ...\n\n\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    ...\n\n\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    ...\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    ...\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    ...\n",
            "sha256sum": "b6f85ddff061e77069cceb9d110c05c679a6ea34b68f3ff69c95c1b07d83c453"
          },
          "contracts/core/AgentTemplate.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nfrom interfaces import UserWalletInterface\nfrom ethereum.ercs import IERC20\n\ninterface UserWalletCustom:\n    def swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256): nonpayable\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct Signature:\n    signature: Bytes[65]\n    signer: address\n    expiration: uint256\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct ActionInstruction:\n    usePrevAmountOut: bool\n    action: ActionType\n    legoId: uint256\n    asset: address\n    vault: address\n    amount: uint256\n    altLegoId: uint256\n    altAsset: address\n    altVault: address\n    altAmount: uint256\n    minAmountOut: uint256\n    pool: address\n    proof: bytes32\n    nftAddr: address\n    nftTokenId: uint256\n    tickLower: int24\n    tickUpper: int24\n    minAmountA: uint256\n    minAmountB: uint256\n    minLpAmount: uint256\n    liqToRemove: uint256\n    recipient: address\n    isWethToEthConversion: bool\n\nstruct PendingOwner:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeDelaySet:\n    delayBlocks: uint256\n\nevent AgentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\ninitialized: public(bool)\nusedSignatures: public(HashMap[Bytes[65], bool])\n\n# owner\nowner: public(address) # owner of the wallet\npendingOwner: public(PendingOwner) # pending owner of the wallet\nownershipChangeDelay: public(uint256) # num blocks to wait before owner can be changed\n\n# eip-712\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\nDEPOSIT_TYPE_HASH: constant(bytes32) = keccak256('Deposit(address userWallet,uint256 legoId,address asset,address vault,uint256 amount,uint256 expiration)')\nWITHDRAWAL_TYPE_HASH: constant(bytes32) = keccak256('Withdrawal(address userWallet,uint256 legoId,address asset,address vaultToken,uint256 vaultTokenAmount,uint256 expiration)')\nREBALANCE_TYPE_HASH: constant(bytes32) = keccak256('Rebalance(address userWallet,uint256 fromLegoId,address fromAsset,address fromVaultToken,uint256 toLegoId,address toVault,uint256 fromVaultTokenAmount,uint256 expiration)')\nSWAP_ACTION_TYPE_HASH: constant(bytes32) =  keccak256('Swap(address userWallet,SwapInstruction[] swapInstructions,uint256 expiration)')\nSWAP_INSTRUCTION_TYPE_HASH: constant(bytes32) = keccak256('SwapInstruction(uint256 legoId,uint256 amountIn,uint256 minAmountOut,address[] tokenPath,address[] poolPath)')\nADD_LIQ_TYPE_HASH: constant(bytes32) = keccak256('AddLiquidity(address userWallet,uint256 legoId,address nftAddr,uint256 nftTokenId,address pool,address tokenA,address tokenB,uint256 amountA,uint256 amountB,int24 tickLower,int24 tickUpper,uint256 minAmountA,uint256 minAmountB,uint256 minLpAmount,uint256 expiration)')\nREMOVE_LIQ_TYPE_HASH: constant(bytes32) = keccak256('RemoveLiquidity(address userWallet,uint256 legoId,address nftAddr,uint256 nftTokenId,address pool,address tokenA,address tokenB,uint256 liqToRemove,uint256 minAmountA,uint256 minAmountB,uint256 expiration)')\nTRANSFER_TYPE_HASH: constant(bytes32) = keccak256('Transfer(address userWallet,address recipient,uint256 amount,address asset,uint256 expiration)')\nETH_TO_WETH_TYPE_HASH: constant(bytes32) = keccak256('EthToWeth(address userWallet,uint256 amount,uint256 depositLegoId,address depositVault,uint256 expiration)')\nWETH_TO_ETH_TYPE_HASH: constant(bytes32) = keccak256('WethToEth(address userWallet,uint256 amount,address recipient,uint256 withdrawLegoId,address withdrawVaultToken,uint256 expiration)')\nCLAIM_REWARDS_TYPE_HASH: constant(bytes32) = keccak256('ClaimRewards(address userWallet,uint256 legoId,address market,address rewardToken,uint256 rewardAmount,bytes32 proof,uint256 expiration)')\nBORROW_TYPE_HASH: constant(bytes32) = keccak256('Borrow(address userWallet,uint256 legoId,address borrowAsset,uint256 amount,uint256 expiration)')\nREPAY_TYPE_HASH: constant(bytes32) = keccak256('Repay(address userWallet,uint256 legoId,address paymentAsset,uint256 paymentAmount,uint256 expiration)')\nBATCH_ACTIONS_TYPE_HASH: constant(bytes32) =  keccak256('BatchActions(address userWallet,ActionInstruction[] instructions,uint256 expiration)')\nACTION_INSTRUCTION_TYPE_HASH: constant(bytes32) = keccak256('ActionInstruction(bool usePrevAmountOut,uint256 action,uint256 legoId,address asset,address vault,uint256 amount,uint256 altLegoId,address altAsset,address altVault,uint256 altAmount,uint256 minAmountOut,address pool,bytes32 proof,address nftAddr,uint256 nftTokenId,int24 tickLower,int24 tickUpper,uint256 minAmountA,uint256 minAmountB,uint256 minLpAmount,uint256 liqToRemove,address recipient,bool isWethToEthConversion)')\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_INSTRUCTIONS: constant(uint256) = 20\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\n\nAPI_VERSION: constant(String[28]) = \"0.0.1\"\n\n\n@deploy\ndef __init__(_minOwnerChangeDelay: uint256, _maxOwnerChangeDelay: uint256):\n    MIN_OWNER_CHANGE_DELAY = _minOwnerChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxOwnerChangeDelay\n\n    # make sure original reference contract can't be initialized\n    self.initialized = True\n\n\n@external\ndef initialize(_owner: address) -> bool:\n    assert not self.initialized # dev: can only initialize once\n    self.initialized = True\n\n    assert empty(address) not in [_owner] # dev: invalid addr\n    self.owner = _owner\n    self.ownershipChangeDelay = MIN_OWNER_CHANGE_DELAY\n\n    return True\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    return API_VERSION\n\n\n###########\n# Deposit #\n###########\n\n\n@nonreentrant\n@external\ndef depositTokens(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(DEPOSIT_TYPE_HASH, _userWallet, _legoId, _asset, _vault, _amount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).depositTokens(_legoId, _asset, _vault, _amount)\n\n\n############\n# Withdraw #\n############\n\n\n@nonreentrant\n@external\ndef withdrawTokens(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(WITHDRAWAL_TYPE_HASH, _userWallet, _legoId, _asset, _vaultToken, _vaultTokenAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).withdrawTokens(_legoId, _asset, _vaultToken, _vaultTokenAmount)\n\n\n#############\n# Rebalance #\n#############\n\n\n@nonreentrant\n@external\ndef rebalance(\n    _userWallet: address,\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REBALANCE_TYPE_HASH, _userWallet, _fromLegoId, _fromAsset, _fromVaultToken, _toLegoId, _toVault, _fromVaultTokenAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).rebalance(_fromLegoId, _fromAsset, _fromVaultToken, _toLegoId, _toVault, _fromVaultTokenAmount)\n\n\n########\n# Swap #\n########\n\n\n@nonreentrant\n@external\ndef swapTokens(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSwapSignature(self._hashSwapInstructions(_userWallet, _swapInstructions, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletCustom(_userWallet).swapTokens(_swapInstructions)\n\n\n@view\n@internal\ndef _encodeSwapInstruction(_instruction: SwapInstruction) -> Bytes[544]:\n    # Just encode, no hash\n    return abi_encode(\n        SWAP_INSTRUCTION_TYPE_HASH,\n        _instruction.legoId,\n        _instruction.amountIn,\n        _instruction.minAmountOut,\n        _instruction.tokenPath,\n        _instruction.poolPath\n    )\n\n\n@view\n@internal\ndef _encodeSwapInstructions(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> Bytes[2720]:\n    concatenated: Bytes[2720] = empty(Bytes[2720]) # max size for 5 instructions - 5*544\n    for i: uint256 in range(len(_swapInstructions), bound=MAX_SWAP_INSTRUCTIONS):\n        concatenated = convert(\n            concat(\n                concatenated, \n                self._encodeSwapInstruction(_swapInstructions[i])\n            ),\n            Bytes[2720]\n        )\n    return concatenated\n\n\n@view\n@internal\ndef _hashSwapInstructions(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _expiration: uint256,\n) -> Bytes[2880]:\n    # Now we encode everything and hash only once at the end\n    return abi_encode(\n        SWAP_ACTION_TYPE_HASH,\n        _userWallet,\n        self._encodeSwapInstructions(_swapInstructions),\n        _expiration\n    )\n\n\n@internal\ndef _isValidSwapSignature(_encodedValue: Bytes[2880], _sig: Signature):\n    encoded_hash: bytes32 = keccak256(_encodedValue)\n    domain_sep: bytes32 = self._domainSeparator()\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', domain_sep, encoded_hash))\n\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n@view\n@external\ndef getSwapActionHash(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _expiration: uint256,\n) -> bytes32:\n    encodedValue: Bytes[2880] = self._hashSwapInstructions(_userWallet, _swapInstructions, _expiration)\n    encoded_hash: bytes32 = keccak256(encodedValue)\n    return keccak256(concat(b'\\x19\\x01', self._domainSeparator(), encoded_hash))\n\n\n##################\n# Borrow + Repay #\n##################\n\n\n@nonreentrant\n@external\ndef borrow(\n    _userWallet: address,\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(BORROW_TYPE_HASH, _userWallet, _legoId, _borrowAsset, _amount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).borrow(_legoId, _borrowAsset, _amount)\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _userWallet: address,\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REPAY_TYPE_HASH, _userWallet, _legoId, _paymentAsset, _paymentAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).repayDebt(_legoId, _paymentAsset, _paymentAmount)\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _userWallet: address,\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(CLAIM_REWARDS_TYPE_HASH, _userWallet, _legoId, _market, _rewardToken, _rewardAmount, _proof, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    extcall UserWalletInterface(_userWallet).claimRewards(_legoId, _market, _rewardToken, _rewardAmount, _proof)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(ADD_LIQ_TYPE_HASH, _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).addLiquidity(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, bool):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REMOVE_LIQ_TYPE_HASH, _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).removeLiquidity(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB)\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _userWallet: address,\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(TRANSFER_TYPE_HASH, _userWallet, _recipient, _amount, _asset, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).transferFunds(_recipient, _amount, _asset)\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@nonreentrant\n@external\ndef convertEthToWeth(\n    _userWallet: address,\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(ETH_TO_WETH_TYPE_HASH, _userWallet, _amount, _depositLegoId, _depositVault, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).convertEthToWeth(_amount, _depositLegoId, _depositVault)\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(\n    _userWallet: address,\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> uint256:\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(WETH_TO_ETH_TYPE_HASH, _userWallet, _amount, _recipient, _withdrawLegoId, _withdrawVaultToken, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).convertWethToEth(_amount, _recipient, _withdrawLegoId, _withdrawVaultToken)\n\n\n#################\n# Batch Actions #\n#################\n\n\n@nonreentrant\n@external\ndef performBatchActions(\n    _userWallet: address,\n    _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> bool:\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidBatchSignature(self._hashBatchActions(_userWallet, _instructions, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n\n    assert len(_instructions) != 0 # dev: no instructions\n    prevAmountReceived: uint256 = 0\n\n    # not using these vars\n    naAddyA: address = empty(address)\n    naValueA: uint256 = 0\n    naValueB: uint256 = 0\n    naValueC: uint256 = 0\n    naValueD: uint256 = 0\n    naBool: bool = False\n\n    # iterate through instructions\n    for j: uint256 in range(len(_instructions), bound=MAX_INSTRUCTIONS):\n        i: ActionInstruction = _instructions[j]\n\n        # deposit\n        if i.action == ActionType.DEPOSIT:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).depositTokens(i.legoId, i.asset, i.vault, amount)\n\n        # withdraw\n        elif i.action == ActionType.WITHDRAWAL:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            prevAmountReceived, naValueA, naValueB = extcall UserWalletInterface(_userWallet).withdrawTokens(i.legoId, i.asset, i.vault, amount)\n\n        # rebalance\n        elif i.action == ActionType.REBALANCE:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).rebalance(i.legoId, i.asset, i.vault, i.altLegoId, i.altVault, amount)\n\n        # borrow\n        elif i.action == ActionType.BORROW:\n            naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).borrow(i.legoId, i.asset, i.amount)\n\n        # repay debt\n        elif i.action == ActionType.REPAY:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            extcall UserWalletInterface(_userWallet).repayDebt(i.legoId, i.asset, amount)\n            prevAmountReceived = 0\n\n        # claim rewards\n        elif i.action == ActionType.CLAIM_REWARDS:\n            extcall UserWalletInterface(_userWallet).claimRewards(i.legoId, i.asset, i.altAsset, i.amount, i.proof)\n            prevAmountReceived = 0\n\n        # add liquidity\n        elif i.action == ActionType.ADD_LIQ:\n            amount: uint256 = i.amount # this only goes towards token A amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            prevAmountReceived, naValueA, naValueB, naValueC, naValueD = extcall UserWalletInterface(_userWallet).addLiquidity(i.legoId, i.nftAddr, i.nftTokenId, i.pool, i.asset, i.altAsset, amount, i.altAmount, i.tickLower, i.tickUpper, i.minAmountA, i.minAmountB, i.minLpAmount)\n\n        # remove liquidity\n        elif i.action == ActionType.REMOVE_LIQ:\n            amount: uint256 = i.liqToRemove # this only goes to `_liqToRemove`\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naValueB, naValueC, naBool = extcall UserWalletInterface(_userWallet).removeLiquidity(i.legoId, i.nftAddr, i.nftTokenId, i.pool, i.asset, i.altAsset, amount, i.minAmountA, i.minAmountB)\n            prevAmountReceived = 0\n\n        # transfer\n        elif i.action == ActionType.TRANSFER:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            extcall UserWalletInterface(_userWallet).transferFunds(i.recipient, amount, i.asset)\n            prevAmountReceived = 0\n\n        # conversion\n        elif i.action == ActionType.CONVERSION:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            if i.isWethToEthConversion:\n                prevAmountReceived = extcall UserWalletInterface(_userWallet).convertWethToEth(amount, i.recipient, i.legoId, i.vault)\n            else:\n                prevAmountReceived, naAddyA, naValueB = extcall UserWalletInterface(_userWallet).convertEthToWeth(amount, i.legoId, i.vault)\n                if naValueB != 0:\n                    prevAmountReceived = naValueB\n\n    return True\n\n\n@view\n@internal\ndef _encodeBatchActionInstruction(_instr: ActionInstruction) -> Bytes[768]:\n    # Just encode, no hash\n    return abi_encode(\n        ACTION_INSTRUCTION_TYPE_HASH,\n        _instr.usePrevAmountOut,\n        _instr.action,\n        _instr.legoId,\n        _instr.asset,\n        _instr.vault,\n        _instr.amount,\n        _instr.altLegoId,\n        _instr.altAsset,\n        _instr.altVault,\n        _instr.altAmount,\n        _instr.minAmountOut,\n        _instr.pool,\n        _instr.proof,\n        _instr.nftAddr,\n        _instr.nftTokenId,\n        _instr.tickLower,\n        _instr.tickUpper,\n        _instr.minAmountA,\n        _instr.minAmountB,\n        _instr.minLpAmount,\n        _instr.liqToRemove,\n        _instr.recipient,\n        _instr.isWethToEthConversion\n    )\n\n\n@view\n@internal\ndef _encodeBatchInstructions(_instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS]) -> Bytes[15360]:\n    concatenated: Bytes[15360] = empty(Bytes[15360]) # max size for 20 instructions - 20*768\n    for i: uint256 in range(len(_instructions), bound=MAX_INSTRUCTIONS):\n        concatenated = convert(\n            concat(\n                concatenated, \n                self._encodeBatchActionInstruction(_instructions[i])\n            ),\n            Bytes[15360]\n        )\n    return concatenated\n\n\n@view\n@internal\ndef _hashBatchActions(_userWallet: address, _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS], _expiration: uint256) -> Bytes[15520]:\n    # Now we encode everything and hash only once at the end\n    return abi_encode(\n        BATCH_ACTIONS_TYPE_HASH,\n        _userWallet,\n        self._encodeBatchInstructions(_instructions),\n        _expiration\n    )\n\n\n@internal\ndef _isValidBatchSignature(_encodedValue: Bytes[15520], _sig: Signature):\n    encoded_hash: bytes32 = keccak256(_encodedValue)\n    domain_sep: bytes32 = self._domainSeparator()\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', domain_sep, encoded_hash))\n\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n@view\n@external\ndef getBatchActionHash(_userWallet: address, _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS], _expiration: uint256) -> bytes32:\n    encodedValue: Bytes[15520] = self._hashBatchActions(_userWallet, _instructions, _expiration)\n    encoded_hash: bytes32 = keccak256(encodedValue)\n    return keccak256(concat(b'\\x19\\x01', self._domainSeparator(), encoded_hash))\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    return keccak256(\n        concat(\n            DOMAIN_TYPE_HASH,\n            keccak256('UnderscoreAgent'),\n            keccak256(API_VERSION),\n            abi_encode(chain.id, self)\n        )\n    )\n\n\n@internal\ndef _isValidSignature(_encodedValue: Bytes[736], _sig: Signature):\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', self._domainSeparator(), keccak256(_encodedValue)))\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n####################\n# Ownership Change #\n####################\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    \"\"\"\n    @notice Initiates a new ownership change\n    @dev Can only be called by the current owner\n    @param _newOwner The address of the new owner\n    \"\"\"\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingOwner = PendingOwner(\n        newOwner= _newOwner,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log AgentOwnershipChangeInitiated(prevOwner=currentOwner, newOwner=_newOwner, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmOwnershipChange():\n    \"\"\"\n    @notice Confirms the ownership change\n    @dev Can only be called by the new owner\n    \"\"\"\n    data: PendingOwner = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwner)\n    log AgentOwnershipChangeConfirmed(prevOwner=prevOwner, newOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelOwnershipChange():\n    \"\"\"\n    @notice Cancels the ownership change\n    @dev Can only be called by the current owner\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    data: PendingOwner = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwner)\n    log AgentOwnershipChangeCancelled(cancelledOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setOwnershipChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the ownership change delay\n    @dev Can only be called by the owner\n    @param _numBlocks The number of blocks to wait before ownership can be changed\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNER_CHANGE_DELAY and _numBlocks <= MAX_OWNER_CHANGE_DELAY # dev: invalid delay\n    self.ownershipChangeDelay = _numBlocks\n    log AgentOwnershipChangeDelaySet(delayBlocks=_numBlocks)\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address) -> bool:\n    \"\"\"\n    @notice transfers funds from the agent wallet to the owner\n    @dev anyone can call this!\n    @param _asset The address of the asset to recover\n    @return bool True if the funds were recovered successfully\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner # dev: no perms\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [owner, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(owner, balance, default_return_value=True) # dev: recovery failed\n    log AgentFundsRecovered(asset=_asset, recipient=owner, balance=balance)\n    return True\n",
            "sha256sum": "b8d4feb4eb5253d5c9ffe64756da40f537f45ddcefb1236b113db0842ac764cf"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AgentTemplate.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "1362b0186ba8a0156280ea672b4103413f00eb98a1a3b0615646541cc8da5257"
      },
      "args": "00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "AgentFactory": {
      "address": "0xf220F44b2308E3018F3D45106Cfdb8E11c868E21",
      "abi": [
        {
          "name": "UserWalletCreated",
          "inputs": [
            {
              "name": "mainAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "configAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "agent",
              "type": "address",
              "indexed": false
            },
            {
              "name": "creator",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentCreated",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "creator",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTemplateSet",
          "inputs": [
            {
              "name": "template",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletConfigTemplateSet",
          "inputs": [
            {
              "name": "template",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentTemplateSet",
          "inputs": [
            {
              "name": "template",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TrialFundsDataSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "shouldWhitelist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NumUserWalletsAllowedSet",
          "inputs": [
            {
              "name": "numAllowed",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NumAgentsAllowedSet",
          "inputs": [
            {
              "name": "numAllowed",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldEnforceWhitelistSet",
          "inputs": [
            {
              "name": "shouldEnforce",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentBlacklistSet",
          "inputs": [
            {
              "name": "agentAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldBlacklist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentFactoryFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentFactoryActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RecoveryCallerSet",
          "inputs": [
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "currentUserWalletTemplate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "currentUserWalletConfigTemplate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "currentAgentTemplate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidUserWalletSetup",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidUserWalletTemplate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserWalletTemplate",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidUserWalletConfigTemplate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserWalletConfigTemplate",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAgentSetup",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createAgent",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createAgent",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAgentTemplate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentTemplate",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidTrialFundsData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setTrialFundsData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWhitelist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldWhitelist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldEnforceWhitelist",
          "inputs": [
            {
              "name": "_shouldEnforce",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumUserWalletsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumUserWalletsAllowed",
          "inputs": [
            {
              "name": "_numAllowed",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumAgentsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumAgentsAllowed",
          "inputs": [
            {
              "name": "_numAllowed",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentBlacklist",
          "inputs": [
            {
              "name": "_agentAddr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverTrialFunds",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverTrialFunds",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_opportunities",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverTrialFundsMany",
          "inputs": [
            {
              "name": "trialFundAsset",
              "type": "address"
            },
            {
              "name": "_recoveries",
              "type": "tuple[]",
              "components": [
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "opportunities",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "vaultToken",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRecoveryCaller",
          "inputs": [
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserWallet",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "recoveryCaller",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userWalletTemplate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userWalletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "_isUserWallet",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserWallets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentTemplateInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgent",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAgents",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentBlacklist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserWalletsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAgentsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "whitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "shouldEnforceWhitelist",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH_ADDR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_userWalletTemplate",
              "type": "address"
            },
            {
              "name": "_userConfigTemplate",
              "type": "address"
            },
            {
              "name": "_agentTemplate",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "contracts/core/AgentFactory.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\n\ninterface MainWallet:\n    def initialize(_walletConfig: address, _addyRegistry: address, _wethAddr: address, _trialFundsAsset: address, _trialFundsInitialAmount: uint256) -> bool: nonpayable\n    def recoverTrialFunds(_opportunities: DynArray[TrialFundsOpp, MAX_LEGOS]) -> bool: nonpayable\n\ninterface WalletConfig:\n    def initialize(_wallet: address, _addyRegistry: address, _owner: address, _initialAgent: address) -> bool: nonpayable\n\ninterface Agent:\n    def initialize(_owner: address) -> bool: nonpayable\n\ninterface AltAgentFactory:\n    def isUserWallet(_addr: address) -> bool: view\n\nstruct TemplateInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n\nstruct TrialFundsData:\n    asset: address\n    amount: uint256\n\nstruct TrialFundsOpp:\n    legoId: uint256\n    vaultToken: address\n\nstruct TrialFundsRecovery:\n    wallet: address\n    opportunities: DynArray[TrialFundsOpp, MAX_LEGOS]\n\nevent UserWalletCreated:\n    mainAddr: indexed(address)\n    configAddr: indexed(address)\n    owner: indexed(address)\n    agent: address\n    creator: address\n\nevent AgentCreated:\n    agent: indexed(address)\n    owner: indexed(address)\n    creator: address\n\nevent UserWalletTemplateSet:\n    template: indexed(address)\n    version: uint256\n\nevent UserWalletConfigTemplateSet:\n    template: indexed(address)\n    version: uint256\n\nevent AgentTemplateSet:\n    template: indexed(address)\n    version: uint256\n\nevent TrialFundsDataSet:\n    asset: indexed(address)\n    amount: uint256\n\nevent WhitelistSet:\n    addr: address\n    shouldWhitelist: bool\n\nevent NumUserWalletsAllowedSet:\n    numAllowed: uint256\n\nevent NumAgentsAllowedSet:\n    numAllowed: uint256\n\nevent ShouldEnforceWhitelistSet:\n    shouldEnforce: bool\n\nevent AgentBlacklistSet:\n    agentAddr: indexed(address)\n    shouldBlacklist: bool\n\nevent AgentFactoryFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent AgentFactoryActivated:\n    isActivated: bool\n\nevent RecoveryCallerSet:\n    caller: indexed(address)\n\ntrialFundsData: public(TrialFundsData)\nrecoveryCaller: public(address)\n\n# user wallets\nuserWalletTemplate: public(TemplateInfo)\nuserWalletConfig: public(TemplateInfo)\n_isUserWallet: public(HashMap[address, bool])\nnumUserWallets: public(uint256)\n\n# agents\nagentTemplateInfo: public(TemplateInfo)\nisAgent: public(HashMap[address, bool])\nnumAgents: public(uint256)\n\n# limits / controls\nagentBlacklist: public(HashMap[address, bool])\nnumUserWalletsAllowed: public(uint256)\nnumAgentsAllowed: public(uint256)\nwhitelist: public(HashMap[address, bool])\nshouldEnforceWhitelist: public(bool)\n\n# config\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\nWETH_ADDR: public(immutable(address))\n\nMAX_LEGOS: constant(uint256) = 20\nMAX_RECOVERIES: constant(uint256) = 100\n\n# agent factories\nOLD_AGENT_FACTORY: constant(address) = 0x7bA5A18b88fFc9bB569d5A7e311c1607a0737a25 # v1\nNEW_AGENT_FACTORY: constant(address) = 0x7C4be37a65E8410c0fb03d62059E3cB04f78c565 # v3\n\n@deploy\ndef __init__(\n    _addyRegistry: address,\n    _wethAddr: address,\n    _userWalletTemplate: address,\n    _userConfigTemplate: address,\n    _agentTemplate: address,\n):\n    assert empty(address) not in [_addyRegistry, _wethAddr] # dev: invalid addrs\n    ADDY_REGISTRY = _addyRegistry\n    WETH_ADDR = _wethAddr\n    gov.__init__(_addyRegistry)\n    self.isActivated = True\n\n    # set agent template\n    if self._isValidUserWalletTemplate(_userWalletTemplate) and self._isValidUserWalletConfigTemplate(_userConfigTemplate):\n        self._setUserWalletTemplate(_userWalletTemplate)\n        self._setUserWalletConfigTemplate(_userConfigTemplate)\n\n    # set agent template\n    if self._isValidAgentTemplate(_agentTemplate):\n        self._setAgentTemplate(_agentTemplate)\n\n\n@view\n@external\ndef currentUserWalletTemplate() -> address:\n    \"\"\"\n    @notice Get the current wallet template address being used by the factory\n    @dev This is a simple getter for the current template address stored in userWalletTemplate\n    @return The address of the current wallet template\n    \"\"\"\n    return self.userWalletTemplate.addr\n\n\n@view\n@external\ndef currentUserWalletConfigTemplate() -> address:\n    \"\"\"\n    @notice Get the current wallet config template address being used by the factory\n    @dev This is a simple getter for the current template address stored in userWalletConfig\n    @return The address of the current wallet config template\n    \"\"\"\n    return self.userWalletConfig.addr\n\n\n@view\n@external\ndef currentAgentTemplate() -> address:\n    \"\"\"\n    @notice Get the current agent template address being used by the factory\n    @dev This is a simple getter for the current template address stored in agentTemplateInfo\n    @return The address of the current agent template\n    \"\"\"\n    return self.agentTemplateInfo.addr\n\n\n######################\n# Create User Wallet #\n######################\n\n\n@view\n@external \ndef isValidUserWalletSetup(_owner: address, _agent: address) -> bool:\n    \"\"\"\n    @notice Check if the provided owner and agent addresses form a valid wallet setup\n    @dev Validates that both templates exist and owner/agent combination is valid\n    @param _owner The address that will own the wallet\n    @param _agent The address that will be the agent (can be empty)\n    @return True if the setup is valid, False otherwise\n    \"\"\"\n    return self._isValidUserWalletSetup(self.userWalletTemplate.addr, self.userWalletConfig.addr, _owner, _agent)\n\n\n@view\n@internal \ndef _isValidUserWalletSetup(_mainTemplate: address, _configTemplate: address, _owner: address, _agent: address) -> bool:\n    if _mainTemplate == empty(address) or _configTemplate == empty(address):\n        return False\n    return _owner != empty(address) and _owner != _agent\n\n\n@external\ndef createUserWallet(_owner: address = msg.sender, _agent: address = empty(address)) -> address:\n    \"\"\"\n    @notice Create a new User Wallet with specified owner and optional agent\n    @dev Creates a minimal proxy of the current template and initializes it\n    @param _owner The address that will own the wallet (defaults to msg.sender)\n    @param _agent The address that will be the agent (defaults to empty address, can add this later)\n    @return The address of the newly created wallet, or empty address if setup is invalid\n    \"\"\"\n    assert self.isActivated # dev: not activated\n\n    mainWalletTemplate: address = self.userWalletTemplate.addr\n    walletConfigTemplate: address = self.userWalletConfig.addr\n    if not self._isValidUserWalletSetup(mainWalletTemplate, walletConfigTemplate, _owner, _agent):\n        return empty(address)\n\n    # check limits\n    if self.shouldEnforceWhitelist and not self.whitelist[msg.sender]:\n        return empty(address)\n    if self.numUserWallets >= self.numUserWalletsAllowed:\n        return empty(address)\n\n    # create both contracts (main wallet and wallet config)\n    mainWalletAddr: address = create_minimal_proxy_to(mainWalletTemplate)\n    walletConfigAddr: address = create_minimal_proxy_to(walletConfigTemplate)\n\n    # initial trial funds asset + amount\n    trialFundsData: TrialFundsData = self.trialFundsData\n    if trialFundsData.asset != empty(address):\n        trialFundsData.amount = min(trialFundsData.amount, staticcall IERC20(trialFundsData.asset).balanceOf(self))\n\n    # initalize main wallet and wallet config\n    assert extcall MainWallet(mainWalletAddr).initialize(walletConfigAddr, ADDY_REGISTRY, WETH_ADDR, trialFundsData.asset, trialFundsData.amount) # dev: could not initialize main wallet\n    assert extcall WalletConfig(walletConfigAddr).initialize(mainWalletAddr, ADDY_REGISTRY, _owner, _agent) # dev: could not initialize wallet config\n\n    # transfer after initialization\n    if trialFundsData.amount != 0:\n        assert extcall IERC20(trialFundsData.asset).transfer(mainWalletAddr, trialFundsData.amount, default_return_value=True) # dev: gift transfer failed\n\n    # update data\n    self._isUserWallet[mainWalletAddr] = True\n    self.numUserWallets += 1\n\n    log UserWalletCreated(mainAddr=mainWalletAddr, configAddr=walletConfigAddr, owner=_owner, agent=_agent, creator=msg.sender)\n    return mainWalletAddr\n\n\n#########################\n# User Wallet Templates #\n#########################\n\n\n# main user wallet\n\n\n@view\n@external \ndef isValidUserWalletTemplate(_newAddr: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is valid to be used as a new user wallet template\n    @dev Validates the address is a contract and different from current template\n    @param _newAddr The address to validate as a potential new template\n    @return True if the address can be used as a template, False otherwise\n    \"\"\"\n    return self._isValidUserWalletTemplate(_newAddr)\n\n\n@view\n@internal \ndef _isValidUserWalletTemplate(_newAddr: address) -> bool:\n    if not _newAddr.is_contract or _newAddr == empty(address):\n        return False\n    return _newAddr != self.userWalletTemplate.addr\n\n\n@external\ndef setUserWalletTemplate(_addr: address) -> bool:\n    \"\"\"\n    @notice Set a new main wallet template address for future wallet deployments\n    @dev Only callable by the governor, updates template info and emits event\n    @param _addr The address of the new template to use\n    @return True if template was successfully updated, False if invalid address\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidUserWalletTemplate(_addr):\n        return False\n    return self._setUserWalletTemplate(_addr)\n\n\n@internal\ndef _setUserWalletTemplate(_addr: address) -> bool:   \n    prevData: TemplateInfo = self.userWalletTemplate\n    newData: TemplateInfo = TemplateInfo(\n        addr=_addr,\n        version=prevData.version + 1,\n        lastModified=block.timestamp,\n    )\n    self.userWalletTemplate = newData\n    log UserWalletTemplateSet(template=_addr, version=newData.version)\n    return True\n\n\n# user config\n\n\n@view\n@external \ndef isValidUserWalletConfigTemplate(_newAddr: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is valid to be used as a new user wallet config template\n    @dev Validates the address is a contract and different from current template\n    @param _newAddr The address to validate as a potential new template\n    @return True if the address can be used as a template, False otherwise\n    \"\"\"\n    return self._isValidUserWalletConfigTemplate(_newAddr)\n\n\n@view\n@internal \ndef _isValidUserWalletConfigTemplate(_newAddr: address) -> bool:\n    if not _newAddr.is_contract or _newAddr == empty(address):\n        return False\n    return _newAddr != self.userWalletConfig.addr\n\n\n@external\ndef setUserWalletConfigTemplate(_addr: address) -> bool:\n    \"\"\"\n    @notice Set a new user wallet config template address for future wallet deployments\n    @dev Only callable by the governor, updates template info and emits event\n    @param _addr The address of the new template to use\n    @return True if template was successfully updated, False if invalid address\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidUserWalletConfigTemplate(_addr):\n        return False\n    return self._setUserWalletConfigTemplate(_addr)\n\n\n@internal\ndef _setUserWalletConfigTemplate(_addr: address) -> bool:   \n    prevData: TemplateInfo = self.userWalletConfig\n    newData: TemplateInfo = TemplateInfo(\n        addr=_addr,\n        version=prevData.version + 1,\n        lastModified=block.timestamp,\n    )\n    self.userWalletConfig = newData\n    log UserWalletConfigTemplateSet(template=_addr, version=newData.version)\n    return True\n\n\n################\n# Create Agent #\n################\n\n\n@view\n@external \ndef isValidAgentSetup(_owner: address) -> bool:\n    \"\"\"\n    @notice Check if the provided owner address forms a valid agent setup\n    @dev Validates that the template exists and owner is not empty\n    @param _owner The address that will own the agent\n    @return True if the setup is valid, False otherwise\n    \"\"\"\n    return self._isValidAgentSetup(self.agentTemplateInfo.addr, _owner)\n\n\n@view\n@internal \ndef _isValidAgentSetup(_agentTemplateInfo: address, _owner: address) -> bool:\n    if _agentTemplateInfo == empty(address):\n        return False\n    return _owner != empty(address)\n\n\n@external\ndef createAgent(_owner: address = msg.sender) -> address:\n    \"\"\"\n    @notice Create a new Agent with specified owner\n    @dev Creates a minimal proxy of the current template and initializes it\n    @param _owner The address that will own the agent (defaults to msg.sender)\n    @return The address of the newly created agent, or empty address if setup is invalid\n    \"\"\"\n    assert self.isActivated # dev: not activated\n\n    agentTemplateInfo: address = self.agentTemplateInfo.addr\n    if not self._isValidAgentSetup(agentTemplateInfo, _owner):\n        return empty(address)\n\n    # check limits\n    if self.shouldEnforceWhitelist and not self.whitelist[msg.sender]:\n        return empty(address)\n    if self.numAgents >= self.numAgentsAllowed:\n        return empty(address)\n\n    # create agent contract\n    agentAddr: address = create_minimal_proxy_to(agentTemplateInfo)\n    assert extcall Agent(agentAddr).initialize(_owner) # dev: could not initialize agent\n\n    # update data\n    self.isAgent[agentAddr] = True\n    self.numAgents += 1\n\n    log AgentCreated(agent=agentAddr, owner=_owner, creator=msg.sender)\n    return agentAddr\n\n\n# agent template\n\n\n@view\n@external \ndef isValidAgentTemplate(_newAddr: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is valid to be used as a new agent template\n    @dev Validates the address is a contract and different from current template\n    @param _newAddr The address to validate as a potential new template\n    @return True if the address can be used as a template, False otherwise\n    \"\"\"\n    return self._isValidAgentTemplate(_newAddr)\n\n\n@view\n@internal \ndef _isValidAgentTemplate(_newAddr: address) -> bool:\n    if not _newAddr.is_contract or _newAddr == empty(address):\n        return False\n    return _newAddr != self.agentTemplateInfo.addr\n\n\n@external\ndef setAgentTemplate(_addr: address) -> bool:\n    \"\"\"\n    @notice Set a new agent template address for future agent deployments\n    @dev Only callable by the governor, updates template info and emits event\n    @param _addr The address of the new template to use\n    @return True if template was successfully updated, False if invalid address\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidAgentTemplate(_addr):\n        return False\n    return self._setAgentTemplate(_addr)\n\n\n@internal\ndef _setAgentTemplate(_addr: address) -> bool:   \n    prevData: TemplateInfo = self.agentTemplateInfo\n    newData: TemplateInfo = TemplateInfo(\n        addr=_addr,\n        version=prevData.version + 1,\n        lastModified=block.timestamp,\n    )\n    self.agentTemplateInfo = newData\n    log AgentTemplateSet(template=_addr, version=newData.version)\n    return True\n\n\n###############\n# Trial Funds #\n###############\n\n\n@view\n@external \ndef isValidTrialFundsData(_asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Check if the provided asset and amount form a valid trial funds setup\n    @dev Validates that the asset is a contract and amount is not zero\n    @param _asset The address of the asset to validate\n    @param _amount The amount of the asset to validate\n    @return True if the setup is valid, False otherwise\n    \"\"\"\n    return self._isValidTrialFundsData(_asset, _amount)\n\n\n@view\n@internal \ndef _isValidTrialFundsData(_asset: address, _amount: uint256) -> bool:\n    if not _asset.is_contract or _asset == empty(address):\n        return False\n    return _amount != 0\n\n\n@external\ndef setTrialFundsData(_asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Set the trial funds asset and amount for future wallet deployments\n    @dev Only callable by the governor, updates the trial funds data\n    @param _asset The address of the asset to set\n    @param _amount The amount of the asset to set\n    @return True if the data was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidTrialFundsData(_asset, _amount):\n        return False\n\n    self.trialFundsData = TrialFundsData(\n        asset=_asset,\n        amount=_amount,\n    )\n    log TrialFundsDataSet(asset=_asset, amount=_amount)\n    return True\n\n\n########################\n# Whitelist and Limits #\n########################\n\n\n@external\ndef setWhitelist(_addr: address, _shouldWhitelist: bool) -> bool:\n    \"\"\"\n    @notice Set the whitelist status for a given address\n    @dev Only callable by the governor, updates the whitelist state\n    @param _addr The address to set the whitelist status for\n    @param _shouldWhitelist True to whitelist, False to unwhitelist\n    @return True if the whitelist status was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.whitelist[_addr] = _shouldWhitelist\n    log WhitelistSet(addr=_addr, shouldWhitelist=_shouldWhitelist)\n    return True\n\n\n@external\ndef setShouldEnforceWhitelist(_shouldEnforce: bool) -> bool:\n    \"\"\"\n    @notice Set whether to enforce the whitelist for agent/wallet creation\n    @dev Only callable by the governor, updates the whitelist enforcement state\n    @param _shouldEnforce True to enforce whitelist, False to disable\n    @return True if the whitelist enforcement state was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.shouldEnforceWhitelist = _shouldEnforce\n    log ShouldEnforceWhitelistSet(shouldEnforce=_shouldEnforce)\n    return True\n\n\n@external\ndef setNumUserWalletsAllowed(_numAllowed: uint256 = max_value(uint256)) -> bool:\n    \"\"\"\n    @notice Set the maximum number of user wallets allowed\n    @dev Only callable by the governor, updates the maximum number of user wallets\n    @param _numAllowed The new maximum number of user wallets allowed\n    @return True if the maximum number was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.numUserWalletsAllowed = _numAllowed\n    log NumUserWalletsAllowedSet(numAllowed=_numAllowed)\n    return True\n\n\n@external\ndef setNumAgentsAllowed(_numAllowed: uint256 = max_value(uint256)) -> bool:\n    \"\"\"\n    @notice Set the maximum number of agents allowed\n    @dev Only callable by the governor, updates the maximum number of agents\n    @param _numAllowed The new maximum number of agents allowed\n    @return True if the maximum number was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.numAgentsAllowed = _numAllowed\n    log NumAgentsAllowedSet(numAllowed=_numAllowed)\n    return True\n\n\n###################\n# Agent Blacklist #\n###################\n\n\n@external\ndef setAgentBlacklist(_agentAddr: address, _shouldBlacklist: bool) -> bool:\n    \"\"\"\n    @notice Set the blacklist status for a given agent address\n    @dev Only callable by the governor, updates the blacklist state\n    @param _agentAddr The address to set the blacklist status for\n    @param _shouldBlacklist True to blacklist, False to unblacklist\n    @return True if the blacklist status was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.agentBlacklist[_agentAddr] = _shouldBlacklist\n    log AgentBlacklistSet(agentAddr=_agentAddr, shouldBlacklist=_shouldBlacklist)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    \"\"\"\n    @notice Recover funds from the factory\n    @dev Only callable by the governor, transfers funds to the recipient\n    @param _asset The address of the asset to recover\n    @param _recipient The address to send the funds to\n    @return True if the funds were successfully recovered, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AgentFactoryFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n    return True\n\n\n@external\ndef recoverTrialFunds(_wallet: address, _opportunities: DynArray[TrialFundsOpp, MAX_LEGOS] = []) -> bool:\n    \"\"\"\n    @notice Recover trial funds from a wallet\n    @dev Only callable by the governor or recovery caller, transfers funds back here\n    @param _wallet The address of the wallet to recover funds from\n    @param _opportunities The list of opportunities to recover funds for\n    @return True if the funds were successfully recovered, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) or msg.sender == self.recoveryCaller # dev: no perms\n    return extcall MainWallet(_wallet).recoverTrialFunds(_opportunities)\n\n\n@external\ndef recoverTrialFundsMany(trialFundAsset: address, _recoveries: DynArray[TrialFundsRecovery, MAX_RECOVERIES]) -> bool:\n    assert gov._isGovernor(msg.sender) or msg.sender == self.recoveryCaller # dev: no perms\n    for r: TrialFundsRecovery in _recoveries:\n        assert extcall MainWallet(r.wallet).recoverTrialFunds(r.opportunities) # dev: recovery failed\n\n    # transfer to new agent factory\n    balance: uint256 = staticcall IERC20(trialFundAsset).balanceOf(self)\n    if balance != 0:\n        assert extcall IERC20(trialFundAsset).transfer(NEW_AGENT_FACTORY, balance, default_return_value=True) # dev: transfer failed\n\n    return True\n\n\n@external\ndef setRecoveryCaller(_caller: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    if _caller == empty(address):\n        return False\n\n    self.recoveryCaller = _caller\n    log RecoveryCallerSet(caller=_caller)\n    return True\n\n\n############\n# Activate #\n############\n\n\n@external\ndef activate(_shouldActivate: bool):\n    \"\"\"\n    @notice Enable or disable the factory's ability to create new wallets\n    @dev Only callable by the governor, toggles isActivated state\n    @param _shouldActivate True to activate the factory, False to deactivate\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.isActivated = _shouldActivate\n    log AgentFactoryActivated(isActivated=_shouldActivate)\n\n\n#################\n# Compatibility #\n#################\n\n\n@view\n@external\ndef isUserWallet(_addr: address) -> bool:\n    isUserWallet: bool = self._isUserWallet[_addr]\n    if isUserWallet:\n        return True\n\n    # new factory\n    isNew: bool = False\n    if NEW_AGENT_FACTORY != empty(address):\n        isNew = staticcall AltAgentFactory(NEW_AGENT_FACTORY).isUserWallet(_addr)\n\n    # old factory\n    isOld: bool = False\n    if OLD_AGENT_FACTORY != empty(address):\n        isOld = staticcall AltAgentFactory(OLD_AGENT_FACTORY).isUserWallet(_addr)\n\n    return isNew or isOld\n",
            "sha256sum": "6bbdb9b6ddc5882ca66210dcfdc48db95e91d7f0e3f881636a41c810ea288b12"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AgentFactory.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "c70b5daad14cada707c6bcc1dad26db3adba695fb4e756607ec52253ae96df37"
      },
      "args": "00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd00000000000000000000000042000000000000000000000000000000000000060000000000000000000000006a5263b0645c7dfd2788ef46f95f210e947e074300000000000000000000000045d1a9429fd603c13cdab685dc2540f4f57df46400000000000000000000000070418b3aaa1044ec8bff6a461b4e43460bb5699e"
    },
    "LegoRegistry": {
      "address": "0x590504539913411CeF7fc1b3Fa49b06FE970c759",
      "abi": [
        {
          "name": "NewLegoRegistered",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "legoType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoAddrUpdated",
          "inputs": [
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "legoType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoAddrDisabled",
          "inputs": [
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "legoType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoHelperSet",
          "inputs": [
            {
              "name": "helperAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewLego",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            },
            {
              "name": "_legoType",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoUpdate",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoDisable",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoInfo",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "legoType",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoDescription",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegos",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastLegoAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastLegoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoHelper",
          "inputs": [
            {
              "name": "_helperAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoHelper",
          "inputs": [
            {
              "name": "_helperAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoHelper",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "legoType",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoAddrToId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numLegos",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/core/LegoRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\n\nfrom ethereum.ercs import IERC20\nimport contracts.modules.Governable as gov\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\nflag LegoType:\n    YIELD_OPP\n    DEX\n\nstruct LegoInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n    legoType: LegoType\n\nevent NewLegoRegistered:\n    addr: indexed(address)\n    legoId: uint256\n    description: String[64]\n    legoType: LegoType\n\nevent LegoAddrUpdated:\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    legoId: uint256\n    version: uint256\n    description: String[64]\n    legoType: LegoType\n\nevent LegoAddrDisabled:\n    prevAddr: indexed(address)\n    legoId: uint256\n    version: uint256\n    description: String[64]\n    legoType: LegoType\n\nevent LegoHelperSet:\n    helperAddr: indexed(address)\n\n# other\nlegoHelper: public(address)\n\n# registry core\nlegoInfo: public(HashMap[uint256, LegoInfo])\nlegoAddrToId: public(HashMap[address, uint256])\nnumLegos: public(uint256)\n\n# config\nADDY_REGISTRY: public(immutable(address))\n\nMAX_VAULTS: constant(uint256) = 15\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    gov.__init__(_addyRegistry)\n    ADDY_REGISTRY = _addyRegistry\n\n    # start at 1 index\n    self.numLegos = 1\n\n\n#################\n# Register Lego #\n#################\n\n\n@view\n@external\ndef isValidNewLegoAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be registered as a new Lego integration\n    @dev Validates address is non-zero, is a contract, and hasn't been registered before\n    @param _addr The address to validate\n    @return True if address can be registered as new Lego, False otherwise\n    \"\"\"\n    return self._isValidNewLegoAddr(_addr)\n\n\n@view\n@internal\ndef _isValidNewLegoAddr(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.legoAddrToId[_addr] == 0\n\n\n@external\ndef registerNewLego(_addr: address, _description: String[64], _legoType: LegoType) -> uint256:\n    \"\"\"\n    @notice Register a new Lego integration contract in the registry\n    @dev Only callable by governor. Sets Lego ID on the contract.\n    @param _addr The address of the Lego contract to register\n    @param _description A brief description of the Lego integration's functionality\n    @param _legoType The type of Lego integration\n    @return The assigned Lego ID if registration successful, 0 if failed\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidNewLegoAddr(_addr):\n        return 0\n\n    data: LegoInfo = LegoInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=_description,\n        legoType=_legoType,\n    )\n\n    legoId: uint256 = self.numLegos\n    self.legoAddrToId[_addr] = legoId\n    self.numLegos = legoId + 1\n    self.legoInfo[legoId] = data\n    assert extcall LegoCommon(_addr).setLegoId(legoId) # dev: set id failed\n\n    log NewLegoRegistered(addr=_addr, legoId=legoId, description=_description, legoType=_legoType)\n    return legoId\n\n\n###############\n# Update Lego #\n###############\n\n\n@view\n@external\ndef isValidLegoUpdate(_legoId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Check if a Lego integration update operation would be valid\n    @dev Validates Lego ID exists and new address is valid\n    @param _legoId The ID of the Lego integration to update\n    @param _newAddr The proposed new address for the Lego integration\n    @return True if update would be valid, False otherwise\n    \"\"\"\n    return self._isValidLegoUpdate(_legoId, _newAddr, self.legoInfo[_legoId].addr)\n\n\n@view\n@internal\ndef _isValidLegoUpdate(_legoId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidLegoId(_legoId):\n        return False\n    if not self._isValidNewLegoAddr(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@external\ndef updateLegoAddr(_legoId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Update the address of an existing Lego\n    @dev Only callable by governor. Updates version and timestamp.\n    @param _legoId The ID of the Lego to update\n    @param _newAddr The new address for the Lego\n    @return True if update successful, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    data: LegoInfo = self.legoInfo[_legoId]\n    prevAddr: address = data.addr # needed for later\n\n    if not self._isValidLegoUpdate(_legoId, _newAddr, prevAddr):\n        return False\n\n    # save new data\n    data.addr = _newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.legoInfo[_legoId] = data\n    self.legoAddrToId[_newAddr] = _legoId\n    assert extcall LegoCommon(_newAddr).setLegoId(_legoId) # dev: set id failed\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.legoAddrToId[prevAddr] = 0\n\n    log LegoAddrUpdated(newAddr=_newAddr, prevAddr=prevAddr, legoId=_legoId, version=data.version, description=data.description, legoType=data.legoType)\n    return True\n\n\n################\n# Disable Lego #\n################\n\n\n@view\n@external\ndef isValidLegoDisable(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Check if a Lego can be disabled\n    @dev Validates Lego ID exists and has a non-empty address\n    @param _legoId The ID of the Lego to check\n    @return True if Lego can be disabled, False otherwise\n    \"\"\"\n    return self._isValidLegoDisable(_legoId, self.legoInfo[_legoId].addr)\n\n\n@view\n@internal\ndef _isValidLegoDisable(_legoId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidLegoId(_legoId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@external\ndef disableLegoAddr(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Disable a Lego by setting its address to empty\n    @dev Only callable by governor. Updates version and timestamp.\n    @param _legoId The ID of the Lego to disable\n    @return True if disable successful, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    data: LegoInfo = self.legoInfo[_legoId]\n    prevAddr: address = data.addr # needed for later\n\n    if not self._isValidLegoDisable(_legoId, prevAddr):\n        return False\n\n    # save new data\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.legoInfo[_legoId] = data\n    self.legoAddrToId[prevAddr] = 0\n\n    log LegoAddrDisabled(prevAddr=prevAddr, legoId=_legoId, version=data.version, description=data.description, legoType=data.legoType)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidLegoAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address is a registered Lego integration\n    @dev Returns true if address has a non-zero Lego ID\n    @param _addr The address to check\n    @return True if address is a registered Lego integration, False otherwise\n    \"\"\"\n    return self.legoAddrToId[_addr] != 0\n\n\n@view\n@external\ndef isValidLegoId(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Check if a Lego ID is valid\n    @dev ID must be non-zero and less than total number of Legos\n    @param _legoId The ID to check\n    @return True if ID is valid, False otherwise\n    \"\"\"\n    return self._isValidLegoId(_legoId)\n\n\n@view\n@internal\ndef _isValidLegoId(_legoId: uint256) -> bool:\n    return _legoId != 0 and _legoId < self.numLegos\n\n\n# lego getters\n\n\n@view\n@external\ndef getLegoId(_addr: address) -> uint256:\n    \"\"\"\n    @notice Get the ID of a Lego from its address\n    @dev Returns 0 if address is not registered\n    @param _addr The address to query\n    @return The Lego ID associated with the address\n    \"\"\"\n    return self.legoAddrToId[_addr]\n\n\n@view\n@external\ndef getLegoAddr(_legoId: uint256) -> address:\n    \"\"\"\n    @notice Get the address of a Lego from its ID\n    @dev Returns empty address if ID is invalid or Lego is disabled\n    @param _legoId The ID to query\n    @return The address associated with the Lego ID\n    \"\"\"\n    return self.legoInfo[_legoId].addr\n\n\n@view\n@external\ndef getLegoInfo(_legoId: uint256) -> LegoInfo:\n    \"\"\"\n    @notice Get all information about a Lego\n    @dev Returns complete LegoInfo struct including address, version, timestamp and description\n    @param _legoId The ID to query\n    @return LegoInfo struct containing all Lego information\n    \"\"\"\n    return self.legoInfo[_legoId]\n\n\n@view\n@external\ndef getLegoDescription(_legoId: uint256) -> String[64]:\n    \"\"\"\n    @notice Get the description of a Lego\n    @dev Returns empty string if ID is invalid\n    @param _legoId The ID to query\n    @return The description associated with the Lego ID\n    \"\"\"\n    return self.legoInfo[_legoId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumLegos() -> uint256:\n    \"\"\"\n    @notice Get the total number of registered Legos\n    @dev Returns number of Legos minus 1 since indexing starts at 1\n    @return The total number of registered Legos\n    \"\"\"\n    return self.numLegos - 1\n\n\n@view\n@external\ndef getLastLegoAddr() -> address:\n    \"\"\"\n    @notice Get the address of the most recently registered Lego\n    @dev Returns the address at index (numLegos - 1)\n    @return The address of the last registered Lego\n    \"\"\"\n    lastIndex: uint256 = self.numLegos - 1\n    return self.legoInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastLegoId() -> uint256:\n    \"\"\"\n    @notice Get the ID of the most recently registered Lego\n    @dev Returns numLegos - 1 since indexing starts at 1\n    @return The ID of the last registered Lego\n    \"\"\"\n    return self.numLegos - 1\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    \"\"\"\n    @notice Get the underlying asset for a vault token\n    @dev Returns empty address if vault token is not registered\n    @param _vaultToken The address of the vault token to query\n    @return The underlying asset address\n    \"\"\"\n    if _vaultToken == empty(address):\n        return empty(address)\n\n    numLegos: uint256 = self.numLegos\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: LegoInfo = self.legoInfo[i]\n        if legoInfo.legoType != LegoType.YIELD_OPP:\n            continue\n\n        asset: address = staticcall LegoYield(legoInfo.addr).getUnderlyingAsset(_vaultToken)\n        if asset != empty(address):\n            return asset\n\n    return empty(address)\n\n\n@view\n@external\ndef getUnderlyingForUser(_user: address, _asset: address) -> uint256:\n    \"\"\"\n    @notice Get the total underlying amount for a user in a given asset\n    @dev Returns 0 if user or asset is empty\n    @param _user The address of the user to query\n    @param _asset The address of the asset to query\n    \"\"\"\n    if empty(address) in [_user, _asset]:\n        return 0\n\n    totalDeposited: uint256 = 0\n    numLegos: uint256 = self.numLegos\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: LegoInfo = self.legoInfo[i]\n        if legoInfo.legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall LegoYield(legoInfo.addr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            vaultTokenBal: uint256 = staticcall IERC20(vaultToken).balanceOf(_user)\n            if vaultTokenBal != 0:\n                totalDeposited += staticcall LegoYield(legoInfo.addr).getUnderlyingAmount(vaultToken, vaultTokenBal)\n\n    return totalDeposited\n\n\n###############\n# Lego Helper #\n###############\n\n\n@view\n@external \ndef isValidLegoHelper(_helperAddr: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be set as the Lego helper\n    @dev Address must be a contract and different from current helper\n    @param _helperAddr The address to validate\n    @return True if address can be set as helper, False otherwise\n    \"\"\"\n    return self._isValidLegoHelper(_helperAddr)\n\n\n@view\n@internal \ndef _isValidLegoHelper(_helperAddr: address) -> bool:\n    if not _helperAddr.is_contract or _helperAddr == empty(address):\n        return False\n    return _helperAddr != self.legoHelper\n\n\n@external\ndef setLegoHelper(_helperAddr: address) -> bool:\n    \"\"\"\n    @notice Set a new Lego helper address\n    @dev Only callable by governor\n    @param _helperAddr The address to set as helper\n    @return True if helper was set successfully, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidLegoHelper(_helperAddr):\n        return False\n    self.legoHelper = _helperAddr\n    log LegoHelperSet(helperAddr=_helperAddr)\n    return True\n\n",
            "sha256sum": "819f09f47f6151e40d99f13be567a0ca38ba2f2e236ecdc324e67d8449044f0a"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/LegoRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "4ed23b01ff8fab15c00e137230ef340b2c1014f684b8845f930bc00d88f3a42a"
      },
      "args": "00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "OracleRegistry": {
      "address": "0xc56add9377Bc3a39f1B928Abc7440E43B6b10e1f",
      "abi": [
        {
          "name": "NewOraclePartnerRegistered",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "oraclePartnerId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OraclePartnerAddrUpdated",
          "inputs": [
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "oraclePartnerId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OraclePartnerAddrDisabled",
          "inputs": [
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "oraclePartnerId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriorityOraclePartnerIdsModified",
          "inputs": [
            {
              "name": "numIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StaleTimeSet",
          "inputs": [
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewOraclePartnerAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewOraclePartner",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerUpdate",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerDisable",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriorityOraclePartnerIds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "areValidPriorityOraclePartnerIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityOraclePartnerIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidStaleTime",
          "inputs": [
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStaleTime",
          "inputs": [
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerInfo",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerDescription",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumOraclePartners",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastOraclePartnerAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastOraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerAddrToId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numOraclePartners",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priorityOraclePartnerIds",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "staleTime",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_STALE_TIME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_STALE_TIME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_minStaleTime",
              "type": "uint256"
            },
            {
              "name": "_maxStaleTime",
              "type": "uint256"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "contracts/core/OracleRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\n\nfrom ethereum.ercs import IERC20Detailed\nimport interfaces.OraclePartnerInterface as OraclePartner\nimport contracts.modules.Governable as gov\n\nstruct OraclePartnerInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nevent NewOraclePartnerRegistered:\n    addr: indexed(address)\n    oraclePartnerId: uint256\n    description: String[64]\n\nevent OraclePartnerAddrUpdated:\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    oraclePartnerId: uint256\n    version: uint256\n    description: String[64]\n\nevent OraclePartnerAddrDisabled:\n    prevAddr: indexed(address)\n    oraclePartnerId: uint256\n    version: uint256\n    description: String[64]\n\nevent PriorityOraclePartnerIdsModified:\n    numIds: uint256\n\nevent StaleTimeSet:\n    staleTime: uint256\n\n# registry core\noraclePartnerInfo: public(HashMap[uint256, OraclePartnerInfo])\noraclePartnerAddrToId: public(HashMap[address, uint256])\nnumOraclePartners: public(uint256)\n\n# custom config\npriorityOraclePartnerIds: public(DynArray[uint256, MAX_PRIORITY_PARTNERS])\nstaleTime: public(uint256)\n\n# config\nADDY_REGISTRY: public(immutable(address))\n\nETH: public(immutable(address))\nMIN_STALE_TIME: public(immutable(uint256))\nMAX_STALE_TIME: public(immutable(uint256))\n\nMAX_PRIORITY_PARTNERS: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_ethAddr: address, _minStaleTime: uint256, _maxStaleTime: uint256, _addyRegistry: address):\n    assert empty(address) not in [_ethAddr, _addyRegistry] # dev: invalid addy registry\n    gov.__init__(_addyRegistry)\n\n    ETH = _ethAddr\n    MIN_STALE_TIME = _minStaleTime\n    MAX_STALE_TIME = _maxStaleTime\n    ADDY_REGISTRY = _addyRegistry\n\n    # start at 1 index\n    self.numOraclePartners = 1\n\n\n#########\n# Price #\n#########\n\n\n@view\n@external\ndef getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Get the USD price of an asset from registered oracle partners\n    @dev Checks priority partners first, then others. Returns 0 if no valid price found.\n    @param _asset The address of the asset to get price for\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The asset price in USD with 18 decimals\n    \"\"\"\n    if _asset == empty(address):\n        return 0\n    return self._getPrice(_asset, _shouldRaise)\n\n\n@view\n@internal\ndef _getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    price: uint256 = 0\n    hasFeedConfig: bool = False\n    alreadyLooked: DynArray[uint256, MAX_PRIORITY_PARTNERS] = []\n    staleTime: uint256 = self.staleTime\n\n    # go thru priority partners first\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self.priorityOraclePartnerIds\n    for i: uint256 in range(len(priorityIds), bound=MAX_PRIORITY_PARTNERS):\n        pid: uint256 = priorityIds[i]\n        hasFeed: bool = False\n        price, hasFeed = self._getPriceFromOraclePartner(pid, _asset, staleTime)\n        if price != 0:\n            break\n        if hasFeed:\n            hasFeedConfig = True\n        alreadyLooked.append(pid)\n\n    # go thru rest of oracle partners\n    if price == 0:\n        numSources: uint256 = self.numOraclePartners\n        for id: uint256 in range(1, numSources, bound=max_value(uint256)):\n            if id in alreadyLooked:\n                continue\n            hasFeed: bool = False\n            price, hasFeed = self._getPriceFromOraclePartner(id, _asset, staleTime)\n            if price != 0:\n                break\n            if hasFeed:\n                hasFeedConfig = True\n\n    # raise exception if feed exists but no price\n    if price == 0 and hasFeedConfig and _shouldRaise:\n        raise \"has price config, no price\"\n\n    return price\n\n\n@view\n@internal\ndef _getPriceFromOraclePartner(_pid: uint256, _asset: address, _staleTime: uint256) -> (uint256, bool):\n    oraclePartner: address = self.oraclePartnerInfo[_pid].addr\n    if oraclePartner == empty(address):\n        return 0, False\n    return staticcall OraclePartner(oraclePartner).getPriceAndHasFeed(_asset, _staleTime, self)\n\n\n# other utils\n\n\n@view\n@external\ndef getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the USD value of a given amount of an asset\n    @dev Accounts for asset decimals in calculation. Returns 0 if no valid price.\n    @param _asset The address of the asset\n    @param _amount The amount of the asset\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The USD value with 18 decimals\n    \"\"\"\n    if _amount == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return price * _amount // (10 ** decimals)\n\n\n@view\n@external\ndef getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the amount of an asset worth a given USD value\n    @dev Accounts for asset decimals in calculation. Returns 0 if no valid price.\n    @param _asset The address of the asset\n    @param _usdValue The USD value to convert to asset amount (18 decimals)\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The amount of the asset\n    \"\"\"\n    if _usdValue == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return _usdValue * (10 ** decimals) // price\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    \"\"\"\n    @notice Check if any oracle partner has a price feed for the asset\n    @dev Iterates through all registered oracle partners\n    @param _asset The address of the asset to check\n    @return True if a price feed exists, False otherwise\n    \"\"\"\n    numSources: uint256 = self.numOraclePartners\n    for id: uint256 in range(1, numSources, bound=max_value(uint256)):\n        oraclePartner: address = self.oraclePartnerInfo[id].addr\n        if oraclePartner == empty(address):\n            continue\n        if staticcall OraclePartner(oraclePartner).hasPriceFeed(_asset):\n            return True\n    return False\n\n\n@view\n@external\ndef getEthUsdValue(_amount: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the USD value of a given amount of ETH\n    @dev Uses ETH price feed. Returns 0 if no valid price.\n    @param _amount The amount of ETH in wei\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The USD value with 18 decimals\n    \"\"\"\n    if _amount == 0:\n        return 0\n    return self._getPrice(ETH, _shouldRaise) * _amount // (10 ** 18)\n\n\n@view\n@external\ndef getEthAmount(_usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the amount of ETH worth a given USD value\n    @dev Uses ETH price feed. Returns 0 if no valid price.\n    @param _usdValue The USD value to convert to ETH amount (18 decimals)\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The amount of ETH in wei\n    \"\"\"\n    if _usdValue == 0:\n        return 0\n    price: uint256 = self._getPrice(ETH, _shouldRaise)\n    if price == 0:\n        return 0\n    return _usdValue * (10 ** 18) // price\n\n\n###########################\n# Register Oracle Partner #\n###########################\n\n\n@view\n@external\ndef isValidNewOraclePartnerAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be registered as a new oracle partner\n    @dev Validates address is non-zero, is a contract, and hasn't been registered before\n    @param _addr The address to validate\n    @return True if address can be registered as new oracle partner, False otherwise\n    \"\"\"\n    return self._isValidNewOraclePartnerAddr(_addr)\n\n\n@view\n@internal\ndef _isValidNewOraclePartnerAddr(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.oraclePartnerAddrToId[_addr] == 0\n\n\n@external\ndef registerNewOraclePartner(_addr: address, _description: String[64]) -> uint256:\n    \"\"\"\n    @notice Register a new oracle partner contract in the registry\n    @dev Sets oracle partner ID on the contract.\n    @param _addr The address of the oracle partner contract to register\n    @param _description A brief description of the oracle partner's functionality\n    @return The assigned oracle partner ID if registration successful, 0 if failed\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidNewOraclePartnerAddr(_addr):\n        return 0\n\n    data: OraclePartnerInfo = OraclePartnerInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=_description,\n    )\n\n    oraclePartnerId: uint256 = self.numOraclePartners\n    self.oraclePartnerAddrToId[_addr] = oraclePartnerId\n    self.numOraclePartners = oraclePartnerId + 1\n    self.oraclePartnerInfo[oraclePartnerId] = data\n    assert extcall OraclePartner(_addr).setOraclePartnerId(oraclePartnerId) # dev: set id failed\n\n    log NewOraclePartnerRegistered(addr=_addr, oraclePartnerId=oraclePartnerId, description=_description)\n    return oraclePartnerId\n\n\n#########################\n# Update Oracle Partner #\n#########################\n\n\n@view\n@external\ndef isValidOraclePartnerUpdate(_oracleId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Check if an oracle partner update operation would be valid\n    @dev Validates oracle ID exists and new address is valid\n    @param _oracleId The ID of the oracle partner to update\n    @param _newAddr The proposed new address for the oracle partner\n    @return True if update would be valid, False otherwise\n    \"\"\"\n    return self._isValidOraclePartnerUpdate(_oracleId, _newAddr, self.oraclePartnerInfo[_oracleId].addr)\n\n\n@view\n@internal\ndef _isValidOraclePartnerUpdate(_oracleId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidOraclePartnerId(_oracleId):\n        return False\n    if not self._isValidNewOraclePartnerAddr(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@external\ndef updateOraclePartnerAddr(_oracleId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Update the address of an existing oracle partner\n    @dev Updates version and timestamp.\n    @param _oracleId The ID of the oracle partner to update\n    @param _newAddr The new address for the oracle partner\n    @return True if update successful, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    data: OraclePartnerInfo = self.oraclePartnerInfo[_oracleId]\n    prevAddr: address = data.addr # needed for later\n\n    if not self._isValidOraclePartnerUpdate(_oracleId, _newAddr, prevAddr):\n        return False\n\n    # save new data\n    data.addr = _newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.oraclePartnerInfo[_oracleId] = data\n    self.oraclePartnerAddrToId[_newAddr] = _oracleId\n    assert extcall OraclePartner(_newAddr).setOraclePartnerId(_oracleId) # dev: set id failed\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.oraclePartnerAddrToId[prevAddr] = 0\n\n    log OraclePartnerAddrUpdated(newAddr=_newAddr, prevAddr=prevAddr, oraclePartnerId=_oracleId, version=data.version, description=data.description)\n    return True\n\n\n##########################\n# Disable Oracle Partner #\n##########################\n\n\n@view\n@external\ndef isValidOraclePartnerDisable(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Check if an oracle partner can be disabled\n    @dev Validates oracle ID exists and has a non-empty address\n    @param _oracleId The ID of the oracle partner to check\n    @return True if oracle partner can be disabled, False otherwise\n    \"\"\"\n    return self._isValidOraclePartnerDisable(_oracleId, self.oraclePartnerInfo[_oracleId].addr)\n\n\n@view\n@internal\ndef _isValidOraclePartnerDisable(_oracleId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidOraclePartnerId(_oracleId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@external\ndef disableOraclePartnerAddr(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Disable an oracle partner by setting its address to empty\n    @dev Updates version and timestamp.\n    @param _oracleId The ID of the oracle partner to disable\n    @return True if disable successful, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    data: OraclePartnerInfo = self.oraclePartnerInfo[_oracleId]\n    prevAddr: address = data.addr # needed for later\n\n    if not self._isValidOraclePartnerDisable(_oracleId, prevAddr):\n        return False\n\n    # save new data\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.oraclePartnerInfo[_oracleId] = data\n    self.oraclePartnerAddrToId[prevAddr] = 0\n\n    log OraclePartnerAddrDisabled(prevAddr=prevAddr, oraclePartnerId=_oracleId, version=data.version, description=data.description)\n    return True\n\n\n############################\n# Priority Oracle Partners #\n############################\n\n\n@view \n@external \ndef getPriorityOraclePartnerIds() -> DynArray[uint256, MAX_PRIORITY_PARTNERS]:\n    \"\"\"\n    @notice Get the list of priority oracle partner IDs\n    @dev Returns ordered list of IDs that are checked first for prices\n    @return Array of oracle partner IDs in priority order\n    \"\"\"\n    return self.priorityOraclePartnerIds\n\n\n@view\n@internal\ndef _sanitizePriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> DynArray[uint256, MAX_PRIORITY_PARTNERS]:\n    sanitizedIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = []\n    for i: uint256 in range(len(_priorityIds), bound=MAX_PRIORITY_PARTNERS):\n        pid: uint256 = _priorityIds[i]\n        if not self._isValidOraclePartnerId(pid):\n            continue\n        if pid in sanitizedIds:\n            continue\n        sanitizedIds.append(pid)\n    return sanitizedIds\n\n\n@view\n@external\ndef areValidPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    \"\"\"\n    @notice Check if a list of priority oracle partner IDs is valid\n    @dev Validates IDs exist and are not duplicated\n    @param _priorityIds Array of oracle partner IDs to validate\n    @return True if all IDs are valid, False otherwise\n    \"\"\"\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self._sanitizePriorityOraclePartnerIds(_priorityIds)\n    return self._areValidPriorityOraclePartnerIds(priorityIds)\n\n\n@view\n@internal\ndef _areValidPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    return len(_priorityIds) != 0\n\n\n@external\ndef setPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    \"\"\"\n    @notice Set the list of priority oracle partner IDs\n    @dev Only callable by governor when registry is activated\n    @param _priorityIds Array of oracle partner IDs in desired priority order\n    @return True if priority list was set successfully, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self._sanitizePriorityOraclePartnerIds(_priorityIds)\n    if not self._areValidPriorityOraclePartnerIds(priorityIds):\n        return False\n\n    self.priorityOraclePartnerIds = priorityIds\n    log PriorityOraclePartnerIdsModified(numIds=len(priorityIds))\n    return True\n\n\n##############\n# Stale Time #\n##############\n\n\n@view\n@external\ndef isValidStaleTime(_staleTime: uint256) -> bool:\n    \"\"\"\n    @notice Check if a stale time value is valid\n    @dev Validates against minimum and maximum allowed stale times\n    @param _staleTime The stale time in seconds to validate\n    @return True if stale time is valid, False otherwise\n    \"\"\"\n    return self._isValidStaleTime(_staleTime)\n\n\n@view\n@internal\ndef _isValidStaleTime(_staleTime: uint256) -> bool:\n    return _staleTime >= MIN_STALE_TIME and _staleTime <= MAX_STALE_TIME\n\n\n@external\ndef setStaleTime(_staleTime: uint256) -> bool:\n    \"\"\"\n    @notice Set the stale time for price feeds\n    @dev Only callable by governor when registry is activated\n    @param _staleTime The stale time in seconds\n    @return True if stale time was set successfully, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidStaleTime(_staleTime):\n        return False\n\n    self.staleTime = _staleTime\n    log StaleTimeSet(staleTime=_staleTime)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidOraclePartnerAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address is a registered oracle partner\n    @dev Returns true if address has a non-zero oracle partner ID\n    @param _addr The address to check\n    @return True if address is a registered oracle partner, False otherwise\n    \"\"\"\n    return self.oraclePartnerAddrToId[_addr] != 0\n\n\n@view\n@external\ndef isValidOraclePartnerId(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Check if an oracle partner ID is valid\n    @dev ID must be non-zero and less than total number of oracle partners\n    @param _oracleId The ID to check\n    @return True if ID is valid, False otherwise\n    \"\"\"\n    return self._isValidOraclePartnerId(_oracleId)\n\n\n@view\n@internal\ndef _isValidOraclePartnerId(_oracleId: uint256) -> bool:\n    return _oracleId != 0 and _oracleId < self.numOraclePartners\n\n\n# oracle partner getters\n\n\n@view\n@external\ndef getOraclePartnerId(_addr: address) -> uint256:\n    \"\"\"\n    @notice Get the ID of an oracle partner from its address\n    @dev Returns 0 if address is not registered\n    @param _addr The address to query\n    @return The oracle partner ID associated with the address\n    \"\"\"\n    return self.oraclePartnerAddrToId[_addr]\n\n\n@view\n@external\ndef getOraclePartnerAddr(_oracleId: uint256) -> address:\n    \"\"\"\n    @notice Get the address of an oracle partner from its ID\n    @dev Returns empty address if ID is invalid or partner is disabled\n    @param _oracleId The ID to query\n    @return The address associated with the oracle partner ID\n    \"\"\"\n    return self.oraclePartnerInfo[_oracleId].addr\n\n\n@view\n@external\ndef getOraclePartnerInfo(_oracleId: uint256) -> OraclePartnerInfo:\n    \"\"\"\n    @notice Get all information about an oracle partner\n    @dev Returns complete OraclePartnerInfo struct including address, version, timestamp and description\n    @param _oracleId The ID to query\n    @return OraclePartnerInfo struct containing all oracle partner information\n    \"\"\"\n    return self.oraclePartnerInfo[_oracleId]\n\n\n@view\n@external\ndef getOraclePartnerDescription(_oracleId: uint256) -> String[64]:\n    \"\"\"\n    @notice Get the description of an oracle partner\n    @dev Returns empty string if ID is invalid\n    @param _oracleId The ID to query\n    @return The description associated with the oracle partner ID\n    \"\"\"\n    return self.oraclePartnerInfo[_oracleId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumOraclePartners() -> uint256:\n    \"\"\"\n    @notice Get the total number of registered oracle partners\n    @dev Returns number of partners minus 1 since indexing starts at 1\n    @return The total number of registered oracle partners\n    \"\"\"\n    return self.numOraclePartners - 1\n\n\n@view\n@external\ndef getLastOraclePartnerAddr() -> address:\n    \"\"\"\n    @notice Get the address of the most recently registered oracle partner\n    @dev Returns the address at index (numOraclePartners - 1)\n    @return The address of the last registered oracle partner\n    \"\"\"\n    lastIndex: uint256 = self.numOraclePartners - 1\n    return self.oraclePartnerInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastOraclePartnerId() -> uint256:\n    \"\"\"\n    @notice Get the ID of the most recently registered oracle partner\n    @dev Returns numOraclePartners - 1 since indexing starts at 1\n    @return The ID of the last registered oracle partner\n    \"\"\"\n    return self.numOraclePartners - 1\n",
            "sha256sum": "5e6257673fe9c79579ab16e6fb577b16d3ad54de66ae3f2dd6f0bada3596e068"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/OracleRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "30535505afc697c84fd4cf9c27fce356aec5b3c378da45073bdb23c2399bffec"
      },
      "args": "000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000003f48000000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "PriceSheets": {
      "address": "0x59918c90eD44a3D7a72375f60C0148Ae18001ADC",
      "abi": [
        {
          "name": "AgentSubPriceSet",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAgentSubPriceSet",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "effectiveBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolSubPriceSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentSubPriceRemoved",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolSubPriceRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentSubPricingEnabled",
          "inputs": [
            {
              "name": "isEnabled",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolTxPriceSheetSet",
          "inputs": [
            {
              "name": "depositFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "withdrawalFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rebalanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "transferFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "addLiqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "removeLiqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimRewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "borrowFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "repayFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolTxPriceSheetRemoved",
          "inputs": [
            {
              "name": "depositFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "withdrawalFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rebalanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "transferFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "addLiqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "removeLiqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimRewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "borrowFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "repayFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolRecipientSet",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSheetsActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCombinedSubData",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_agentPaidThru",
              "type": "uint256"
            },
            {
              "name": "_protocolPaidThru",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentSubPriceData",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidSubPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finalizePendingAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentSubPricingEnabled",
          "inputs": [
            {
              "name": "_isEnabled",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolSubPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeProtocolSubPrice",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTransactionFeeData",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidTxPriceSheet",
          "inputs": [
            {
              "name": "_depositFee",
              "type": "uint256"
            },
            {
              "name": "_withdrawalFee",
              "type": "uint256"
            },
            {
              "name": "_rebalanceFee",
              "type": "uint256"
            },
            {
              "name": "_transferFee",
              "type": "uint256"
            },
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_addLiqFee",
              "type": "uint256"
            },
            {
              "name": "_removeLiqFee",
              "type": "uint256"
            },
            {
              "name": "_claimRewardsFee",
              "type": "uint256"
            },
            {
              "name": "_borrowFee",
              "type": "uint256"
            },
            {
              "name": "_repayFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolTxPriceSheet",
          "inputs": [
            {
              "name": "_depositFee",
              "type": "uint256"
            },
            {
              "name": "_withdrawalFee",
              "type": "uint256"
            },
            {
              "name": "_rebalanceFee",
              "type": "uint256"
            },
            {
              "name": "_transferFee",
              "type": "uint256"
            },
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_addLiqFee",
              "type": "uint256"
            },
            {
              "name": "_removeLiqFee",
              "type": "uint256"
            },
            {
              "name": "_claimRewardsFee",
              "type": "uint256"
            },
            {
              "name": "_borrowFee",
              "type": "uint256"
            },
            {
              "name": "_repayFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeProtocolTxPriceSheet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolRecipient",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriceChangeDelay",
          "inputs": [
            {
              "name": "_delayBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolRecipient",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolTxPriceData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "depositFee",
                  "type": "uint256"
                },
                {
                  "name": "withdrawalFee",
                  "type": "uint256"
                },
                {
                  "name": "rebalanceFee",
                  "type": "uint256"
                },
                {
                  "name": "transferFee",
                  "type": "uint256"
                },
                {
                  "name": "swapFee",
                  "type": "uint256"
                },
                {
                  "name": "addLiqFee",
                  "type": "uint256"
                },
                {
                  "name": "removeLiqFee",
                  "type": "uint256"
                },
                {
                  "name": "claimRewardsFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowFee",
                  "type": "uint256"
                },
                {
                  "name": "repayFee",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolSubPriceData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgentSubPricingEnabled",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentSubPriceData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAgentSubPrices",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "subInfo",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "asset",
                      "type": "address"
                    },
                    {
                      "name": "usdValue",
                      "type": "uint256"
                    },
                    {
                      "name": "trialPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "payPeriod",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "effectiveBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priceChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_TRIAL_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_TRIAL_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_PAY_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_PAY_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_PRICE_CHANGE_BUFFER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_minTrialPeriod",
              "type": "uint256"
            },
            {
              "name": "_maxTrialPeriod",
              "type": "uint256"
            },
            {
              "name": "_minPayPeriod",
              "type": "uint256"
            },
            {
              "name": "_maxPayPeriod",
              "type": "uint256"
            },
            {
              "name": "_minPriceChangeBuffer",
              "type": "uint256"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "contracts/core/PriceSheets.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\nimport contracts.modules.Governable as gov\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n    def governor() -> address: view\n\ninterface OracleRegistry:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AgentFactory:\n    def isAgent(_agent: address) -> bool: view\n\ninterface Agent:\n    def owner() -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct TxPriceSheet:\n    depositFee: uint256\n    withdrawalFee: uint256\n    rebalanceFee: uint256\n    transferFee: uint256\n    swapFee: uint256\n    addLiqFee: uint256\n    removeLiqFee: uint256\n    claimRewardsFee: uint256\n    borrowFee: uint256\n    repayFee: uint256\n\nstruct SubscriptionInfo:\n    asset: address\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct PendingSubPrice:\n    subInfo: SubscriptionInfo\n    effectiveBlock: uint256\n\nevent AgentSubPriceSet:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent PendingAgentSubPriceSet:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n    effectiveBlock: uint256\n\nevent ProtocolSubPriceSet:\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent AgentSubPriceRemoved:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent ProtocolSubPriceRemoved:\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent AgentSubPricingEnabled:\n    isEnabled: bool\n\nevent ProtocolTxPriceSheetSet:\n    depositFee: uint256\n    withdrawalFee: uint256\n    rebalanceFee: uint256\n    transferFee: uint256\n    swapFee: uint256\n    addLiqFee: uint256\n    removeLiqFee: uint256\n    claimRewardsFee: uint256\n    borrowFee: uint256\n    repayFee: uint256\n\nevent ProtocolTxPriceSheetRemoved:\n    depositFee: uint256\n    withdrawalFee: uint256\n    rebalanceFee: uint256\n    transferFee: uint256\n    swapFee: uint256\n    addLiqFee: uint256\n    removeLiqFee: uint256\n    claimRewardsFee: uint256\n    borrowFee: uint256\n    repayFee: uint256\n\nevent ProtocolRecipientSet:\n    recipient: indexed(address)\n\nevent PriceChangeDelaySet:\n    delayBlocks: uint256\n\nevent PriceSheetsActivated:\n    isActivated: bool\n\n# protocol pricing\nprotocolRecipient: public(address) # protocol recipient\nprotocolTxPriceData: public(TxPriceSheet) # protocol transaction pricing\nprotocolSubPriceData: public(SubscriptionInfo) # protocol subscription pricing\n\n# agent pricing\nisAgentSubPricingEnabled: public(bool)\nagentSubPriceData: public(HashMap[address, SubscriptionInfo]) # agent -> subscription pricing\n\n# pending price changes\npendingAgentSubPrices: public(HashMap[address, PendingSubPrice])\npriceChangeDelay: public(uint256) # number of blocks that must pass before price changes take effect\n\n# config\nADDY_REGISTRY: public(immutable(address))\nisActivated: public(bool)\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\n\nMIN_TRIAL_PERIOD: public(immutable(uint256))\nMAX_TRIAL_PERIOD: public(immutable(uint256))\nMIN_PAY_PERIOD: public(immutable(uint256))\nMAX_PAY_PERIOD: public(immutable(uint256))\nMIN_PRICE_CHANGE_BUFFER: public(immutable(uint256))\n\nMAX_TX_FEE: constant(uint256) = 10_00 # 10.00%\n\n\n@deploy\ndef __init__(\n    _minTrialPeriod: uint256,\n    _maxTrialPeriod: uint256,\n    _minPayPeriod: uint256,\n    _maxPayPeriod: uint256,\n    _minPriceChangeBuffer: uint256,\n    _addyRegistry: address,\n):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    gov.__init__(_addyRegistry)\n    self.protocolRecipient = staticcall AddyRegistry(_addyRegistry).governor()\n    self.isActivated = True\n\n    ADDY_REGISTRY = _addyRegistry\n    MIN_TRIAL_PERIOD = _minTrialPeriod\n    MAX_TRIAL_PERIOD = _maxTrialPeriod\n    MIN_PAY_PERIOD = _minPayPeriod\n    MAX_PAY_PERIOD = _maxPayPeriod\n    MIN_PRICE_CHANGE_BUFFER = _minPriceChangeBuffer\n\n\n@view\n@internal\ndef _isRegisteredAgent(_agent: address) -> bool:\n    agentFactory: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    return staticcall AgentFactory(agentFactory).isAgent(_agent)\n\n\n######################\n# Subscription Utils #\n######################\n\n\n@view\n@external\ndef getCombinedSubData(_user: address, _agent: address, _agentPaidThru: uint256, _protocolPaidThru: uint256, _oracleRegistry: address) -> (SubPaymentInfo, SubPaymentInfo):\n    \"\"\"\n    @notice Get combined subscription data for an agent and protocol\n    @dev Returns a struct containing payment amounts and paid through blocks for both agent and protocol\n    @param _user The address of the user\n    @param _agent The address of the agent\n    @param _agentPaidThru The paid through block for the agent\n    @param _protocolPaidThru The paid through block for the protocol\n    @param _oracleRegistry The address of the oracle registry\n    @return protocolData struct containing payment amounts and paid through blocks for the protocol\n    @return agentData struct containing payment amounts and paid through blocks for the agent\n    \"\"\"\n    # NOTE: in future, we may have different pricing tiers depending on the `_user`\n\n    # protocol sub info\n    protocolData: SubPaymentInfo = self._updatePaidThroughBlock(_protocolPaidThru, self.protocolSubPriceData, _oracleRegistry)\n    if protocolData.amount != 0:\n        protocolData.recipient = self.protocolRecipient\n\n    # agent sub info\n    agentData: SubPaymentInfo = empty(SubPaymentInfo)\n    if _agent != empty(address):\n        agentData = self._updatePaidThroughBlock(_agentPaidThru, self.agentSubPriceData[_agent], _oracleRegistry)\n        agentData.recipient = _agent\n\n    return protocolData, agentData\n\n\n@view\n@internal\ndef _updatePaidThroughBlock(_paidThroughBlock: uint256, _subData: SubscriptionInfo, _oracleRegistry: address) -> SubPaymentInfo:\n    data: SubPaymentInfo = empty(SubPaymentInfo)\n    data.paidThroughBlock = _paidThroughBlock\n\n    # subscription was added (since last checked)\n    if _paidThroughBlock == 0 and _subData.usdValue != 0:\n        data.paidThroughBlock = block.number + _subData.trialPeriod\n        data.didChange = True\n\n    # subscription was removed (since last checked)\n    elif _paidThroughBlock != 0 and _subData.usdValue == 0:\n        data.paidThroughBlock = 0\n        data.didChange = True\n\n    # check if subscription needs to be paid\n    if data.paidThroughBlock != 0 and block.number > data.paidThroughBlock:\n        data.amount = staticcall OracleRegistry(_oracleRegistry).getAssetAmount(_subData.asset, _subData.usdValue)\n\n        # if something fails with price feed, allow transaction through.\n        # it's on agent developer to make sure price feed is working, so they can get paid\n        if data.amount != 0:\n            data.paidThroughBlock = block.number + _subData.payPeriod\n            data.usdValue = _subData.usdValue\n            data.asset = _subData.asset\n            data.didChange = True\n\n    return data\n\n\n######################\n# Agent Subscription #\n######################\n\n\n@view\n@external\ndef getAgentSubPriceData(_agent: address) -> SubscriptionInfo:\n    \"\"\"\n    @notice Get the subscription pricing data for a specific agent\n    @dev Returns empty SubscriptionInfo if agent subscription pricing is disabled\n    @param _agent The address of the agent to query\n    @return SubscriptionInfo struct containing subscription details\n    \"\"\"\n    if not self.isAgentSubPricingEnabled:\n        return empty(SubscriptionInfo)\n    return self.agentSubPriceData[_agent]\n\n\n# set agent sub price\n\n\n@view\n@external\ndef isValidSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Check if subscription price parameters are valid\n    @dev Validates asset, USD value, trial period, and pay period against constraints\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if all parameters are valid\n    \"\"\"\n    return self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod)\n\n\n@view\n@internal\ndef _isValidSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    if _asset == empty(address):\n        return False\n\n    if _payPeriod < MIN_PAY_PERIOD or _payPeriod > MAX_PAY_PERIOD:\n        return False\n\n    if _trialPeriod < MIN_TRIAL_PERIOD or _trialPeriod > MAX_TRIAL_PERIOD:\n        return False\n\n    return _usdValue != 0\n\n\n@external\ndef setAgentSubPrice(_agent: address, _asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Set subscription pricing for a specific agent\n    @dev Creates a pending subscription price change that can be finalized after priceChangeDelay blocks\n    @param _agent The address of the agent\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if pending subscription price was set successfully\n    \"\"\"\n    assert self._isRegisteredAgent(_agent) # dev: agent not registered\n    isAgentOwner: bool = staticcall Agent(_agent).owner() == msg.sender\n    assert isAgentOwner or gov._isGovernor(msg.sender) # dev: no perms\n\n    if isAgentOwner:\n        assert self.isActivated # dev: not active\n\n    # validation\n    assert _agent != empty(address) # dev: invalid agent\n    if not self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod):\n        return False\n\n    # create pending subscription price\n    subInfo: SubscriptionInfo = SubscriptionInfo(\n        asset=_asset,\n        usdValue=_usdValue,\n        trialPeriod=_trialPeriod,\n        payPeriod=_payPeriod,\n    )\n\n    # set price change immediately if delay is 0\n    priceChangeDelay: uint256 = self.priceChangeDelay\n    if priceChangeDelay == 0:\n        self._setAgentSubPrice(_agent, subInfo)\n        return True\n\n    # set pending price change\n    effectiveBlock: uint256 = block.number + priceChangeDelay\n    self.pendingAgentSubPrices[_agent] = PendingSubPrice(subInfo=subInfo, effectiveBlock=effectiveBlock)\n    log PendingAgentSubPriceSet(agent=_agent, asset=_asset, usdValue=_usdValue, trialPeriod=_trialPeriod, payPeriod=_payPeriod, effectiveBlock=effectiveBlock)\n\n    return True\n\n\n# finalize agent sub price\n\n\n@external\ndef finalizePendingAgentSubPrice(_agent: address) -> bool:\n    \"\"\"\n    @notice Finalize a pending subscription price for an agent\n    @dev Can only be called after priceChangeDelay blocks have passed since the pending change was created\n    @param _agent The address of the agent\n    @return bool True if subscription price was finalized successfully\n    \"\"\"\n    assert self.isActivated # dev: not active\n\n    pendingPrice: PendingSubPrice = self.pendingAgentSubPrices[_agent]\n    assert pendingPrice.effectiveBlock != 0 and block.number >= pendingPrice.effectiveBlock # dev: time delay not reached\n    self.pendingAgentSubPrices[_agent] = empty(PendingSubPrice)\n\n    # apply pending subscription price\n    self._setAgentSubPrice(_agent, pendingPrice.subInfo)\n    return True\n\n\n@internal\ndef _setAgentSubPrice(_agent: address, _subInfo: SubscriptionInfo):\n    self.agentSubPriceData[_agent] = _subInfo\n    log AgentSubPriceSet(agent=_agent, asset=_subInfo.asset, usdValue=_subInfo.usdValue, trialPeriod=_subInfo.trialPeriod, payPeriod=_subInfo.payPeriod)\n\n\n# removing agent sub price\n\n\n@external\ndef removeAgentSubPrice(_agent: address) -> bool:\n    \"\"\"\n    @notice Remove subscription pricing for a specific agent\n    @dev Only callable by governor\n    @param _agent The address of the agent\n    @return bool True if agent subscription price was removed successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    assert self._isRegisteredAgent(_agent) # dev: agent not registered\n\n    prevInfo: SubscriptionInfo = self.agentSubPriceData[_agent]\n    if empty(address) in [prevInfo.asset, _agent]:\n        return False\n\n    self.agentSubPriceData[_agent] = empty(SubscriptionInfo)\n    log AgentSubPriceRemoved(agent=_agent, asset=prevInfo.asset, usdValue=prevInfo.usdValue, trialPeriod=prevInfo.trialPeriod, payPeriod=prevInfo.payPeriod)\n    return True\n\n\n# enable / disable agent sub pricing\n\n\n@external\ndef setAgentSubPricingEnabled(_isEnabled: bool) -> bool:\n    \"\"\"\n    @notice Enable or disable agent subscription pricing\n    @dev Only callable by governor\n    @param _isEnabled True to enable, False to disable\n    @return bool True if agent subscription pricing state was changed successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    assert _isEnabled != self.isAgentSubPricingEnabled # dev: no change\n    self.isAgentSubPricingEnabled = _isEnabled\n    log AgentSubPricingEnabled(isEnabled=_isEnabled)\n    return True\n\n\n#########################\n# Protocol Subscription #\n#########################\n\n\n# set protocol sub price\n\n\n@external\ndef setProtocolSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Set subscription pricing for the protocol\n    @dev Only callable by governor\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if protocol subscription price was set successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    # validation\n    if not self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod):\n        return False\n\n    # save data\n    self.protocolSubPriceData = SubscriptionInfo(\n        asset=_asset,\n        usdValue=_usdValue,\n        trialPeriod=_trialPeriod,\n        payPeriod=_payPeriod,\n    )\n\n    log ProtocolSubPriceSet(asset=_asset, usdValue=_usdValue, trialPeriod=_trialPeriod, payPeriod=_payPeriod)\n    return True\n\n\n# removing protocol sub price\n\n\n@external\ndef removeProtocolSubPrice() -> bool:\n    \"\"\"\n    @notice Remove subscription pricing for the protocol\n    @dev Only callable by governor\n    @return bool True if protocol subscription price was removed successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    prevInfo: SubscriptionInfo = self.protocolSubPriceData\n    if prevInfo.asset == empty(address):\n        return False\n\n    self.protocolSubPriceData = empty(SubscriptionInfo)\n    log ProtocolSubPriceRemoved(asset=prevInfo.asset, usdValue=prevInfo.usdValue, trialPeriod=prevInfo.trialPeriod, payPeriod=prevInfo.payPeriod)\n    return True\n\n\n####################\n# Protocol Tx Fees #\n####################\n\n\n# utilities\n\n\n@view\n@external\ndef getTransactionFeeData(_user: address, _action: ActionType) -> (uint256, address):\n    \"\"\"\n    @notice Get transaction fee data for the protocol\n    @dev Returns a tuple containing the fee amount and recipient address for the protocol\n    @param _user The address of the user\n    @param _action The type of action being performed\n    @return feeAmount The fee amount for the action\n    @return recipient The recipient address for the fee\n    \"\"\"\n    # NOTE: in future, we may have different pricing tiers depending on the `_user`\n    return self._getTxFeeForAction(_action, self.protocolTxPriceData), self.protocolRecipient\n\n\n@view\n@internal\ndef _getTxFeeForAction(_action: ActionType, _prices: TxPriceSheet) -> uint256:\n    if _action == ActionType.DEPOSIT:\n        return _prices.depositFee\n    elif _action == ActionType.WITHDRAWAL:\n        return _prices.withdrawalFee\n    elif _action == ActionType.REBALANCE:\n        return _prices.rebalanceFee\n    elif _action == ActionType.TRANSFER:\n        return _prices.transferFee\n    elif _action == ActionType.SWAP:\n        return _prices.swapFee\n    elif _action == ActionType.ADD_LIQ:\n        return _prices.addLiqFee\n    elif _action == ActionType.REMOVE_LIQ:\n        return _prices.removeLiqFee\n    elif _action == ActionType.CLAIM_REWARDS:\n        return _prices.claimRewardsFee\n    elif _action == ActionType.BORROW:\n        return _prices.borrowFee\n    elif _action == ActionType.REPAY:\n        return _prices.repayFee\n    else:\n        return 0\n\n\n# set protocol tx price sheet\n\n\n@view\n@external\ndef isValidTxPriceSheet(\n    _depositFee: uint256,\n    _withdrawalFee: uint256,\n    _rebalanceFee: uint256,\n    _transferFee: uint256,\n    _swapFee: uint256,\n    _addLiqFee: uint256,\n    _removeLiqFee: uint256,\n    _claimRewardsFee: uint256,\n    _borrowFee: uint256,\n    _repayFee: uint256,\n) -> bool:\n    \"\"\"\n    @notice Check if transaction price sheet parameters are valid\n    @dev Validates fee percentages against constraints\n    @param _depositFee The fee percentage for deposits\n    @param _withdrawalFee The fee percentage for withdrawals\n    @param _rebalanceFee The fee percentage for rebalances\n    @param _transferFee The fee percentage for transfers\n    @param _swapFee The fee percentage for swaps\n    @param _addLiqFee The fee percentage for adding liquidity\n    @param _removeLiqFee The fee percentage for removing liquidity\n    @param _claimRewardsFee The fee percentage for claiming rewards\n    @param _borrowFee The fee percentage for borrowing\n    @param _repayFee The fee percentage for repaying\n    @return bool True if all parameters are valid\n    \"\"\"\n    return self._isValidTxPriceSheet(_depositFee, _withdrawalFee, _rebalanceFee, _transferFee, _swapFee, _addLiqFee, _removeLiqFee, _claimRewardsFee, _borrowFee, _repayFee)\n\n\n@view\n@internal\ndef _isValidTxPriceSheet(\n    _depositFee: uint256,\n    _withdrawalFee: uint256,\n    _rebalanceFee: uint256,\n    _transferFee: uint256,\n    _swapFee: uint256,\n    _addLiqFee: uint256,\n    _removeLiqFee: uint256,\n    _claimRewardsFee: uint256,\n    _borrowFee: uint256,\n    _repayFee: uint256,\n) -> bool:\n    return _depositFee <= MAX_TX_FEE and _withdrawalFee <= MAX_TX_FEE and _rebalanceFee <= MAX_TX_FEE and _transferFee <= MAX_TX_FEE and _swapFee <= MAX_TX_FEE and _addLiqFee <= MAX_TX_FEE and _removeLiqFee <= MAX_TX_FEE and _claimRewardsFee <= MAX_TX_FEE and _borrowFee <= MAX_TX_FEE and _repayFee <= MAX_TX_FEE\n\n\n@external\ndef setProtocolTxPriceSheet(\n    _depositFee: uint256,\n    _withdrawalFee: uint256,\n    _rebalanceFee: uint256,\n    _transferFee: uint256,\n    _swapFee: uint256,\n    _addLiqFee: uint256,\n    _removeLiqFee: uint256,\n    _claimRewardsFee: uint256,\n    _borrowFee: uint256,\n    _repayFee: uint256,\n) -> bool:\n    \"\"\"\n    @notice Set transaction price sheet for the protocol\n    @dev Only callable by governor\n    @param _depositFee The fee percentage for deposits\n    @param _withdrawalFee The fee percentage for withdrawals\n    @param _rebalanceFee The fee percentage for rebalances\n    @param _transferFee The fee percentage for transfers\n    @param _swapFee The fee percentage for swaps\n    @param _addLiqFee The fee percentage for adding liquidity\n    @param _removeLiqFee The fee percentage for removing liquidity\n    @param _claimRewardsFee The fee percentage for claiming rewards\n    @param _borrowFee The fee percentage for borrowing\n    @param _repayFee The fee percentage for repaying\n    @return bool True if protocol price sheet was set successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    # validation\n    if not self._isValidTxPriceSheet(_depositFee, _withdrawalFee, _rebalanceFee, _transferFee, _swapFee, _addLiqFee, _removeLiqFee, _claimRewardsFee, _borrowFee, _repayFee):\n        return False\n\n    # save data\n    self.protocolTxPriceData = TxPriceSheet(\n        depositFee=_depositFee,\n        withdrawalFee=_withdrawalFee,\n        rebalanceFee=_rebalanceFee,\n        transferFee=_transferFee,\n        swapFee=_swapFee,\n        addLiqFee=_addLiqFee,\n        removeLiqFee=_removeLiqFee,\n        claimRewardsFee=_claimRewardsFee,\n        borrowFee=_borrowFee,\n        repayFee=_repayFee,\n    )\n\n    log ProtocolTxPriceSheetSet(depositFee=_depositFee, withdrawalFee=_withdrawalFee, rebalanceFee=_rebalanceFee, transferFee=_transferFee, swapFee=_swapFee, addLiqFee=_addLiqFee, removeLiqFee=_removeLiqFee, claimRewardsFee=_claimRewardsFee, borrowFee=_borrowFee, repayFee=_repayFee)\n    return True\n\n\n# remove protocol tx price sheet\n\n\n@external\ndef removeProtocolTxPriceSheet() -> bool:\n    \"\"\"\n    @notice Remove transaction price sheet for the protocol\n    @dev Only callable by governor\n    @return bool True if protocol price sheet was removed successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    prevInfo: TxPriceSheet = self.protocolTxPriceData\n    self.protocolTxPriceData = empty(TxPriceSheet)\n    log ProtocolTxPriceSheetRemoved(depositFee=prevInfo.depositFee, withdrawalFee=prevInfo.withdrawalFee, rebalanceFee=prevInfo.rebalanceFee, transferFee=prevInfo.transferFee, swapFee=prevInfo.swapFee, addLiqFee=prevInfo.addLiqFee, removeLiqFee=prevInfo.removeLiqFee, claimRewardsFee=prevInfo.claimRewardsFee, borrowFee=prevInfo.borrowFee, repayFee=prevInfo.repayFee)\n    return True\n\n\n######################\n# Protocol Recipient #\n######################\n\n\n@external\ndef setProtocolRecipient(_recipient: address) -> bool:\n    \"\"\"\n    @notice Set the recipient address for protocol fees\n    @dev Only callable by governor\n    @param _recipient The address to receive protocol fees\n    @return bool True if protocol recipient was set successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    assert _recipient != empty(address) # dev: invalid recipient\n    self.protocolRecipient = _recipient\n    log ProtocolRecipientSet(recipient=_recipient)\n    return True\n\n\n######################\n# Price Change Delay #\n######################\n\n\n@external\ndef setPriceChangeDelay(_delayBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Set the number of blocks required before price changes take effect\n    @dev Only callable by governor\n    @param _delayBlocks The number of blocks to wait before price changes take effect\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    assert _delayBlocks == 0 or _delayBlocks >= MIN_PRICE_CHANGE_BUFFER # dev: invalid delay\n    self.priceChangeDelay = _delayBlocks\n    log PriceChangeDelaySet(delayBlocks=_delayBlocks)\n    return True\n\n\n############\n# Activate #\n############\n\n\n@external\ndef activate(_shouldActivate: bool):\n    \"\"\"\n    @notice Activate or deactivate the price sheets registry\n    @dev Only callable by governor. When deactivated, most functions cannot be called.\n    @param _shouldActivate True to activate, False to deactivate\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log PriceSheetsActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "f5276f291fc4fd02da37ff4210db6d2dc773149a70a72a44cd57453981e8f010"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/PriceSheets.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "5a3332594aa58dcc5fdb91f9a152bebbbfd4636bc202f1cfa3ab9c8a48129acc"
      },
      "args": "000000000000000000000000000000000000000000000000000000000000a8c0000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000000000000000003b8260000000000000000000000000000000000000000000000000000000000000a8c000000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "ChainlinkFeeds": {
      "address": "0x6035ff5936563132caD931a3a2F328477372fb82",
      "abi": [
        {
          "name": "ChainlinkFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "chainlinkFeed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getConfiguredAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getChainlinkData",
          "inputs": [
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getChainlinkData",
          "inputs": [
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableChainlinkPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "feed",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "needsEthToUsd",
                  "type": "bool"
                },
                {
                  "name": "needsBtcToUsd",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "BTC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_btcAddr",
              "type": "address"
            },
            {
              "name": "_ethUsdFeed",
              "type": "address"
            },
            {
              "name": "_btcUsdFeed",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "contracts/modules/OracleAssetData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "ebfec365e231ba18d5a0509682ce49c61d855719b832216297c6db33665c7be8"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/oracles/ChainlinkFeeds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: OraclePartner\ninitializes: gov\ninitializes: oad\nexports: gov.__interface__\nexports: oad.__interface__\n\nimport contracts.modules.Governable as gov\nimport contracts.modules.OracleAssetData as oad\nimport interfaces.OraclePartnerInterface as OraclePartner\n\ninterface ChainlinkFeed:\n    def latestRoundData() -> ChainlinkRound: view\n    def decimals() -> uint8: view \n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nstruct ChainlinkConfig:\n    feed: address\n    decimals: uint256\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n\nevent ChainlinkFeedAdded:\n    asset: indexed(address)\n    chainlinkFeed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n\nevent ChainlinkFeedDisabled:\n    asset: indexed(address)\n\n# chainlink config\nfeedConfig: public(HashMap[address, ChainlinkConfig])\n\n# general config\noraclePartnerId: public(uint256)\nADDY_REGISTRY: public(immutable(address))\n\n# default assets\nWETH: public(immutable(address))\nETH: public(immutable(address))\nBTC: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\n\n\n@deploy\ndef __init__(\n    _wethAddr: address,\n    _ethAddr: address,\n    _btcAddr: address,\n    _ethUsdFeed: address,\n    _btcUsdFeed: address,\n    _addyRegistry: address,\n):\n    assert empty(address) not in [_wethAddr, _ethAddr, _btcAddr, _addyRegistry] # dev: invalid addrs\n    ADDY_REGISTRY = _addyRegistry\n    gov.__init__(_addyRegistry)\n    oad.__init__()\n\n    # set default assets\n    WETH = _wethAddr\n    ETH = _ethAddr\n    BTC = _btcAddr\n\n    # set default feeds\n    if _ethUsdFeed != empty(address):\n        assert self._setChainlinkFeed(ETH, _ethUsdFeed, False, False)\n        assert self._setChainlinkFeed(WETH, _ethUsdFeed, False, False)\n    if _btcUsdFeed != empty(address):\n        assert self._setChainlinkFeed(BTC, _btcUsdFeed, False, False)\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    config: ChainlinkConfig = self.feedConfig[_asset]\n    if config.feed == empty(address):\n        return 0\n    return self._getPrice(config.feed, config.decimals, config.needsEthToUsd, config.needsBtcToUsd, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    config: ChainlinkConfig = self.feedConfig[_asset]\n    if config.feed == empty(address):\n        return 0, False\n    return self._getPrice(config.feed, config.decimals, config.needsEthToUsd, config.needsBtcToUsd, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(\n    _feed: address, \n    _decimals: uint256,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n    _staleTime: uint256,\n) -> uint256:\n    price: uint256 = self._getChainlinkData(_feed, _decimals, _staleTime)\n    if price == 0:\n        return 0\n\n    # if price needs ETH -> USD conversion\n    if _needsEthToUsd:\n        ethConfig: ChainlinkConfig = self.feedConfig[ETH]\n        ethUsdPrice: uint256 = self._getChainlinkData(ethConfig.feed, ethConfig.decimals, _staleTime)\n        price = price * ethUsdPrice // (10 ** NORMALIZED_DECIMALS)\n\n    # if price needs BTC -> USD conversion\n    elif _needsBtcToUsd:\n        btcConfig: ChainlinkConfig = self.feedConfig[BTC]\n        btcUsdPrice: uint256 = self._getChainlinkData(btcConfig.feed, btcConfig.decimals, _staleTime)\n        price = price * btcUsdPrice // (10 ** NORMALIZED_DECIMALS)\n\n    return price\n\n\n@view\n@external\ndef getChainlinkData(_feed: address, _decimals: uint256, _staleTime: uint256 = 0) -> uint256:\n    return self._getChainlinkData(_feed, _decimals, _staleTime)\n\n\n@view\n@internal\ndef _getChainlinkData(_feed: address, _decimals: uint256, _staleTime: uint256) -> uint256:\n    oracle: ChainlinkRound = staticcall ChainlinkFeed(_feed).latestRoundData()\n\n    # NOTE: choosing to fail gracefully in Underscore\n\n    # oracle has no price\n    if oracle.answer <= 0:\n        return 0\n\n    # bad decimals\n    if _decimals > NORMALIZED_DECIMALS:\n        return 0\n\n    # price is too stale\n    if _staleTime != 0 and block.timestamp - oracle.updatedAt > _staleTime:\n        return 0\n\n    # handle decimal normalization\n    price: uint256 = convert(oracle.answer, uint256)\n    decimals: uint256 = _decimals\n    if decimals < NORMALIZED_DECIMALS:\n        decimals = NORMALIZED_DECIMALS - decimals\n        price = price * (10 ** decimals)\n\n    return price\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self._hasPriceFeed(_asset)\n\n\n@view\n@internal\ndef _hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset].feed != empty(address)\n\n\n#####################\n# Config Price Feed #\n#####################\n\n\n# set price feed\n\n\n@view\n@external\ndef isValidChainlinkFeed(\n    _asset: address, \n    _feed: address,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n) -> bool:\n    decimals: uint256 = convert(staticcall ChainlinkFeed(_feed).decimals(), uint256)\n    return self._isValidChainlinkFeed(_asset, _feed, decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n@view\n@internal\ndef _isValidChainlinkFeed(\n    _asset: address, \n    _feed: address,\n    _decimals: uint256,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n) -> bool:\n    if empty(address) in [_asset, _feed]:\n        return False\n    if _needsEthToUsd and _needsBtcToUsd:\n        return False\n    return self._getPrice(_feed, _decimals, _needsEthToUsd, _needsBtcToUsd, 0) != 0\n\n\n@external\ndef setChainlinkFeed(\n    _asset: address, \n    _feed: address, \n    _needsEthToUsd: bool = False,\n    _needsBtcToUsd: bool = False,\n) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    return self._setChainlinkFeed(_asset, _feed, _needsEthToUsd, _needsBtcToUsd)\n\n\n@internal\ndef _setChainlinkFeed(\n    _asset: address, \n    _feed: address, \n    _needsEthToUsd: bool = False,\n    _needsBtcToUsd: bool = False,\n) -> bool:\n    decimals: uint256 = convert(staticcall ChainlinkFeed(_feed).decimals(), uint256)\n    if not self._isValidChainlinkFeed(_asset, _feed, decimals, _needsEthToUsd, _needsBtcToUsd):\n        return False\n\n    self.feedConfig[_asset] = ChainlinkConfig(\n        feed=_feed,\n        decimals=decimals,\n        needsEthToUsd=_needsEthToUsd,\n        needsBtcToUsd=_needsBtcToUsd,\n    )\n    oad._addAsset(_asset)\n    log ChainlinkFeedAdded(asset=_asset, chainlinkFeed=_feed, needsEthToUsd=_needsEthToUsd, needsBtcToUsd=_needsBtcToUsd)\n    return True\n\n\n# disable price feed\n\n\n@external\ndef disableChainlinkPriceFeed(_asset: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    assert _asset not in [ETH, WETH, BTC] # dev: cannot disable default feeds\n    if not self._hasPriceFeed(_asset):\n        return False\n    self.feedConfig[_asset] = empty(ChainlinkConfig)\n    oad._removeAsset(_asset)\n    log ChainlinkFeedDisabled(asset=_asset)\n    return True\n\n\n##########\n# Config #\n##########\n\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4) # dev: no perms\n    prevId: uint256 = self.oraclePartnerId\n    assert prevId == 0 or prevId == _oracleId # dev: invalid oracle id\n    self.oraclePartnerId = _oracleId\n    return True\n",
            "sha256sum": "3a767ff98ad6509e52e033a0e73730d79e1b7051fc98216c883abef596bf7b3e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/oracles/ChainlinkFeeds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "5bd82a3a0aec56f04b25f3f41e88ead8367f1a9d959f0052cfc09e902c2d6304"
      },
      "args": "0000000000000000000000004200000000000000000000000000000000000006000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb00000000000000000000000071041dddad3595f9ced3dccfbe3d1f4b0a16bb7000000000000000000000000064c911996d3c6ac71f9b455b1e8e7266bcbd848f00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "PythFeeds": {
      "address": "0xB8090783aBF7B6336121FAfd6c4aCa3C4516792D",
      "abi": [
        {
          "name": "PythFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feedId",
              "type": "bytes32",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PythFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PythPriceUpdated",
          "inputs": [
            {
              "name": "payload",
              "type": "bytes",
              "indexed": false
            },
            {
              "name": "feeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EthRecoveredFromPyth",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getConfiguredAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePythPrices",
          "inputs": [
            {
              "name": "_payloads",
              "type": "bytes[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPythFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPythFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disablePythPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidEthRecovery",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverEthBalance",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "PYTH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_pyth",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "contracts/modules/OracleAssetData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "ebfec365e231ba18d5a0509682ce49c61d855719b832216297c6db33665c7be8"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/oracles/PythFeeds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: OraclePartner\ninitializes: gov\ninitializes: oad\nexports: gov.__interface__\nexports: oad.__interface__\n\nimport contracts.modules.Governable as gov\nimport contracts.modules.OracleAssetData as oad\nimport interfaces.OraclePartnerInterface as OraclePartner\n\ninterface PythNetwork:\n    def getPriceUnsafe(_priceFeedId: bytes32) -> PythPrice: view\n    def priceFeedExists(_priceFeedId: bytes32) -> bool: view\n    def getUpdateFee(_payLoad: Bytes[2048]) -> uint256: view\n    def updatePriceFeeds(_payLoad: Bytes[2048]): payable\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct PythPrice:\n    price: int64\n    confidence: uint64\n    exponent: int32\n    publishTime: uint64\n\nevent PythFeedAdded:\n    asset: indexed(address)\n    feedId: indexed(bytes32)\n\nevent PythFeedDisabled:\n    asset: indexed(address)\n\nevent PythPriceUpdated:\n    payload: Bytes[2048]\n    feeAmount: uint256\n    caller: indexed(address)\n\nevent EthRecoveredFromPyth:\n    recipient: indexed(address)\n    amount: uint256\n\n# pyth config\nPYTH: public(immutable(address))\nfeedConfig: public(HashMap[address, bytes32])\n\n# general config\noraclePartnerId: public(uint256)\nADDY_REGISTRY: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\nMAX_PRICE_UPDATES: constant(uint256) = 15\n\n\n@deploy\ndef __init__(_pyth: address, _addyRegistry: address):\n    assert empty(address) not in [_pyth, _addyRegistry] # dev: invalid addrs\n    PYTH = _pyth\n    ADDY_REGISTRY = _addyRegistry\n    gov.__init__(_addyRegistry)\n    oad.__init__()\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0\n    return self._getPrice(feedId, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0, False\n    return self._getPrice(feedId, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(_feedId: bytes32, _staleTime: uint256) -> uint256:\n    priceData: PythPrice = staticcall PythNetwork(PYTH).getPriceUnsafe(_feedId)\n\n    # NOTE: choosing to fail gracefully in Underscore\n\n    # no price\n    if priceData.price <= 0:\n        return 0\n\n    # price is too stale\n    publishTime: uint256 = convert(priceData.publishTime, uint256)\n    if _staleTime != 0 and block.timestamp - publishTime > _staleTime:\n        return 0\n\n    price: uint256 = convert(priceData.price, uint256)\n    confidence: uint256 = convert(priceData.confidence, uint256)\n    scale: uint256 = 10 ** NORMALIZED_DECIMALS\n    exponent: uint256 = 0\n\n    # negative exponent: multiply by 10^(18-|exponent|)\n    if priceData.exponent < 0:\n        exponent = convert(-priceData.exponent, uint256)\n        price = price * scale // (10 ** exponent)\n        confidence = confidence * scale // (10 ** exponent)\n\n    # positive exponent: multiply by 10^(18+exponent)\n    else:\n        exponent = convert(priceData.exponent, uint256)\n        price = price * scale * (10 ** exponent)\n        confidence = confidence * scale * (10 ** exponent)\n\n    # invalid price\n    if confidence >= price:\n        return 0\n\n    return price - confidence\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self._hasPriceFeed(_asset)\n\n\n@view\n@internal\ndef _hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset] != empty(bytes32)\n\n\n################\n# Update Price #\n################\n\n\n@external\ndef updatePythPrices(_payloads: DynArray[Bytes[2048], MAX_PRICE_UPDATES]):\n    for i: uint256 in range(len(_payloads), bound=MAX_PRICE_UPDATES):\n        p: Bytes[2048] = _payloads[i]\n        feeAmount: uint256 = staticcall PythNetwork(PYTH).getUpdateFee(p)\n        assert self.balance >= feeAmount # dev: insufficient balance\n        extcall PythNetwork(PYTH).updatePriceFeeds(p, value=feeAmount)\n        log PythPriceUpdated(payload=p, feeAmount=feeAmount, caller=msg.sender)\n\n\n#####################\n# Config Price Feed #\n#####################\n\n\n# set price feed\n\n\n@view\n@external\ndef isValidPythFeed(_asset: address, _feedId: bytes32) -> bool:\n    return self._isValidPythFeed(_asset, _feedId)\n\n\n@view\n@internal\ndef _isValidPythFeed(_asset: address, _feedId: bytes32) -> bool:\n    if _asset == empty(address):\n        return False\n    return staticcall PythNetwork(PYTH).priceFeedExists(_feedId)\n\n\n@external\ndef setPythFeed(_asset: address, _feedId: bytes32) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    if not self._isValidPythFeed(_asset, _feedId):\n        return False\n    self.feedConfig[_asset] = _feedId\n    oad._addAsset(_asset)\n    log PythFeedAdded(asset=_asset, feedId=_feedId)\n    return True\n\n\n# disable price feed\n\n\n@external\ndef disablePythPriceFeed(_asset: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    if not self._hasPriceFeed(_asset):\n        return False\n    self.feedConfig[_asset] = empty(bytes32)\n    oad._removeAsset(_asset)\n    log PythFeedDisabled(asset=_asset)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@view\n@external\ndef isValidEthRecovery(_recipient: address) -> bool:\n    return self._isValidEthRecovery(_recipient, self.balance)\n\n\n@view\n@internal\ndef _isValidEthRecovery(_recipient: address, _balance: uint256) -> bool:\n    return _recipient != empty(address) and _balance != 0\n\n\n@external\ndef recoverEthBalance(_recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    balance: uint256 = self.balance\n    if not self._isValidEthRecovery(_recipient, balance):\n        return False\n    send(_recipient, balance)\n    log EthRecoveredFromPyth(recipient=_recipient, amount=balance)\n    return True\n\n\n##########\n# Config #\n##########\n\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4) # dev: no perms\n    prevId: uint256 = self.oraclePartnerId\n    assert prevId == 0 or prevId == _oracleId # dev: invalid oracle id\n    self.oraclePartnerId = _oracleId\n    return True\n",
            "sha256sum": "7a9fa8f3822ff8f660ee6179cd0e5b9d1a08dbcffc326c9db7ea212d5a8e1e6c"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/oracles/PythFeeds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "7b1dbcc280b124a08eb3f0c7ddddf8a4024e54c9ca1064a8e51d11d6e6418138"
      },
      "args": "0000000000000000000000008250f4af4b972684f7b336503e2d6dfedeb1487a00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "StorkFeeds": {
      "address": "0x389e7d981A74cd957bf56d83cCB85e6fc9e9d9bD",
      "abi": [
        {
          "name": "StorkFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feedId",
              "type": "bytes32",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StorkFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StorkPriceUpdated",
          "inputs": [
            {
              "name": "payload",
              "type": "bytes",
              "indexed": false
            },
            {
              "name": "feeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EthRecoveredFromStork",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getConfiguredAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateStorkPrices",
          "inputs": [
            {
              "name": "_payloads",
              "type": "bytes[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidStorkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStorkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableStorkPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidEthRecovery",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverEthBalance",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "STORK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_stork",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "contracts/modules/OracleAssetData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "ebfec365e231ba18d5a0509682ce49c61d855719b832216297c6db33665c7be8"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/oracles/StorkFeeds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: OraclePartner\ninitializes: gov\ninitializes: oad\nexports: gov.__interface__\nexports: oad.__interface__\n\nimport contracts.modules.Governable as gov\nimport contracts.modules.OracleAssetData as oad\nimport interfaces.OraclePartnerInterface as OraclePartner\n\ninterface StorkNetwork:\n    def getTemporalNumericValueUnsafeV1(_priceFeedId: bytes32) -> TemporalNumericValue: view\n    def updateTemporalNumericValuesV1(_payLoad: Bytes[2048]): payable\n    def getUpdateFeeV1(_payLoad: Bytes[2048]) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct TemporalNumericValue:\n    timestampNs: uint64\n    quantizedValue: uint256\n\nevent StorkFeedAdded:\n    asset: indexed(address)\n    feedId: indexed(bytes32)\n\nevent StorkFeedDisabled:\n    asset: indexed(address)\n\nevent StorkPriceUpdated:\n    payload: Bytes[2048]\n    feeAmount: uint256\n    caller: indexed(address)\n\nevent EthRecoveredFromStork:\n    recipient: indexed(address)\n    amount: uint256\n\n# stork config\nSTORK: public(immutable(address))\nfeedConfig: public(HashMap[address, bytes32])\n\n# general config\noraclePartnerId: public(uint256)\nADDY_REGISTRY: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\nMAX_PRICE_UPDATES: constant(uint256) = 15\n\n\n@deploy\ndef __init__(_stork: address, _addyRegistry: address):\n    assert empty(address) not in [_stork, _addyRegistry] # dev: invalid addrs\n    STORK = _stork\n    ADDY_REGISTRY = _addyRegistry\n    gov.__init__(_addyRegistry)\n    oad.__init__()\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0\n    return self._getPrice(feedId, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0, False\n    return self._getPrice(feedId, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(_feedId: bytes32, _staleTime: uint256) -> uint256:\n    priceData: TemporalNumericValue = staticcall StorkNetwork(STORK).getTemporalNumericValueUnsafeV1(_feedId)\n\n    # NOTE: choosing to fail gracefully in Underscore\n\n    # no price\n    if priceData.quantizedValue == 0:\n        return 0\n\n    # price is too stale\n    publishTime: uint256 = convert(priceData.timestampNs, uint256) // 1_000_000_000\n    if _staleTime != 0 and block.timestamp - publishTime > _staleTime:\n        return 0\n\n    return priceData.quantizedValue\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self._hasPriceFeed(_asset)\n\n\n@view\n@internal\ndef _hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset] != empty(bytes32)\n\n\n################\n# Update Price #\n################\n\n\n@external\ndef updateStorkPrices(_payloads: DynArray[Bytes[2048], MAX_PRICE_UPDATES]):\n    for i: uint256 in range(len(_payloads), bound=MAX_PRICE_UPDATES):\n        p: Bytes[2048] = _payloads[i]\n        feeAmount: uint256 = staticcall StorkNetwork(STORK).getUpdateFeeV1(p)\n        assert self.balance >= feeAmount # dev: insufficient balance\n        extcall StorkNetwork(STORK).updateTemporalNumericValuesV1(p, value=feeAmount)\n        log StorkPriceUpdated(payload=p, feeAmount=feeAmount, caller=msg.sender)\n\n\n#####################\n# Config Price Feed #\n#####################\n\n\n# set price feed\n\n\n@view\n@external\ndef isValidStorkFeed(_asset: address, _feedId: bytes32) -> bool:\n    return self._isValidStorkFeed(_asset, _feedId)\n\n\n@view\n@internal\ndef _isValidStorkFeed(_asset: address, _feedId: bytes32) -> bool:\n    if _asset == empty(address):\n        return False\n    priceData: TemporalNumericValue = staticcall StorkNetwork(STORK).getTemporalNumericValueUnsafeV1(_feedId)\n    return priceData.timestampNs != 0\n\n\n@external\ndef setStorkFeed(_asset: address, _feedId: bytes32) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    if not self._isValidStorkFeed(_asset, _feedId):\n        return False\n    self.feedConfig[_asset] = _feedId\n    oad._addAsset(_asset)\n    log StorkFeedAdded(asset=_asset, feedId=_feedId)\n    return True\n\n\n# disable price feed\n\n\n@external\ndef disableStorkPriceFeed(_asset: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    if not self._hasPriceFeed(_asset):\n        return False\n    self.feedConfig[_asset] = empty(bytes32)\n    oad._removeAsset(_asset)\n    log StorkFeedDisabled(asset=_asset)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@view\n@external\ndef isValidEthRecovery(_recipient: address) -> bool:\n    return self._isValidEthRecovery(_recipient, self.balance)\n\n\n@view\n@internal\ndef _isValidEthRecovery(_recipient: address, _balance: uint256) -> bool:\n    return _recipient != empty(address) and _balance != 0\n\n\n@external\ndef recoverEthBalance(_recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    balance: uint256 = self.balance\n    if not self._isValidEthRecovery(_recipient, balance):\n        return False\n    send(_recipient, balance)\n    log EthRecoveredFromStork(recipient=_recipient, amount=balance)\n    return True\n\n\n##########\n# Config #\n##########\n\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4) # dev: no perms\n    prevId: uint256 = self.oraclePartnerId\n    assert prevId == 0 or prevId == _oracleId # dev: invalid oracle id\n    self.oraclePartnerId = _oracleId\n    return True\n",
            "sha256sum": "6330b4f87b0b78462f4a48fb3ebddcaea18a0aa9fc94c7b184b35a536fc67f74"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/oracles/StorkFeeds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "967a58d3f3e05a2eb5daba9dedf01897f85f7a332b38e5b276f752bb4b52e782"
      },
      "args": "000000000000000000000000647dfd812bc1e116c6992cb2bc353b2112176fd600000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "LegoAaveV3": {
      "address": "0x904CCd911533259C1d6B4C50d87DE8130ABeb55D",
      "abi": [
        {
          "name": "AaveV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3LegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3Activated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ADDRESS_PROVIDER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_aaveV3",
              "type": "address"
            },
            {
              "name": "_addressProvider",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoAaveV3.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface AaveProtocolDataProvider:\n    def getReserveTokensAddresses(_asset: address) -> (address, address, address): view\n    def getAllATokens() -> DynArray[TokenData, MAX_ATOKENS]: view\n    def getTotalDebt(_asset: address) -> uint256: view\n\ninterface AaveV3Pool:\n    def supply(_asset: address, _amount: uint256, _onBehalfOf: address, _referralCode: uint16): nonpayable\n    def withdraw(_asset: address, _amount: uint256, _to: address): nonpayable\n\ninterface AToken:\n    def UNDERLYING_ASSET_ADDRESS() -> address: view\n    def totalSupply() -> uint256: view\n\ninterface AaveV3AddressProvider:\n    def getPoolDataProvider() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct TokenData:\n    symbol: String[32]\n    tokenAddress: address\n\nevent AaveV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent AaveV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent AaveV3FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent AaveV3LegoIdSet:\n    legoId: uint256\n\nevent AaveV3Activated:\n    isActivated: bool\n\n# aave v3\nAAVE_V3_POOL: public(immutable(address))\nAAVE_V3_ADDRESS_PROVIDER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nMAX_ATOKENS: constant(uint256) = 40\n\n\n@deploy\ndef __init__(_aaveV3: address, _addressProvider: address, _addyRegistry: address):\n    assert empty(address) not in [_aaveV3, _addressProvider, _addyRegistry] # dev: invalid addrs\n    AAVE_V3_POOL = _aaveV3\n    AAVE_V3_ADDRESS_PROVIDER = _addressProvider\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AAVE_V3_POOL, AAVE_V3_ADDRESS_PROVIDER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@internal\ndef _getPoolDataProvider() -> address:\n    return staticcall AaveV3AddressProvider(AAVE_V3_ADDRESS_PROVIDER).getPoolDataProvider()\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidAToken(_vaultToken, self._getPoolDataProvider())\n\n\n@view\n@internal\ndef _isValidAToken(_aToken: address, _dataProvider: address) -> bool:\n    aTokens: DynArray[TokenData, MAX_ATOKENS] = staticcall AaveProtocolDataProvider(_dataProvider).getAllATokens()\n    for i: uint256 in range(len(aTokens), bound=MAX_ATOKENS):\n        if aTokens[i].tokenAddress == _aToken:\n            return True\n    return False\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken, self._getPoolDataProvider())\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address, _dataProvider: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidAToken(_vaultToken, _dataProvider):\n        asset = staticcall AToken(_vaultToken).UNDERLYING_ASSET_ADDRESS()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    # treated as 1:1\n    return _assetAmount\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken, self._getPoolDataProvider())\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall AToken(_vaultToken).totalSupply()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    dataProvider: address = self._getPoolDataProvider()\n    asset: address = self._getUnderlyingAsset(_vaultToken, dataProvider)\n    if asset == empty(address):\n        return 0 # invalid vault token\n    return staticcall AaveProtocolDataProvider(dataProvider).getTotalDebt(asset)\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    vaultToken: address = self._getVaultToken(_asset, _vault)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preRecipientVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    extcall AaveV3Pool(AAVE_V3_POOL).supply(_asset, depositAmount, _recipient, 0)\n\n    # validate vault token transfer\n    newRecipientVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient)\n    vaultTokenAmountReceived: uint256 = newRecipientVaultBalance - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log AaveV3Deposit(sender=msg.sender, asset=_asset, vaultToken=vaultToken, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, vaultToken, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n@view\n@internal\ndef _getVaultToken(_asset: address, _vault: address) -> address:\n    vault: address = _vault\n    if _vault != empty(address):\n        vault = yld.assetOpportunities[_asset][1] # only one opportunity for aave v3\n    assert yld.indexOfAssetOpportunity[_asset][vault] != 0 # dev: asset + vault not supported\n    return vault\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    vaultToken: address = self._getVaultToken(_asset, _vaultToken)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n    preRecipientAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall AaveV3Pool(AAVE_V3_POOL).withdraw(_asset, max_value(uint256), _recipient)\n\n    # validate asset transfer\n    newRecipientAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n    assetAmountReceived: uint256 = newRecipientAssetBalance - preRecipientAssetBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log AaveV3Withdrawal(sender=msg.sender, asset=_asset, vaultToken=vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    # Aave has no rewards on Base\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # Aave has no rewards on Base\n    return False\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    # specific to lego\n    dataProvider: address = self._getPoolDataProvider()\n    vaultToken: address = (staticcall AaveProtocolDataProvider(dataProvider).getReserveTokensAddresses(_asset))[0]\n    assert vaultToken != empty(address) # dev: invalid asset\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, vaultToken)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    vaultToken: address = yld.assetOpportunities[_asset][1] # only one opportunity for aave v3\n    yld._removeAssetOpportunity(_asset, vaultToken)\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AaveV3FundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log AaveV3LegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log AaveV3Activated(isActivated=_shouldActivate)",
            "sha256sum": "c092210771d357a1b27d7bfa209c54e6b15582a804ac8ddd4c4c16586a182d83"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoAaveV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "3121c78ea12b0273621c0652f57d5f1847c7d9250756bed50ca21307afe9e89a"
      },
      "args": "000000000000000000000000a238dd80c259a72e81d7e4664a9801593f98d1c5000000000000000000000000e20fcbdbffc4dd138ce8b2e6fbb6cb49777ad64d00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "LegoCompoundV3": {
      "address": "0x8546b0ad0C399930847ce725921DBE0F7c106aD9",
      "abi": [
        {
          "name": "CompoundV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3RewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3LegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3Activated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCompRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_CONFIGURATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_configurator",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "contracts/legos/yield/LegoCompoundV3.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\n\n# `hasClaimableRewards()` is not a view function, sadly due to compound v3 constraints\n# keeping here to uncomment to test all other functions\n# implements: LegoCommon \n# from interfaces import LegoCommon\n\ninterface CompoundV3:\n    def withdrawTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def supplyTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def totalSupply() -> uint256: view\n    def totalBorrow() -> uint256: view\n    def baseToken() -> address: view\n\ninterface CompoundV3Rewards:\n    def getRewardOwed(_comet: address, _user: address) -> RewardOwed: nonpayable\n    def claim(_comet: address, _user: address, _shouldAccrue: bool): nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface CompoundV3Configurator:\n    def factory(_cometAsset: address) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct RewardOwed:\n    token: address\n    owed: uint256\n\nevent CompoundV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent CompoundV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent CompoundV3FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent CompoundV3RewardsAddrSet:\n    addr: address\n\nevent CompoundV3LegoIdSet:\n    legoId: uint256\n\nevent CompoundV3Activated:\n    isActivated: bool\n\n# compound v3\ncompoundRewards: public(address)\nCOMPOUND_V3_CONFIGURATOR: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\n\n@deploy\ndef __init__(_configurator: address, _addyRegistry: address):\n    assert empty(address) not in [_configurator, _addyRegistry] # dev: invalid addrs\n    COMPOUND_V3_CONFIGURATOR = _configurator\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [COMPOUND_V3_CONFIGURATOR]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidCometAddr(_vaultToken)\n\n\n@view\n@internal\ndef _isValidCometAddr(_cometAddr: address) -> bool:\n    return staticcall CompoundV3Configurator(COMPOUND_V3_CONFIGURATOR).factory(_cometAddr) != empty(address)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidCometAddr(_vaultToken):\n        asset = staticcall CompoundV3(_vaultToken).baseToken()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    # treated as 1:1\n    return _assetAmount\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV3(_vaultToken).totalSupply()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV3(_vaultToken).totalBorrow()\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preRecipientVaultBalance: uint256 = staticcall IERC20(_vault).balanceOf(_recipient)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    extcall CompoundV3(_vault).supplyTo(_recipient, _asset, depositAmount) # dev: could not deposit into compound v3\n\n    # validate vault token transfer\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vault).balanceOf(_recipient) - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log CompoundV3Deposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preRecipientBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall CompoundV3(_vaultToken).withdrawTo(_recipient, _asset, max_value(uint256)) # dev: could not withdraw from compound v3\n\n    # validate received asset , transfer back to user\n    assetAmountReceived: uint256 = staticcall IERC20(_asset).balanceOf(_recipient) - preRecipientBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log CompoundV3Withdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    compRewards: address = self.compoundRewards\n    assert compRewards != empty(address) # dev: no comp rewards addr set\n    if _market != empty(address):\n        extcall CompoundV3Rewards(compRewards).claim(_market, _user, True)\n    else:\n        self._hasClaimableOrShouldClaim(_user, True, compRewards)\n\n\n# sadly, this is not a view function because of `getRewardOwed()`\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return self._hasClaimableOrShouldClaim(_user, False, self.compoundRewards)\n\n\n@internal\ndef _hasClaimableOrShouldClaim(_user: address, _shouldClaim: bool, _compRewards: address) -> bool:\n    hasClaimable: bool = False\n    numAssets: uint256 = yld.numAssets\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = yld.assets[i]\n        comet: address = yld.assetOpportunities[asset][1] # only a single \"vault token\" (comet) per asset\n\n        rewardOwed: RewardOwed = extcall CompoundV3Rewards(_compRewards).getRewardOwed(comet, _user)\n        if rewardOwed.owed != 0:\n            hasClaimable = True\n            if _shouldClaim:\n                extcall CompoundV3Rewards(_compRewards).claim(comet, _user, True)\n            else:\n                break\n\n    return hasClaimable\n\n\n# set rewards addr\n\n\n@external\ndef setCompRewardsAddr(_addr: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.compoundRewards = _addr\n    log CompoundV3RewardsAddrSet(addr=_addr)\n    return True\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log CompoundV3FundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log CompoundV3LegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log CompoundV3Activated(isActivated=_shouldActivate)\n",
            "sha256sum": "a0d90887052957ec1926f70df76717f7f03e71d0d96544668dae60a3ce3c6d4e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoCompoundV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "f678ca2eeb081b50fc5fb652024c46e005feb6fe4eef9d89ed213e1bb04c8479"
      },
      "args": "00000000000000000000000045939657d1ca34a8fa39a924b71d28fe8431e58100000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "LegoEuler": {
      "address": "0x38400f38E1e7E5d0c49C10a43c37a32977b62339",
      "abi": [
        {
          "name": "EulerDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setEulerRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EVAULT_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EARN_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_evaultFactory",
              "type": "address"
            },
            {
              "name": "_earnFactory",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoEuler.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface Erc4626Interface:\n    def redeem(_vaultTokenAmount: uint256, _recipient: address, _owner: address) -> uint256: nonpayable\n    def deposit(_assetAmount: uint256, _recipient: address) -> uint256: nonpayable\n    def convertToAssets(_vaultTokenAmount: uint256) -> uint256: view\n    def convertToShares(_assetAmount: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def asset() -> address: view\n\ninterface EulerRewardsDistributor:\n    def claim(_users: DynArray[address, 10], _rewardTokens: DynArray[address, 10], _claimAmounts: DynArray[uint256, 10], _proofs: DynArray[bytes32, 10]): nonpayable\n    def operators(_user: address, _operator: address) -> bool: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface EulerEarnFactory:\n    def isValidDeployment(_vault: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface EulerEvaultFactory:\n    def isProxy(_vault: address) -> bool: view\n\ninterface EulerVault:\n    def totalBorrows() -> uint256: view\n\nevent EulerDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent EulerWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent EulerFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent EulerRewardsAddrSet:\n    addr: address\n\nevent EulerLegoIdSet:\n    legoId: uint256\n\nevent EulerActivated:\n    isActivated: bool\n\n# euler\neulerRewards: public(address)\nEULER_EVAULT_FACTORY: public(immutable(address))\nEULER_EARN_FACTORY: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nLEGO_ACCESS_ABI: constant(String[64]) = \"toggleOperator(address,address)\"\n\n\n@deploy\ndef __init__(_evaultFactory: address, _earnFactory: address, _addyRegistry: address):\n    assert empty(address) not in [_evaultFactory, _earnFactory, _addyRegistry] # dev: invalid addrs\n    EULER_EVAULT_FACTORY = _evaultFactory\n    EULER_EARN_FACTORY = _earnFactory\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [EULER_EVAULT_FACTORY, EULER_EARN_FACTORY]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    eulerRewards: address = self.eulerRewards\n    if staticcall EulerRewardsDistributor(eulerRewards).operators(_user, self):\n        return empty(address), empty(String[64]), 0\n    else:\n        return eulerRewards, LEGO_ACCESS_ABI, 2\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidEulerVault(_vaultToken)\n\n\n@view\n@internal\ndef _isValidEulerVault(_vaultToken: address) -> bool:\n    return staticcall EulerEvaultFactory(EULER_EVAULT_FACTORY).isProxy(_vaultToken) or staticcall EulerEarnFactory(EULER_EARN_FACTORY).isValidDeployment(_vaultToken)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidEulerVault(_vaultToken):\n        asset = staticcall Erc4626Interface(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall Erc4626Interface(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall EulerVault(_vaultToken).totalBorrows()\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    vaultTokenAmountReceived: uint256 = extcall Erc4626Interface(_vault).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log EulerDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    transferVaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert transferVaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, transferVaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    vaultTokenAmount: uint256 = min(transferVaultTokenAmount, staticcall IERC20(_vaultToken).balanceOf(self))\n    assetAmountReceived: uint256 = extcall Erc4626Interface(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log EulerWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    eulerRewards: address = self.eulerRewards\n    assert eulerRewards != empty(address) # dev: no euler rewards addr set\n    if _rewardToken == empty(address):\n        return\n    extcall EulerRewardsDistributor(eulerRewards).claim([_user], [_rewardToken], [_rewardAmount], [_proof])\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setEulerRewardsAddr(_addr: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.eulerRewards = _addr\n    log EulerRewardsAddrSet(addr=_addr)\n    return True\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log EulerFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log EulerLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log EulerActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "dfcfe41373f42a5751243c4a4ea5e05c132077dc801b7e89bfad7c6cea2d96f9"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoEuler.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "2c74654f6756cc5429d48f00523dd5cbc60cd680d7eedb9ba416e93e193c65a3"
      },
      "args": "0000000000000000000000007f321498a801a191a93c840750ed637149ddf8d000000000000000000000000072bbdb652f2aec9056115644efccdd1986f51f1500000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "LegoFluid": {
      "address": "0xfC78950624d322D30D11aF8363BEB3BdA559FaB9",
      "abi": [
        {
          "name": "FluidDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_RESOLVER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_fluidResolver",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoFluid.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface Erc4626Interface:\n    def redeem(_vaultTokenAmount: uint256, _recipient: address, _owner: address) -> uint256: nonpayable\n    def deposit(_assetAmount: uint256, _recipient: address) -> uint256: nonpayable\n    def convertToAssets(_vaultTokenAmount: uint256) -> uint256: view\n    def convertToShares(_assetAmount: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def asset() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface FluidLendingResolver:\n    def getAllFTokens() -> DynArray[address, MAX_FTOKENS]: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nevent FluidDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent FluidWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent FluidFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent FluidLegoIdSet:\n    legoId: uint256\n\nevent FluidActivated:\n    isActivated: bool\n\n# fluid\nFLUID_RESOLVER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nMAX_FTOKENS: constant(uint256) = 50\n\n\n@deploy\ndef __init__(_fluidResolver: address, _addyRegistry: address):\n    assert empty(address) not in [_fluidResolver, _addyRegistry] # dev: invalid addrs\n    FLUID_RESOLVER = _fluidResolver\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [FLUID_RESOLVER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidFToken(_vaultToken)\n\n\n@view\n@internal\ndef _isValidFToken(_fToken: address) -> bool:\n    fTokens: DynArray[address, MAX_FTOKENS] = staticcall FluidLendingResolver(FLUID_RESOLVER).getAllFTokens()\n    return _fToken in fTokens\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidFToken(_vaultToken):\n        asset = staticcall Erc4626Interface(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall Erc4626Interface(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return 0 # TODO\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    vaultTokenAmountReceived: uint256 = extcall Erc4626Interface(_vault).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log FluidDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    transferVaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert transferVaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, transferVaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    vaultTokenAmount: uint256 = min(transferVaultTokenAmount, staticcall IERC20(_vaultToken).balanceOf(self))\n    assetAmountReceived: uint256 = extcall Erc4626Interface(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log FluidWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log FluidFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log FluidLegoIdSet(legoId=_legoId)\n    return True",
            "sha256sum": "97a987b3bfa25b285d9b17fe337311609c3c515cbd9fa661c55ea6d288bd8f0b"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoFluid.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "f952363f11b268c1c45a1ee0d594b84af5ce0e75b05e206fa4a68055bca9f936"
      },
      "args": "0000000000000000000000003af6fbec4a2fe517f56e402c65e3f4c3e18c1d8600000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "LegoMoonwell": {
      "address": "0xCAacba1b91F4004CCba7d3Ffea0CaAd7E588EEe4",
      "abi": [
        {
          "name": "MoonwellDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_COMPTROLLER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_moonwellComptroller",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoMoonwell.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface CompoundV2:\n    def redeem(_ctokenAmount: uint256) -> uint256: nonpayable\n    def mint(_amount: uint256) -> uint256: nonpayable\n    def exchangeRateStored() -> uint256: view\n    def totalBorrows() -> uint256: view\n    def totalSupply() -> uint256: view\n    def underlying() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface MoonwellComptroller:\n    def getAllMarkets() -> DynArray[address, MAX_MARKETS]: view\n    def claimReward(_holder: address): nonpayable\n    def rewardDistributor() -> address: view\n\ninterface MoonwellRewardDistributor:\n    def getOutstandingRewardsForUser(_user: address) -> DynArray[RewardWithMToken, MAX_MARKETS]: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface WethContract:\n    def deposit(): payable\n\nstruct RewardWithMToken:\n    mToken: address\n    rewards: DynArray[RewardInfo, MAX_ASSETS]\n\nstruct RewardInfo:\n    emissionToken: address\n    totalAmount: uint256\n    supplySide: uint256\n    borrowSide: uint256\n\nevent MoonwellDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MoonwellWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent MoonwellFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent MoonwellLegoIdSet:\n    legoId: uint256\n\nevent MoonwellActivated:\n    isActivated: bool\n\n# moonwell\nMOONWELL_COMPTROLLER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\nWETH: public(immutable(address))\n\nMAX_MARKETS: constant(uint256) = 50\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(_moonwellComptroller: address, _addyRegistry: address, _wethAddr: address):\n    assert empty(address) not in [_moonwellComptroller, _addyRegistry, _wethAddr] # dev: invalid addrs\n    MOONWELL_COMPTROLLER = _moonwellComptroller\n    ADDY_REGISTRY = _addyRegistry\n    WETH = _wethAddr\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n    yld.__init__()\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MOONWELL_COMPTROLLER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidCToken(_vaultToken)\n\n\n@view\n@internal\ndef _isValidCToken(_cToken: address) -> bool:\n    compMarkets: DynArray[address, MAX_MARKETS] = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).getAllMarkets()\n    return _cToken in compMarkets\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidCToken(_vaultToken):\n        asset = staticcall CompoundV2(_vaultToken).underlying()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return _vaultTokenAmount * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return _assetAmount * (10 ** 18) // staticcall CompoundV2(_vaultToken).exchangeRateStored()\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV2(_vaultToken).totalSupply() * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV2(_vaultToken).totalBorrows()\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vault).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    assert extcall CompoundV2(_vault).mint(depositAmount) == 0 # dev: could not deposit into moonwell\n\n    # validate received vault tokens, transfer back to user\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vault).balanceOf(self) - preLegoVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n    assert extcall IERC20(_vault).transfer(_recipient, vaultTokenAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log MoonwellDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assert extcall CompoundV2(_vaultToken).redeem(max_value(uint256)) == 0 # dev: could not withdraw from moonwell\n\n    # when withdrawing weth, they give eth\n    if _asset == WETH:\n        extcall WethContract(WETH).deposit(value=self.balance)\n\n    # validate received asset , transfer back to user\n    assetAmountReceived: uint256 = staticcall IERC20(_asset).balanceOf(self) - preLegoBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n    assert extcall IERC20(_asset).transfer(_recipient, assetAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log MoonwellWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    extcall MoonwellComptroller(MOONWELL_COMPTROLLER).claimReward(_user)\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    rewardDistributor: address = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).rewardDistributor()\n    rewardsWithMToken: DynArray[RewardWithMToken, MAX_MARKETS] = staticcall MoonwellRewardDistributor(rewardDistributor).getOutstandingRewardsForUser(_user)\n    for i: uint256 in range(len(rewardsWithMToken), bound=MAX_MARKETS):\n        rewardsInfo: DynArray[RewardInfo, MAX_ASSETS] = rewardsWithMToken[i].rewards\n        for j: uint256 in range(len(rewardsInfo), bound=MAX_ASSETS):\n            if rewardsInfo[j].totalAmount > 0:\n                return True\n    return False\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid vault and/or asset\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log MoonwellFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log MoonwellLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log MoonwellActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "c80c24755f0555ad98e09a1f0161726382334028102b13b2c24c23dcb4f1d94e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoMoonwell.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "f30d6a9cbdf72b83f10a2b9a6329d764887a437670ddeb39a43ed6283f565a6f"
      },
      "args": "000000000000000000000000fbb21d0380bee3312b33c4353c8936a0f13ef26c00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd0000000000000000000000004200000000000000000000000000000000000006"
    },
    "LegoMorpho": {
      "address": "0x055104Bc79447c94655aABA432D60e0f2ab44cb3",
      "abi": [
        {
          "name": "MorphoDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMorphoRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morphoRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_FACTORY_LEGACY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_morphoFactory",
              "type": "address"
            },
            {
              "name": "_morphoFactoryLegacy",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoMorpho.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface Erc4626Interface:\n    def redeem(_vaultTokenAmount: uint256, _recipient: address, _owner: address) -> uint256: nonpayable\n    def deposit(_assetAmount: uint256, _recipient: address) -> uint256: nonpayable\n    def convertToAssets(_vaultTokenAmount: uint256) -> uint256: view\n    def convertToShares(_assetAmount: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def asset() -> address: view\n\ninterface MorphoRewardsDistributor:\n    def claim(_user: address, _rewardToken: address, _claimable: uint256, _proof: bytes32) -> uint256: nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface MetaMorphoFactory:\n    def isMetaMorpho(_vault: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nevent MorphoDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MorphoWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent MorphoRewardsAddrSet:\n    addr: address\n\nevent MorphoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent MorphoLegoIdSet:\n    legoId: uint256\n\nevent MorphoActivated:\n    isActivated: bool\n\n# morpho\nmorphoRewards: public(address)\nMORPHO_FACTORY: public(immutable(address))\nMORPHO_FACTORY_LEGACY: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\n\n@deploy\ndef __init__(_morphoFactory: address, _morphoFactoryLegacy: address, _addyRegistry: address):\n    assert empty(address) not in [_morphoFactory, _morphoFactoryLegacy, _addyRegistry] # dev: invalid addrs\n    MORPHO_FACTORY = _morphoFactory\n    MORPHO_FACTORY_LEGACY = _morphoFactoryLegacy\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MORPHO_FACTORY, MORPHO_FACTORY_LEGACY]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidMorphoVault(_vaultToken)\n\n\n@view\n@internal\ndef _isValidMorphoVault(_vaultToken: address) -> bool:\n    return staticcall MetaMorphoFactory(MORPHO_FACTORY).isMetaMorpho(_vaultToken) or staticcall MetaMorphoFactory(MORPHO_FACTORY_LEGACY).isMetaMorpho(_vaultToken)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidMorphoVault(_vaultToken):\n        asset = staticcall Erc4626Interface(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall Erc4626Interface(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return 0 # TODO\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    vaultTokenAmountReceived: uint256 = extcall Erc4626Interface(_vault).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log MorphoDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    transferVaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert transferVaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, transferVaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    vaultTokenAmount: uint256 = min(transferVaultTokenAmount, staticcall IERC20(_vaultToken).balanceOf(self))\n    assetAmountReceived: uint256 = extcall Erc4626Interface(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log MorphoWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    morphoRewards: address = self.morphoRewards\n    assert morphoRewards != empty(address) # dev: no morpho rewards addr set\n    extcall MorphoRewardsDistributor(morphoRewards).claim(_user, _rewardToken, _rewardAmount, _proof)\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setMorphoRewardsAddr(_addr: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.morphoRewards = _addr\n    log MorphoRewardsAddrSet(addr=_addr)\n    return True\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log MorphoFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log MorphoLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log MorphoActivated(isActivated=_shouldActivate)",
            "sha256sum": "85b9459c550122cccfa6b917ce3c5d785ecdee9bbc689e239577fa88f7b134e2"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoMorpho.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "097d95c51b87f9d8c2b426962d563bf11808df38412d9142a3470ba3ad7e17ff"
      },
      "args": "000000000000000000000000ff62a7c278c62ed665133147129245053bbf5918000000000000000000000000a9c3d3a366466fa809d1ae982fb2c46e5fc4110100000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "LegoSky": {
      "address": "0x43bd7a38464179d56402341d03bF030BF3140D41",
      "abi": [
        {
          "name": "SkyDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SkyWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SkyFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SkyLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SkyActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "usdc",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "usds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "susds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "SKY_PSM",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_skyPsm",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoSky.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface SkyPsm:\n    def swapExactIn(_assetIn: address, _assetOut: address, _amountIn: uint256, _minAmountOut: uint256, _receiver: address, _referralCode: uint256) -> uint256: nonpayable\n    def convertToAssets(_asset: address, _numShares: uint256) -> uint256: view\n    def convertToShares(_asset: address, _amount: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def susds() -> address: view\n    def usdc() -> address: view\n    def usds() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nevent SkyDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent SkyWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent SkyFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent SkyLegoIdSet:\n    legoId: uint256\n\nevent SkyActivated:\n    isActivated: bool\n\n# sky assets\nusdc: public(address)\nusds: public(address)\nsusds: public(address)\nSKY_PSM: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMIN_SLIPPAGE: constant(uint256) = 2_00 # 2%\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(_skyPsm: address, _addyRegistry: address):\n    assert empty(address) not in [_skyPsm, _addyRegistry] # dev: invalid addrs\n    SKY_PSM = _skyPsm\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n\n    # sky assets\n    usdc: address = staticcall SkyPsm(_skyPsm).usdc()\n    if usdc != empty(address):\n        assert extcall IERC20(usdc).approve(_skyPsm, max_value(uint256), default_return_value=True) # dev: max approval failed\n        self.usdc = usdc\n    usds: address = staticcall SkyPsm(_skyPsm).usds()\n    if usds != empty(address):\n        assert extcall IERC20(usds).approve(_skyPsm, max_value(uint256), default_return_value=True) # dev: max approval failed\n        self.usds = usds\n    susds: address = staticcall SkyPsm(_skyPsm).susds()\n    if susds != empty(address):\n        assert extcall IERC20(susds).approve(_skyPsm, max_value(uint256), default_return_value=True) # dev: max approval failed\n        self.susds = susds\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [SKY_PSM]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# assets and vault tokens\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    if _asset not in [self.usdc, self.usds]:\n        return []\n    return [self.susds]\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    return [self.usdc, self.usds]\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    return _vaultToken == self.susds\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    if not self._isVaultToken(_vaultToken):\n        return empty(address)\n    return self.usds # treating usds as default underlying asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treating usds as default underlying asset\n    return staticcall SkyPsm(SKY_PSM).convertToAssets(self.usds, _vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if _asset not in [self.usdc, self.usds]:\n        return 0 # invalid asset\n    if _vaultToken != self.susds:\n        return 0 # invalid vault token\n    return staticcall SkyPsm(SKY_PSM).convertToShares(_asset, _assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall SkyPsm(SKY_PSM).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return 0\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    assert _asset in [self.usdc, self.usds] # dev: invalid asset\n    vaultToken: address = self.susds\n    if _vault != empty(address):\n        assert vaultToken == _vault # dev: invalid vault\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preRecipientVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # calc min amount out\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    expectedShares: uint256 = staticcall SkyPsm(SKY_PSM).convertToShares(_asset, depositAmount)\n    minAmountOut: uint256 = expectedShares * (HUNDRED_PERCENT - MIN_SLIPPAGE) // HUNDRED_PERCENT\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall SkyPsm(SKY_PSM).swapExactIn(_asset, vaultToken, depositAmount, minAmountOut, _recipient, 0)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log SkyDeposit(sender=msg.sender, asset=_asset, vaultToken=vaultToken, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, vaultToken, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    assert _asset in [self.usdc, self.usds] # dev: invalid asset\n    vaultToken: address = self.susds\n    if _vaultToken != empty(address):\n        assert vaultToken == _vaultToken # dev: invalid vault\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n    preRecipientAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n\n    # transfer vaults tokens to this contract\n    transferVaultTokenAmount: uint256 = min(_amount, staticcall IERC20(vaultToken).balanceOf(msg.sender))\n    assert transferVaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(vaultToken).transferFrom(msg.sender, self, transferVaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # calc min amount out\n    vaultTokenAmount: uint256 = min(transferVaultTokenAmount, staticcall IERC20(vaultToken).balanceOf(self))\n    expectedAssetAmount: uint256 = staticcall SkyPsm(SKY_PSM).convertToAssets(_asset, vaultTokenAmount)\n    minAmountOut: uint256 = expectedAssetAmount * (HUNDRED_PERCENT - MIN_SLIPPAGE) // HUNDRED_PERCENT\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall SkyPsm(SKY_PSM).swapExactIn(vaultToken, _asset, vaultTokenAmount, minAmountOut, _recipient, 0)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log SkyWithdrawal(sender=msg.sender, asset=_asset, vaultToken=vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log SkyFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log SkyLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log SkyActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "166e2db61b122a708742387db5f1a7bdf09a9edcc60c5765cde5e948fb4de791"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoSky.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "1c39a7ee73952df20f435cace48b2030e15227da432b679cb3cc086814a077b5"
      },
      "args": "0000000000000000000000001601843c5e9bc251a3272907010afa41fa18347e00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "LegoAeroClassic": {
      "address": "0xdE426b4f9f6C6ed8D254b6363089597d9eb102A3",
      "abi": [
        {
          "name": "AerodromeSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroClassicCoreRouterPoolSet",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroClassicFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCoreRouterPool",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_ROUTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_aerodromeFactory",
              "type": "address"
            },
            {
              "name": "_aerodromeRouter",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/dexes/LegoAeroClassic.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoDex\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom interfaces import LegoDex\nfrom interfaces import LegoCommon\n\ninterface AeroRouter:\n    def addLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _amountADesired: uint256, _amountBDesired: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _lpAmount: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256): nonpayable\n    def swapExactTokensForTokens(_amountIn: uint256, _amountOutMin: uint256, _path: DynArray[Route, MAX_SWAP_HOPS + 2], _to: address, _deadline: uint256) -> DynArray[uint256, MAX_SWAP_HOPS + 2]: nonpayable \n    def quoteAddLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _factory: address, _amountADesired: uint256, _amountBDesired: uint256) -> (uint256, uint256, uint256): view\n    def quoteRemoveLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _factory: address, _liquidity: uint256) -> (uint256, uint256): view\n\ninterface AeroClassicPool:\n    def swap(_amount0Out: uint256, _amount1Out: uint256, _recipient: address, _data: Bytes[256]): nonpayable\n    def getAmountOut(_amountIn: uint256, _tokenIn: address) -> uint256: view\n    def getReserves() -> (uint256, uint256, uint256): view\n    def tokens() -> (address, address): view\n    def stable() -> bool: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n\ninterface AeroFactory:\n    def getPool(_tokenA: address, _tokenB: address, _isStable: bool) -> address: view\n    def getFee(_pool: address, _isStable: bool) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n    legoId: uint256\n\nstruct Route:\n    from_: address\n    to: address \n    stable: bool\n    factory: address\n\nevent AerodromeSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent AerodromeLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AerodromeLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroClassicCoreRouterPoolSet:\n    pool: indexed(address)\n\nevent AeroClassicFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent AerodromeLegoIdSet:\n    legoId: uint256\n\nevent AerodromeActivated:\n    isActivated: bool\n\n# aero\ncoreRouterPool: public(address)\nAERODROME_FACTORY: public(immutable(address))\nAERODROME_ROUTER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nMAX_SWAP_HOPS: constant(uint256) = 5\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _aerodromeFactory: address,\n    _aerodromeRouter: address,\n    _addyRegistry: address,\n    _coreRouterPool: address,\n):\n    assert empty(address) not in [_aerodromeFactory, _aerodromeRouter, _addyRegistry, _coreRouterPool] # dev: invalid addrs\n    AERODROME_FACTORY = _aerodromeFactory\n    AERODROME_ROUTER = _aerodromeRouter\n    ADDY_REGISTRY = _addyRegistry\n    self.coreRouterPool = _coreRouterPool\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AERODROME_FACTORY, AERODROME_ROUTER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n########\n# Swap #\n########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    initialAmountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert initialAmountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, initialAmountIn, default_return_value=True) # dev: transfer failed\n    initialAmountIn = min(initialAmountIn, staticcall IERC20(tokenIn).balanceOf(self))\n\n    # transfer initial amount to first pool\n    assert extcall IERC20(tokenIn).transfer(_poolPath[0], initialAmountIn, default_return_value=True) # dev: transfer failed\n\n    aeroFactory: address = AERODROME_FACTORY\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = initialAmountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to next pool (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = _poolPath[i + 1]\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, aeroFactory)\n\n    # final amount\n    toAmount: uint256 = tempAmountIn\n    assert toAmount >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        initialAmountIn -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(tokenIn, initialAmountIn, tokenOut, toAmount, True, _oracleRegistry)\n    log AerodromeSwap(sender=msg.sender, tokenIn=tokenIn, tokenOut=tokenOut, amountIn=initialAmountIn, amountOut=toAmount, usdValue=usdValue, numTokens=numTokens, recipient=_recipient)\n    return initialAmountIn, toAmount, refundAssetAmount, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _aeroFactory: address,\n) -> uint256:\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual aerodrome pool\n    assert staticcall AeroFactory(_aeroFactory).getPool(_tokenIn, _tokenOut, staticcall AeroClassicPool(_pool).stable()) == _pool # dev: invalid pool\n\n    zeroForOne: bool = _tokenIn == token0\n    amountOut: uint256 = staticcall AeroClassicPool(_pool).getAmountOut(_amountIn, _tokenIn)\n    assert amountOut != 0 # dev: no tokens swapped\n\n    # put in correct order\n    amount0Out: uint256 = amountOut\n    amount1Out: uint256 = 0\n    if zeroForOne:\n        amount0Out = 0\n        amount1Out = amountOut\n\n    extcall AeroClassicPool(_pool).swap(amount0Out, amount1Out, _recipient, b\"\")\n    return amountOut\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    transferAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert transferAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, transferAmountA, default_return_value=True) # dev: transfer failed\n    liqAmountA: uint256 = min(transferAmountA, staticcall IERC20(_tokenA).balanceOf(self))\n\n    # token b\n    transferAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert transferAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, transferAmountB, default_return_value=True) # dev: transfer failed\n    liqAmountB: uint256 = min(transferAmountB, staticcall IERC20(_tokenB).balanceOf(self))\n\n    # approvals\n    router: address = AERODROME_ROUTER\n    assert extcall IERC20(_tokenA).approve(router, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    liqAmountA, liqAmountB, lpAmountReceived = extcall AeroRouter(router).addLiquidity(\n        _tokenA,\n        _tokenB,\n        staticcall AeroClassicPool(_pool).stable(),\n        liqAmountA,\n        liqAmountB,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert lpAmountReceived != 0 # dev: no liquidity added\n    if _minLpAmount != 0:\n        assert lpAmountReceived >= _minLpAmount # dev: insufficient liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(router, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, False, _oracleRegistry)\n    log AerodromeLiquidityAdded(sender=msg.sender, tokenA=_tokenA, tokenB=_tokenB, amountA=liqAmountA, amountB=liqAmountB, lpAmountReceived=lpAmountReceived, usdValue=usdValue, recipient=_recipient)\n    return lpAmountReceived, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, 0\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token\n    transferAmount: uint256 = min(_liqToRemove, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n    lpAmount: uint256 = min(transferAmount, staticcall IERC20(_lpToken).balanceOf(self))\n\n    # approvals\n    router: address = AERODROME_ROUTER\n    assert extcall IERC20(_lpToken).approve(router, lpAmount, default_return_value=True) # dev: approval failed\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = extcall AeroRouter(router).removeLiquidity(\n        _tokenA,\n        _tokenB,\n        staticcall AeroClassicPool(_pool).stable(),\n        lpAmount,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert amountA != 0 # dev: no amountA removed\n    assert amountB != 0 # dev: no amountB removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, False, _oracleRegistry)\n    log AerodromeLiquidityRemoved(sender=msg.sender, pool=_pool, tokenA=_tokenA, tokenB=_tokenB, amountA=amountA, amountB=amountB, lpToken=_lpToken, lpAmountBurned=lpAmount, usdValue=usdValue, recipient=_recipient)\n    return amountA, amountB, usdValue, lpAmount, refundedLpAmount, refundedLpAmount != 0\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # in uniswap v2, the lp token is the pool address\n    return _pool\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # in uniswap v2, the pool is the lp token address\n    return _lpToken\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    factory: address = AERODROME_FACTORY\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n\n    # get pool options\n    stablePool: address = staticcall AeroFactory(factory).getPool(_tokenA, _tokenB, True)\n    volatilePool: address = staticcall AeroFactory(factory).getPool(_tokenA, _tokenB, False)\n\n    # no pools found\n    if stablePool == empty(address) and volatilePool == empty(address):\n        return empty(BestPool)\n\n    # stable pool\n    stableLiquidity: uint256 = 0\n    if stablePool != empty(address):\n        reserve0, reserve1, na = staticcall AeroClassicPool(stablePool).getReserves()\n        stableLiquidity = reserve0 + reserve1\n\n    # volatile pool\n    volatileLiquidity: uint256 = 0\n    if volatilePool != empty(address):\n        reserve0, reserve1, na = staticcall AeroClassicPool(volatilePool).getReserves()\n        volatileLiquidity = reserve0 + reserve1\n\n    # best pool determined by liquidity\n    bestPoolAddr: address = stablePool\n    bestLiquidity: uint256 = stableLiquidity\n    isStable: bool = True\n    if volatileLiquidity > stableLiquidity:\n        bestPoolAddr = volatilePool\n        bestLiquidity = volatileLiquidity\n        isStable = False\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=staticcall AeroFactory(factory).getFee(bestPoolAddr, isStable),\n        liquidity=bestLiquidity,\n        numCoins=2,\n        legoId=self.legoId,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    factory: address = AERODROME_FACTORY\n    stablePool: address = staticcall AeroFactory(factory).getPool(_tokenIn, _tokenOut, True)\n    volatilePool: address = staticcall AeroFactory(factory).getPool(_tokenIn, _tokenOut, False)\n    if stablePool == empty(address) and volatilePool == empty(address):\n        return empty(address), 0\n\n    # stable pool\n    stableAmountOut: uint256 = 0\n    if stablePool != empty(address):\n        stableAmountOut = staticcall AeroClassicPool(stablePool).getAmountOut(_amountIn, _tokenIn)\n\n    # volatile pool\n    volatileAmountOut: uint256 = 0\n    if volatilePool != empty(address):\n        volatileAmountOut = staticcall AeroClassicPool(volatilePool).getAmountOut(_amountIn, _tokenIn)\n\n    if stableAmountOut == 0 and volatileAmountOut == 0:\n        return empty(address), 0\n\n    pool: address = stablePool\n    amountOut: uint256 = stableAmountOut\n    if volatileAmountOut > stableAmountOut:\n        pool = volatilePool\n        amountOut = volatileAmountOut\n\n    return pool, amountOut\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    return staticcall AeroClassicPool(_pool).getAmountOut(_amountIn, _tokenIn)\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    # TODO: implement stable pools\n    pool: address = staticcall AeroFactory(AERODROME_FACTORY).getPool(_tokenIn, _tokenOut, False)\n    if pool == empty(address):\n        return empty(address), max_value(uint256)\n\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(pool).tokens()\n    return pool, self._getAmountInForVolatilePools(pool, token0 == _tokenIn, _amountOut)\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if not staticcall AeroClassicPool(_pool).stable():\n        token0: address = empty(address)\n        token1: address = empty(address)\n        token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n        return self._getAmountInForVolatilePools(_pool, token0 == _tokenIn, _amountOut)\n    else:\n        return max_value(uint256) # TODO: implement stable pools\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    return staticcall AeroRouter(AERODROME_ROUTER).quoteAddLiquidity(_tokenA, _tokenB, staticcall AeroClassicPool(_pool).stable(), AERODROME_FACTORY, _availAmountA, _availAmountB)\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    return staticcall AeroRouter(AERODROME_ROUTER).quoteRemoveLiquidity(_tokenA, _tokenB, staticcall AeroClassicPool(_pool).stable(), AERODROME_FACTORY, _lpAmount)\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    if not staticcall AeroClassicPool(_pool).stable():\n        return self._getPriceUnsafeVolatilePool(_pool, _targetToken, _oracleRegistry)\n    else:\n        return 0 # TODO: implement stable pools\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _isSwap: bool,\n    _oracleRegistry: address,\n) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    usdValueA: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenA, _amountA)\n    usdValueB: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenB, _amountB)\n    if _isSwap:\n        return max(usdValueA, usdValueB)\n    else:\n        return usdValueA + usdValueB\n\n\n@view\n@internal\ndef _getPriceUnsafeVolatilePool(_pool: address, _targetToken: address, _oracleRegistry: address) -> uint256:\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    # oracle registry\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token1, False)\n    else:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token0, False)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # reserves\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n    reserve0, reserve1, na = staticcall AeroClassicPool(_pool).getReserves()\n\n    # avoid division by zero\n    if reserve0 == 0 or reserve1 == 0:\n        return 0  \n\n    # price of token0 in token1\n    priceZeroToOne: uint256 = reserve1 * EIGHTEEN_DECIMALS // reserve0\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n@view\n@internal\ndef _getAmountInForVolatilePools(_pool: address, _zeroForOne: bool, _amountOut: uint256) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n    reserve0, reserve1, na = staticcall AeroClassicPool(_pool).getReserves()\n    if reserve0 == 0 or reserve1 == 0:\n        return max_value(uint256)\n\n    # determine which token is which\n    reserveIn: uint256 = reserve0\n    reserveOut: uint256 = reserve1\n    if not _zeroForOne:\n        reserveIn = reserve1\n        reserveOut = reserve0\n\n    if _amountOut > reserveOut:\n        return max_value(uint256)\n\n    fee: uint256 = staticcall AeroFactory(AERODROME_FACTORY).getFee(_pool, False)\n    numerator: uint256 = reserveIn * _amountOut * 100_00\n    denominator: uint256 = (reserveOut - _amountOut) * (100_00 - fee)\n    return (numerator // denominator) + 1\n\n\n####################\n# Core Router Pool #\n####################\n\n\n@external\ndef setCoreRouterPool(_addr: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.coreRouterPool = _addr\n    log AeroClassicCoreRouterPoolSet(pool=_addr)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AeroClassicFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log AerodromeLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log AerodromeActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "20cce152f70d0875d3fde8fba33da8643c073a0ea19c1fab4a3736931f2ee830"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/LegoAeroClassic.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "3eee96eb4a2287fbbd8d114b071ef07b3b658e73fd966c5f6518fd27bd9113ea"
      },
      "args": "000000000000000000000000420dd381b31aef6683db6b902084cb0ffece40da000000000000000000000000cf77a3ba9a5ca399b7c97c74d54e5b1beb874e4300000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd000000000000000000000000cdac0d6c6c59727a65f871236188350531885c43"
    },
    "LegoAeroSlipstream": {
      "address": "0xD6A7aDdB5bCF306e9D5C0d431103C5641576bB90",
      "abi": [
        {
          "name": "AeroSlipStreamSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamCoreRouterPoolSet",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamNftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "uniswapV3SwapCallback",
          "inputs": [
            {
              "name": "_amount0Delta",
              "type": "int256"
            },
            {
              "name": "_amount1Delta",
              "type": "int256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCoreRouterPool",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_NFT_MANAGER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_QUOTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_aeroFactory",
              "type": "address"
            },
            {
              "name": "_aeroNftPositionManager",
              "type": "address"
            },
            {
              "name": "_aeroQuoter",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/dexes/LegoAeroSlipstream.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: IUniswapV3Callback\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC721\nfrom ethereum.ercs import IERC20Detailed\nfrom interfaces import LegoCommon\n\n# `getSwapAmountOut()` and `getSwapAmountIn()` cannot be view functions, sadly\n# keeping here to uncomment to test all other functions\n# implements: LegoDex\n# from interfaces import LegoDex\n\ninterface AeroSlipStreamPool:\n    def swap(_recipient: address, _zeroForOne: bool, _amountSpecified: int256, _sqrtPriceLimitX96: uint160, _data: Bytes[256]) -> (int256, int256): nonpayable\n    def slot0() -> (uint160, int24, uint16, uint16, uint16, bool): view\n    def tickSpacing() -> int24: view\n    def liquidity() -> uint128: view\n    def token0() -> address: view\n    def token1() -> address: view\n    def fee() -> uint24: view\n\ninterface AeroNftPositionManager:\n    def increaseLiquidity(_params: IncreaseLiquidityParams) -> (uint128, uint256, uint256): nonpayable\n    def decreaseLiquidity(_params: DecreaseLiquidityParams) -> (uint256, uint256): nonpayable\n    def mint(_params: MintParams) -> (uint256, uint128, uint256, uint256): nonpayable\n    def collect(_params: CollectParams) -> (uint256, uint256): nonpayable\n    def positions(_tokenId: uint256) -> PositionData: view\n    def burn(_tokenId: uint256): nonpayable\n\ninterface AeroQuoter:\n    def quoteExactOutputSingle(_params: QuoteExactOutputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInputSingle(_params: QuoteExactInputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n\ninterface IUniswapV3Callback:\n    def uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]): nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n\ninterface AeroSlipStreamFactory:\n    def getPool(_tokenA: address, _tokenB: address, _tickSpacing: int24) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct PoolSwapData:\n    pool: address\n    tokenIn: address\n    amountIn: uint256\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n    legoId: uint256\n\nstruct QuoteExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    tickSpacing: int24\n    sqrtPriceLimitX96: uint160\n\nstruct QuoteExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amount: uint256\n    tickSpacing: int24\n    sqrtPriceLimitX96: uint160\n\nstruct MintParams:\n    token0: address\n    token1: address\n    tickSpacing: int24\n    tickLower: int24\n    tickUpper: int24\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    recipient: address\n    deadline: uint256\n    sqrtPriceX96: uint160\n\nstruct IncreaseLiquidityParams:\n    tokenId: uint256\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct DecreaseLiquidityParams:\n    tokenId: uint256\n    liquidity: uint128\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct CollectParams:\n    tokenId: uint256\n    recipient: address\n    amount0Max: uint128\n    amount1Max: uint128\n\nstruct PositionData:\n    nonce: uint96\n    operator: address\n    token0: address\n    token1: address\n    tickSpacing: uint24\n    tickLower: int24\n    tickUpper: int24\n    liquidity: uint128\n    feeGrowthInside0LastX128: uint256\n    feeGrowthInside1LastX128: uint256\n    tokensOwed0: uint128\n    tokensOwed1: uint128\n\nevent AeroSlipStreamSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent AeroSlipStreamLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityAdded: uint256\n    nftTokenId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroSlipStreamLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    nftTokenId: uint256\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityRemoved: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroSlipStreamCoreRouterPoolSet:\n    pool: indexed(address)\n\nevent AeroSlipStreamFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent AeroSlipStreamNftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\nevent AeroSlipStreamLegoIdSet:\n    legoId: uint256\n\nevent AeroSlipStreamActivated:\n    isActivated: bool\n\n# aero\ncoreRouterPool: public(address)\nAERO_SLIPSTREAM_FACTORY: public(immutable(address))\nAERO_SLIPSTREAM_NFT_MANAGER: public(immutable(address))\nAERO_SLIPSTREAM_QUOTER: public(immutable(address))\n\n# transient\npoolSwapData: transient(PoolSwapData)\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nTICK_SPACING: constant(int24[5]) = [1, 50, 100, 200, 2000]\nMIN_SQRT_RATIO_PLUS_ONE: constant(uint160) = 4295128740\nMAX_SQRT_RATIO_MINUS_ONE: constant(uint160) = 1461446703485210103287273052203988822378723970341\nTICK_LOWER: constant(int24) = -887272\nTICK_UPPER: constant(int24) = 887272\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UnderscoreErc721\"\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nUNISWAP_Q96: constant(uint256) = 2 ** 96  # uniswap's fixed point scaling factor\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _aeroFactory: address,\n    _aeroNftPositionManager: address,\n    _aeroQuoter: address,\n    _addyRegistry: address,\n    _coreRouterPool: address,\n):\n    assert empty(address) not in [_aeroFactory, _aeroNftPositionManager, _aeroQuoter, _addyRegistry, _coreRouterPool] # dev: invalid addrs\n    AERO_SLIPSTREAM_FACTORY = _aeroFactory\n    AERO_SLIPSTREAM_NFT_MANAGER = _aeroNftPositionManager\n    AERO_SLIPSTREAM_QUOTER = _aeroQuoter\n    ADDY_REGISTRY = _addyRegistry\n    self.coreRouterPool = _coreRouterPool\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    assert _data == ERC721_RECEIVE_DATA # dev: did not receive from within Underscore wallet\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AERO_SLIPSTREAM_FACTORY, AERO_SLIPSTREAM_NFT_MANAGER, AERO_SLIPSTREAM_QUOTER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n########\n# Swap #\n########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    initialAmountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert initialAmountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, initialAmountIn, default_return_value=True) # dev: transfer failed\n    initialAmountIn = min(initialAmountIn, staticcall IERC20(tokenIn).balanceOf(self))\n\n    aeroFactory: address = AERO_SLIPSTREAM_FACTORY\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = initialAmountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, aeroFactory)\n\n    # final amount\n    toAmount: uint256 = tempAmountIn\n    assert toAmount >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        initialAmountIn -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(tokenIn, initialAmountIn, tokenOut, toAmount, True, _oracleRegistry)\n    log AeroSlipStreamSwap(sender=msg.sender, tokenIn=tokenIn, tokenOut=tokenOut, amountIn=initialAmountIn, amountOut=toAmount, usdValue=usdValue, numTokens=numTokens, recipient=_recipient)\n    return initialAmountIn, toAmount, refundAssetAmount, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _aeroFactory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall AeroSlipStreamPool(_pool).token0(), staticcall AeroSlipStreamPool(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual aero pool\n    assert staticcall AeroSlipStreamFactory(_aeroFactory).getPool(_tokenIn, _tokenOut, staticcall AeroSlipStreamPool(_pool).tickSpacing()) == _pool # dev: invalid pool\n\n    # save in transient storage (for use in callback)\n    self.poolSwapData = PoolSwapData(\n        pool=_pool,\n        tokenIn=_tokenIn,\n        amountIn=_amountIn,\n    )\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    sqrtPriceLimitX96: uint160 = MAX_SQRT_RATIO_MINUS_ONE\n    if zeroForOne:\n        sqrtPriceLimitX96 = MIN_SQRT_RATIO_PLUS_ONE\n\n    # perform swap\n    amount0: int256 = 0\n    amount1: int256 = 0\n    amount0, amount1 = extcall AeroSlipStreamPool(_pool).swap(_recipient, zeroForOne, convert(_amountIn, int256), sqrtPriceLimitX96, b\"\")\n\n    # check swap results\n    toAmount: uint256 = 0\n    if zeroForOne:\n        toAmount = convert(-amount1, uint256)\n    else:\n        toAmount = convert(-amount0, uint256)\n\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n# callback\n\n\n@external\ndef uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]):\n    poolSwapData: PoolSwapData = self.poolSwapData\n    assert msg.sender == poolSwapData.pool # dev: no perms\n\n    # transfer tokens to pool\n    assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.pool, poolSwapData.amountIn, default_return_value=True) # dev: transfer failed\n    self.poolSwapData = empty(PoolSwapData)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    tokens: address[2] = [staticcall AeroSlipStreamPool(_pool).token0(), staticcall AeroSlipStreamPool(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    transferAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert transferAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, transferAmountA, default_return_value=True) # dev: transfer failed\n    liqAmountA: uint256 = min(transferAmountA, staticcall IERC20(_tokenA).balanceOf(self))\n\n    # token b\n    transferAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert transferAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, transferAmountB, default_return_value=True) # dev: transfer failed\n    liqAmountB: uint256 = min(transferAmountB, staticcall IERC20(_tokenB).balanceOf(self))\n\n    # approvals\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # organized the index of tokens\n    token0: address = _tokenA\n    token1: address = _tokenB\n    amount0: uint256 = liqAmountA\n    amount1: uint256 = liqAmountB\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if tokens[0] != _tokenA:\n        token0 = _tokenB\n        token1 = _tokenA\n        amount0 = liqAmountB\n        amount1 = liqAmountA\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # add liquidity\n    nftTokenId: uint256 = _nftTokenId\n    liquidityAdded: uint256 = 0\n    liquidityAddedInt128: uint128 = 0\n    if _nftTokenId == 0:\n        nftTokenId, liquidityAddedInt128, amount0, amount1 = self._mintNewPosition(nftPositionManager, _pool, token0, token1, _tickLower, _tickUpper, amount0, amount1, minAmount0, minAmount1, _recipient)\n    else:\n        liquidityAddedInt128, amount0, amount1 = self._increaseExistingPosition(nftPositionManager, _nftTokenId, amount0, amount1, minAmount0, minAmount1, _recipient)\n\n    liquidityAdded = convert(liquidityAddedInt128, uint256)\n    assert liquidityAdded != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    # a/b amounts\n    liqAmountA = amount0\n    liqAmountB = amount1\n    if tokens[0] != _tokenA:\n        liqAmountA = amount1\n        liqAmountB = amount0\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, False, _oracleRegistry)\n    log AeroSlipStreamLiquidityAdded(sender=msg.sender, tokenA=_tokenA, tokenB=_tokenB, amountA=liqAmountA, amountB=liqAmountB, liquidityAdded=liquidityAdded, nftTokenId=nftTokenId, usdValue=usdValue, recipient=_recipient)\n    return liquidityAdded, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, nftTokenId\n\n\n@internal\ndef _mintNewPosition(\n    _nftPositionManager: address,\n    _pool: address,\n    _token0: address,\n    _token1: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint256, uint128, uint256, uint256):\n    tickSpacing: int24 = staticcall AeroSlipStreamPool(_pool).tickSpacing()\n\n    tickLower: int24 = 0\n    tickUpper: int24 = 0\n    tickLower, tickUpper = self._getTicks(tickSpacing, _tickLower, _tickUpper)\n\n    # mint new position\n    params: MintParams = MintParams(\n        token0=_token0,\n        token1=_token1,\n        tickSpacing=tickSpacing,\n        tickLower=tickLower,\n        tickUpper=tickUpper,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        recipient=_recipient,\n        deadline=block.timestamp,\n        sqrtPriceX96=0,\n    )\n    return extcall AeroNftPositionManager(_nftPositionManager).mint(params)\n\n\n@view\n@internal\ndef _getTicks(_tickSpacing: int24, _tickLower: int24, _tickUpper: int24) -> (int24, int24):\n    tickLower: int24 = _tickLower\n    if _tickLower == min_value(int24):\n        tickLower = (TICK_LOWER // _tickSpacing) * _tickSpacing\n\n    tickUpper: int24 = _tickUpper\n    if _tickUpper == max_value(int24):\n        tickUpper = (TICK_UPPER // _tickSpacing) * _tickSpacing\n\n    return tickLower, tickUpper\n\n\n@internal\ndef _increaseExistingPosition(\n    _nftPositionManager: address,\n    _tokenId: uint256,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint128, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_tokenId) == self # dev: nft not here\n\n    liquidityAddedInt128: uint128 = 0\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    params: IncreaseLiquidityParams = IncreaseLiquidityParams(\n        tokenId=_tokenId,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        deadline=block.timestamp,\n    )\n    liquidityAddedInt128, amount0, amount1 = extcall AeroNftPositionManager(_nftPositionManager).increaseLiquidity(params)\n\n    # collect fees (if applicable) -- must be done before transferring nft\n    positionData: PositionData = staticcall AeroNftPositionManager(_nftPositionManager).positions(_tokenId)\n    self._collectFees(_nftPositionManager, _tokenId, _recipient, positionData)\n\n    # transfer nft to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _tokenId)\n\n    return liquidityAddedInt128, amount0, amount1\n\n\n@internal\ndef _collectFees(_nftPositionManager: address, _tokenId: uint256, _recipient: address, _positionData: PositionData) -> (uint256, uint256):\n    if _positionData.tokensOwed0 == 0 and _positionData.tokensOwed1 == 0:\n        return 0, 0\n\n    params: CollectParams = CollectParams(\n        tokenId=_tokenId,\n        recipient=_recipient,\n        amount0Max=max_value(uint128),\n        amount1Max=max_value(uint128),\n    )\n    return extcall AeroNftPositionManager(_nftPositionManager).collect(params)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    assert self.isActivated # dev: not activated\n\n    # make sure nft is here\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n    originalLiquidity: uint128 = positionData.liquidity\n\n    # validate tokens\n    tokens: address[2] = [positionData.token0, positionData.token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # organized the index of tokens\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if _tokenA != tokens[0]:\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # decrease liquidity\n    liqToRemove: uint256 = min(_liqToRemove, convert(positionData.liquidity, uint256))\n    assert liqToRemove != 0 # dev: no liquidity to remove\n\n    params: DecreaseLiquidityParams = DecreaseLiquidityParams(\n        tokenId=_nftTokenId,\n        liquidity=convert(liqToRemove, uint128),\n        amount0Min=minAmount0,\n        amount1Min=minAmount1,\n        deadline=block.timestamp,\n    )\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = extcall AeroNftPositionManager(nftPositionManager).decreaseLiquidity(params)\n    assert amount0 != 0 and amount1 != 0 # dev: no liquidity removed\n\n    # a/b amounts\n    amountA: uint256 = amount0\n    amountB: uint256 = amount1\n    if _tokenA != tokens[0]:\n        amountA = amount1\n        amountB = amount0\n\n    # get latest position data -- collect withdrawn tokens AND any fees (if applicable)\n    positionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n    self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # burn nft (if applicable)\n    isDepleted: bool = False\n    if positionData.liquidity == 0:\n        isDepleted = True\n        extcall AeroNftPositionManager(nftPositionManager).burn(_nftTokenId)\n\n    # transfer nft to recipient\n    else:\n        extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, False, _oracleRegistry)\n    liquidityRemoved: uint256 = convert(originalLiquidity - positionData.liquidity, uint256)\n    log AeroSlipStreamLiquidityRemoved(sender=msg.sender, pool=_pool, nftTokenId=_nftTokenId, tokenA=_tokenA, tokenB=_tokenB, amountA=amountA, amountB=amountB, liquidityRemoved=liquidityRemoved, usdValue=usdValue, recipient=_recipient)\n    return amountA, amountB, usdValue, liquidityRemoved, 0, isDepleted\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # no lp tokens for aero slipstream (uni v3)\n    return empty(address)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # no lp tokens for aero slipstream (uni v3)\n    return empty(address)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    bestPoolAddr: address = empty(address)\n    na: int24 = 0\n    bestPoolAddr, na = self._getDeepestLiqPool(_tokenA, _tokenB)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    # get token balances\n    tokenABal: uint256 = staticcall IERC20(_tokenA).balanceOf(bestPoolAddr)\n    tokenBBal: uint256 = staticcall IERC20(_tokenB).balanceOf(bestPoolAddr)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=convert(staticcall AeroSlipStreamPool(bestPoolAddr).fee() // 100, uint256), # normalize to have 100_00 denominator\n        liquidity=tokenABal + tokenBBal, # not exactly \"liquidity\" but this comparable to \"reserves\"\n        numCoins=2,\n        legoId=self.legoId,\n    )\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestPoolAddr, bestTickSpacing = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            tickSpacing=bestTickSpacing,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            tickSpacing=staticcall AeroSlipStreamPool(_pool).tickSpacing(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestPoolAddr, bestTickSpacing = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            tickSpacing=bestTickSpacing,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountIn\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            tickSpacing=staticcall AeroSlipStreamPool(_pool).tickSpacing(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountIn\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n\n    # get correct numerator and denominator\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    sqrtPriceX96Squared: uint256 = self._getSqrtPriceX96(_pool) ** 2\n    if _tokenA == token0:\n        numerator = sqrtPriceX96Squared\n        denominator = UNISWAP_Q96 ** 2\n    else:\n        numerator = UNISWAP_Q96 ** 2\n        denominator = sqrtPriceX96Squared\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = _availAmountA * numerator // denominator\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = _availAmountB * denominator // numerator\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n\n    # calculate expected amounts out\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    amount0Out: uint256 = _lpAmount * UNISWAP_Q96 // sqrtPriceX96\n    amount1Out: uint256 = _lpAmount * sqrtPriceX96 // UNISWAP_Q96\n\n    # return amounts out\n    if _tokenA == token0:\n        return amount0Out, amount1Out\n    else:\n        return amount1Out, amount0Out\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n    token1: address = staticcall AeroSlipStreamPool(_pool).token1()\n\n    # oracle registry\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token1, False)\n    else:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token0, False)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # price of token0 in token1\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    numerator: uint256 = sqrtPriceX96 ** 2 * EIGHTEEN_DECIMALS\n    priceZeroToOne: uint256 = numerator // (UNISWAP_Q96 ** 2)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address) -> (address, int24):\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestLiquidity: uint128 = 0\n\n    factory: address = AERO_SLIPSTREAM_FACTORY\n    for i: uint256 in range(5):\n        tickSpacing: int24 = TICK_SPACING[i]\n        pool: address = staticcall AeroSlipStreamFactory(factory).getPool(_tokenA, _tokenB, tickSpacing)\n        if pool == empty(address):\n            continue\n        liquidity: uint128 = staticcall AeroSlipStreamPool(pool).liquidity()\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestTickSpacing = tickSpacing\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestTickSpacing\n\n\n@view\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _isSwap: bool,\n    _oracleRegistry: address,\n) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    usdValueA: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenA, _amountA)\n    usdValueB: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenB, _amountB)\n    if _isSwap:\n        return max(usdValueA, usdValueB)\n    else:\n        return usdValueA + usdValueB\n\n\n@view\n@internal\ndef _getSqrtPriceX96(_pool: address) -> uint256:\n    sqrtPriceX96: uint160 = 0\n    tick: int24 = 0\n    observationIndex: uint16 = 0\n    observationCardinality: uint16 = 0\n    observationCardinalityNext: uint16 = 0\n    unlocked: bool = False\n    sqrtPriceX96, tick, observationIndex, observationCardinality, observationCardinalityNext, unlocked = staticcall AeroSlipStreamPool(_pool).slot0()\n    return convert(sqrtPriceX96, uint256)\n\n\n####################\n# Core Router Pool #\n####################\n\n\n@external\ndef setCoreRouterPool(_addr: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.coreRouterPool = _addr\n    log AeroSlipStreamCoreRouterPoolSet(pool=_addr)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AeroSlipStreamFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log AeroSlipStreamNftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log AeroSlipStreamLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log AeroSlipStreamActivated(isActivated=_shouldActivate)",
            "sha256sum": "29517b7ec02a12ac366659cd108220f5f0d2c93daf8496f6a3df1c4951d2272e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/LegoAeroSlipstream.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "a77b4b58c6367b1050cfed7c05c5eadc8769b9f761a733d765db19be69c4a578"
      },
      "args": "0000000000000000000000005e7bb104d84c7cb9b682aac2f3d509f5f406809a000000000000000000000000827922686190790b37229fd06084350e74485b72000000000000000000000000254cf9e1e6e233aa1ac962cb9b05b2cfeaae15b000000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd000000000000000000000000b2cc224c1c9fee385f8ad6a55b4d94e92359dc59"
    },
    "LegoCurve": {
      "address": "0xEA11B89c506a1B4b2D214643d4019BBc64B92958",
      "abi": [
        {
          "name": "CurveSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_META_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_REGISTRIES",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "StableSwapNg",
                  "type": "address"
                },
                {
                  "name": "TwoCryptoNg",
                  "type": "address"
                },
                {
                  "name": "TricryptoNg",
                  "type": "address"
                },
                {
                  "name": "TwoCrypto",
                  "type": "address"
                },
                {
                  "name": "MetaPool",
                  "type": "address"
                },
                {
                  "name": "RateProvider",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_curveAddressProvider",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/dexes/LegoCurve.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n# pragma optimize codesize\n\nimplements: LegoDex\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom interfaces import LegoDex\nfrom interfaces import LegoCommon\n\ninterface CurveMetaRegistry:\n    def get_coin_indices(_pool: address, _from: address, _to: address) -> (int128, int128, bool): view\n    def find_pools_for_coins(_from: address, _to: address) -> DynArray[address, MAX_POOLS]: view\n    def get_registry_handlers_from_pool(_pool: address) -> address[10]: view\n    def get_pool_from_lp_token(_lpToken: address) -> address: view\n    def get_base_registry(_addr: address) -> address: view\n    def get_balances(_pool: address) -> uint256[8]: view\n    def get_coins(_pool: address) -> address[8]: view\n    def get_n_coins(_pool: address) -> uint256: view\n    def get_lp_token(_pool: address) -> address: view\n    def is_registered(_pool: address) -> bool: view\n    def is_meta(_pool: address) -> bool: view\n\ninterface TwoCryptoPool:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: nonpayable\n    def exchange(_i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool = False, _receiver: address = msg.sender) -> uint256: payable\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _useEth: bool = False, _recipient: address = msg.sender): nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: payable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[2]) -> uint256: view\n\ninterface TwoCryptoNgPool:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _recipient: address = msg.sender) -> uint256[2]: nonpayable\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, receiver: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[2], _isDeposit: bool) -> uint256: view\n\ninterface StableNgTwo:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: DynArray[uint256, 2], _recipient: address = msg.sender, _claimAdminFees: bool = True) -> DynArray[uint256, 2]: nonpayable\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: int128, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: DynArray[uint256, 2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 2], _isDeposit: bool) -> uint256: view\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: int128) -> uint256: view\n\ninterface TriCryptoPool:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[3], _useEth: bool = False, _recipient: address = msg.sender, _claimAdminFees: bool = True) -> uint256[3]: nonpayable\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: uint256[3], _minLpAmount: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: payable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[3], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolTwo:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _recipient: address = msg.sender) -> uint256[2]: nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[2], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolThree:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[3], _recipient: address = msg.sender) -> uint256[3]: nonpayable\n    def add_liquidity(_amounts: uint256[3], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[3], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolFour:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[4], _recipient: address = msg.sender) -> uint256[4]: nonpayable\n    def add_liquidity(_amounts: uint256[4], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[4], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolCommon:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: int128, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: int128) -> uint256: view\n\ninterface StableNgThree:\n    def add_liquidity(_amounts: DynArray[uint256, 3], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 3], _isDeposit: bool) -> uint256: view\n\ninterface StableNgFour:\n    def add_liquidity(_amounts: DynArray[uint256, 4], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 4], _isDeposit: bool) -> uint256: view\n\ninterface CommonCurvePool:\n    def exchange(_i: int128, _j: int128, _dx: uint256, _min_dy: uint256, _receiver: address = msg.sender) -> uint256: nonpayable\n    def fee() -> uint256: view\n\ninterface CurveRateProvider:\n    def get_quotes(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> DynArray[Quote, MAX_QUOTES]: view\n    def get_aggregated_rate(_tokenIn: address, _tokenOut: address) -> uint256: view\n\ninterface CryptoLegacyPool:\n    def exchange(_i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool = False) -> uint256: payable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface CurveAddressProvider:\n    def get_address(_id: uint256) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nflag PoolType:\n    STABLESWAP_NG\n    TWO_CRYPTO_NG\n    TRICRYPTO_NG\n    TWO_CRYPTO\n    METAPOOL\n    CRYPTO\n\nstruct Quote:\n    source_token_index: uint256\n    dest_token_index: uint256\n    is_underlying: bool\n    amount_out: uint256\n    pool: address\n    source_token_pool_balance: uint256\n    dest_token_pool_balance: uint256\n    pool_type: uint8\n\nstruct PoolData:\n    pool: address\n    indexTokenA: uint256\n    indexTokenB: uint256\n    poolType: PoolType\n    numCoins: uint256\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n    legoId: uint256\n\nstruct CurveRegistries:\n    StableSwapNg: address\n    TwoCryptoNg: address\n    TricryptoNg: address\n    TwoCrypto: address\n    MetaPool: address\n    RateProvider: address\n\nevent CurveSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent CurveLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent CurveLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\nevent CurveFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent CurveLegoIdSet:\n    legoId: uint256\n\nevent CurveActivated:\n    isActivated: bool\n\n# curve\nCURVE_META_REGISTRY: public(immutable(address))\nCURVE_REGISTRIES: public(immutable(CurveRegistries))\n\n# curve address provider ids\nMETAPOOL_FACTORY_ID: constant(uint256) = 3\nTWO_CRYPTO_FACTORY_ID: constant(uint256) = 6\nMETA_REGISTRY_ID: constant(uint256) = 7\nTRICRYPTO_NG_FACTORY_ID: constant(uint256) = 11\nSTABLESWAP_NG_FACTORY_ID: constant(uint256) = 12\nTWO_CRYPTO_NG_FACTORY_ID: constant(uint256) = 13\nRATE_PROVIDER_ID: constant(uint256) = 18\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_POOLS: constant(uint256) = 50\nMAX_QUOTES: constant(uint256) = 100\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(_curveAddressProvider: address, _addyRegistry: address):\n    assert empty(address) not in [_curveAddressProvider, _addyRegistry] # dev: invalid addrs\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n\n    CURVE_META_REGISTRY = staticcall CurveAddressProvider(_curveAddressProvider).get_address(META_REGISTRY_ID)\n    CURVE_REGISTRIES = CurveRegistries(\n        StableSwapNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(STABLESWAP_NG_FACTORY_ID),\n        TwoCryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_NG_FACTORY_ID),\n        TricryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TRICRYPTO_NG_FACTORY_ID),\n        TwoCrypto= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_FACTORY_ID),\n        MetaPool= staticcall CurveAddressProvider(_curveAddressProvider).get_address(METAPOOL_FACTORY_ID),\n        RateProvider= staticcall CurveAddressProvider(_curveAddressProvider).get_address(RATE_PROVIDER_ID),\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [CURVE_META_REGISTRY]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n########\n# Swap #\n########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    initialAmountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert initialAmountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, initialAmountIn, default_return_value=True) # dev: transfer failed\n    initialAmountIn = min(initialAmountIn, staticcall IERC20(tokenIn).balanceOf(self))\n\n    curveMetaRegistry: address = CURVE_META_REGISTRY\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = initialAmountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, curveMetaRegistry)\n\n    # final amount\n    toAmount: uint256 = tempAmountIn\n    assert toAmount >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        initialAmountIn -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(tokenIn, initialAmountIn, tokenOut, toAmount, True, _oracleRegistry)\n    log CurveSwap(sender=msg.sender, tokenIn=tokenIn, tokenOut=tokenOut, amountIn=initialAmountIn, amountOut=toAmount, usdValue=usdValue, numTokens=numTokens, recipient=_recipient)\n    return initialAmountIn, toAmount, refundAssetAmount, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _curveMetaRegistry: address,\n) -> uint256:\n    toAmount: uint256 = 0\n    p: PoolData = self._getPoolData(_pool, _tokenIn, _tokenOut, _curveMetaRegistry)\n    assert extcall IERC20(_tokenIn).approve(_pool, _amountIn, default_return_value=True) # dev: approval failed\n\n    # stable ng\n    if p.poolType == PoolType.STABLESWAP_NG:\n        toAmount = extcall CommonCurvePool(_pool).exchange(convert(p.indexTokenA, int128), convert(p.indexTokenB, int128), _amountIn, 0, _recipient)\n\n    # two crypto ng\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        toAmount = extcall TwoCryptoNgPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, _recipient)\n\n    # two crypto + tricrypto ng pools\n    elif p.poolType == PoolType.TRICRYPTO_NG or p.poolType == PoolType.TWO_CRYPTO:\n        toAmount = extcall TwoCryptoPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, False, _recipient)\n\n    # meta pools\n    elif p.poolType == PoolType.METAPOOL:\n        if staticcall CurveMetaRegistry(_curveMetaRegistry).is_meta(_pool):\n            raise \"Not Implemented\"\n        else:\n            toAmount = extcall CommonCurvePool(_pool).exchange(convert(p.indexTokenA, int128), convert(p.indexTokenB, int128), _amountIn, 0, _recipient)\n\n    # crypto v1\n    else:\n        toAmount = extcall CryptoLegacyPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, False)\n        if _recipient != self:\n            assert extcall IERC20(_tokenOut).transfer(_recipient, toAmount, default_return_value=True) # dev: transfer failed\n\n    assert extcall IERC20(_tokenIn).approve(_pool, 0, default_return_value=True) # dev: approval failed\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    assert empty(address) not in [_tokenA, _tokenB] # dev: invalid tokens\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n        liqAmountA = min(liqAmountA, staticcall IERC20(_tokenA).balanceOf(self))\n        assert extcall IERC20(_tokenA).approve(_pool, liqAmountA, default_return_value=True) # dev: approval failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n        liqAmountB = min(liqAmountB, staticcall IERC20(_tokenB).balanceOf(self))\n        assert extcall IERC20(_tokenB).approve(_pool, liqAmountB, default_return_value=True) # dev: approval failed\n\n    assert liqAmountA != 0 or liqAmountB != 0 # dev: need at least one token amount\n\n    # pool data\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        lpAmountReceived = self._addLiquidityStableNg(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        lpAmountReceived = self._addLiquidityTwoCryptoNg(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        lpAmountReceived = self._addLiquidityTwoCrypto(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        lpAmountReceived = self._addLiquidityTricrypto(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        lpAmountReceived = self._addLiquidityMetaPool(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    assert lpAmountReceived != 0 # dev: no liquidity added\n\n    # handle token a refunds / approvals\n    refundAssetAmountA: uint256 = 0\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n        currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n        if currentLegoBalanceA > preLegoBalanceA:\n            refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n            assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n            liqAmountA -= refundAssetAmountA\n\n    # handle token b refunds / approvals\n    refundAssetAmountB: uint256 = 0\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n        currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n        if currentLegoBalanceB > preLegoBalanceB:\n            refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n            assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n            liqAmountB -= refundAssetAmountB\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, False, _oracleRegistry)\n    log CurveLiquidityAdded(sender=msg.sender, tokenA=_tokenA, tokenB=_tokenB, amountA=liqAmountA, amountB=liqAmountB, lpAmountReceived=lpAmountReceived, usdValue=usdValue, recipient=_recipient)\n    return lpAmountReceived, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, 0\n\n\n@internal\ndef _addLiquidityStableNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    lpAmountReceived: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: DynArray[uint256, 2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgTwo(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 3:\n        amounts: DynArray[uint256, 3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgThree(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 4:\n        amounts: DynArray[uint256, 4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgFour(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    return lpAmountReceived\n\n\n@internal\ndef _addLiquidityTwoCryptoNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TwoCryptoNgPool(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n\n@internal\ndef _addLiquidityTwoCrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TwoCryptoPool(_p.pool).add_liquidity(amounts, _minLpAmount, False, _recipient)\n\n\n@internal\ndef _addLiquidityTricrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[3] = [0, 0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TriCryptoPool(_p.pool).add_liquidity(amounts, _minLpAmount, False, _recipient)\n\n\n@internal\ndef _addLiquidityMetaPool(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    lpAmountReceived: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: uint256[2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolTwo(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 3:\n        amounts: uint256[3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolThree(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 4:\n        amounts: uint256[4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolFour(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    return lpAmountReceived\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    assert self.isActivated # dev: not activated\n\n    # if one of the tokens is empty, it means they only want to remove liquidity for one token\n    assert _tokenA != empty(address) or _tokenB != empty(address) # dev: invalid tokens\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    isEmptyTokenA: bool = _tokenA == empty(address)\n    isOneCoinRemoval: bool = isEmptyTokenA or _tokenB == empty(address)\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token amount\n    lpAmount: uint256 = min(_liqToRemove, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n    lpAmount = min(lpAmount, staticcall IERC20(_lpToken).balanceOf(self))\n\n    # approvals\n    assert extcall IERC20(_lpToken).approve(_pool, lpAmount, default_return_value=True) # dev: approval failed\n\n    # pool data\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityStableNgOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityStableNg(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTwoCryptoNgOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTwoCryptoNg(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTwoCryptoOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTwoCrypto(p, lpAmount, _tokenA, _tokenB, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTricryptoOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTricrypto(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityMetaPoolOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityMetaPool(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    assert amountA != 0 or amountB != 0 # dev: nothing removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, False, _oracleRegistry)\n    log CurveLiquidityRemoved(sender=msg.sender, pool=_pool, tokenA=_tokenA, tokenB=_tokenB, amountA=amountA, amountB=amountB, lpToken=_lpToken, lpAmountBurned=lpAmount, usdValue=usdValue, recipient=_recipient)\n    return amountA, amountB, usdValue, lpAmount, refundedLpAmount, refundedLpAmount != 0\n\n\n# stable ng\n\n\n@internal\ndef _removeLiquidityStableNgOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall StableNgTwo(_p.pool).remove_liquidity_one_coin(_lpAmount, convert(tokenIndex, int128), minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityStableNg(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools, can't give minAmountsOut for other coins\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    minAmountsOut: DynArray[uint256, 2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    amountsOut: DynArray[uint256, 2] = extcall StableNgTwo(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient, False)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# two crypto ng\n\n\n@internal\ndef _removeLiquidityTwoCryptoNgOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TwoCryptoNgPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTwoCryptoNg(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools, can't give minAmountsOut for other coins\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    minAmountsOut: uint256[2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    amountsOut: uint256[2] = extcall TwoCryptoNgPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# two crypto\n\n\n@internal\ndef _removeLiquidityTwoCryptoOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TwoCryptoPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, False, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTwoCrypto(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _tokenA: address,\n    _tokenB: address,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    # pre balances\n    preBalTokenA: uint256 = staticcall IERC20(_tokenA).balanceOf(_recipient)\n    preBalTokenB: uint256 = staticcall IERC20(_tokenB).balanceOf(_recipient)\n\n    # organize min amounts out\n    minAmountsOut: uint256[2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    extcall TwoCryptoPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, False, _recipient)\n\n    # get amounts\n    amountA: uint256 = 0\n    postBalTokenA: uint256 = staticcall IERC20(_tokenA).balanceOf(_recipient)\n    if postBalTokenA > preBalTokenA:\n        amountA = postBalTokenA - preBalTokenA\n\n    amountB: uint256 = 0\n    postBalTokenB: uint256 = staticcall IERC20(_tokenB).balanceOf(_recipient)\n    if postBalTokenB > preBalTokenB:\n        amountB = postBalTokenB - preBalTokenB\n\n    return amountA, amountB\n\n\n# tricrypto ng\n\n\n@internal\ndef _removeLiquidityTricryptoOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TriCryptoPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, False, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTricrypto(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    minAmountsOut: uint256[3] = [0, 0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # NOTE: user can only specify two min amounts out, the third will be set to zero\n\n    # remove liquidity\n    amountsOut: uint256[3] = extcall TriCryptoPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, False, _recipient, False)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# meta pool\n\n\n@internal\ndef _removeLiquidityMetaPoolOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall MetaPoolCommon(_p.pool).remove_liquidity_one_coin(_lpAmount, convert(tokenIndex, int128), minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityMetaPool(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n\n    # NOTE: user can only specify two min amounts out, the third/fourth will be set to zero\n\n    if _p.numCoins == 2:\n        minAmountsOut: uint256[2] = [0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[2] = extcall MetaPoolTwo(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    elif _p.numCoins == 3:\n        minAmountsOut: uint256[3] = [0, 0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[3] = extcall MetaPoolThree(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    elif _p.numCoins == 4:\n        minAmountsOut: uint256[4] = [0, 0, 0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[4] = extcall MetaPoolFour(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    else:\n        raise \"meta pool: pools beyond 4-coin are not supported\"\n\n    return amountA, amountB\n\n\n# utils\n\n\n@pure\n@internal\ndef _getTokenIndexAndMinAmountOut(\n    _isEmptyTokenA: bool,\n    _indexTokenA: uint256,\n    _indexTokenB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = _indexTokenA\n    minAmountOut: uint256 = _minAmountA\n    if _isEmptyTokenA:\n        tokenIndex = _indexTokenB\n        minAmountOut = _minAmountB\n    return tokenIndex, minAmountOut\n\n\n@pure\n@internal\ndef _getTokenAmounts(_isEmptyTokenA: bool, _amountOut: uint256) -> (uint256, uint256):\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    if _isEmptyTokenA:\n        amountB = _amountOut\n    else:\n        amountA = _amountOut\n    return amountA, amountB\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    return staticcall CurveMetaRegistry(CURVE_META_REGISTRY).get_lp_token(_pool)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    return staticcall CurveMetaRegistry(CURVE_META_REGISTRY).get_pool_from_lp_token(_lpToken)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return empty(address)\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    metaRegistry: address = CURVE_META_REGISTRY\n\n    # all pools with tokens\n    allPools: DynArray[address, MAX_POOLS] = staticcall CurveMetaRegistry(metaRegistry).find_pools_for_coins(_tokenA, _tokenB)\n    if len(allPools) == 0:\n        return empty(BestPool)\n\n    # get deepest liquidity pool\n    bestPoolAddr: address = empty(address)\n    na1: int128 = 0\n    na2: int128 = 0\n    bestLiquidity: uint256 = 0\n    bestPoolAddr, na1, na2, bestLiquidity = self._getDeepestLiqPool(_tokenA, _tokenB, allPools, metaRegistry)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=staticcall CommonCurvePool(bestPoolAddr).fee() // 1000000, # normalize to have 100_00 denominator\n        liquidity=bestLiquidity,\n        numCoins=staticcall CurveMetaRegistry(metaRegistry).get_n_coins(bestPoolAddr),\n        legoId=self.legoId,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    return self._getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n\n\n@view\n@internal\ndef _getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPool: address = empty(address)\n    bestAmountOut: uint256 = 0\n\n    quotes: DynArray[Quote, MAX_QUOTES] = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_quotes(_tokenIn, _tokenOut, _amountIn)\n    for quote: Quote in quotes:\n        if quote.amount_out > bestAmountOut:\n            bestAmountOut = quote.amount_out\n            bestPool = quote.pool\n\n    return bestPool, bestAmountOut\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    quotes: DynArray[Quote, MAX_QUOTES] = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_quotes(_tokenIn, _tokenOut, _amountIn)\n    bestAmountOut: uint256 = 0\n    for quote: Quote in quotes:\n        if _pool == quote.pool:\n            return quote.amount_out\n    return 0\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    expAmountIn: uint256 = self._getSwapAmountIn(empty(address), _tokenIn, _tokenOut, _amountOut)\n    if expAmountIn == 0:\n        return empty(address), 0\n\n    # NOTE: this isn't perfect, but it's good enough\n\n    bestPool: address = empty(address)\n    na: uint256 = 0\n    bestPool, na = self._getBestSwapAmountOut(_tokenIn, _tokenOut, expAmountIn)\n    return bestPool, expAmountIn\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n    return self._getSwapAmountIn(_pool, _tokenIn, _tokenOut, _amountOut)\n\n\n@view\n@internal\ndef _getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    rate: uint256 = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_aggregated_rate(_tokenIn, _tokenOut)\n    if rate == 0:\n        return 0\n    decimalsTokenIn: uint256 = convert(staticcall IERC20Detailed(_tokenIn).decimals(), uint256)\n    return _amountOut * (10 ** decimalsTokenIn) // rate\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    balances: uint256[8] = staticcall CurveMetaRegistry(metaRegistry).get_balances(_pool)\n    reserveA: uint256 = balances[p.indexTokenA]\n    reserveB: uint256 = balances[p.indexTokenB]\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return 0, 0, 0\n\n    # calculate optimal amounts\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = self._getCorrectRatioAmounts(_availAmountA, _availAmountB, reserveA, reserveB)\n\n    expectedLpAmount: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        expectedLpAmount = self._getAddLiqAmountsInStableNg(p, amountA, amountB)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        expectedLpAmount = self._getAddLiqAmountsInCryptoNg(p, amountA, amountB)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        expectedLpAmount = self._getAddLiqAmountsInTwoCrypto(p, amountA, amountB)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        expectedLpAmount = self._getAddLiqAmountsInTricrypto(p, amountA, amountB)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        expectedLpAmount = self._getAddLiqAmountsInMetaPool(p, amountA, amountB)\n\n    if expectedLpAmount == 0:\n        return 0, 0, 0\n\n    return amountA, amountB, expectedLpAmount\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # NOTE: in this case, allowing 0x0 for one token, signifying desire to withdraw just one token\n\n    # normal scenario, 2-coin pool\n    if _tokenA != empty(address) and _tokenB != empty(address):\n        return self._getRemoveLiqAmountsOutTwoCoinPool(p, _tokenA, _tokenB, _lpAmount, metaRegistry)\n\n    # withdraw just one token\n    amountOut: uint256 = 0\n    tokenIndex: uint256 = p.indexTokenA\n    if _tokenA == empty(address):\n        tokenIndex = p.indexTokenB\n\n    # perform calculation\n    if p.poolType == PoolType.STABLESWAP_NG:\n        amountOut = staticcall StableNgTwo(p.pool).calc_withdraw_one_coin(_lpAmount, convert(tokenIndex, int128))\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        amountOut = staticcall TwoCryptoNgPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        amountOut = staticcall TwoCryptoPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        amountOut = staticcall TriCryptoPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        amountOut = staticcall MetaPoolCommon(p.pool).calc_withdraw_one_coin(_lpAmount, convert(tokenIndex, int128))\n\n    # get in correct order\n    amountA: uint256 = amountOut\n    amountB: uint256 = 0\n    if _tokenA == empty(address):\n        amountA = 0\n        amountB = amountOut\n\n    return amountA, amountB\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    return 0\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _isSwap: bool,\n    _oracleRegistry: address,\n) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    usdValueA: uint256 = 0\n    if _tokenA != empty(address) and _amountA != 0:\n        usdValueA = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenA, _amountA)\n    usdValueB: uint256 = 0\n    if _tokenB != empty(address) and _amountB != 0:\n        usdValueB = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenB, _amountB)\n    if _isSwap:\n        return max(usdValueA, usdValueB)\n    else:\n        return usdValueA + usdValueB\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address, _allPools: DynArray[address, MAX_POOLS], _metaRegistry: address) -> (address, int128, int128, uint256):\n    bestPoolAddr: address = empty(address)\n    bestTokenAIndex: int128 = 0\n    bestTokenBIndex: int128 = 0\n    bestLiquidity: uint256 = 0\n\n    for i: uint256 in range(len(_allPools), bound=MAX_POOLS):\n        pool: address = _allPools[i]\n        if pool == empty(address):\n            continue\n\n        # balances\n        balances: uint256[8] = staticcall CurveMetaRegistry(_metaRegistry).get_balances(pool)\n        if balances[0] == 0:\n            continue\n\n        # token indexes \n        indexTokenA: int128 = 0\n        indexTokenB: int128 = 0\n        na: bool = False\n        indexTokenA, indexTokenB, na = staticcall CurveMetaRegistry(_metaRegistry).get_coin_indices(pool, _tokenA, _tokenB)\n\n        # compare liquidity\n        liquidity: uint256 = balances[indexTokenA] + balances[indexTokenB]\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestTokenAIndex = indexTokenA\n            bestTokenBIndex = indexTokenB\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestTokenAIndex, bestTokenBIndex, bestLiquidity\n\n\n@view\n@internal\ndef _getPoolData(_pool: address, _tokenA: address, _tokenB: address, _metaRegistry: address) -> PoolData:\n    assert staticcall CurveMetaRegistry(_metaRegistry).is_registered(_pool) # dev: invalid pool\n    coins: address[8] = staticcall CurveMetaRegistry(_metaRegistry).get_coins(_pool)\n\n    # validate tokens\n    if _tokenA != empty(address):\n        assert _tokenA in coins # dev: invalid tokens\n    if _tokenB != empty(address):\n        assert _tokenB in coins # dev: invalid tokens\n\n    # get indices\n    indexTokenA: uint256 = max_value(uint256)\n    indexTokenB: uint256 = max_value(uint256)\n    numCoins: uint256 = 0\n    for coin: address in coins:\n        if coin == empty(address):\n            break\n        if coin == _tokenA:\n            indexTokenA = numCoins\n        elif coin == _tokenB:\n            indexTokenB = numCoins\n        numCoins += 1\n\n    return PoolData(\n        pool=_pool,\n        indexTokenA=indexTokenA,\n        indexTokenB=indexTokenB,\n        poolType=self._getPoolType(_pool, _metaRegistry),\n        numCoins=numCoins,\n    )\n\n\n@view\n@internal\ndef _getPoolType(_pool: address, _metaRegistry: address) -> PoolType:\n    # check what type of pool this is based on where it's registered on Curve\n    registryHandlers: address[10] = staticcall CurveMetaRegistry(_metaRegistry).get_registry_handlers_from_pool(_pool)\n    baseRegistry: address = staticcall CurveMetaRegistry(_metaRegistry).get_base_registry(registryHandlers[0])\n\n    curveRegistries: CurveRegistries = CURVE_REGISTRIES\n    poolType: PoolType = empty(PoolType)\n    if baseRegistry == curveRegistries.StableSwapNg:\n        poolType = PoolType.STABLESWAP_NG\n    elif baseRegistry == curveRegistries.TwoCryptoNg:\n        poolType = PoolType.TWO_CRYPTO_NG\n    elif baseRegistry == curveRegistries.TricryptoNg:\n        poolType = PoolType.TRICRYPTO_NG\n    elif baseRegistry == curveRegistries.TwoCrypto:\n        poolType = PoolType.TWO_CRYPTO\n    elif baseRegistry == curveRegistries.MetaPool:\n        poolType = PoolType.METAPOOL\n    else:\n        poolType = PoolType.CRYPTO\n    return poolType\n\n\n@view\n@internal\ndef _getAddLiqAmountsInStableNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    expLpAmount: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: DynArray[uint256, 2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgTwo(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 3:\n        amounts: DynArray[uint256, 3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgThree(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 4:\n        amounts: DynArray[uint256, 4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgFour(_p.pool).calc_token_amount(amounts, True)\n\n    return expLpAmount\n\n\n@view\n@internal\ndef _getAddLiqAmountsInCryptoNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TwoCryptoNgPool(_p.pool).calc_token_amount(amounts, True)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInTwoCrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TwoCryptoPool(_p.pool).calc_token_amount(amounts)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInTricrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[3] = [0, 0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TriCryptoPool(_p.pool).calc_token_amount(amounts, True)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInMetaPool(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    expLpAmount: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: uint256[2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolTwo(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 3:\n        amounts: uint256[3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolThree(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 4:\n        amounts: uint256[4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolFour(_p.pool).calc_token_amount(amounts, True)\n\n    return expLpAmount\n\n\n@view\n@internal\ndef _getRemoveLiqAmountsOutTwoCoinPool(\n    _p: PoolData,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n    _metaRegistry: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools\n    if _p.numCoins > 2:\n        return max_value(uint256), max_value(uint256)\n\n    # get balances\n    balances: uint256[8] = staticcall CurveMetaRegistry(_metaRegistry).get_balances(_p.pool)\n    reserveA: uint256 = balances[_p.indexTokenA]\n    reserveB: uint256 = balances[_p.indexTokenB]\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return max_value(uint256), max_value(uint256)\n\n    # calculate expected amounts out\n    lpToken: address = staticcall CurveMetaRegistry(_metaRegistry).get_lp_token(_p.pool)\n    totalSupply: uint256 = staticcall IERC20(lpToken).totalSupply()\n    expectedAmountA: uint256 = _lpAmount * reserveA // totalSupply\n    expectedAmountB: uint256 = _lpAmount * reserveB // totalSupply\n    return expectedAmountA, expectedAmountB\n\n\n@view\n@internal\ndef _getCorrectRatioAmounts(\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n    _reserveA: uint256,\n    _reserveB: uint256,\n) -> (uint256, uint256):\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = self._quote(_availAmountA, _reserveA, _reserveB)\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = self._quote(_availAmountB, _reserveB, _reserveA)\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB\n\n\n@view\n@internal\ndef _quote(_amountA: uint256, _reserveA: uint256, _reserveB: uint256) -> uint256:\n    return (_amountA * _reserveB) // _reserveA\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log CurveFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log CurveLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log CurveActivated(isActivated=_shouldActivate)",
            "sha256sum": "8ec0efa87673b9a808f501b87225f447348d5aad1c8b1ea91afbfa4ef4601a30"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/LegoCurve.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "f8115cee09410c086448c3172ec23b9d319f37aa6abe4aa71ccd736eb35b9124"
      },
      "args": "0000000000000000000000005ffe7fb82894076ecb99a30d6a32e969e6e35e9800000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "LegoUniswapV2": {
      "address": "0xFA56408A68ba9bF5Df0F1CF4187B7260fDf38fC4",
      "abi": [
        {
          "name": "UniswapV2LiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2LiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2Swap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniV2WethCoreRouterPoolSet",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniV2FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2LegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2Activated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCoreRouterPool",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_ROUTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_uniswapV2Factory",
              "type": "address"
            },
            {
              "name": "_uniswapV2Router",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/dexes/LegoUniswapV2.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoDex\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom interfaces import LegoDex\nfrom interfaces import LegoCommon\n\ninterface IUniswapV2Pair:\n    def swap(_amount0Out: uint256, _amount1Out: uint256, _recipient: address, _data: Bytes[256]): nonpayable\n    def getReserves() -> (uint112, uint112, uint32): view\n    def token0() -> address: view\n    def token1() -> address: view\n\ninterface UniV2Router:\n    def addLiquidity(_tokenA: address, _tokenB: address, _amountADesired: uint256, _amountBDesired: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_tokenA: address, _tokenB: address, _lpAmount: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256): nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n\ninterface UniV2Factory:\n    def getPair(_tokenA: address, _tokenB: address) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n    legoId: uint256\n\nevent UniswapV2LiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV2LiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV2Swap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent UniV2WethCoreRouterPoolSet:\n    pool: indexed(address)\n\nevent UniV2FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent UniswapV2LegoIdSet:\n    legoId: uint256\n\nevent UniswapV2Activated:\n    isActivated: bool\n\n# uniswap\ncoreRouterPool: public(address)\nUNISWAP_V2_FACTORY: public(immutable(address))\nUNISWAP_V2_ROUTER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _uniswapV2Factory: address,\n    _uniswapV2Router: address,\n    _addyRegistry: address,\n    _coreRouterPool: address,\n):\n    assert empty(address) not in [_uniswapV2Factory, _uniswapV2Router, _addyRegistry, _coreRouterPool] # dev: invalid addrs\n    UNISWAP_V2_FACTORY = _uniswapV2Factory\n    UNISWAP_V2_ROUTER = _uniswapV2Router\n    ADDY_REGISTRY = _addyRegistry\n    self.coreRouterPool = _coreRouterPool\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [UNISWAP_V2_FACTORY, UNISWAP_V2_ROUTER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n########\n# Swap #\n########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    initialAmountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert initialAmountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, initialAmountIn, default_return_value=True) # dev: transfer failed\n    initialAmountIn = min(initialAmountIn, staticcall IERC20(tokenIn).balanceOf(self))\n\n    # transfer initial amount to first pool\n    assert extcall IERC20(tokenIn).transfer(_poolPath[0], initialAmountIn, default_return_value=True) # dev: transfer failed\n\n    uniswapV2Factory: address = UNISWAP_V2_FACTORY\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = initialAmountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to next pool (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = _poolPath[i + 1]\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, uniswapV2Factory)\n\n    # final amount\n    toAmount: uint256 = tempAmountIn\n    assert toAmount >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        initialAmountIn -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(tokenIn, initialAmountIn, tokenOut, toAmount, True, _oracleRegistry)\n    log UniswapV2Swap(sender=msg.sender, tokenIn=tokenIn, tokenOut=tokenOut, amountIn=initialAmountIn, amountOut=toAmount, usdValue=usdValue, numTokens=numTokens, recipient=_recipient)\n    return initialAmountIn, toAmount, refundAssetAmount, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _uniswapV2Factory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual uniswap v2 pool\n    assert staticcall UniV2Factory(_uniswapV2Factory).getPair(_tokenIn, _tokenOut) == _pool # dev: invalid pool\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    amountOut: uint256 = self._getAmountOut(_pool, zeroForOne, _amountIn)\n    assert amountOut != 0 # dev: no tokens swapped\n\n    # put in correct order\n    amount0Out: uint256 = amountOut\n    amount1Out: uint256 = 0\n    if zeroForOne:\n        amount0Out = 0\n        amount1Out = amountOut\n\n    # perform swap\n    extcall IUniswapV2Pair(_pool).swap(amount0Out, amount1Out, _recipient, b\"\")\n    return amountOut\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    transferAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert transferAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, transferAmountA, default_return_value=True) # dev: transfer failed\n    liqAmountA: uint256 = min(transferAmountA, staticcall IERC20(_tokenA).balanceOf(self))\n\n    # token b\n    transferAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert transferAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, transferAmountB, default_return_value=True) # dev: transfer failed\n    liqAmountB: uint256 = min(transferAmountB, staticcall IERC20(_tokenB).balanceOf(self))\n\n    # approvals\n    router: address = UNISWAP_V2_ROUTER\n    assert extcall IERC20(_tokenA).approve(router, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    liqAmountA, liqAmountB, lpAmountReceived = extcall UniV2Router(router).addLiquidity(\n        _tokenA,\n        _tokenB,\n        liqAmountA,\n        liqAmountB,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert lpAmountReceived != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(router, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, False, _oracleRegistry)\n    log UniswapV2LiquidityAdded(sender=msg.sender, tokenA=_tokenA, tokenB=_tokenB, amountA=liqAmountA, amountB=liqAmountB, lpAmountReceived=lpAmountReceived, usdValue=usdValue, recipient=_recipient)\n    return lpAmountReceived, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, 0\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token\n    transferAmount: uint256 = min(_liqToRemove, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n    lpAmount: uint256 = min(transferAmount, staticcall IERC20(_lpToken).balanceOf(self))\n\n    # approvals\n    router: address = UNISWAP_V2_ROUTER\n    assert extcall IERC20(_lpToken).approve(router, lpAmount, default_return_value=True) # dev: approval failed\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = extcall UniV2Router(router).removeLiquidity(\n        _tokenA,\n        _tokenB,\n        lpAmount,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert amountA != 0 # dev: no amountA removed\n    assert amountB != 0 # dev: no amountB removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, False, _oracleRegistry)\n    log UniswapV2LiquidityRemoved(sender=msg.sender, pool=_pool, tokenA=_tokenA, tokenB=_tokenB, amountA=amountA, amountB=amountB, lpToken=_lpToken, lpAmountBurned=lpAmount, usdValue=usdValue, recipient=_recipient)\n    return amountA, amountB, usdValue, lpAmount, refundedLpAmount, refundedLpAmount != 0\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # in uniswap v2, the lp token is the pool address\n    return _pool\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # in uniswap v2, the pool is the lp token address\n    return _lpToken\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenA, _tokenB)\n    if pool == empty(address):\n        return empty(BestPool)\n\n    # get reserves\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(pool).getReserves()\n\n    return BestPool(\n        pool=pool,\n        fee=30, # 0.3%, denominator is 100_00\n        liquidity=convert(reserve0 + reserve1, uint256),\n        numCoins=2,\n        legoId=self.legoId,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenIn, _tokenOut)\n    if pool == empty(address):\n        return empty(address), 0\n    token0: address = staticcall IUniswapV2Pair(pool).token0()\n    return pool, self._getAmountOut(pool, _tokenIn == token0, _amountIn)\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    return self._getAmountOut(_pool, _tokenIn == token0, _amountIn)\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenIn, _tokenOut)\n    if pool == empty(address):\n        return empty(address), 0\n    token0: address = staticcall IUniswapV2Pair(pool).token0()\n    return pool, self._getAmountIn(pool, _tokenIn == token0, _amountOut)\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    return self._getAmountIn(_pool, _tokenIn == token0, _amountOut)\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n\n    reserveA: uint256 = 0\n    reserveB: uint256 = 0\n    reserveA, reserveB = self._getReserves(_pool, _tokenA == token0)\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return 0, 0, 0\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = self._quote(_availAmountA, reserveA, reserveB)\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = self._quote(_availAmountB, reserveB, reserveA)\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n\n    reserveA: uint256 = 0\n    reserveB: uint256 = 0\n    reserveA, reserveB = self._getReserves(_pool, _tokenA == token0)\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return max_value(uint256), max_value(uint256)\n\n    # calculate expected amounts out\n    totalSupply: uint256 = staticcall IERC20(_pool).totalSupply()\n    expectedAmountA: uint256 = _lpAmount * reserveA // totalSupply\n    expectedAmountB: uint256 = _lpAmount * reserveB // totalSupply\n    return expectedAmountA, expectedAmountB\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    token1: address = staticcall IUniswapV2Pair(_pool).token1()\n\n    # oracle registry\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token1, False)\n    else:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token0, False)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # reserves\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(_pool).getReserves()\n\n    # avoid division by zero\n    if reserve0 == 0 or reserve1 == 0:\n        return 0  \n\n    # price of token0 in token1\n    priceZeroToOne: uint256 = convert(reserve1, uint256) * EIGHTEEN_DECIMALS // convert(reserve0, uint256)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _isSwap: bool,\n    _oracleRegistry: address,\n) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    usdValueA: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenA, _amountA)\n    usdValueB: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenB, _amountB)\n    if _isSwap:\n        return max(usdValueA, usdValueB)\n    else:\n        return usdValueA + usdValueB\n\n\n@view\n@internal\ndef _quote(_amountA: uint256, _reserveA: uint256, _reserveB: uint256) -> uint256:\n    return (_amountA * _reserveB) // _reserveA\n\n\n@view\n@internal\ndef _getReserves(_pool: address, _isTokenAZeroIndex: bool) -> (uint256, uint256):\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(_pool).getReserves()\n\n    # determine which token is which\n    reserveA: uint256 = convert(reserve0, uint256)\n    reserveB: uint256 = convert(reserve1, uint256)\n    if not _isTokenAZeroIndex:\n        reserveA = convert(reserve1, uint256)\n        reserveB = convert(reserve0, uint256)\n\n    return reserveA, reserveB\n\n\n@view\n@internal\ndef _getAmountOut(\n    _pool: address,\n    _zeroForOne: bool,\n    _amountIn: uint256,\n) -> uint256:\n    if _amountIn == 0:\n        return 0\n\n    # get reserves\n    reserveIn: uint256 = 0\n    reserveOut: uint256 = 0\n    reserveIn, reserveOut = self._getReserves(_pool, _zeroForOne)\n    if reserveIn == 0 or reserveOut == 0:\n        return 0\n\n    # calculate amount out\n    amountInWithFee: uint256 = _amountIn * 997 # 1000 - 3 (0.3% fee)\n    numerator: uint256 = amountInWithFee * reserveOut\n    denominator: uint256 = (reserveIn * 1000) + amountInWithFee\n    return numerator // denominator\n\n\n@view\n@internal\ndef _getAmountIn(_pool: address, _zeroForOne: bool, _amountOut: uint256) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    reserveIn: uint256 = 0\n    reserveOut: uint256 = 0\n    reserveIn, reserveOut = self._getReserves(_pool, _zeroForOne)\n    if reserveIn == 0 or reserveOut == 0:\n        return max_value(uint256)\n\n    if _amountOut > reserveOut:\n        return max_value(uint256)\n\n    numerator: uint256 = reserveIn * _amountOut * 1000\n    denominator: uint256 = (reserveOut - _amountOut) * 997\n    return (numerator // denominator) + 1\n\n\n####################\n# Core Router Pool #\n####################\n\n\n@external\ndef setCoreRouterPool(_addr: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.coreRouterPool = _addr\n    log UniV2WethCoreRouterPoolSet(pool=_addr)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log UniV2FundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log UniswapV2LegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log UniswapV2Activated(isActivated=_shouldActivate)",
            "sha256sum": "effa5194031233aeb4b62c9fe68470f4c0369a868e6647e501eb3497fbd20a27"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/LegoUniswapV2.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "00a413fdce28c0271efc34b1d70747baee0ecbb1026d1c94c579277eab84e412"
      },
      "args": "0000000000000000000000008909dc15e40173ff4699343b6eb8132c65e18ec60000000000000000000000004752ba5dbc23f44d87826276bf6fd6b1c372ad2400000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd00000000000000000000000088a43bbdf9d098eec7bceda4e2494615dfd9bb9c"
    },
    "LegoUniswapV3": {
      "address": "0x83C1864F112A9CD8b9e93c4a166F4d885244Eef3",
      "abi": [
        {
          "name": "UniswapV3Swap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3SwapInPool",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": false
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniV3FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniV3CoreRouterPoolSet",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniV3NftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3Activated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "uniswapV3SwapCallback",
          "inputs": [
            {
              "name": "_amount0Delta",
              "type": "int256"
            },
            {
              "name": "_amount1Delta",
              "type": "int256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCoreRouterPool",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_NFT_MANAGER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_QUOTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_uniswapV3Factory",
              "type": "address"
            },
            {
              "name": "_uniNftPositionManager",
              "type": "address"
            },
            {
              "name": "_uniV3Quoter",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/dexes/LegoUniswapV3.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: IUniswapV3Callback\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC721\nfrom ethereum.ercs import IERC20Detailed\nfrom interfaces import LegoCommon\n\n# `getSwapAmountOut()` and `getSwapAmountIn()` cannot be view functions, sadly\n# keeping here to uncomment to test all other functions\n# implements: LegoDex\n# from interfaces import LegoDex\n\ninterface UniV3Pool:\n    def slot0() -> (uint160, int24, uint16, uint16, uint16, uint8, bool): view\n    def swap(_recipient: address, _zeroForOne: bool, _amountSpecified: int256, _sqrtPriceLimitX96: uint160, _data: Bytes[256]) -> (int256, int256): nonpayable\n    def liquidity() -> uint128: view\n    def tickSpacing() -> int24: view\n    def token0() -> address: view\n    def token1() -> address: view\n    def fee() -> uint24: view\n\ninterface UniV3NftPositionManager:\n    def increaseLiquidity(_params: IncreaseLiquidityParams) -> (uint128, uint256, uint256): nonpayable\n    def decreaseLiquidity(_params: DecreaseLiquidityParams) -> (uint256, uint256): nonpayable\n    def mint(_params: MintParams) -> (uint256, uint128, uint256, uint256): nonpayable\n    def collect(_params: CollectParams) -> (uint256, uint256): nonpayable\n    def positions(_tokenId: uint256) -> PositionData: view\n    def burn(_tokenId: uint256): nonpayable\n\ninterface UniV3Quoter:\n    def quoteExactOutputSingle(_params: QuoteExactOutputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInputSingle(_params: QuoteExactInputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInput(_path: Bytes[1024], _amountIn: uint256) -> uint256: nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n\ninterface IUniswapV3Callback:\n    def uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]): nonpayable\n\ninterface UniV3Factory:\n    def getPool(_tokenA: address, _tokenB: address, _fee: uint24) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct QuoteExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    fee: uint24\n    sqrtPriceLimitX96: uint160\n\nstruct QuoteExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amount: uint256\n    fee: uint24\n    sqrtPriceLimitX96: uint160\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n    legoId: uint256\n\nstruct MintParams:\n    token0: address\n    token1: address\n    fee: uint24\n    tickLower: int24\n    tickUpper: int24\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    recipient: address\n    deadline: uint256\n\nstruct IncreaseLiquidityParams:\n    tokenId: uint256\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct DecreaseLiquidityParams:\n    tokenId: uint256\n    liquidity: uint128\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct CollectParams:\n    tokenId: uint256\n    recipient: address\n    amount0Max: uint128\n    amount1Max: uint128\n\nstruct PositionData:\n    nonce: uint96\n    operator: address\n    token0: address\n    token1: address\n    fee: uint24\n    tickLower: int24\n    tickUpper: int24\n    liquidity: uint128\n    feeGrowthInside0LastX128: uint256\n    feeGrowthInside1LastX128: uint256\n    tokensOwed0: uint128\n    tokensOwed1: uint128\n\nstruct PoolSwapData:\n    pool: address\n    tokenIn: address\n    amountIn: uint256\n\nevent UniswapV3Swap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent UniswapV3SwapInPool:\n    sender: indexed(address)\n    pool: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: address\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV3LiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityAdded: uint256\n    nftTokenId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV3LiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    nftTokenId: uint256\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityRemoved: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniV3FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent UniV3CoreRouterPoolSet:\n    pool: indexed(address)\n\nevent UniV3NftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\nevent UniswapV3LegoIdSet:\n    legoId: uint256\n\nevent UniswapV3Activated:\n    isActivated: bool\n\n# transient\ncoreRouterPool: public(address)\npoolSwapData: transient(PoolSwapData)\n\n# uni\nUNIV3_FACTORY: public(immutable(address))\nUNIV3_NFT_MANAGER: public(immutable(address))\nUNIV3_QUOTER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nFEE_TIERS: constant(uint24[4]) = [100, 500, 3000, 10000] # 0.01%, 0.05%, 0.3%, 1%\nMIN_SQRT_RATIO_PLUS_ONE: constant(uint160) = 4295128740\nMAX_SQRT_RATIO_MINUS_ONE: constant(uint160) = 1461446703485210103287273052203988822378723970341\nTICK_LOWER: constant(int24) = -887272\nTICK_UPPER: constant(int24) = 887272\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UnderscoreErc721\"\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nUNISWAP_Q96: constant(uint256) = 2 ** 96  # uniswap's fixed point scaling factor\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n@deploy\ndef __init__(\n    _uniswapV3Factory: address,\n    _uniNftPositionManager: address,\n    _uniV3Quoter: address,\n    _addyRegistry: address,\n    _coreRouterPool: address,\n):\n    assert empty(address) not in [_uniswapV3Factory, _uniNftPositionManager, _uniV3Quoter, _addyRegistry, _coreRouterPool] # dev: invalid addrs\n    UNIV3_FACTORY = _uniswapV3Factory\n    UNIV3_NFT_MANAGER = _uniNftPositionManager\n    UNIV3_QUOTER = _uniV3Quoter\n    ADDY_REGISTRY = _addyRegistry\n    self.coreRouterPool = _coreRouterPool\n    self.isActivated = True\n    gov.__init__(_addyRegistry)\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    assert _data == ERC721_RECEIVE_DATA # dev: did not receive from within Underscore wallet\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [UNIV3_FACTORY, UNIV3_NFT_MANAGER, UNIV3_QUOTER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n########\n# Swap #\n########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    initialAmountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert initialAmountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, initialAmountIn, default_return_value=True) # dev: transfer failed\n    initialAmountIn = min(initialAmountIn, staticcall IERC20(tokenIn).balanceOf(self))\n\n    uniswapV3Factory: address = UNIV3_FACTORY\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = initialAmountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, uniswapV3Factory)\n\n    # final amount\n    toAmount: uint256 = tempAmountIn\n    assert toAmount >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        initialAmountIn -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(tokenIn, initialAmountIn, tokenOut, toAmount, True, _oracleRegistry)\n    log UniswapV3Swap(sender=msg.sender, tokenIn=tokenIn, tokenOut=tokenOut, amountIn=initialAmountIn, amountOut=toAmount, usdValue=usdValue, numTokens=numTokens, recipient=_recipient)\n    return initialAmountIn, toAmount, refundAssetAmount, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _uniswapV3Factory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall UniV3Pool(_pool).token0(), staticcall UniV3Pool(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual uniswap v3 pool\n    assert staticcall UniV3Factory(_uniswapV3Factory).getPool(_tokenIn, _tokenOut, staticcall UniV3Pool(_pool).fee()) == _pool # dev: invalid pool\n\n    # save in transient storage (for use in callback)\n    self.poolSwapData = PoolSwapData(\n        pool=_pool,\n        tokenIn=_tokenIn,\n        amountIn=_amountIn,\n    )\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    sqrtPriceLimitX96: uint160 = MAX_SQRT_RATIO_MINUS_ONE\n    if zeroForOne:\n        sqrtPriceLimitX96 = MIN_SQRT_RATIO_PLUS_ONE\n\n    # perform swap\n    amount0: int256 = 0\n    amount1: int256 = 0\n    amount0, amount1 = extcall UniV3Pool(_pool).swap(_recipient, zeroForOne, convert(_amountIn, int256), sqrtPriceLimitX96, b\"\")\n\n    toAmount: uint256 = 0\n    if zeroForOne:\n        toAmount = convert(-amount1, uint256)\n    else:\n        toAmount = convert(-amount0, uint256)\n\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n# callback\n\n\n@external\ndef uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]):\n    poolSwapData: PoolSwapData = self.poolSwapData\n    assert msg.sender == poolSwapData.pool # dev: no perms\n\n    # transfer tokens to pool\n    assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.pool, poolSwapData.amountIn, default_return_value=True) # dev: transfer failed\n    self.poolSwapData = empty(PoolSwapData)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    tokens: address[2] = [staticcall UniV3Pool(_pool).token0(), staticcall UniV3Pool(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    transferAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert transferAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, transferAmountA, default_return_value=True) # dev: transfer failed\n    liqAmountA: uint256 = min(transferAmountA, staticcall IERC20(_tokenA).balanceOf(self))\n\n    # token b\n    transferAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert transferAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, transferAmountB, default_return_value=True) # dev: transfer failed\n    liqAmountB: uint256 = min(transferAmountB, staticcall IERC20(_tokenB).balanceOf(self))\n\n    # approvals\n    nftPositionManager: address = UNIV3_NFT_MANAGER\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # organized the index of tokens\n    token0: address = _tokenA\n    token1: address = _tokenB\n    amount0: uint256 = liqAmountA\n    amount1: uint256 = liqAmountB\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if tokens[0] != _tokenA:\n        token0 = _tokenB\n        token1 = _tokenA\n        amount0 = liqAmountB\n        amount1 = liqAmountA\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # add liquidity\n    nftTokenId: uint256 = _nftTokenId\n    liquidityAdded: uint256 = 0\n    liquidityAddedInt128: uint128 = 0\n    if _nftTokenId == 0:\n        nftTokenId, liquidityAddedInt128, amount0, amount1 = self._mintNewPosition(nftPositionManager, _pool, token0, token1, _tickLower, _tickUpper, amount0, amount1, minAmount0, minAmount1, _recipient)\n    else:\n        liquidityAddedInt128, amount0, amount1 = self._increaseExistingPosition(nftPositionManager, _nftTokenId, amount0, amount1, minAmount0, minAmount1, _recipient)\n\n    liquidityAdded = convert(liquidityAddedInt128, uint256)\n    assert liquidityAdded != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    # a/b amounts\n    liqAmountA = amount0\n    liqAmountB = amount1\n    if tokens[0] != _tokenA:\n        liqAmountA = amount1\n        liqAmountB = amount0\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, False, _oracleRegistry)\n    log UniswapV3LiquidityAdded(sender=msg.sender, tokenA=_tokenA, tokenB=_tokenB, amountA=liqAmountA, amountB=liqAmountB, liquidityAdded=liquidityAdded, nftTokenId=nftTokenId, usdValue=usdValue, recipient=_recipient)\n    return liquidityAdded, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, nftTokenId\n\n\n@internal\ndef _mintNewPosition(\n    _nftPositionManager: address,\n    _pool: address,\n    _token0: address,\n    _token1: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint256, uint128, uint256, uint256):\n    tickLower: int24 = 0\n    tickUpper: int24 = 0\n    tickLower, tickUpper = self._getTicks(_pool, _tickLower, _tickUpper)\n\n    # mint new position\n    params: MintParams = MintParams(\n        token0=_token0,\n        token1=_token1,\n        fee=staticcall UniV3Pool(_pool).fee(),\n        tickLower=tickLower,\n        tickUpper=tickUpper,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        recipient=_recipient,\n        deadline=block.timestamp,\n    )\n    return extcall UniV3NftPositionManager(_nftPositionManager).mint(params)\n\n\n@view\n@internal\ndef _getTicks(_pool: address, _tickLower: int24, _tickUpper: int24) -> (int24, int24):\n    tickSpacing: int24 = 0\n    if _tickLower == min_value(int24) or _tickUpper == max_value(int24):\n        tickSpacing = staticcall UniV3Pool(_pool).tickSpacing()\n\n    tickLower: int24 = _tickLower\n    if _tickLower == min_value(int24):\n        tickLower = (TICK_LOWER // tickSpacing) * tickSpacing\n\n    tickUpper: int24 = _tickUpper\n    if _tickUpper == max_value(int24):\n        tickUpper = (TICK_UPPER // tickSpacing) * tickSpacing\n\n    return tickLower, tickUpper\n\n\n@internal\ndef _increaseExistingPosition(\n    _nftPositionManager: address,\n    _tokenId: uint256,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint128, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_tokenId) == self # dev: nft not here\n\n    liquidityAddedInt128: uint128 = 0\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    params: IncreaseLiquidityParams = IncreaseLiquidityParams(\n        tokenId=_tokenId,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        deadline=block.timestamp,\n    )\n    liquidityAddedInt128, amount0, amount1 = extcall UniV3NftPositionManager(_nftPositionManager).increaseLiquidity(params)\n\n    # collect fees (if applicable) -- must be done before transferring nft\n    positionData: PositionData = staticcall UniV3NftPositionManager(_nftPositionManager).positions(_tokenId)\n    self._collectFees(_nftPositionManager, _tokenId, _recipient, positionData)\n\n    # transfer nft to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _tokenId)\n\n    return liquidityAddedInt128, amount0, amount1\n\n\n@internal\ndef _collectFees(_nftPositionManager: address, _tokenId: uint256, _recipient: address, _positionData: PositionData) -> (uint256, uint256):\n    if _positionData.tokensOwed0 == 0 and _positionData.tokensOwed1 == 0:\n        return 0, 0\n\n    params: CollectParams = CollectParams(\n        tokenId=_tokenId,\n        recipient=_recipient,\n        amount0Max=max_value(uint128),\n        amount1Max=max_value(uint128),\n    )\n    return extcall UniV3NftPositionManager(_nftPositionManager).collect(params)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    assert self.isActivated # dev: not activated\n\n    # make sure nft is here\n    nftPositionManager: address = UNIV3_NFT_MANAGER\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall UniV3NftPositionManager(nftPositionManager).positions(_nftTokenId)\n    originalLiquidity: uint128 = positionData.liquidity\n\n    # validate tokens\n    tokens: address[2] = [positionData.token0, positionData.token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # organized the index of tokens\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if _tokenA != tokens[0]:\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # decrease liquidity\n    liqToRemove: uint256 = min(_liqToRemove, convert(positionData.liquidity, uint256))\n    assert liqToRemove != 0 # dev: no liquidity to remove\n\n    params: DecreaseLiquidityParams = DecreaseLiquidityParams(\n        tokenId=_nftTokenId,\n        liquidity=convert(liqToRemove, uint128),\n        amount0Min=minAmount0,\n        amount1Min=minAmount1,\n        deadline=block.timestamp,\n    )\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = extcall UniV3NftPositionManager(nftPositionManager).decreaseLiquidity(params)\n    assert amount0 != 0 and amount1 != 0 # dev: no liquidity removed\n\n    # a/b amounts\n    amountA: uint256 = amount0\n    amountB: uint256 = amount1\n    if _tokenA != tokens[0]:\n        amountA = amount1\n        amountB = amount0\n\n    # get latest position data -- collect withdrawn tokens AND any fees (if applicable)\n    positionData = staticcall UniV3NftPositionManager(nftPositionManager).positions(_nftTokenId)\n    self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # burn nft (if applicable)\n    isDepleted: bool = False\n    if positionData.liquidity == 0:\n        isDepleted = True\n        extcall UniV3NftPositionManager(nftPositionManager).burn(_nftTokenId)\n\n    # transfer nft to recipient\n    else:\n        extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, False, _oracleRegistry)\n    liquidityRemoved: uint256 = convert(originalLiquidity - positionData.liquidity, uint256)\n    log UniswapV3LiquidityRemoved(sender=msg.sender, pool=_pool, nftTokenId=_nftTokenId, tokenA=_tokenA, tokenB=_tokenB, amountA=amountA, amountB=amountB, liquidityRemoved=liquidityRemoved, usdValue=usdValue, recipient=_recipient)\n    return amountA, amountB, usdValue, liquidityRemoved, 0, isDepleted\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # no lp tokens for uniswap v3\n    return empty(address)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # no lp tokens for uniswap v3\n    return empty(address)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenA, _tokenB)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    # get token balances\n    tokenABal: uint256 = staticcall IERC20(_tokenA).balanceOf(bestPoolAddr)\n    tokenBBal: uint256 = staticcall IERC20(_tokenB).balanceOf(bestPoolAddr)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=convert(bestFeeTier // 100, uint256), # normalize to have 100_00 denominator\n        liquidity=tokenABal + tokenBBal, # not exactly \"liquidity\" but this comparable to \"reserves\"\n        numCoins=2,\n        legoId=self.legoId,\n    )\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            fee=bestFeeTier,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            fee=staticcall UniV3Pool(_pool).fee(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            fee=bestFeeTier,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountIn\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            fee=staticcall UniV3Pool(_pool).fee(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountIn\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall UniV3Pool(_pool).token0()\n\n    # get correct numerator and denominator\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    sqrtPriceX96Squared: uint256 = self._getSqrtPriceX96(_pool) ** 2\n    if _tokenA == token0:\n        numerator = sqrtPriceX96Squared\n        denominator = UNISWAP_Q96 ** 2\n    else:\n        numerator = UNISWAP_Q96 ** 2\n        denominator = sqrtPriceX96Squared\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = _availAmountA * numerator // denominator\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = _availAmountB * denominator // numerator\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall UniV3Pool(_pool).token0()\n\n    # calculate expected amounts out\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    amount0Out: uint256 = _lpAmount * UNISWAP_Q96 // sqrtPriceX96\n    amount1Out: uint256 = _lpAmount * sqrtPriceX96 // UNISWAP_Q96\n\n    # return amounts out\n    if _tokenA == token0:\n        return amount0Out, amount1Out\n    else:\n        return amount1Out, amount0Out\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    token0: address = staticcall UniV3Pool(_pool).token0()\n    token1: address = staticcall UniV3Pool(_pool).token1()\n\n    # oracle registry\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token1, False)\n    else:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token0, False)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # price of token0 in token1\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    numerator: uint256 = sqrtPriceX96 ** 2 * EIGHTEEN_DECIMALS\n    priceZeroToOne: uint256 = numerator // (UNISWAP_Q96 ** 2)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address) -> (address, uint24):\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestLiquidity: uint128 = 0\n\n    factory: address = UNIV3_FACTORY\n    for i: uint256 in range(4):\n        fee: uint24 = FEE_TIERS[i]\n        pool: address = staticcall UniV3Factory(factory).getPool(_tokenA, _tokenB, fee)\n        if pool == empty(address):\n            continue\n        liquidity: uint128 = staticcall UniV3Pool(pool).liquidity()\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestFeeTier = fee\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestFeeTier\n\n\n@view\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _isSwap: bool,\n    _oracleRegistry: address,\n) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    usdValueA: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenA, _amountA)\n    usdValueB: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenB, _amountB)\n    if _isSwap:\n        return max(usdValueA, usdValueB)\n    else:\n        return usdValueA + usdValueB\n\n\n@view\n@internal\ndef _getSqrtPriceX96(_pool: address) -> uint256:\n    sqrtPriceX96: uint160 = 0\n    tick: int24 = 0\n    observationIndex: uint16 = 0\n    observationCardinality: uint16 = 0\n    observationCardinalityNext: uint16 = 0\n    feeProtocol: uint8 = 0\n    unlocked: bool = False\n    sqrtPriceX96, tick, observationIndex, observationCardinality, observationCardinalityNext, feeProtocol, unlocked = staticcall UniV3Pool(_pool).slot0()\n    return convert(sqrtPriceX96, uint256)\n\n\n####################\n# Core Router Pool #\n####################\n\n\n@external\ndef setCoreRouterPool(_addr: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.coreRouterPool = _addr\n    log UniV3CoreRouterPoolSet(pool=_addr)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log UniV3FundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log UniV3NftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log UniswapV3LegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log UniswapV3Activated(isActivated=_shouldActivate)",
            "sha256sum": "2ec1d4facb8a830327243c457456f92fd3698ffe76a8177fc23abb569dfc5d73"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/LegoUniswapV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "051bf51d6d6d2291081ad59d1e29242439cd1f4bc8ebf73e8a70970bb80714ab"
      },
      "args": "00000000000000000000000033128a8fc17869897dce68ed026d694621f6fdfd00000000000000000000000003a520b32c04bf3beef7beb72e919cf822ed34f10000000000000000000000003d4e44eb1374240ce5f1b871ab261cd16335b76a00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd000000000000000000000000d0b53d9277642d899df5c87a3966a349a798f224"
    },
    "LegoHelper": {
      "address": "0xd313d00cC5E2129799B90Ad538334BB19e17dfEd",
      "abi": [
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aaveV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aaveV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "euler",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fluid",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fluidId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "moonwell",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "moonwellId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morpho",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morphoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "sky",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "skyId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV2",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV2Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodrome",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeSlipstream",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeSlipstreamId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curve",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curveId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "legoDesc",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_amountInAvailable",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_amountInAvailable",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "prepareSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_routes",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOutViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOutViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountInViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountInViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ROUTER_TOKENA",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ROUTER_TOKENB",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "SKY_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_SLIPSTREAM_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_routerTokenA",
              "type": "address"
            },
            {
              "name": "_routerTokenB",
              "type": "address"
            },
            {
              "name": "_aaveV3Id",
              "type": "uint256"
            },
            {
              "name": "_compoundV3Id",
              "type": "uint256"
            },
            {
              "name": "_eulerId",
              "type": "uint256"
            },
            {
              "name": "_fluidId",
              "type": "uint256"
            },
            {
              "name": "_moonwellId",
              "type": "uint256"
            },
            {
              "name": "_morphoId",
              "type": "uint256"
            },
            {
              "name": "_skyId",
              "type": "uint256"
            },
            {
              "name": "_uniswapV2Id",
              "type": "uint256"
            },
            {
              "name": "_uniswapV3Id",
              "type": "uint256"
            },
            {
              "name": "_aerodromeId",
              "type": "uint256"
            },
            {
              "name": "_aerodromeSlipstreamId",
              "type": "uint256"
            },
            {
              "name": "_curveId",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "contracts/core/LegoHelper.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nfrom interfaces import LegoYield\nfrom interfaces import LegoDex\nfrom ethereum.ercs import IERC20\n\ninterface LegoRegistry:\n    def getLegoAddr(_legoId: uint256) -> address: view\n    def isValidLegoId(_legoId: uint256) -> bool: view\n    def legoInfo(_legoId: uint256) -> LegoInfo: view\n    def numLegos() -> uint256: view\n\ninterface LegoDexNonStandard:\n    def getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256): nonpayable\n    def getSwapAmountOut(_pool: address, _tokenIn: address, _tokenOut: address, _amountIn: uint256) -> uint256: nonpayable\n    def getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256): nonpayable\n    def getSwapAmountIn(_pool: address, _tokenIn: address, _tokenOut: address, _amountOut: uint256) -> uint256: nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nflag LegoType:\n    YIELD_OPP\n    DEX\n\nstruct SwapRoute:\n    legoId: uint256\n    pool: address\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    amountOut: uint256\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct UnderlyingData:\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    legoDesc: String[64]\n\nstruct LegoInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n    legoType: LegoType\n\nADDY_REGISTRY: public(immutable(address))\n\n# key router tokens\nROUTER_TOKENA: public(immutable(address))\nROUTER_TOKENB: public(immutable(address))\n\n# yield lego ids\nAAVE_V3_ID: public(immutable(uint256))\nCOMPOUND_V3_ID: public(immutable(uint256))\nEULER_ID: public(immutable(uint256))\nFLUID_ID: public(immutable(uint256))\nMOONWELL_ID: public(immutable(uint256))\nMORPHO_ID: public(immutable(uint256))\nSKY_ID: public(immutable(uint256))\n\n# dex lego ids\nUNISWAP_V2_ID: public(immutable(uint256))\nUNISWAP_V3_ID: public(immutable(uint256))\nAERODROME_ID: public(immutable(uint256))\nAERODROME_SLIPSTREAM_ID: public(immutable(uint256))\nCURVE_ID: public(immutable(uint256))\n\nMAX_ROUTES: constant(uint256) = 10\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_LEGOS: constant(uint256) = 20\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\n\n\n@deploy\ndef __init__(\n    _addyRegistry: address,\n    _routerTokenA: address,\n    _routerTokenB: address,\n    # yield lego ids\n    _aaveV3Id: uint256,\n    _compoundV3Id: uint256,\n    _eulerId: uint256,\n    _fluidId: uint256,\n    _moonwellId: uint256,\n    _morphoId: uint256,\n    _skyId: uint256,\n    # dex lego ids\n    _uniswapV2Id: uint256,\n    _uniswapV3Id: uint256,\n    _aerodromeId: uint256,\n    _aerodromeSlipstreamId: uint256,\n    _curveId: uint256,\n):\n    assert empty(address) not in [_addyRegistry, _routerTokenA, _routerTokenB] # dev: invalid address\n    ADDY_REGISTRY = _addyRegistry\n    ROUTER_TOKENA = _routerTokenA\n    ROUTER_TOKENB = _routerTokenB\n\n    # yield lego ids\n    legoRegistry: address = staticcall AddyRegistry(_addyRegistry).getAddy(2)\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_aaveV3Id) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_compoundV3Id) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_eulerId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_fluidId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_moonwellId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_morphoId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_skyId) # dev: invalid id\n\n    AAVE_V3_ID = _aaveV3Id\n    COMPOUND_V3_ID = _compoundV3Id\n    EULER_ID = _eulerId\n    FLUID_ID = _fluidId\n    MOONWELL_ID = _moonwellId\n    MORPHO_ID = _morphoId\n    SKY_ID = _skyId\n\n    # dex lego ids\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_uniswapV2Id) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_uniswapV3Id) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_aerodromeId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_aerodromeSlipstreamId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_curveId) # dev: invalid id\n\n    UNISWAP_V2_ID = _uniswapV2Id\n    UNISWAP_V3_ID = _uniswapV3Id\n    AERODROME_ID = _aerodromeId\n    AERODROME_SLIPSTREAM_ID = _aerodromeSlipstreamId\n    CURVE_ID = _curveId\n\n\n###############\n# Yield Legos #\n###############\n\n\n@view\n@external\ndef aaveV3() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(AAVE_V3_ID)\n\n\n@view\n@external\ndef aaveV3Id() -> uint256:\n    return AAVE_V3_ID\n\n\n@view\n@external\ndef compoundV3() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(COMPOUND_V3_ID)\n\n\n@view\n@external\ndef compoundV3Id() -> uint256:\n    return COMPOUND_V3_ID\n\n\n@view\n@external\ndef euler() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(EULER_ID)\n\n\n@view\n@external\ndef eulerId() -> uint256:\n    return EULER_ID\n\n\n@view\n@external\ndef fluid() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(FLUID_ID)\n\n\n@view\n@external\ndef fluidId() -> uint256:\n    return FLUID_ID\n\n\n@view\n@external\ndef moonwell() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(MOONWELL_ID)\n\n\n@view\n@external\ndef moonwellId() -> uint256:\n    return MOONWELL_ID\n\n\n@view\n@external\ndef morpho() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(MORPHO_ID)\n\n\n@view\n@external\ndef morphoId() -> uint256:\n    return MORPHO_ID\n\n\n@view\n@external\ndef sky() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(SKY_ID)\n\n\n@view\n@external\ndef skyId() -> uint256:\n    return SKY_ID\n\n\n#############\n# DEX Legos #\n#############\n\n\n@view\n@external\ndef uniswapV2() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(UNISWAP_V2_ID)\n\n\n@view\n@external\ndef uniswapV2Id() -> uint256:\n    return UNISWAP_V2_ID\n\n\n@view\n@external\ndef uniswapV3() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(UNISWAP_V3_ID)\n\n\n@view\n@external\ndef uniswapV3Id() -> uint256:\n    return UNISWAP_V3_ID\n\n\n@view\n@external\ndef aerodrome() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(AERODROME_ID)\n\n\n@view\n@external\ndef aerodromeId() -> uint256:\n    return AERODROME_ID\n\n\n@view\n@external\ndef aerodromeSlipstream() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(AERODROME_SLIPSTREAM_ID)\n\n\n@view\n@external\ndef aerodromeSlipstreamId() -> uint256:\n    return AERODROME_SLIPSTREAM_ID\n\n\n@view\n@external\ndef curve() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(CURVE_ID)\n\n\n@view\n@external\ndef curveId() -> uint256:\n    return CURVE_ID\n\n\n#################\n# Yield Helpers #\n#################\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if _assetAmount == 0 or _asset == empty(address) or _vaultToken == empty(address):\n        return 0\n\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: LegoInfo = staticcall LegoRegistry(legoRegistry).legoInfo(i)\n        if legoInfo.legoType != LegoType.YIELD_OPP:\n            continue\n\n        vaultTokenAmount: uint256 = staticcall LegoYield(legoInfo.addr).getVaultTokenAmount(_asset, _assetAmount, _vaultToken)\n        if vaultTokenAmount != 0:\n            return vaultTokenAmount\n\n    return 0\n\n\n@view\n@external\ndef getLegoFromVaultToken(_vaultToken: address) -> (uint256, address, String[64]):\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: LegoInfo = staticcall LegoRegistry(legoRegistry).legoInfo(i)\n        if legoInfo.legoType != LegoType.YIELD_OPP:\n            continue\n        if staticcall LegoYield(legoInfo.addr).isVaultToken(_vaultToken):\n            return i, legoInfo.addr, legoInfo.description\n    return 0, empty(address), \"\"\n\n\n@view\n@external\ndef getUnderlyingData(_asset: address, _amount: uint256) -> UnderlyingData:\n    if _amount == 0 or _asset == empty(address):\n        return empty(UnderlyingData)\n\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    oracleRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: LegoInfo = staticcall LegoRegistry(legoRegistry).legoInfo(i)\n        if legoInfo.legoType != LegoType.YIELD_OPP:\n            continue\n\n        asset: address = empty(address)\n        underlyingAmount: uint256 = 0\n        usdValue: uint256 = 0\n        asset, underlyingAmount, usdValue = staticcall LegoYield(legoInfo.addr).getUnderlyingData(_asset, _amount, oracleRegistry)\n        if asset != empty(address):\n            return UnderlyingData(\n                asset=asset,\n                amount=underlyingAmount,\n                usdValue=usdValue,\n                legoId=i,\n                legoAddr=legoInfo.addr,\n                legoDesc=legoInfo.description,\n            )\n\n    return UnderlyingData(\n        asset=_asset,\n        amount=_amount,\n        usdValue=staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount),\n        legoId=0,\n        legoAddr=empty(address),\n        legoDesc=\"\",\n    )\n\n\n########################\n# Dex: Swap High Level #\n########################\n\n\n@external\ndef getRoutesAndSwapInstructionsAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _slippage: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    routes: DynArray[SwapRoute, MAX_ROUTES] = self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, _amountIn, _includeLegoIds)\n    return self._prepareSwapInstructionsAmountOut(_slippage, routes)\n\n\n@external\ndef getRoutesAndSwapInstructionsAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _amountInAvailable: uint256,\n    _slippage: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    routes: DynArray[SwapRoute, MAX_ROUTES] = self._getBestSwapRoutesAmountIn(_tokenIn, _tokenOut, _amountOut, _includeLegoIds)\n    if len(routes) == 0:\n        return []\n\n    # let's re-run the routes with amountIn as input (this is more accurate, for example, Aerodrome doesn't have getAmountIn for stable pools\n    amountIn: uint256 = min(_amountInAvailable, routes[0].amountIn)\n    routes = self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, amountIn, _includeLegoIds)\n    return self._prepareSwapInstructionsAmountOut(_slippage, routes)\n\n\n########################\n# Dex: Swap Amount Out #\n########################\n\n\n# prepare swap instructions (amountIn as input)\n\n\n@external\ndef prepareSwapInstructionsAmountOut(_slippage: uint256, _routes: DynArray[SwapRoute, MAX_ROUTES]) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    return self._prepareSwapInstructionsAmountOut(_slippage, _routes)\n\n\n@internal\ndef _prepareSwapInstructionsAmountOut(_slippage: uint256, _routes: DynArray[SwapRoute, MAX_ROUTES]) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    if len(_routes) == 0:\n        return []\n\n    instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS] = []\n\n    # start with first route\n    prevRoute: SwapRoute = _routes[0]\n    prevInstruction: SwapInstruction = self._createNewInstruction(prevRoute, _slippage)\n\n    # iterate thru swap routes, skip first\n    for i: uint256 in range(1, len(_routes), bound=MAX_ROUTES):\n        newRoute: SwapRoute = _routes[i]\n        assert prevRoute.tokenOut == newRoute.tokenIn # dev: invalid route\n\n        # add to previous instruction\n        if prevRoute.legoId == newRoute.legoId:\n            prevInstruction.minAmountOut = newRoute.amountOut * (HUNDRED_PERCENT - _slippage) // HUNDRED_PERCENT\n            prevInstruction.tokenPath.append(newRoute.tokenOut)\n            prevInstruction.poolPath.append(newRoute.pool)\n\n        # create new instruction\n        else:\n            instructions.append(prevInstruction)\n            prevInstruction = self._createNewInstruction(newRoute, _slippage)\n\n        # set previous item\n        prevRoute = newRoute\n\n    # add last instruction\n    instructions.append(prevInstruction)\n    return instructions\n\n\n@view\n@internal\ndef _createNewInstruction(_route: SwapRoute, _slippage: uint256) -> SwapInstruction:\n    return SwapInstruction(\n        legoId=_route.legoId,\n        amountIn=_route.amountIn,\n        minAmountOut=_route.amountOut * (HUNDRED_PERCENT - _slippage) // HUNDRED_PERCENT,\n        tokenPath=[_route.tokenIn, _route.tokenOut],\n        poolPath=[_route.pool],\n    )\n\n\n# best swap routes (amountIn as input)\n\n\n@external\ndef getBestSwapRoutesAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    return self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, _amountIn, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapRoutesAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    if _tokenIn == _tokenOut or _amountIn == 0 or empty(address) in [_tokenIn, _tokenOut]:\n        return []\n\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n\n    # required data\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    routerTokenA: address = ROUTER_TOKENA\n    routerTokenB: address = ROUTER_TOKENB\n\n    # direct swap route\n    directSwapRoute: SwapRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _tokenOut, _amountIn, numLegos, legoRegistry, _includeLegoIds)\n\n    # check with router pools\n    withRouterHopAmountOut: uint256 = 0\n    withHopRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    withRouterHopAmountOut, withHopRoutes = self._getBestSwapAmountOutWithRouterPool(routerTokenA, routerTokenB, _tokenIn, _tokenOut, _amountIn, numLegos, legoRegistry, _includeLegoIds)\n\n    # compare direct swap route with hop routes\n    if directSwapRoute.amountOut > withRouterHopAmountOut:\n        bestSwapRoutes = [directSwapRoute]\n\n    # update router token pool (if possible)\n    elif withRouterHopAmountOut != 0:\n        bestSwapRoutes = withHopRoutes\n\n    return bestSwapRoutes\n\n\n# check various routes via core router pools\n\n\n@external\ndef getBestSwapAmountOutWithRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    return self._getBestSwapAmountOutWithRouterPool(ROUTER_TOKENA, ROUTER_TOKENB, _tokenIn, _tokenOut, _amountIn, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountOutWithRouterPool(\n    _routerTokenA: address,\n    _routerTokenB: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n\n    # nothing to do, already have router pool to use\n    if self._isRouterPool(_tokenIn, _tokenOut, _routerTokenA, _routerTokenB):\n        return 0, []\n\n    isMultiHop: bool = False\n    finalAmountOut: uint256 = 0\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    firstRoute: SwapRoute = empty(SwapRoute)\n    secondRoute: SwapRoute = empty(SwapRoute)\n\n    # usdc -> weth -> tokenOut\n    if _tokenIn == _routerTokenA:\n        firstRoute = self._getSwapAmountOutViaRouterPool(_routerTokenA, _routerTokenB, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getBestSwapAmountOutSinglePool(_routerTokenB, _tokenOut, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> weth -> usdc\n    elif _tokenOut == _routerTokenA:\n        firstRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _routerTokenB, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getSwapAmountOutViaRouterPool(_routerTokenB, _routerTokenA, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # weth -> usdc -> tokenOut\n    elif _tokenIn == _routerTokenB:\n        firstRoute = self._getSwapAmountOutViaRouterPool(_routerTokenB, _routerTokenA, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getBestSwapAmountOutSinglePool(_routerTokenA, _tokenOut, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> usdc -> weth\n    elif _tokenOut == _routerTokenB:\n        firstRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _routerTokenA, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getSwapAmountOutViaRouterPool(_routerTokenA, _routerTokenB, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # let's try multi hop routes\n    else:\n        isMultiHop = True\n\n        # router token A as starting point\n        viaRouterTokenAAmountOut: uint256 = 0\n        viaRouterTokenARoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenAAmountOut, viaRouterTokenARoutes = self._checkRouterPoolForMiddleSwapAmountOut(_routerTokenA, _routerTokenB, _tokenIn, _tokenOut, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # router token B as starting point\n        viaRouterTokenBAmountOut: uint256 = 0\n        viaRouterTokenBRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenBAmountOut, viaRouterTokenBRoutes = self._checkRouterPoolForMiddleSwapAmountOut(_routerTokenB, _routerTokenA, _tokenIn, _tokenOut, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # compare\n        if viaRouterTokenAAmountOut > viaRouterTokenBAmountOut:\n            finalAmountOut = viaRouterTokenAAmountOut\n            bestSwapRoutes = viaRouterTokenARoutes\n        elif viaRouterTokenBAmountOut != 0:\n            finalAmountOut = viaRouterTokenBAmountOut\n            bestSwapRoutes = viaRouterTokenBRoutes\n\n    if not isMultiHop:\n        finalAmountOut = secondRoute.amountOut\n        bestSwapRoutes = [firstRoute, secondRoute]\n\n    return finalAmountOut, bestSwapRoutes\n\n\n@internal\ndef _checkRouterPoolForMiddleSwapAmountOut(\n    _firstRouterTokenHop: address,\n    _secondRouterTokenHop: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    secondHopToTokenOut: SwapRoute = empty(SwapRoute)\n\n    # tokenIn -> first Router Token\n    tokenInToFirstHop: SwapRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _firstRouterTokenHop, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n    if tokenInToFirstHop.amountOut == 0:\n        return 0, []\n\n    # first Router Token -> tokenOut\n    firstHopToTokenOut: SwapRoute = self._getBestSwapAmountOutSinglePool(_firstRouterTokenHop, _tokenOut, tokenInToFirstHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # first Router Token -> second Router Token -- this will always happen in router pools (i.e. usdc <-> weth)\n    firstHopToSecondHop: SwapRoute = self._getSwapAmountOutViaRouterPool(_firstRouterTokenHop, _secondRouterTokenHop, tokenInToFirstHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # second Router Token -> tokenOut\n    if firstHopToSecondHop.amountOut != 0:\n        secondHopToTokenOut = self._getBestSwapAmountOutSinglePool(_secondRouterTokenHop, _tokenOut, firstHopToSecondHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # compare routes\n    if firstHopToTokenOut.amountOut > secondHopToTokenOut.amountOut:\n        return firstHopToTokenOut.amountOut, [tokenInToFirstHop, firstHopToTokenOut]\n    elif secondHopToTokenOut.amountOut != 0:\n        return secondHopToTokenOut.amountOut, [tokenInToFirstHop, firstHopToSecondHop, secondHopToTokenOut]\n    return 0, []\n\n\n# single pool\n\n\n@external\ndef getBestSwapAmountOutSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    return self._getBestSwapAmountOutSinglePool(_tokenIn, _tokenOut, _amountIn, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountOutSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=_amountIn,\n        amountOut=0,\n    )\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego info\n        legoInfo: LegoInfo = staticcall LegoRegistry(_legoRegistry).legoInfo(i)\n        if legoInfo.legoType != LegoType.DEX:\n            continue\n\n        pool: address = empty(address)\n        amountOut: uint256 = 0\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            pool, amountOut = extcall LegoDexNonStandard(legoInfo.addr).getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n        else:\n            pool, amountOut = staticcall LegoDex(legoInfo.addr).getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n\n        # compare best\n        if pool != empty(address) and amountOut > bestRoute.amountOut:\n            bestRoute.pool = pool\n            bestRoute.amountOut = amountOut\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n# router pool only\n\n\n@external\ndef getSwapAmountOutViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    return self._getSwapAmountOutViaRouterPool(_tokenIn, _tokenOut, _amountIn, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getSwapAmountOutViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    # NOTE: _tokenIn and _tokenOut need to be ROUTER_TOKENA/ROUTER_TOKENB -- in the `getCoreRouterPool()` pool\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=_amountIn,\n        amountOut=0,\n    )\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego info\n        legoInfo: LegoInfo = staticcall LegoRegistry(_legoRegistry).legoInfo(i)\n        if legoInfo.legoType != LegoType.DEX:\n            continue\n\n        # get router pool\n        pool: address = staticcall LegoDex(legoInfo.addr).getCoreRouterPool()\n        if pool == empty(address):\n            continue\n\n        amountOut: uint256 = 0\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            amountOut = extcall LegoDexNonStandard(legoInfo.addr).getSwapAmountOut(pool, _tokenIn, _tokenOut, _amountIn)\n        else:\n            amountOut = staticcall LegoDex(legoInfo.addr).getSwapAmountOut(pool, _tokenIn, _tokenOut, _amountIn)\n\n        # compare best\n        if amountOut > bestRoute.amountOut:\n            bestRoute.pool = pool\n            bestRoute.amountOut = amountOut\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n#######################\n# Dex: Swap Amount In #\n#######################\n\n\n# best swap routes (amountOut as input)\n\n\n@external\ndef getBestSwapRoutesAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    return self._getBestSwapRoutesAmountIn(_tokenIn, _tokenOut, _amountOut, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapRoutesAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    if _tokenIn == _tokenOut or _amountOut == 0 or empty(address) in [_tokenIn, _tokenOut]:\n        return []\n\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n\n    # required data\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    routerTokenA: address = ROUTER_TOKENA\n    routerTokenB: address = ROUTER_TOKENB\n\n    # direct swap route\n    directSwapRoute: SwapRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _tokenOut, _amountOut, numLegos, legoRegistry, _includeLegoIds)\n\n    # check with router pools\n    withRouterHopAmountIn: uint256 = 0\n    withHopRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    withRouterHopAmountIn, withHopRoutes = self._getBestSwapAmountInWithRouterPool(routerTokenA, routerTokenB, _tokenIn, _tokenOut, _amountOut, numLegos, legoRegistry, _includeLegoIds)\n\n    # compare direct swap route with hop routes\n    if directSwapRoute.amountIn < withRouterHopAmountIn:\n        bestSwapRoutes = [directSwapRoute]\n\n    # update router token pool (if possible)\n    elif withRouterHopAmountIn != max_value(uint256):\n        bestSwapRoutes = withHopRoutes\n\n    return bestSwapRoutes\n\n\n# check various routes via core router pools\n\n\n@external\ndef getBestSwapAmountInWithRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    return self._getBestSwapAmountInWithRouterPool(ROUTER_TOKENA, ROUTER_TOKENB, _tokenIn, _tokenOut, _amountOut, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountInWithRouterPool(\n    _routerTokenA: address,\n    _routerTokenB: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n\n    # nothing to do, already have router pool to use\n    if self._isRouterPool(_tokenIn, _tokenOut, _routerTokenA, _routerTokenB):\n        return max_value(uint256), []\n\n    isMultiHop: bool = False\n    finalAmountIn: uint256 = max_value(uint256)\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    firstRoute: SwapRoute = empty(SwapRoute)\n    secondRoute: SwapRoute = empty(SwapRoute)\n\n    # usdc -> weth -> tokenOut\n    if _tokenIn == _routerTokenA:\n        secondRoute = self._getBestSwapAmountInSinglePool(_routerTokenB, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getSwapAmountInViaRouterPool(_routerTokenA, _routerTokenB, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> weth -> usdc\n    elif _tokenOut == _routerTokenA:\n        secondRoute = self._getSwapAmountInViaRouterPool(_routerTokenB, _routerTokenA, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _routerTokenB, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # weth -> usdc -> tokenOut\n    elif _tokenIn == _routerTokenB:\n        secondRoute = self._getBestSwapAmountInSinglePool(_routerTokenA, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getSwapAmountInViaRouterPool(_routerTokenB, _routerTokenA, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> usdc -> weth\n    elif _tokenOut == _routerTokenB:\n        secondRoute = self._getSwapAmountInViaRouterPool(_routerTokenA, _routerTokenB, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _routerTokenA, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # let's try multi hop routes\n    else:\n        isMultiHop = True\n\n        # router token A as starting point\n        viaRouterTokenAAmountIn: uint256 = 0\n        viaRouterTokenARoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenAAmountIn, viaRouterTokenARoutes = self._checkRouterPoolForMiddleSwapAmountIn(_routerTokenA, _routerTokenB, _tokenIn, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # router token B as starting point\n        viaRouterTokenBAmountIn: uint256 = 0\n        viaRouterTokenBRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenBAmountIn, viaRouterTokenBRoutes = self._checkRouterPoolForMiddleSwapAmountIn(_routerTokenB, _routerTokenA, _tokenIn, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # compare\n        if viaRouterTokenAAmountIn < viaRouterTokenBAmountIn:\n            finalAmountIn = viaRouterTokenAAmountIn\n            bestSwapRoutes = viaRouterTokenARoutes\n        elif viaRouterTokenBAmountIn != max_value(uint256):\n            finalAmountIn = viaRouterTokenBAmountIn\n            bestSwapRoutes = viaRouterTokenBRoutes\n\n    if not isMultiHop:\n        finalAmountIn = firstRoute.amountIn\n        bestSwapRoutes = [firstRoute, secondRoute]\n\n    return finalAmountIn, bestSwapRoutes\n\n\n@internal\ndef _checkRouterPoolForMiddleSwapAmountIn(\n    _firstRouterToken: address,\n    _secondRouterToken: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    tokenInToFirstHop: SwapRoute = empty(SwapRoute)\n    tokenInToFirstHop.amountIn = max_value(uint256)\n\n    # second Router Token -> tokenOut\n    secondHopToTokenOut: SwapRoute = self._getBestSwapAmountInSinglePool(_secondRouterToken, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n    if secondHopToTokenOut.amountIn == max_value(uint256):\n        return max_value(uint256), []\n\n    # tokenIn -> second Router Token\n    tokenInToSecondHop: SwapRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _secondRouterToken, secondHopToTokenOut.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # first Router Token -> second Router Token -- this will always happen in router pools (i.e. usdc <-> weth)\n    firstHopToSecondHop: SwapRoute = self._getSwapAmountInViaRouterPool(_firstRouterToken, _secondRouterToken, secondHopToTokenOut.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> first Router Token\n    if firstHopToSecondHop.amountIn != max_value(uint256):\n        tokenInToFirstHop = self._getBestSwapAmountInSinglePool(_tokenIn, _firstRouterToken, firstHopToSecondHop.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # compare routes\n    if tokenInToSecondHop.amountIn < tokenInToFirstHop.amountIn:\n        return tokenInToSecondHop.amountIn, [tokenInToSecondHop, secondHopToTokenOut]\n    elif tokenInToFirstHop.amountIn != max_value(uint256):\n        return tokenInToFirstHop.amountIn, [tokenInToFirstHop, firstHopToSecondHop, secondHopToTokenOut]\n    return max_value(uint256), []\n\n\n# single pool\n\n\n@external\ndef getBestSwapAmountInSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    return self._getBestSwapAmountInSinglePool(_tokenIn, _tokenOut, _amountOut, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountInSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=max_value(uint256),\n        amountOut=_amountOut,\n    )\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        legoInfo: LegoInfo = staticcall LegoRegistry(_legoRegistry).legoInfo(i)\n        if legoInfo.legoType != LegoType.DEX:\n            continue\n\n        pool: address = empty(address)\n        amountIn: uint256 = max_value(uint256)\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            pool, amountIn = extcall LegoDexNonStandard(legoInfo.addr).getBestSwapAmountIn(_tokenIn, _tokenOut, _amountOut)\n        else:\n            pool, amountIn = staticcall LegoDex(legoInfo.addr).getBestSwapAmountIn(_tokenIn, _tokenOut, _amountOut)\n\n        # compare best\n        if pool != empty(address) and amountIn != 0 and amountIn < bestRoute.amountIn:\n            bestRoute.pool = pool\n            bestRoute.amountIn = amountIn\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n# router pool only\n\n\n@external\ndef getSwapAmountInViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegos()\n    return self._getSwapAmountInViaRouterPool(_tokenIn, _tokenOut, _amountOut, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getSwapAmountInViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    # NOTE: _tokenIn and _tokenOut need to be ROUTER_TOKENA/ROUTER_TOKENB -- in the `getCoreRouterPool()` pool\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=max_value(uint256),\n        amountOut=_amountOut,\n    )\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        legoInfo: LegoInfo = staticcall LegoRegistry(_legoRegistry).legoInfo(i)\n        if legoInfo.legoType != LegoType.DEX:\n            continue\n\n        # get router pool\n        pool: address = staticcall LegoDex(legoInfo.addr).getCoreRouterPool()\n        if pool == empty(address):\n            continue\n\n        amountIn: uint256 = max_value(uint256)\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            amountIn = extcall LegoDexNonStandard(legoInfo.addr).getSwapAmountIn(pool, _tokenIn, _tokenOut, _amountOut)\n        else:\n            amountIn = staticcall LegoDex(legoInfo.addr).getSwapAmountIn(pool, _tokenIn, _tokenOut, _amountOut)\n\n        # compare best\n        if amountIn != 0 and amountIn < bestRoute.amountIn:\n            bestRoute.pool = pool\n            bestRoute.amountIn = amountIn\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n@view\n@internal\ndef _isRouterPool(_tokenIn: address, _tokenOut: address, _routerTokenA: address, _routerTokenB: address) -> bool:\n    return _tokenIn in [_routerTokenA, _routerTokenB] and _tokenOut in [_routerTokenA, _routerTokenB]\n",
            "sha256sum": "a7091b77c9ced17debc901a9159dc27e41beeca2f9e31ff894a0a401e24822bc"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/LegoHelper.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "1bbe46cf384ce7fa5e31aefc869f3df4ee9ff782234148bc7a32e638200d28df"
      },
      "args": "00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda0291300000000000000000000000042000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a"
    }
  }
}