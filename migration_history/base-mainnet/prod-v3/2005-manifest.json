{
  "contracts": {
    "AddyRegistry": {
      "address": "0x7BcD6d471D1A068012A79347C7a944d1Df01a1AE",
      "abi": [
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewPendingAddyCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdatePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisablePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddy",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyUpdate",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyDisable",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyId",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddy",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyInfo",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyDescription",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddyAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddyId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyToId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddy",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddyUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddyDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_ADDY_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_ADDY_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "REGISTRY_STR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setIsUserWalletOrAgent",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_isThing",
              "type": "bool"
            },
            {
              "name": "_setUserWalletMap",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewAddy",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddy",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingNewAddy",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAddyAddr",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddyUpdate",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAddyUpdate",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableAddyAddr",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddyDisable",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAddyDisable",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAddyChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAddyChangeDelayToMin",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserWallet",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgent",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minGovChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxGovChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_minRegistryChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/Registry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nstruct AddyInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddy:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddyPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddyConfirmed:\n    addr: indexed(address)\n    addyId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewPendingAddyCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdatePending:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdateConfirmed:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyUpdateCancelled:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisablePending:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisableConfirmed:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyDisableCancelled:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyChangeDelaySet:\n    delayBlocks: uint256\n    registry: String[28]\n\n# core registry\naddyInfo: public(HashMap[uint256, AddyInfo])\naddyToId: public(HashMap[address, uint256])\nnumAddys: public(uint256)\n\n# pending changes\npendingNewAddy: public(HashMap[address, PendingNewAddy]) # addr -> pending new addy\npendingAddyUpdate: public(HashMap[uint256, PendingAddyUpdate]) # addyId -> pending addy update\npendingAddyDisable: public(HashMap[uint256, PendingAddyDisable]) # addyId -> pending addy disable\naddyChangeDelay: public(uint256)\n\nMIN_ADDY_CHANGE_DELAY: public(immutable(uint256))\nMAX_ADDY_CHANGE_DELAY: public(immutable(uint256))\nREGISTRY_STR: public(immutable(String[28]))\n\n\n@deploy\ndef __init__(_minAddyChangeDelay: uint256, _maxAddyChangeDelay: uint256, _registryStr: String[28]):\n    assert _minAddyChangeDelay < _maxAddyChangeDelay # dev: invalid delay\n    MIN_ADDY_CHANGE_DELAY = _minAddyChangeDelay\n    MAX_ADDY_CHANGE_DELAY = _maxAddyChangeDelay\n\n    REGISTRY_STR = _registryStr\n\n    # start at 1 index\n    self.numAddys = 1\n\n\n############\n# New Addy #\n############\n\n\n@view\n@external\ndef isValidNewAddy(_addr: address) -> bool:\n    return self._isValidNewAddy(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddy(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addyToId[_addr] == 0\n\n\n@internal\ndef _registerNewAddy(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new address in the registry\n    @dev This function sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address to be registered\n    @param _description A short description of the address (max 64 characters)\n    @return True if the registration was successfully initiated, False if the address is invalid\n    \"\"\"\n    if not self._isValidNewAddy(_addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingNewAddy[_addr] = PendingNewAddy(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddyPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmNewAddy(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending address registration after the required delay period\n    @dev This function finalizes the registration by assigning an ID and storing the address info\n    @param _addr The address to confirm registration for\n    @return The assigned ID for the registered address, or 0 if confirmation fails\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    if not self._isValidNewAddy(_addr):\n        self.pendingNewAddy[_addr] = empty(PendingNewAddy) # clear pending\n        return 0\n\n    # register new addy\n    addyId: uint256 = self.numAddys\n    self.addyToId[_addr] = addyId\n    self.numAddys = addyId + 1\n    self.addyInfo[addyId] = AddyInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n\n    log NewAddyConfirmed(addr=_addr, addyId=addyId, description=data.description, registry=REGISTRY_STR)\n    return addyId\n\n\n@internal\ndef _cancelPendingNewAddy(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending address registration\n    @dev This function removes the pending registration and emits a cancellation event\n    @param _addr The address whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n    log NewPendingAddyCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n###############\n# Update Addy #\n###############\n\n\n@view\n@external\ndef isValidAddyUpdate(_addyId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddyUpdate(_addyId, _newAddr, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyUpdate(_addyId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    if not self._isValidNewAddy(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@internal\ndef _updateAddyAddr(_addyId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered address\n    @dev This function sets up a pending update that requires confirmation after a delay period\n    @param _addyId The ID of the address to update\n    @param _newAddr The new address to set\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyUpdate(_addyId, _newAddr, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyUpdate[_addyId] = PendingAddyUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyUpdatePending(addyId=_addyId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address update after the required delay period\n    @dev This function finalizes the update by updating the address info and version\n    @param _addyId The ID of the address to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyUpdate(_addyId, pendingData.newAddr, prevAddr):\n        self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = pendingData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[pendingData.newAddr] = _addyId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n\n    log AddyUpdateConfirmed(addyId=_addyId, description=data.description, newAddr=pendingData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address update\n    @dev This function removes the pending update and emits a cancellation event\n    @param _addyId The ID of the address whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyUpdateCancelled(addyId=_addyId, description=prevData.description, newAddr=pendingData.newAddr, prevAddr=prevData.addr, initiatedBlock=pendingData.initiatedBlock, confirmBlock=pendingData.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Disable Addy #\n################\n\n\n@view\n@external\ndef isValidAddyDisable(_addyId: uint256) -> bool:\n    return self._isValidAddyDisable(_addyId, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyDisable(_addyId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@internal\ndef _disableAddyAddr(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered address\n    @dev This function sets up a pending disable that requires confirmation after a delay period\n    @param _addyId The ID of the address to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyDisable(_addyId, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyDisable[_addyId] = PendingAddyDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyDisablePending(addyId=_addyId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address disable after the required delay period\n    @dev This function finalizes the disable by clearing the address and updating version\n    @param _addyId The ID of the address to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyDisable(_addyId, prevAddr):\n        self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n\n    log AddyDisableConfirmed(addyId=_addyId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address disable\n    @dev This function removes the pending disable and emits a cancellation event\n    @param _addyId The ID of the address whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    data: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyDisableCancelled(addyId=_addyId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Change Delay #\n################\n\n\n@internal\ndef _setAddyChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for address changes\n    @dev The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert _numBlocks >= MIN_ADDY_CHANGE_DELAY and _numBlocks <= MAX_ADDY_CHANGE_DELAY # dev: invalid delay\n    self.addyChangeDelay = _numBlocks\n    log AddyChangeDelaySet(delayBlocks=_numBlocks, registry=REGISTRY_STR)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidAddyAddr(_addr: address) -> bool:\n    return self._isValidAddyAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddyAddr(_addr: address) -> bool:\n    return self.addyToId[_addr] != 0\n\n\n@view\n@external\ndef isValidAddyId(_addyId: uint256) -> bool:\n    return self._isValidAddyId(_addyId)\n\n\n@view\n@internal\ndef _isValidAddyId(_addyId: uint256) -> bool:\n    return _addyId != 0 and _addyId < self.numAddys\n\n\n# addy getters\n\n\n@view\n@external\ndef getAddyId(_addr: address) -> uint256:\n    return self._getAddyId(_addr)\n\n\n@view\n@internal\ndef _getAddyId(_addr: address) -> uint256:\n    return self.addyToId[_addr]\n\n\n@view\n@external\ndef getAddy(_addyId: uint256) -> address:\n    return self._getAddy(_addyId)\n\n\n@view\n@internal\ndef _getAddy(_addyId: uint256) -> address:\n    return self.addyInfo[_addyId].addr\n\n\n@view\n@external\ndef getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self._getAddyInfo(_addyId)\n\n\n@view\n@internal\ndef _getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self.addyInfo[_addyId]\n\n\n@view\n@external\ndef getAddyDescription(_addyId: uint256) -> String[64]:\n    return self._getAddyDescription(_addyId)\n\n\n@view\n@internal\ndef _getAddyDescription(_addyId: uint256) -> String[64]:\n    return self.addyInfo[_addyId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumAddys() -> uint256:\n    return self._getNumAddys()\n\n\n@view\n@internal\ndef _getNumAddys() -> uint256:\n    return self.numAddys - 1\n\n\n@view\n@external\ndef getLastAddyAddr() -> address:\n    return self._getLastAddyAddr()\n\n\n@view\n@internal\ndef _getLastAddyAddr() -> address:\n    lastIndex: uint256 = self.numAddys - 1\n    return self.addyInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastAddyId() -> uint256:\n    return self._getLastAddyId()\n\n\n@view\n@internal\ndef _getLastAddyId() -> uint256:\n    return self.numAddys - 1\n",
            "sha256sum": "460d2db094c5b32c0788cc51d7e857c0e7e2f223f570937c46cb97599441b29e"
          },
          "contracts/core/registries/AddyRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\ninitializes: registry\n\nexports: gov.__interface__\nexports: registry.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Registry as registry\n\n# wallets / agents\nisUserWallet: public(HashMap[address, bool])\nisAgent: public(HashMap[address, bool])\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n    _minRegistryChangeDelay: uint256,\n    _maxRegistryChangeDelay: uint256,\n):\n    # initialize gov\n    gov.__init__(_initialGov, empty(address), _minGovChangeDelay, _maxGovChangeDelay)\n\n    # initialize registry\n    registry.__init__(_minRegistryChangeDelay, _maxRegistryChangeDelay, \"AddyRegistry.vy\")\n\n\n@external\ndef setIsUserWalletOrAgent(_addr: address, _isThing: bool, _setUserWalletMap: bool) -> bool:\n    assert registry._isValidAddyAddr(msg.sender) # dev: sender unknown\n    assert msg.sender == registry._getAddy(1) # dev: sender must be agent factory\n    if _addr == empty(address) or not _addr.is_contract: \n        return False\n    if _setUserWalletMap:\n        self.isUserWallet[_addr] = _isThing\n    else:\n        self.isAgent[_addr] = _isThing\n    return True\n\n\n############\n# New Addy #\n############\n\n\n@external\ndef registerNewAddy(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new address\n    @dev Only callable by governance. Sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address to register\n    @param _description A short description of the address (max 64 characters)\n    @return True if the registration was successfully initiated, False if the address is invalid\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._registerNewAddy(_addr, _description)\n\n\n@external\ndef confirmNewAddy(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending address registration after the required delay period\n    @dev Only callable by governance. Finalizes the registration by assigning an ID\n    @param _addr The address to confirm registration for\n    @return The assigned ID for the registered address, or 0 if confirmation fails\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmNewAddy(_addr)\n\n\n@external\ndef cancelPendingNewAddy(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending address registration\n    @dev Only callable by governance. Removes the pending registration and emits a cancellation event\n    @param _addr The address whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelPendingNewAddy(_addr)\n\n\n###############\n# Update Addy #\n###############\n\n\n@external\ndef updateAddyAddr(_addyId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered address\n    @dev Only callable by governance. Sets up a pending update that requires confirmation after a delay period\n    @param _addyId The ID of the address to update\n    @param _newAddr The new address to set\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._updateAddyAddr(_addyId, _newAddr)\n\n\n@external\ndef confirmAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address update after the required delay period\n    @dev Only callable by governance. Finalizes the update by updating the address info\n    @param _addyId The ID of the address to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmAddyUpdate(_addyId)\n\n\n@external\ndef cancelPendingAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address update\n    @dev Only callable by governance. Removes the pending update and emits a cancellation event\n    @param _addyId The ID of the address whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelPendingAddyUpdate(_addyId)\n\n\n################\n# Disable Addy #\n################\n\n\n@external\ndef disableAddyAddr(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered address\n    @dev Only callable by governance. Sets up a pending disable that requires confirmation after a delay period\n    @param _addyId The ID of the address to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._disableAddyAddr(_addyId)\n\n\n@external\ndef confirmAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address disable after the required delay period\n    @dev Only callable by governance. Finalizes the disable by clearing the address\n    @param _addyId The ID of the address to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmAddyDisable(_addyId)\n\n\n@external\ndef cancelPendingAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address disable\n    @dev Only callable by governance. Removes the pending disable and emits a cancellation event\n    @param _addyId The ID of the address whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelPendingAddyDisable(_addyId)\n\n\n################\n# Change Delay #\n################\n\n\n@external\ndef setAddyChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for address changes\n    @dev Only callable by governance. The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._setAddyChangeDelay(_numBlocks)\n\n\n@external\ndef setAddyChangeDelayToMin() -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._setAddyChangeDelay(registry.MIN_ADDY_CHANGE_DELAY)",
            "sha256sum": "77894bee6f9e3d1bb1ba2cc75d800df7d5e9859165b8af057ec18cc464f86e65"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/registries/AddyRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "b1e6d09dbd152641c55ee138c8f163779228a9cfe445e6e1d369aa7a48258cee"
      },
      "args": "0000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "UserWalletTemplate": {
      "address": "0xe43D5bD11a2A6A9348EFC516ad9Ac3D32164A5A0",
      "abi": [
        {
          "name": "UserWalletDeposit",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletWithdrawal",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundVaultTokenAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletSwap",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "swapAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "toAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletBorrow",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "borrowAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "borrowAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletRepayDebt",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "paymentAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "paymentAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "remainingDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletLiquidityAdded",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "liqAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletLiquidityRemoved",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": false
            },
            {
              "name": "removedAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "removedAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "refundedLpAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletFundsTransferred",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletRewardsClaimed",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": false
            },
            {
              "name": "market",
              "type": "address",
              "indexed": false
            },
            {
              "name": "rewardToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "rewardAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "proof",
              "type": "bytes32",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletEthConvertedToWeth",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "paidEth",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "weth",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletWethConvertedToEth",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "weth",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletSubscriptionPaid",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "paidThroughBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTransactionFeePaid",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "protocolRecipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "protocolAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRecipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ambassadorAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "fee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "action",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTrialFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountRecovered",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "remainingAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletNftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canBeAmbassador",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "clawBackTrialFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "migrateWalletOut",
          "inputs": [
            {
              "name": "_newWallet",
              "type": "address"
            },
            {
              "name": "_assetsToMigrate",
              "type": "address[]"
            },
            {
              "name": "_whitelistToMigrate",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "walletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsAsset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsInitialAmount",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "wethAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_walletConfig",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_trialFundsAsset",
              "type": "address"
            },
            {
              "name": "_trialFundsInitialAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "interfaces/LegoCredit.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (address, uint256, uint256):\n    ...\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (address, uint256, uint256, uint256):\n    ...\n",
            "sha256sum": "d7579ab6500e6022fa9cb561479c40d062438d29e002dcc5f66036eea7dc0856"
          },
          "interfaces/UserWalletInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n# struct SwapInstruction:\n#     legoId: uint256\n#     amountIn: uint256\n#     minAmountOut: uint256\n#     tokenPath: DynArray[address, 5]\n#     poolPath: DynArray[address, 5 - 1]\n\n\n# @external\n# def swapTokens(_swapInstructions: DynArray[SwapInstruction, 5]) -> (uint256, uint256, uint256):\n#     ...\n\n\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    ...\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    ...\n\n\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    ...\n\n\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    ...\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    ...\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    ...\n",
            "sha256sum": "b6f85ddff061e77069cceb9d110c05c679a6ea34b68f3ff69c95c1b07d83c453"
          },
          "contracts/core/templates/UserWalletTemplate.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n# pragma optimize codesize\n\nimplements: UserWalletInterface\nfrom interfaces import LegoDex\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\nfrom interfaces import LegoCredit\nfrom interfaces import UserWalletInterface\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC721\n\ninterface WalletConfig:\n    def finishMigrationIn(_whitelistToMigrate: DynArray[address, MAX_MIGRATION_WHITELIST], _assetsMigrated: DynArray[address, MAX_MIGRATION_ASSETS], _vaultTokensMigrated: DynArray[address, MAX_MIGRATION_ASSETS]) -> bool: nonpayable\n    def handleSubscriptionsAndPermissions(_agent: address, _action: ActionType, _assets: DynArray[address, MAX_ASSETS], _legoIds: DynArray[uint256, MAX_LEGOS], _cd: CoreData) -> (SubPaymentInfo, SubPaymentInfo): nonpayable\n    def updateYieldTrackingOnWithdrawal(_vaultToken: address, _vaultTokenAmountBurned: uint256, _asset: address, _assetAmountReceived: uint256, _legoRegistry: address) -> uint256: nonpayable\n    def updateYieldTrackingOnDeposit(_asset: address, _vaultToken: address, _vaultTokenAmountReceived: uint256, _assetAmountDeposited: uint256, _legoRegistry: address): nonpayable\n    def getAvailableTxAmount(_asset: address, _wantedAmount: uint256, _shouldCheckTrialFunds: bool, _cd: CoreData = empty(CoreData)) -> uint256: view\n    def updateYieldTrackingOnSwap(_tokenIn: address, _tokenOut: address, _tokenOutAmount: uint256, _legoRegistry: address): nonpayable\n    def updateYieldTrackingOnEntry(_asset: address, _amount: uint256, _legoRegistry: address): nonpayable\n    def updateYieldTrackingOnExit(_asset: address, _legoRegistry: address): nonpayable\n    def canTransferToRecipient(_recipient: address) -> bool: view\n    def isVaultToken(_asset: address) -> bool: view\n    def canWalletBeAmbassador() -> bool: view\n    def getProceedsAddr() -> address: view\n    def myAmbassador() -> address: view\n    def owner() -> address: view\n\ninterface LegoRegistry:\n    def getVaultTokensForUser(_user: address, _asset: address) -> DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER]: view\n    def getUnderlyingForUser(_user: address, _asset: address) -> uint256: view\n    def getUnderlyingAsset(_vaultToken: address) -> address: view\n    def getLegoAddr(_legoId: uint256) -> address: view\n\ninterface AgentFactory:\n    def payAmbassadorYieldBonus(_ambassador: address, _asset: address, _amount: uint256) -> bool: nonpayable\n    def agentBlacklist(_agentAddr: address) -> bool: view\n    def isUserWallet(_wallet: address) -> bool: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getEthUsdValue(_amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface WethContract:\n    def withdraw(_amount: uint256): nonpayable\n    def deposit(): payable\n\ninterface PriceSheets:\n    def getTransactionFeeDataWithAmbassadorRatio(_user: address, _action: ActionType) -> (uint256, address, uint256): view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface UserWallet:\n    def walletConfig() -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct CoreData:\n    owner: address\n    wallet: address\n    walletConfig: address\n    addyRegistry: address\n    agentFactory: address\n    legoRegistry: address\n    priceSheets: address\n    oracleRegistry: address\n    trialFundsAsset: address\n    trialFundsInitialAmount: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct VaultTokenInfo:\n    legoId: uint256\n    vaultToken: address\n\nevent UserWalletDeposit:\n    signer: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    vaultTokenAmountReceived: uint256\n    refundAssetAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletWithdrawal:\n    signer: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    vaultTokenAmountBurned: uint256\n    refundVaultTokenAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletSwap:\n    signer: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    swapAmount: uint256\n    toAmount: uint256\n    refundAssetAmount: uint256\n    usdValue: uint256\n    numTokens: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletBorrow:\n    signer: indexed(address)\n    borrowAsset: indexed(address)\n    borrowAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletRepayDebt:\n    signer: indexed(address)\n    paymentAsset: indexed(address)\n    paymentAmount: uint256\n    usdValue: uint256\n    remainingDebt: uint256\n    legoId: uint256\n    legoAddr: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletLiquidityAdded:\n    signer: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    liqAmountA: uint256\n    liqAmountB: uint256\n    liquidityAdded: uint256\n    pool: address\n    usdValue: uint256\n    refundAssetAmountA: uint256\n    refundAssetAmountB: uint256\n    nftTokenId: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletLiquidityRemoved:\n    signer: indexed(address)\n    tokenA: indexed(address)\n    tokenB: address\n    removedAmountA: uint256\n    removedAmountB: uint256\n    usdValue: uint256\n    isDepleted: bool\n    liquidityRemoved: uint256\n    lpToken: indexed(address)\n    refundedLpAmount: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletFundsTransferred:\n    signer: indexed(address)\n    recipient: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    usdValue: uint256\n    isSignerAgent: bool\n\nevent UserWalletRewardsClaimed:\n    signer: address\n    market: address\n    rewardToken: address\n    rewardAmount: uint256\n    usdValue: uint256\n    proof: bytes32\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletEthConvertedToWeth:\n    signer: indexed(address)\n    amount: uint256\n    paidEth: uint256\n    weth: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletWethConvertedToEth:\n    signer: indexed(address)\n    amount: uint256\n    weth: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletSubscriptionPaid:\n    recipient: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    isAgent: bool\n\nevent UserWalletTransactionFeePaid:\n    asset: indexed(address)\n    protocolRecipient: indexed(address)\n    protocolAmount: uint256\n    ambassadorRecipient: indexed(address)\n    ambassadorAmount: uint256\n    fee: uint256\n    action: ActionType\n\nevent UserWalletTrialFundsRecovered:\n    asset: indexed(address)\n    amountRecovered: uint256\n    remainingAmount: uint256\n\nevent UserWalletNftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    owner: indexed(address)\n\n# core \nwalletConfig: public(address)\n\n# trial funds info\ntrialFundsAsset: public(address)\ntrialFundsInitialAmount: public(uint256)\n\n# config\nwethAddr: public(address)\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\nLEGO_REGISTRY_ID: constant(uint256) = 2\nPRICE_SHEETS_ID: constant(uint256) = 3\nORACLE_REGISTRY_ID: constant(uint256) = 4\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_ASSETS: constant(uint256) = 25\nMAX_LEGOS: constant(uint256) = 20\nMAX_VAULTS_FOR_USER: constant(uint256) = 30\nMAX_MIGRATION_ASSETS: constant(uint256) = 40\nMAX_MIGRATION_WHITELIST: constant(uint256) = 20\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UnderscoreErc721\"\nAPI_VERSION: constant(String[28]) = \"0.0.3\"\n\nADDY_REGISTRY: public(immutable(address))\n\n\n@deploy\ndef __init__(\n    _walletConfig: address,\n    _addyRegistry: address,\n    _wethAddr: address,\n    _trialFundsAsset: address,\n    _trialFundsInitialAmount: uint256,\n):\n    \"\"\"\n    @notice Initializes a new UserWallet contract with required configuration parameters\n    @dev Sets up the wallet with its configuration, registry addresses, and optional trial funds\n    @param _walletConfig Address of the wallet configuration contract that manages permissions and settings\n    @param _addyRegistry Address of the registry contract that stores core protocol addresses\n    @param _wethAddr Address of the WETH contract for ETH wrapping/unwrapping functionality\n    @param _trialFundsAsset Address of the asset used for trial funds (can be empty)\n    @param _trialFundsInitialAmount Initial amount of trial funds to be held (can be 0)\n    \"\"\"\n    assert empty(address) not in [_walletConfig, _addyRegistry, _wethAddr] # dev: invalid addrs\n    self.walletConfig = _walletConfig\n    self.wethAddr = _wethAddr\n    ADDY_REGISTRY = _addyRegistry\n\n    # trial funds info\n    if _trialFundsAsset != empty(address) and _trialFundsInitialAmount != 0:   \n        self.trialFundsAsset = _trialFundsAsset\n        self.trialFundsInitialAmount = _trialFundsInitialAmount\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    \"\"\"\n    @notice Returns the current API version of the contract\n    @dev Returns a constant string representing the contract version\n    @return String[28] The API version string\n    \"\"\"\n    return API_VERSION\n\n\n@view\n@external\ndef canBeAmbassador() -> bool:\n    \"\"\"\n    @notice Checks if the current wallet can be an ambassador\n    @dev Returns True if the wallet is a valid ambassador, False otherwise\n    @return bool True if the wallet can be an ambassador, False otherwise\n    \"\"\"\n    return staticcall WalletConfig(self.walletConfig).canWalletBeAmbassador()\n\n\n###########\n# Deposit #\n###########\n\n\n@nonreentrant\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    \"\"\"\n    @notice Deposits tokens into a specified lego integration and vault\n    @param _legoId The ID of the lego to use for deposit\n    @param _asset The address of the token to deposit\n    @param _vault The target vault address\n    @param _amount The amount to deposit (defaults to max)\n    @return uint256 The amount of assets deposited\n    @return address The vault token address\n    @return uint256 The amount of vault tokens received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.DEPOSIT, [_asset], [_legoId], cd)\n    return self._depositTokens(msg.sender, _legoId, _asset, _vault, _amount, isSignerAgent, cd)\n\n\n@internal\ndef _depositTokens(\n    _signer: address,\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256,\n    _isSignerAgent: bool,\n    _cd: CoreData,\n) -> (uint256, address, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # finalize amount\n    amount: uint256 = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_asset, _amount, False, _cd)\n    assert extcall IERC20(_asset).approve(legoAddr, amount, default_return_value=True) # dev: approval failed\n\n    # deposit into lego partner\n    assetAmountDeposited: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    refundAssetAmount: uint256 = 0\n    usdValue: uint256 = 0\n    assetAmountDeposited, vaultToken, vaultTokenAmountReceived, refundAssetAmount, usdValue = extcall LegoYield(legoAddr).depositTokens(_asset, amount, _vault, self)\n    assert extcall IERC20(_asset).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # update yield tracking\n    extcall WalletConfig(_cd.walletConfig).updateYieldTrackingOnDeposit(_asset, vaultToken, vaultTokenAmountReceived, assetAmountDeposited, _cd.legoRegistry)\n\n    log UserWalletDeposit(signer=_signer, asset=_asset, vaultToken=vaultToken, assetAmountDeposited=assetAmountDeposited, vaultTokenAmountReceived=vaultTokenAmountReceived, refundAssetAmount=refundAssetAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return assetAmountDeposited, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@nonreentrant\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    \"\"\"\n    @notice Withdraws tokens from a specified lego integration and vault\n    @param _legoId The ID of the lego to use for withdrawal\n    @param _asset The address of the token to withdraw\n    @param _vaultToken The vault token address\n    @param _vaultTokenAmount The amount of vault tokens to withdraw (defaults to max)\n    @return uint256 The amount of assets received\n    @return uint256 The amount of vault tokens burned\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.WITHDRAWAL, [_asset], [_legoId], cd)\n    return self._withdrawTokens(msg.sender, _legoId, _asset, _vaultToken, _vaultTokenAmount, isSignerAgent, True, cd)\n\n\n@internal\ndef _withdrawTokens(\n    _signer: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256,\n    _isSignerAgent: bool,\n    _shouldHandleFees: bool,\n    _cd: CoreData,\n) -> (uint256, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # finalize amount, this will look at vault token balance (not always 1:1 with underlying asset)\n    withdrawAmount: uint256 = _vaultTokenAmount\n    if _vaultToken != empty(address):\n        withdrawAmount = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_vaultToken, _vaultTokenAmount, False, _cd)\n\n        # some vault tokens require max value approval (comp v3)\n        assert extcall IERC20(_vaultToken).approve(legoAddr, max_value(uint256), default_return_value=True) # dev: approval failed\n\n    assert withdrawAmount != 0 # dev: nothing to withdraw\n\n    # withdraw from lego partner\n    assetAmountReceived: uint256 = 0\n    vaultTokenAmountBurned: uint256 = 0\n    refundVaultTokenAmount: uint256 = 0\n    usdValue: uint256 = 0\n    assetAmountReceived, vaultTokenAmountBurned, refundVaultTokenAmount, usdValue = extcall LegoYield(legoAddr).withdrawTokens(_asset, withdrawAmount, _vaultToken, self)\n\n    # zero out approvals\n    if _vaultToken != empty(address):\n        assert extcall IERC20(_vaultToken).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # handle yield profit\n    assetProfitAmount: uint256 = extcall WalletConfig(_cd.walletConfig).updateYieldTrackingOnWithdrawal(_vaultToken, vaultTokenAmountBurned, _asset, assetAmountReceived, _cd.legoRegistry)\n    if _shouldHandleFees and assetProfitAmount != 0:\n        sentProfit: uint256 = self._handleTransactionFees(ActionType.WITHDRAWAL, _asset, assetProfitAmount, _cd.priceSheets, _cd.agentFactory)\n        assetAmountReceived -= sentProfit\n\n    log UserWalletWithdrawal(signer=_signer, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, vaultTokenAmountBurned=vaultTokenAmountBurned, refundVaultTokenAmount=refundVaultTokenAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return assetAmountReceived, vaultTokenAmountBurned, usdValue\n\n\n#############\n# Rebalance #\n#############\n\n\n@nonreentrant\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    \"\"\"\n    @notice Withdraws tokens from one lego and deposits them into another (always same asset)\n    @param _fromLegoId The ID of the source lego\n    @param _fromAsset The address of the token to rebalance\n    @param _fromVaultToken The source vault token address\n    @param _toLegoId The ID of the destination lego\n    @param _toVault The destination vault address\n    @param _fromVaultTokenAmount The vault token amount to rebalance (defaults to max)\n    @return uint256 The amount of assets deposited in the destination vault\n    @return address The destination vault token address\n    @return uint256 The amount of destination vault tokens received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REBALANCE, [_fromAsset], [_fromLegoId, _toLegoId], cd)\n\n    # withdraw from the first lego\n    assetAmountReceived: uint256 = 0\n    na: uint256 = 0\n    withdrawUsdValue: uint256 = 0\n    assetAmountReceived, na, withdrawUsdValue = self._withdrawTokens(msg.sender, _fromLegoId, _fromAsset, _fromVaultToken, _fromVaultTokenAmount, isSignerAgent, True, cd)\n\n    # deposit the received assets into the second lego\n    assetAmountDeposited: uint256 = 0\n    newVaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    depositUsdValue: uint256 = 0\n    assetAmountDeposited, newVaultToken, vaultTokenAmountReceived, depositUsdValue = self._depositTokens(msg.sender, _toLegoId, _fromAsset, _toVault, assetAmountReceived, isSignerAgent, cd)\n\n    usdValue: uint256 = max(withdrawUsdValue, depositUsdValue)\n    return assetAmountDeposited, newVaultToken, vaultTokenAmountReceived, usdValue\n\n\n########\n# Swap #\n########\n\n\n@nonreentrant\n@external\ndef swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256):\n    \"\"\"\n    @notice Swaps tokens between lego integrations\n    @param _swapInstructions The instructions for the swaps\n    @return uint256 The amount of assets deposited\n    @return uint256 The amount of assets received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    numSwapInstructions: uint256 = len(_swapInstructions)\n    assert numSwapInstructions != 0 # dev: no swaps\n\n    cd: CoreData = self._getCoreData()\n\n    # get high level swap info to check permissions\n    tokenIn: address = empty(address)\n    tokenOut: address = empty(address)\n    initialAmountIn: uint256 = 0\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    tokenIn, tokenOut, initialAmountIn, legoIds = self._getHighLevelSwapInfo(numSwapInstructions, _swapInstructions, cd)\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.SWAP, [tokenIn, tokenOut], legoIds, cd)\n\n    # check if swap token is trial funds asset\n    isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(tokenIn, cd.trialFundsAsset, cd.legoRegistry)\n\n    # perform swap instructions\n    amountIn: uint256 = initialAmountIn\n    lastTokenOut: address = empty(address)\n    lastTokenOutAmount: uint256 = 0\n    lastUsdValue: uint256 = 0\n    for j: uint256 in range(numSwapInstructions, bound=MAX_SWAP_INSTRUCTIONS):\n        i: SwapInstruction = _swapInstructions[j]\n\n        # from lego to lego, must follow the same token path\n        if lastTokenOut != empty(address):\n            newTokenIn: address = i.tokenPath[0]\n            assert lastTokenOut == newTokenIn # dev: invalid token path\n            amountIn = min(lastTokenOutAmount, staticcall IERC20(newTokenIn).balanceOf(self))\n\n        lastTokenOut, lastTokenOutAmount, lastUsdValue = self._performSwapInstruction(i.legoId, amountIn, i.minAmountOut, i.tokenPath, i.poolPath, msg.sender, isSignerAgent, cd.legoRegistry, cd.oracleRegistry)\n\n    # make sure they still have enough trial funds\n    self._checkTrialFundsPostTx(isTrialFundsVaultToken, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n\n     # yield tracking\n    extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnSwap(tokenIn, lastTokenOut, lastTokenOutAmount, cd.legoRegistry)\n\n    # handle tx fees\n    if isSignerAgent:\n        self._handleTransactionFees(ActionType.SWAP, lastTokenOut, lastTokenOutAmount, cd.priceSheets, cd.agentFactory)\n\n    return initialAmountIn, lastTokenOutAmount, lastUsdValue\n\n\n@internal\ndef _performSwapInstruction(\n    _legoId: uint256,\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _signer: address,\n    _isSignerAgent: bool,\n    _legoRegistry: address,\n    _oracleRegistry: address,\n) -> (address, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # get token in and token out\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[len(_tokenPath) - 1]\n\n    # approve token in\n    assert extcall IERC20(tokenIn).approve(legoAddr, _amountIn, default_return_value=True) # dev: approval failed\n\n    # swap assets via lego partner\n    tokenInAmount: uint256 = 0\n    tokenOutAmount: uint256 = 0\n    refundTokenInAmount: uint256 = 0\n    usdValue: uint256 = 0\n    tokenInAmount, tokenOutAmount, refundTokenInAmount, usdValue = extcall LegoDex(legoAddr).swapTokens(_amountIn, _minAmountOut, _tokenPath, _poolPath, self, _oracleRegistry)\n\n    # reset approvals\n    assert extcall IERC20(tokenIn).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log UserWalletSwap(signer=_signer, tokenIn=tokenIn, tokenOut=tokenOut, swapAmount=tokenInAmount, toAmount=tokenOutAmount, refundAssetAmount=refundTokenInAmount, usdValue=usdValue, numTokens=len(_tokenPath), legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return tokenOut, tokenOutAmount, usdValue\n\n\n@view\n@internal\ndef _getHighLevelSwapInfo(\n    _numSwapInstructions: uint256,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _cd: CoreData,\n) -> (address, address, uint256, DynArray[uint256, MAX_LEGOS]):   \n    firstRoutePath: DynArray[address, MAX_TOKEN_PATH] = _swapInstructions[0].tokenPath\n    firstRouteNumTokens: uint256 = len(firstRoutePath)\n    assert firstRouteNumTokens >= 2 # dev: invalid token path\n\n    # finalize token in and token out\n    tokenIn: address = firstRoutePath[0]\n    tokenOut: address = empty(address)\n    if _numSwapInstructions == 1:\n        tokenOut = firstRoutePath[firstRouteNumTokens - 1]\n\n    else:\n        lastRoutePath: DynArray[address, MAX_TOKEN_PATH] = _swapInstructions[_numSwapInstructions - 1].tokenPath\n        lastRouteNumTokens: uint256 = len(lastRoutePath)\n        assert lastRouteNumTokens >= 2 # dev: invalid token path\n        tokenOut = lastRoutePath[lastRouteNumTokens - 1]\n\n    assert empty(address) not in [tokenIn, tokenOut] # dev: invalid token path\n\n    # get lego ids\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    for i: uint256 in range(_numSwapInstructions, bound=MAX_SWAP_INSTRUCTIONS):\n        legoId: uint256 = _swapInstructions[i].legoId\n        if legoId not in legoIds:\n            legoIds.append(legoId)\n\n    # finalize amount in\n    amountIn: uint256 = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(tokenIn, _swapInstructions[0].amountIn, True, _cd)\n\n    return tokenIn, tokenOut, amountIn, legoIds\n\n\n##################\n# Borrow + Repay #\n##################\n\n\n# borrow\n\n\n@nonreentrant\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    \"\"\"\n    @notice Borrows an asset from a lego integration\n    @param _legoId The ID of the lego to borrow from\n    @param _borrowAsset The address of the asset to borrow\n    @param _amount The amount of the asset to borrow\n    @return address The address of the asset borrowed\n    @return uint256 The amount of the asset borrowed\n    @return uint256 The usd value of the borrowing\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.BORROW, [_borrowAsset], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego can perform this action\n    self._checkLegoAccessForAction(legoAddr)\n\n    # borrow via lego partner\n    borrowAsset: address = empty(address)\n    borrowAmount: uint256 = 0\n    usdValue: uint256 = 0\n    borrowAsset, borrowAmount, usdValue = extcall LegoCredit(legoAddr).borrow(_borrowAsset, _amount, self, cd.oracleRegistry)\n\n    log UserWalletBorrow(signer=msg.sender, borrowAsset=borrowAsset, borrowAmount=borrowAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return borrowAsset, borrowAmount, usdValue\n\n\n# repay debt\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    \"\"\"\n    @notice Repays debt for a lego integration\n    @param _legoId The ID of the lego to repay debt for\n    @param _paymentAsset The address of the asset to use for repayment\n    @param _paymentAmount The amount of the asset to use for repayment\n    @return address The address of the asset used for repayment\n    @return uint256 The amount of the asset used for repayment\n    @return uint256 The usd value of the repayment\n    @return uint256 The remaining debt\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REPAY, [_paymentAsset], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego can perform this action\n    self._checkLegoAccessForAction(legoAddr)\n\n    # finalize amount\n    paymentAmount: uint256 = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_paymentAsset, _paymentAmount, True, cd)\n\n    # check if payment asset is trial funds asset\n    isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(_paymentAsset, cd.trialFundsAsset, cd.legoRegistry)\n\n    # repay debt via lego partner\n    paymentAsset: address = empty(address)\n    usdValue: uint256 = 0\n    remainingDebt: uint256 = 0\n    assert extcall IERC20(_paymentAsset).approve(legoAddr, paymentAmount, default_return_value=True) # dev: approval failed\n    paymentAsset, paymentAmount, usdValue, remainingDebt = extcall LegoCredit(legoAddr).repayDebt(_paymentAsset, paymentAmount, self, cd.oracleRegistry)\n    assert extcall IERC20(_paymentAsset).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # make sure they still have enough trial funds\n    self._checkTrialFundsPostTx(isTrialFundsVaultToken, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n\n    # yield tracking -- paying back debt with vault token\n    extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnExit(_paymentAsset, cd.legoRegistry)\n\n    log UserWalletRepayDebt(signer=msg.sender, paymentAsset=paymentAsset, paymentAmount=paymentAmount, usdValue=usdValue, remainingDebt=remainingDebt, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return paymentAsset, paymentAmount, usdValue, remainingDebt\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    \"\"\"\n    @notice Claims rewards from a lego integration\n    @param _legoId The lego ID to claim rewards from\n    @param _market The market to claim rewards from\n    @param _rewardToken The reward token to claim\n    @param _rewardAmount The reward amount to claim\n    @param _proof The proof to verify the rewards\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CLAIM_REWARDS, [_rewardToken], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego has access to claim rewards\n    self._checkLegoAccessForAction(legoAddr)\n\n    # pre reward balance\n    preRewardBalance: uint256 = 0\n    if _rewardToken != empty(address):\n        preRewardBalance = staticcall IERC20(_rewardToken).balanceOf(self)\n\n    # claim rewards\n    extcall LegoCommon(legoAddr).claimRewards(self, _market, _rewardToken, _rewardAmount, _proof)\n\n    # post reward balance\n    postRewardBalance: uint256 = 0\n    if _rewardToken != empty(address):\n        postRewardBalance = staticcall IERC20(_rewardToken).balanceOf(self)\n    rewardAmount: uint256 = postRewardBalance - preRewardBalance\n\n    # handle tx fees\n    if isSignerAgent:\n        self._handleTransactionFees(ActionType.CLAIM_REWARDS, _rewardToken, rewardAmount, cd.priceSheets, cd.agentFactory)\n\n    usdValue: uint256 = 0\n    if rewardAmount != 0:\n        usdValue = staticcall OracleRegistry(cd.oracleRegistry).getUsdValue(_rewardToken, rewardAmount)\n    log UserWalletRewardsClaimed(signer=msg.sender, market=_market, rewardToken=_rewardToken, rewardAmount=rewardAmount, usdValue=usdValue, proof=_proof, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    \"\"\"\n    @notice Adds liquidity to a pool\n    @param _legoId The ID of the lego to use for adding liquidity\n    @param _nftAddr The address of the NFT token contract\n    @param _nftTokenId The ID of the NFT token to use for adding liquidity\n    @param _pool The address of the pool to add liquidity to\n    @param _tokenA The address of the first token to add liquidity\n    @param _tokenB The address of the second token to add liquidity\n    @param _amountA The amount of the first token to add liquidity\n    @param _amountB The amount of the second token to add liquidity\n    @param _tickLower The lower tick of the liquidity range\n    @param _tickUpper The upper tick of the liquidity range\n    @param _minAmountA The minimum amount of the first token to add liquidity\n    @param _minAmountB The minimum amount of the second token to add liquidity\n    @param _minLpAmount The minimum amount of lp token amount to receive\n    @return uint256 The amount of liquidity added\n    @return uint256 The amount of the first token added\n    @return uint256 The amount of the second token added\n    @return uint256 The usd value of the liquidity added\n    @return uint256 The ID of the NFT token used for adding liquidity\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.ADD_LIQ, [_tokenA, _tokenB], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # token a\n    amountA: uint256 = 0\n    isTrialFundsVaultTokenA: bool = False\n    if _amountA != 0:\n        amountA = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_tokenA, _amountA, True, cd)\n        assert extcall IERC20(_tokenA).approve(legoAddr, amountA, default_return_value=True) # dev: approval failed\n        isTrialFundsVaultTokenA = self._isTrialFundsVaultToken(_tokenA, cd.trialFundsAsset, cd.legoRegistry)\n\n    # token b\n    amountB: uint256 = 0\n    isTrialFundsVaultTokenB: bool = False\n    if _amountB != 0:\n        amountB = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_tokenB, _amountB, True, cd)\n        assert extcall IERC20(_tokenB).approve(legoAddr, amountB, default_return_value=True) # dev: approval failed\n        isTrialFundsVaultTokenB = self._isTrialFundsVaultToken(_tokenB, cd.trialFundsAsset, cd.legoRegistry)\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # add liquidity via lego partner\n    liquidityAdded: uint256 = 0\n    liqAmountA: uint256 = 0\n    liqAmountB: uint256 = 0\n    usdValue: uint256 = 0\n    refundAssetAmountA: uint256 = 0\n    refundAssetAmountB: uint256 = 0\n    nftTokenId: uint256 = 0\n    liquidityAdded, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, nftTokenId = extcall LegoDex(legoAddr).addLiquidity(_nftTokenId, _pool, _tokenA, _tokenB, _tickLower, _tickUpper, amountA, amountB, _minAmountA, _minAmountB, _minLpAmount, self, cd.oracleRegistry)\n\n    # validate the nft came back\n    if hasNftLiqPosition:\n        assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n\n    # token a\n    self._checkTrialFundsPostTx(isTrialFundsVaultTokenA, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n    if amountA != 0:\n        assert extcall IERC20(_tokenA).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n        extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnExit(_tokenA, cd.legoRegistry)\n\n    # token b\n    self._checkTrialFundsPostTx(isTrialFundsVaultTokenB, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n    if amountB != 0:\n        assert extcall IERC20(_tokenB).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n        extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnExit(_tokenB, cd.legoRegistry)\n\n    log UserWalletLiquidityAdded(signer=msg.sender, tokenA=_tokenA, tokenB=_tokenB, liqAmountA=liqAmountA, liqAmountB=liqAmountB, liquidityAdded=liquidityAdded, pool=_pool, usdValue=usdValue, refundAssetAmountA=refundAssetAmountA, refundAssetAmountB=refundAssetAmountB, nftTokenId=nftTokenId, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return liquidityAdded, liqAmountA, liqAmountB, usdValue, nftTokenId\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    \"\"\"\n    @notice Removes liquidity from a pool\n    @param _legoId The ID of the lego to use for removing liquidity\n    @param _nftAddr The address of the NFT token contract\n    @param _nftTokenId The ID of the NFT token to use for removing liquidity\n    @param _pool The address of the pool to remove liquidity from\n    @param _tokenA The address of the first token to remove liquidity\n    @param _tokenB The address of the second token to remove liquidity\n    @param _liqToRemove The amount of liquidity to remove\n    @param _minAmountA The minimum amount of the first token to remove liquidity\n    @param _minAmountB The minimum amount of the second token to remove liquidity\n    @return uint256 The amount of the first token removed\n    @return uint256 The amount of the second token removed\n    @return uint256 The usd value of the liquidity removed\n    @return bool True if the liquidity moved to lego contract was depleted, false otherwise\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REMOVE_LIQ, [_tokenA, _tokenB], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    lpToken: address = empty(address)\n    liqToRemove: uint256 = _liqToRemove\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # handle lp token\n    else:\n        lpToken = staticcall LegoDex(legoAddr).getLpToken(_pool)\n        liqToRemove = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(lpToken, liqToRemove, False, cd)\n        assert extcall IERC20(lpToken).approve(legoAddr, liqToRemove, default_return_value=True) # dev: approval failed\n\n    # remove liquidity via lego partner\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    usdValue: uint256 = 0\n    liquidityRemoved: uint256 = 0\n    refundedLpAmount: uint256 = 0\n    isDepleted: bool = False\n    amountA, amountB, usdValue, liquidityRemoved, refundedLpAmount, isDepleted = extcall LegoDex(legoAddr).removeLiquidity(_nftTokenId, _pool, _tokenA, _tokenB, lpToken, liqToRemove, _minAmountA, _minAmountB, self, cd.oracleRegistry)\n\n    # validate the nft came back, reset lp token approvals\n    if hasNftLiqPosition:\n        if not isDepleted:\n            assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n    else:\n        assert extcall IERC20(lpToken).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # yield tracking -- if vault tokens are what is removed from liquidity\n    extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnEntry(_tokenA, amountA, cd.legoRegistry)\n    extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnEntry(_tokenB, amountB, cd.legoRegistry)\n\n    log UserWalletLiquidityRemoved(signer=msg.sender, tokenA=_tokenA, tokenB=_tokenB, removedAmountA=amountA, removedAmountB=amountB, usdValue=usdValue, isDepleted=isDepleted, liquidityRemoved=liquidityRemoved, lpToken=lpToken, refundedLpAmount=refundedLpAmount, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return amountA, amountB, usdValue, isDepleted\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    \"\"\"\n    @notice Transfers funds to a specified recipient\n    @dev Handles both ETH and token transfers with optional amount specification\n    @param _recipient The address to receive the funds\n    @param _amount The amount to transfer (defaults to max)\n    @param _asset The token address (empty for ETH)\n    @return uint256 The amount of funds transferred\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.TRANSFER, [_asset], [], cd)\n    return self._transferFunds(msg.sender, _recipient, _amount, _asset, isSignerAgent, cd)\n\n\n@internal\ndef _transferFunds(\n    _signer: address,\n    _recipient: address,\n    _amount: uint256,\n    _asset: address,\n    _isSignerAgent: bool,\n    _cd: CoreData,\n) -> (uint256, uint256):\n    transferAmount: uint256 = 0\n    usdValue: uint256 = 0\n\n    # validate recipient\n    if _recipient != _cd.owner:\n        assert staticcall WalletConfig(_cd.walletConfig).canTransferToRecipient(_recipient) # dev: recipient not allowed\n\n    # handle eth\n    if _asset == empty(address):\n        transferAmount = min(_amount, self.balance)\n        assert transferAmount != 0 # dev: nothing to transfer\n        send(_recipient, transferAmount)\n        usdValue = staticcall OracleRegistry(_cd.oracleRegistry).getEthUsdValue(transferAmount)\n\n    # erc20 tokens\n    else:\n\n        # check if vault token of trial funds asset\n        isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(_asset, _cd.trialFundsAsset, _cd.legoRegistry)\n        transferAmount = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_asset, _amount, True, _cd)\n\n        assert extcall IERC20(_asset).transfer(_recipient, transferAmount, default_return_value=True) # dev: transfer failed\n        usdValue = staticcall OracleRegistry(_cd.oracleRegistry).getUsdValue(_asset, transferAmount)\n\n        # make sure they still have enough trial funds\n        self._checkTrialFundsPostTx(isTrialFundsVaultToken, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, _cd.legoRegistry)\n\n        # yield tracking -- transferring out vault token\n        extcall WalletConfig(_cd.walletConfig).updateYieldTrackingOnExit(_asset, _cd.legoRegistry)\n\n    log UserWalletFundsTransferred(signer=_signer, recipient=_recipient, asset=_asset, amount=transferAmount, usdValue=usdValue, isSignerAgent=_isSignerAgent)\n    return transferAmount, usdValue\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@nonreentrant\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    \"\"\"\n    @notice Converts ETH to WETH and optionally deposits into a lego integration and vault\n    @param _amount The amount of ETH to convert (defaults to max)\n    @param _depositLegoId The lego ID to use for deposit (optional)\n    @param _depositVault The vault address for deposit (optional)\n    @return uint256 The amount of assets deposited (if deposit performed)\n    @return address The vault token address (if deposit performed)\n    @return uint256 The amount of vault tokens received (if deposit performed)\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    weth: address = self.wethAddr\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CONVERSION, [weth], [_depositLegoId], cd)\n\n    # convert eth to weth\n    amount: uint256 = min(_amount, self.balance)\n    assert amount != 0 # dev: nothing to convert\n    extcall WethContract(weth).deposit(value=amount)\n    log UserWalletEthConvertedToWeth(signer=msg.sender, amount=amount, paidEth=msg.value, weth=weth, isSignerAgent=isSignerAgent)\n\n    # deposit weth into lego partner\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    if _depositLegoId != 0:\n        depositUsdValue: uint256 = 0\n        amount, vaultToken, vaultTokenAmountReceived, depositUsdValue = self._depositTokens(msg.sender, _depositLegoId, weth, _depositVault, amount, isSignerAgent, cd)\n\n    return amount, vaultToken, vaultTokenAmountReceived\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    \"\"\"\n    @notice Converts WETH to ETH and optionally withdraws from a vault first\n    @param _amount The amount of WETH to convert (defaults to max)\n    @param _recipient The address to receive the ETH (optional)\n    @param _withdrawLegoId The lego ID to withdraw from (optional)\n    @param _withdrawVaultToken The vault token to withdraw (optional)\n    @return uint256 The amount of ETH received\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    weth: address = self.wethAddr\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CONVERSION, [weth], [_withdrawLegoId], cd)\n\n    # withdraw weth from lego partner (if applicable)\n    amount: uint256 = _amount\n    usdValue: uint256 = 0\n    if _withdrawLegoId != 0:\n        _na: uint256 = 0\n        amount, _na, usdValue = self._withdrawTokens(msg.sender, _withdrawLegoId, weth, _withdrawVaultToken, _amount, isSignerAgent, True, cd)\n\n    # convert weth to eth\n    amount = min(amount, staticcall IERC20(weth).balanceOf(self))\n    assert amount != 0 # dev: nothing to convert\n    extcall WethContract(weth).withdraw(amount)\n    log UserWalletWethConvertedToEth(signer=msg.sender, amount=amount, weth=weth, isSignerAgent=isSignerAgent)\n\n    # transfer eth to recipient (if applicable)\n    if _recipient != empty(address):\n        amount, usdValue = self._transferFunds(msg.sender, _recipient, amount, empty(address), isSignerAgent, cd)\n\n    return amount\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@internal\ndef _getCoreData() -> CoreData:\n    addyRegistry: address = ADDY_REGISTRY\n    walletConfig: address = self.walletConfig\n    return CoreData(\n        owner=staticcall WalletConfig(walletConfig).owner(),\n        wallet=self,\n        walletConfig=walletConfig,\n        addyRegistry=addyRegistry,\n        agentFactory=staticcall AddyRegistry(addyRegistry).getAddy(AGENT_FACTORY_ID),\n        legoRegistry=staticcall AddyRegistry(addyRegistry).getAddy(LEGO_REGISTRY_ID),\n        priceSheets=staticcall AddyRegistry(addyRegistry).getAddy(PRICE_SHEETS_ID),\n        oracleRegistry=staticcall AddyRegistry(addyRegistry).getAddy(ORACLE_REGISTRY_ID),\n        trialFundsAsset=self.trialFundsAsset,\n        trialFundsInitialAmount=self.trialFundsInitialAmount,\n    )\n\n\n# payments (subscriptions, transaction fees)\n\n\n@internal\ndef _checkPermsAndHandleSubs(\n    _signer: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n    _cd: CoreData,\n) -> bool:\n    agent: address = _signer\n    if _signer == _cd.owner:\n        agent = empty(address)\n\n    # check if agent is blacklisted\n    if agent != empty(address):\n        assert not staticcall AgentFactory(_cd.agentFactory).agentBlacklist(agent) # dev: agent is blacklisted\n\n    # handle subscriptions and permissions\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = extcall WalletConfig(_cd.walletConfig).handleSubscriptionsAndPermissions(agent, _action, _assets, _legoIds, _cd)\n\n    # handle protocol subscription payment\n    if protocolSub.amount != 0:\n        assert extcall IERC20(protocolSub.asset).transfer(protocolSub.recipient, protocolSub.amount, default_return_value=True) # dev: protocol subscription payment failed\n        log UserWalletSubscriptionPaid(recipient=protocolSub.recipient, asset=protocolSub.asset, amount=protocolSub.amount, usdValue=protocolSub.usdValue, paidThroughBlock=protocolSub.paidThroughBlock, isAgent=False)\n\n    # handle agent subscription payment\n    if agentSub.amount != 0:\n        assert extcall IERC20(agentSub.asset).transfer(agentSub.recipient, agentSub.amount, default_return_value=True) # dev: agent subscription payment failed\n        log UserWalletSubscriptionPaid(recipient=agent, asset=agentSub.asset, amount=agentSub.amount, usdValue=agentSub.usdValue, paidThroughBlock=agentSub.paidThroughBlock, isAgent=True)\n\n    return agent != empty(address)\n\n\n@internal\ndef _handleTransactionFees(\n    _action: ActionType,\n    _asset: address,\n    _amount: uint256,\n    _priceSheets: address,\n    _agentFactory: address,\n) -> uint256:\n    if _amount == 0 or _asset == empty(address):\n        return 0\n\n    # pay ambassador yield bonus first (we do early return once we get into tx fees)\n    ambassadorRecipient: address = empty(address)\n    if _action == ActionType.WITHDRAWAL:\n        ambassadorRecipient = self._getAmbassadorProceedsAddr(empty(address))\n        extcall AgentFactory(_agentFactory).payAmbassadorYieldBonus(ambassadorRecipient, _asset, _amount)\n\n    # get transaction fees\n    fee: uint256 = 0\n    protocolRecipient: address = empty(address)\n    ambassadorRatio: uint256 = 0\n    fee, protocolRecipient, ambassadorRatio = staticcall PriceSheets(_priceSheets).getTransactionFeeDataWithAmbassadorRatio(self, _action)\n    if fee == 0 or protocolRecipient == empty(address):\n        return 0\n\n    adjFee: uint256 = min(fee, HUNDRED_PERCENT)\n    feeTotalAmount: uint256 = min(_amount * adjFee // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if feeTotalAmount == 0:\n        return 0\n\n    protocolAmount: uint256 = feeTotalAmount\n    ambassadorAmount: uint256 = 0\n\n    # pay ambassador proceeds\n    if ambassadorRatio != 0:\n        ambassadorRecipient = self._getAmbassadorProceedsAddr(ambassadorRecipient)\n        ambassadorAmount = self._payAmbassadorTxFee(_asset, protocolAmount, ambassadorRatio, ambassadorRecipient)\n        if ambassadorAmount != 0:\n            protocolAmount = min(protocolAmount - ambassadorAmount, staticcall IERC20(_asset).balanceOf(self))\n\n    # pay protocol proceeds\n    if protocolAmount != 0:\n        assert extcall IERC20(_asset).transfer(protocolRecipient, protocolAmount, default_return_value=True) # dev: protocol tx fee payment failed\n\n    log UserWalletTransactionFeePaid(asset=_asset, protocolRecipient=protocolRecipient, protocolAmount=protocolAmount, ambassadorRecipient=ambassadorRecipient, ambassadorAmount=ambassadorAmount, fee=fee, action=_action)\n    return feeTotalAmount\n\n\n# ambassador\n\n\n@view\n@internal\ndef _getAmbassadorProceedsAddr(_maybeAmbassador: address) -> address:\n    if _maybeAmbassador != empty(address):\n        return _maybeAmbassador\n\n    myAmbassador: address = staticcall WalletConfig(self.walletConfig).myAmbassador()\n    if myAmbassador == empty(address):\n        return empty(address)\n    ambassadorWalletConfig: address = staticcall UserWallet(myAmbassador).walletConfig()\n    return staticcall WalletConfig(ambassadorWalletConfig).getProceedsAddr()\n\n\n@internal\ndef _payAmbassadorTxFee(\n    _asset: address,\n    _amount: uint256,\n    _ambassadorRatio: uint256,\n    _ambassadorAddr: address,\n) -> uint256:\n    if _ambassadorAddr == empty(address):\n        return 0\n\n    ambassadorRatio: uint256 = min(_ambassadorRatio, HUNDRED_PERCENT)\n    amount: uint256 = min(_amount * ambassadorRatio // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if amount != 0:\n        assert extcall IERC20(_asset).transfer(_ambassadorAddr, amount, default_return_value=True) # dev: ambassador tx fee payment failed\n\n    return min(_amount, amount)\n\n\n# allow lego to perform action\n\n\n@internal\ndef _checkLegoAccessForAction(_legoAddr: address):\n    targetAddr: address = empty(address)\n    accessAbi: String[64] = empty(String[64])\n    numInputs: uint256 = 0\n    targetAddr, accessAbi, numInputs = staticcall LegoCommon(_legoAddr).getAccessForLego(self)\n\n    # nothing to do here\n    if targetAddr == empty(address):\n        return\n\n    method_abi: bytes4 = convert(slice(keccak256(accessAbi), 0, 4), bytes4)\n    success: bool = False\n    response: Bytes[32] = b\"\"\n\n    # assumes input is: lego addr (operator)\n    if numInputs == 1:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    # assumes input (and order) is: user addr (owner), lego addr (operator)\n    elif numInputs == 2:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    # assumes input (and order) is: user addr (owner), lego addr (operator), allowed bool\n    elif numInputs == 3:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n                convert(True, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    assert success # dev: failed to set operator\n\n\n# trial funds\n\n\n@view\n@internal\ndef _isTrialFundsVaultToken(_asset: address, _trialFundsAsset: address, _legoRegistry: address) -> bool:\n    if _trialFundsAsset == empty(address) or _asset == _trialFundsAsset:\n        return False\n    return _trialFundsAsset == staticcall LegoRegistry(_legoRegistry).getUnderlyingAsset(_asset)\n\n\n@view\n@internal\ndef _checkTrialFundsPostTx(_isTrialFundsVaultToken: bool, _trialFundsAsset: address, _trialFundsInitialAmount: uint256, _legoRegistry: address):\n    if not _isTrialFundsVaultToken:\n        return\n    postUnderlying: uint256 = staticcall LegoRegistry(_legoRegistry).getUnderlyingForUser(self, _trialFundsAsset)\n    assert postUnderlying >= _trialFundsInitialAmount # dev: cannot transfer trial funds vault token\n\n\n@external\ndef clawBackTrialFunds() -> bool:\n    \"\"\"\n    @notice Claw back trial funds from the wallet by withdrawing from vault tokens and transferring to the agent factory\n    @dev This function can only be called by the agent factory, owner, or wallet config. It will:\n        1. Check if there are trial funds to recover\n        2. Calculate target recovery amount with 2% buffer\n        3. Transfer any available balance directly\n        4. Withdraw from vault tokens if needed\n        5. Update trial funds tracking data\n    @return bool True if trial funds were clawed back successfully, False otherwise\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    assert msg.sender in [cd.agentFactory, cd.owner, cd.walletConfig] # dev: no perms\n\n    # make sure something to recover\n    if cd.trialFundsAsset == empty(address) or cd.trialFundsInitialAmount == 0:\n        return False\n\n    # account for extra dust / yield\n    targetRecoveryAmount: uint256 = cd.trialFundsInitialAmount * 101_00 // HUNDRED_PERCENT # 1% buffer\n    amountRecovered: uint256 = 0\n\n    # transfer any available balance\n    balanceAvail: uint256 = staticcall IERC20(cd.trialFundsAsset).balanceOf(self)\n    if balanceAvail != 0:\n        availableAmount: uint256 = min(balanceAvail, targetRecoveryAmount)\n        assert extcall IERC20(cd.trialFundsAsset).transfer(cd.agentFactory, availableAmount, default_return_value=True) # dev: trial funds transfer failed\n        amountRecovered += availableAmount\n        targetRecoveryAmount -= availableAmount\n\n    if targetRecoveryAmount == 0:\n        return True\n\n    # iterate through vault tokens (related to trial funds)\n    trialFundsVaultTokens: DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER] = staticcall LegoRegistry(cd.legoRegistry).getVaultTokensForUser(self, cd.trialFundsAsset)\n    for v: VaultTokenInfo in trialFundsVaultTokens:\n        assetAmountReceived: uint256 = 0\n        na1: uint256 = 0\n        na2: uint256 = 0\n        assetAmountReceived, na1, na2 = self._withdrawTokens(cd.agentFactory, v.legoId, cd.trialFundsAsset, v.vaultToken, max_value(uint256), False, False, cd)\n\n        # recover funds\n        transferAmount: uint256 = min(assetAmountReceived, targetRecoveryAmount)\n        assert extcall IERC20(cd.trialFundsAsset).transfer(cd.agentFactory, transferAmount, default_return_value=True) # dev: trial funds transfer failed\n        amountRecovered += transferAmount\n        targetRecoveryAmount -= transferAmount\n\n        # reached target recovery amount, deposit any extra balance back lego\n        if targetRecoveryAmount == 0:\n            depositAmount: uint256 = min(assetAmountReceived - transferAmount, staticcall IERC20(cd.trialFundsAsset).balanceOf(self))\n            if depositAmount != 0:\n                self._depositTokens(msg.sender, v.legoId, cd.trialFundsAsset, v.vaultToken, depositAmount, False, cd)\n            break\n\n    if amountRecovered == 0:\n        return False\n\n    # update trial funds data\n    newTrialFundsInitialAmount: uint256 = cd.trialFundsInitialAmount - min(cd.trialFundsInitialAmount, amountRecovered)\n    self.trialFundsInitialAmount = newTrialFundsInitialAmount\n    if newTrialFundsInitialAmount == 0:\n        self.trialFundsAsset = empty(address)\n\n    log UserWalletTrialFundsRecovered(asset=cd.trialFundsAsset, amountRecovered=amountRecovered, remainingAmount=newTrialFundsInitialAmount)\n    return True\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256) -> bool:\n    \"\"\"\n    @notice Recovers an NFT from the wallet\n    @param _collection The address of the NFT collection\n    @param _nftTokenId The ID of the NFT to recover\n    @return bool True if the NFT was recovered successfully, False otherwise\n    \"\"\"\n    owner: address = staticcall WalletConfig(self.walletConfig).owner()\n    assert msg.sender == owner # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, owner, _nftTokenId)\n    log UserWalletNftRecovered(collection=_collection, nftTokenId=_nftTokenId, owner=owner)\n    return True\n\n\n# wallet migration\n\n\n@external\ndef migrateWalletOut(\n    _newWallet: address,\n    _assetsToMigrate: DynArray[address, MAX_MIGRATION_ASSETS],\n    _whitelistToMigrate: DynArray[address, MAX_MIGRATION_WHITELIST],\n) -> bool:\n    \"\"\"\n    @notice Migrates a wallet to a new wallet\n    @param _newWallet The address of the new wallet\n    @param _assetsToMigrate The assets to migrate\n    @param _whitelistToMigrate The whitelist to migrate\n    @return bool True if the migration was successful, False otherwise\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    assert msg.sender == cd.walletConfig # dev: only wallet config can call this\n    assert staticcall AgentFactory(cd.agentFactory).isUserWallet(_newWallet) # dev: must be Underscore wallet\n\n    # eth\n    if self.balance != 0:\n        send(_newWallet, self.balance)\n\n    assetsMigrated: DynArray[address, MAX_MIGRATION_ASSETS] = []\n    vaultTokensMigrated: DynArray[address, MAX_MIGRATION_ASSETS] = []\n\n    # erc20 tokens\n    for asset: address in _assetsToMigrate:\n        if asset == empty(address):\n            continue\n\n        assetBal: uint256 = staticcall IERC20(asset).balanceOf(self)\n        if assetBal == 0:\n            continue\n\n        assert extcall IERC20(asset).transfer(_newWallet, assetBal, default_return_value=True) # dev: asset transfer failed\n        if staticcall WalletConfig(cd.walletConfig).isVaultToken(asset):\n            vaultTokensMigrated.append(asset)\n        else:\n            assetsMigrated.append(asset)\n\n    # finish migration of new wallet\n    newWalletConfig: address = staticcall UserWallet(_newWallet).walletConfig()\n    assert extcall WalletConfig(newWalletConfig).finishMigrationIn(_whitelistToMigrate, assetsMigrated, vaultTokensMigrated) # dev: migration failed\n\n    # update yield tracking for this wallet\n    if len(vaultTokensMigrated) != 0:\n        for vaultToken: address in vaultTokensMigrated:\n            extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnExit(vaultToken, cd.legoRegistry)\n\n    return True\n",
            "sha256sum": "80e4eea98ba2b6fdfdc90d2b68d99a1935d4de55dad5a211b51a5d286daee56d"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/templates/UserWalletTemplate.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "36875a4312171e5448643193da4235ac19bade0f9911802dc6f0eb5baca7196e"
      },
      "args": ""
    },
    "UserWalletConfigTemplate": {
      "address": "0x61293F1bF484d20dcc841175b4E4A0F46c26658c",
      "abi": [
        {
          "name": "AgentAdded",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "allowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "allowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentModified",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "allowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "allowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentDisabled",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAllowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevAllowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoIdAddedToAgent",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetAddedToAgent",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AllowedActionsModified",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRebalance",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canTransfer",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSwap",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canConvert",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canAddLiq",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRemoveLiq",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canClaimRewards",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canBorrow",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRepay",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanTransferToAltOwnerWalletsSet",
          "inputs": [
            {
              "name": "canTransfer",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrCancelled",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrRemoved",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrSetViaMigration",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ReserveAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanWalletBeAmbassadorSet",
          "inputs": [
            {
              "name": "canWalletBeAmbassador",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorForwarderSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletStartMigration",
          "inputs": [
            {
              "name": "newWallet",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numAssetsToMigrate",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numWhitelistToMigrate",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletFinishMigration",
          "inputs": [
            {
              "name": "oldWallet",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numWhitelistMigrated",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numVaultTokensMigrated",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numAssetsMigrated",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeInitiated",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeConfirmed",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeCancelled",
          "inputs": [
            {
              "name": "cancelledOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingOwnerChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeOwnership",
          "inputs": [
            {
              "name": "_newOwner",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOwnershipChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "owner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingOwner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newOwner",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ownershipChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "_ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWallet",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgentActive",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canAgentAccess",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            },
            {
              "name": "_legoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentSubscriptionStatus",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getProtocolSubscriptionStatus",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMakeSubscriptionPayments",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "handleSubscriptionsAndPermissions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            },
            {
              "name": "_legoIds",
              "type": "uint256[]"
            },
            {
              "name": "_cd",
              "type": "tuple",
              "components": [
                {
                  "name": "owner",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "addyRegistry",
                  "type": "address"
                },
                {
                  "name": "agentFactory",
                  "type": "address"
                },
                {
                  "name": "legoRegistry",
                  "type": "address"
                },
                {
                  "name": "priceSheets",
                  "type": "address"
                },
                {
                  "name": "oracleRegistry",
                  "type": "address"
                },
                {
                  "name": "trialFundsAsset",
                  "type": "address"
                },
                {
                  "name": "trialFundsInitialAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailableTxAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_wantedAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldCheckTrialFunds",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailableTxAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_wantedAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldCheckTrialFunds",
              "type": "bool"
            },
            {
              "name": "_cd",
              "type": "tuple",
              "components": [
                {
                  "name": "owner",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "addyRegistry",
                  "type": "address"
                },
                {
                  "name": "agentFactory",
                  "type": "address"
                },
                {
                  "name": "legoRegistry",
                  "type": "address"
                },
                {
                  "name": "priceSheets",
                  "type": "address"
                },
                {
                  "name": "oracleRegistry",
                  "type": "address"
                },
                {
                  "name": "trialFundsAsset",
                  "type": "address"
                },
                {
                  "name": "trialFundsInitialAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldTrackingOnDeposit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmountReceived",
              "type": "uint256"
            },
            {
              "name": "_assetAmountDeposited",
              "type": "uint256"
            },
            {
              "name": "_legoRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldTrackingOnWithdrawal",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmountBurned",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmountReceived",
              "type": "uint256"
            },
            {
              "name": "_legoRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldTrackingOnSwap",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenOutAmount",
              "type": "uint256"
            },
            {
              "name": "_legoRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldTrackingOnEntry",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_legoRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldTrackingOnExit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_legoRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startMigrationOut",
          "inputs": [
            {
              "name": "_newWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startMigrationOut",
          "inputs": [
            {
              "name": "_newWallet",
              "type": "address"
            },
            {
              "name": "_assetsToMigrate",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startMigrationOut",
          "inputs": [
            {
              "name": "_newWallet",
              "type": "address"
            },
            {
              "name": "_assetsToMigrate",
              "type": "address[]"
            },
            {
              "name": "_whitelistToMigrate",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishMigrationIn",
          "inputs": [
            {
              "name": "_whitelistToMigrate",
              "type": "address[]"
            },
            {
              "name": "_assetsMigrated",
              "type": "address[]"
            },
            {
              "name": "_vaultTokensMigrated",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            },
            {
              "name": "_allowedLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            },
            {
              "name": "_allowedLegoIds",
              "type": "uint256[]"
            },
            {
              "name": "_allowedActions",
              "type": "tuple",
              "components": [
                {
                  "name": "isSet",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRebalance",
                  "type": "bool"
                },
                {
                  "name": "canTransfer",
                  "type": "bool"
                },
                {
                  "name": "canSwap",
                  "type": "bool"
                },
                {
                  "name": "canConvert",
                  "type": "bool"
                },
                {
                  "name": "canAddLiq",
                  "type": "bool"
                },
                {
                  "name": "canRemoveLiq",
                  "type": "bool"
                },
                {
                  "name": "canClaimRewards",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLegoIdForAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetForAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "modifyAllowedActions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "modifyAllowedActions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedActions",
              "type": "tuple",
              "components": [
                {
                  "name": "isSet",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRebalance",
                  "type": "bool"
                },
                {
                  "name": "canTransfer",
                  "type": "bool"
                },
                {
                  "name": "canSwap",
                  "type": "bool"
                },
                {
                  "name": "canConvert",
                  "type": "bool"
                },
                {
                  "name": "canAddLiq",
                  "type": "bool"
                },
                {
                  "name": "canRemoveLiq",
                  "type": "bool"
                },
                {
                  "name": "canClaimRewards",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canTransferToRecipient",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesWalletHaveSameOwner",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanTransferToAltOwnerWallets",
          "inputs": [
            {
              "name": "_canTransfer",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setReserveAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManyReserveAssets",
          "inputs": [
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getProceedsAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAmbassadorForwarder",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanWalletBeAmbassador",
          "inputs": [
            {
              "name": "_canWalletBeAmbassador",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "wallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "didSetWallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolSub",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "installBlock",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "reserveAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentSettings",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "isActive",
                  "type": "bool"
                },
                {
                  "name": "installBlock",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "allowedLegoIds",
                  "type": "uint256[]"
                },
                {
                  "name": "allowedActions",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "isSet",
                      "type": "bool"
                    },
                    {
                      "name": "canDeposit",
                      "type": "bool"
                    },
                    {
                      "name": "canWithdraw",
                      "type": "bool"
                    },
                    {
                      "name": "canRebalance",
                      "type": "bool"
                    },
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canSwap",
                      "type": "bool"
                    },
                    {
                      "name": "canConvert",
                      "type": "bool"
                    },
                    {
                      "name": "canAddLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canRemoveLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "canBorrow",
                      "type": "bool"
                    },
                    {
                      "name": "canRepay",
                      "type": "bool"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRecipientAllowed",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingWhitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canTransferToAltOwnerWallets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canWalletBeAmbassador",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ambassadorForwarder",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "myAmbassador",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "didMigrateIn",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "didMigrateOut",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultTokenAmounts",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "depositedAmounts",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_initialAgent",
              "type": "address"
            },
            {
              "name": "_ambassador",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_minOwnerChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxOwnerChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Ownership.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AgentFactory:\n    def canCancelCriticalAction(_addr: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct PendingOwner:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent OwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    cancelledBy: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeDelaySet:\n    delayBlocks: uint256\n\n# owner\nowner: public(address) # owner of the wallet\npendingOwner: public(PendingOwner) # pending owner of the wallet\nownershipChangeDelay: public(uint256) # num blocks to wait before owner can be changed\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\n_ADDY_REGISTRY: public(immutable(address))\n\nAGENT_FACTORY_ID: constant(uint256) = 1\n\n\n@deploy\ndef __init__(\n    _owner: address,\n    _addyRegistry: address,\n    _minOwnerChangeDelay: uint256,\n    _maxOwnerChangeDelay: uint256,\n):\n    assert empty(address) not in [_owner, _addyRegistry] # dev: invalid addrs\n    self.owner = _owner\n    _ADDY_REGISTRY = _addyRegistry\n\n    assert _minOwnerChangeDelay < _maxOwnerChangeDelay # dev: invalid delay\n    MIN_OWNER_CHANGE_DELAY = _minOwnerChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxOwnerChangeDelay\n    self.ownershipChangeDelay = _minOwnerChangeDelay\n\n\n####################\n# Ownership Change #\n####################\n\n\n@view\n@external\ndef hasPendingOwnerChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending ownership change\n    @return bool True if there is a pending ownership change, false otherwise\n    \"\"\"\n    return self._hasPendingOwnerChange()\n\n\n@view\n@internal\ndef _hasPendingOwnerChange() -> bool:\n    return self.pendingOwner.confirmBlock != 0\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    \"\"\"\n    @notice Initiates a new ownership change\n    @dev Can only be called by the current owner\n    @param _newOwner The address of the new owner\n    \"\"\"\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingOwner = PendingOwner(\n        newOwner= _newOwner,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log OwnershipChangeInitiated(prevOwner=currentOwner, newOwner=_newOwner, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmOwnershipChange():\n    \"\"\"\n    @notice Confirms the ownership change\n    @dev Can only be called by the new owner\n    \"\"\"\n    data: PendingOwner = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeConfirmed(prevOwner=prevOwner, newOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelOwnershipChange():\n    \"\"\"\n    @notice Cancels the ownership change\n    @dev Can only be called by the current owner or governance\n    \"\"\"\n    agentFactory: address = staticcall AddyRegistry(_ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    assert msg.sender == self.owner or staticcall AgentFactory(agentFactory).canCancelCriticalAction(msg.sender) # dev: no perms (only owner or governance)\n\n    data: PendingOwner = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeCancelled(cancelledOwner=data.newOwner, cancelledBy=msg.sender, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setOwnershipChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the ownership change delay\n    @dev Can only be called by the owner\n    @param _numBlocks The number of blocks to wait before ownership can be changed\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNER_CHANGE_DELAY and _numBlocks <= MAX_OWNER_CHANGE_DELAY # dev: invalid delay\n    self.ownershipChangeDelay = _numBlocks\n    log OwnershipChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "2f0e7c45d64763e64f27ede081332d3ba84c61832ea4721e2123a6cd7654870b"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "contracts/core/templates/UserWalletConfigTemplate.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n# pragma optimize codesize\n\ninitializes: own\nexports: own.__interface__\n\nimport contracts.modules.Ownership as own\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\n\ninterface UserWallet:\n    def migrateWalletOut(_newWallet: address, _assetsToMigrate: DynArray[address, MAX_MIGRATION_ASSETS], _whitelistToMigrate: DynArray[address, MAX_MIGRATION_WHITELIST]) -> bool: nonpayable\n    def trialFundsInitialAmount() -> uint256: view\n    def clawBackTrialFunds() -> bool: nonpayable\n    def trialFundsAsset() -> address: view\n    def walletConfig() -> address: view\n    def canBeAmbassador() -> bool: view\n\ninterface WalletConfig:\n    def vaultTokenAmounts(_vaultToken: address) -> uint256: view\n    def depositedAmounts(_vaultToken: address) -> uint256: view\n    def isRecipientAllowed(_addr: address) -> bool: view\n    def hasPendingOwnerChange() -> bool: view\n    def myAmbassador() -> address: view\n    def owner() -> address: view\n\ninterface LegoRegistry:\n    def getLegoFromVaultToken(_vaultToken: address) -> (uint256, address): view\n    def getUnderlyingForUser(_user: address, _asset: address) -> uint256: view\n    def isVaultToken(_vaultToken: address) -> bool: view\n    def isValidLegoId(_legoId: uint256) -> bool: view\n\ninterface PriceSheets:\n    def getCombinedSubData(_user: address, _agent: address, _agentPaidThru: uint256, _protocolPaidThru: uint256, _oracleRegistry: address) -> (SubPaymentInfo, SubPaymentInfo): view\n    def getAgentSubPriceData(_agent: address) -> SubscriptionInfo: view\n    def protocolSubPriceData() -> SubscriptionInfo: view\n\ninterface AgentFactory:\n    def canCancelCriticalAction(_addr: address) -> bool: view\n    def isUserWallet(_wallet: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct AgentInfo:\n    isActive: bool\n    installBlock: uint256\n    paidThroughBlock: uint256\n    allowedAssets: DynArray[address, MAX_ASSETS]\n    allowedLegoIds: DynArray[uint256, MAX_LEGOS]\n    allowedActions: AllowedActions\n\nstruct PendingWhitelist:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct CoreData:\n    owner: address\n    wallet: address\n    walletConfig: address\n    addyRegistry: address\n    agentFactory: address\n    legoRegistry: address\n    priceSheets: address\n    oracleRegistry: address\n    trialFundsAsset: address\n    trialFundsInitialAmount: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct ProtocolSub:\n    installBlock: uint256\n    paidThroughBlock: uint256\n\nstruct AllowedActions:\n    isSet: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRebalance: bool\n    canTransfer: bool\n    canSwap: bool\n    canConvert: bool\n    canAddLiq: bool\n    canRemoveLiq: bool\n    canClaimRewards: bool\n    canBorrow: bool\n    canRepay: bool\n\nstruct ReserveAsset:\n    asset: address\n    amount: uint256\n\nstruct SubscriptionInfo:\n    asset: address\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent AgentAdded:\n    agent: indexed(address)\n    allowedAssets: uint256\n    allowedLegoIds: uint256\n\nevent AgentModified:\n    agent: indexed(address)\n    allowedAssets: uint256\n    allowedLegoIds: uint256\n\nevent AgentDisabled:\n    agent: indexed(address)\n    prevAllowedAssets: uint256\n    prevAllowedLegoIds: uint256\n\nevent LegoIdAddedToAgent:\n    agent: indexed(address)\n    legoId: indexed(uint256)\n\nevent AssetAddedToAgent:\n    agent: indexed(address)\n    asset: indexed(address)\n\nevent AllowedActionsModified:\n    agent: indexed(address)\n    canDeposit: bool\n    canWithdraw: bool\n    canRebalance: bool\n    canTransfer: bool\n    canSwap: bool\n    canConvert: bool\n    canAddLiq: bool\n    canRemoveLiq: bool\n    canClaimRewards: bool\n    canBorrow: bool\n    canRepay: bool\n\nevent CanTransferToAltOwnerWalletsSet:\n    canTransfer: bool\n\nevent WhitelistAddrPending:\n    addr: indexed(address)\n    confirmBlock: uint256\n\nevent WhitelistAddrConfirmed:\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent WhitelistAddrCancelled:\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    cancelledBy: indexed(address)\n\nevent WhitelistAddrRemoved:\n    addr: indexed(address)\n\nevent WhitelistAddrSetViaMigration:\n    addr: indexed(address)\n\nevent ReserveAssetSet:\n    asset: indexed(address)\n    amount: uint256\n\nevent CanWalletBeAmbassadorSet:\n    canWalletBeAmbassador: bool\n\nevent AmbassadorForwarderSet:\n    addr: indexed(address)\n\nevent FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent UserWalletStartMigration:\n    newWallet: indexed(address)\n    numAssetsToMigrate: uint256\n    numWhitelistToMigrate: uint256\n\nevent UserWalletFinishMigration:\n    oldWallet: indexed(address)\n    numWhitelistMigrated: uint256\n    numVaultTokensMigrated: uint256\n    numAssetsMigrated: uint256\n\n# core\nwallet: public(address)\ndidSetWallet: public(bool)\n\n# user settings\nprotocolSub: public(ProtocolSub) # subscription info\nreserveAssets: public(HashMap[address, uint256]) # asset -> reserve amount\nagentSettings: public(HashMap[address, AgentInfo]) # agent -> agent info\n\n# transfer whitelist\nisRecipientAllowed: public(HashMap[address, bool]) # recipient -> is allowed\npendingWhitelist: public(HashMap[address, PendingWhitelist]) # addr -> pending whitelist\ncanTransferToAltOwnerWallets: public(bool)\n\n# ambassador settings\ncanWalletBeAmbassador: public(bool)\nambassadorForwarder: public(address)\nmyAmbassador: public(address) # cannot be edited -- inviter of THIS user wallet\n\n# migration\ndidMigrateIn: public(bool)\ndidMigrateOut: public(bool)\n\n# yield tracking\nisVaultToken: public(HashMap[address, bool]) # asset -> is vault token\nvaultTokenAmounts: public(HashMap[address, uint256]) # vault token -> vault token amount\ndepositedAmounts: public(HashMap[address, uint256]) # vault token -> underlying asset amount\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\nLEGO_REGISTRY_ID: constant(uint256) = 2\nPRICE_SHEETS_ID: constant(uint256) = 3\nORACLE_REGISTRY_ID: constant(uint256) = 4\n\nMAX_MIGRATION_ASSETS: constant(uint256) = 40\nMAX_MIGRATION_WHITELIST: constant(uint256) = 20\nMAX_ASSETS: constant(uint256) = 25\nMAX_LEGOS: constant(uint256) = 20\nAPI_VERSION: constant(String[28]) = \"0.0.3\"\n\nADDY_REGISTRY: public(immutable(address))\n\n\n@deploy\ndef __init__(\n    _owner: address,\n    _initialAgent: address,\n    _ambassador: address,\n    _addyRegistry: address,\n    _minOwnerChangeDelay: uint256,\n    _maxOwnerChangeDelay: uint256,\n):\n    \"\"\"\n    @notice Initializes a new UserWalletConfig contract with ownership and agent settings\n    @dev Sets up the config with owner, registry, and optional initial agent. Also initializes protocol subscription.\n    @param _owner Address of the contract owner who will have administrative privileges\n    @param _initialAgent Address of the initial agent to be set up (can be empty)\n    @param _ambassador Address of the ambassador who invited the user (can be empty)\n    @param _addyRegistry Address of the registry contract that stores core protocol addresses\n    @param _minOwnerChangeDelay Minimum delay in blocks required for ownership changes\n    @param _maxOwnerChangeDelay Maximum delay in blocks allowed for ownership changes\n    \"\"\"\n    assert empty(address) not in [_addyRegistry, _owner] # dev: invalid addrs\n    assert _initialAgent != _owner # dev: agent cannot be owner\n\n    # initialize ownership\n    own.__init__(_owner, _addyRegistry, _minOwnerChangeDelay, _maxOwnerChangeDelay)\n\n    ADDY_REGISTRY = _addyRegistry\n    priceSheets: address = staticcall AddyRegistry(_addyRegistry).getAddy(PRICE_SHEETS_ID)\n\n    # initial agent setup\n    if _initialAgent != empty(address):\n        subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).getAgentSubPriceData(_initialAgent)\n        paidThroughBlock: uint256 = 0\n        if subInfo.usdValue != 0:\n            paidThroughBlock = block.number + subInfo.trialPeriod\n        self.agentSettings[_initialAgent] = AgentInfo(\n            isActive=True,\n            installBlock=block.number,\n            paidThroughBlock=paidThroughBlock,\n            allowedAssets=[],\n            allowedLegoIds=[],\n            allowedActions=empty(AllowedActions),\n        )\n        log AgentAdded(agent=_initialAgent, allowedAssets=0, allowedLegoIds=0)\n\n    # protocol subscription\n    protocolSub: ProtocolSub = empty(ProtocolSub)\n    protocolSub.installBlock = block.number\n    subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).protocolSubPriceData()\n    if subInfo.usdValue != 0:\n        protocolSub.paidThroughBlock = block.number + subInfo.trialPeriod\n    self.protocolSub = protocolSub\n\n    # ambassador settings\n    self.canWalletBeAmbassador = True\n    if _ambassador != empty(address):\n        self.myAmbassador = _ambassador\n\n    self.canTransferToAltOwnerWallets = True\n\n\n@external\ndef setWallet(_wallet: address) -> bool:\n    \"\"\"\n    @notice Sets the associated wallet address for this config contract\n    @dev Can only be called once by the agent factory. Establishes the link between config and wallet.\n    @param _wallet Address of the wallet contract to be associated with this config\n    @return bool True if the wallet was successfully set\n    \"\"\"\n    assert not self.didSetWallet # dev: wallet already set\n    assert _wallet != empty(address) # dev: invalid wallet\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID) # dev: no perms\n    self.wallet = _wallet\n    self.didSetWallet = True\n    return True\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    \"\"\"\n    @notice Returns the current API version of the contract\n    @dev Returns a constant string representing the contract version\n    @return String[28] The API version string\n    \"\"\"\n    return API_VERSION\n\n\n#####################\n# Agent Permissions #\n#####################\n\n\n@view\n@external\ndef isAgentActive(_agent: address) -> bool:\n    return self.agentSettings[_agent].isActive\n\n\n@view\n@external\ndef canAgentAccess(\n    _agent: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n) -> bool:\n    return self._canAgentAccess(self.agentSettings[_agent], _action, _assets, _legoIds)\n\n\n@view\n@internal\ndef _canAgentAccess(\n    _agentInfo: AgentInfo,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n) -> bool:\n    \"\"\"\n    @notice Checks if an agent has permission to perform a specific action with given assets and lego IDs\n    @dev Validates agent's active status, allowed actions, allowed assets, and allowed lego IDs\n    @param _agentInfo The agent's information including permissions and allowed actions\n    @param _action The type of action being attempted\n    @param _assets Array of asset addresses involved in the action\n    @param _legoIds Array of lego IDs involved in the action\n    @return True if the agent has permission to perform the action, False otherwise\n    \"\"\"\n    if not _agentInfo.isActive:\n        return False\n\n    # check allowed actions\n    if not self._canAgentPerformAction(_action, _agentInfo.allowedActions):\n        return False\n\n    # check allowed assets\n    if len(_agentInfo.allowedAssets) != 0:\n        for i: uint256 in range(len(_assets), bound=MAX_ASSETS):\n            asset: address = _assets[i]\n            if asset != empty(address) and asset not in _agentInfo.allowedAssets:\n                return False\n\n    # check allowed lego ids\n    if len(_agentInfo.allowedLegoIds) != 0:\n        for i: uint256 in range(len(_legoIds), bound=MAX_LEGOS):\n            legoId: uint256 = _legoIds[i]\n            if legoId != 0 and legoId not in _agentInfo.allowedLegoIds:\n                return False\n\n    return True\n\n\n@view\n@internal\ndef _canAgentPerformAction(_action: ActionType, _allowedActions: AllowedActions) -> bool:\n    if not _allowedActions.isSet or _action == empty(ActionType):\n        return True\n    if _action == ActionType.DEPOSIT:\n        return _allowedActions.canDeposit\n    elif _action == ActionType.WITHDRAWAL:\n        return _allowedActions.canWithdraw\n    elif _action == ActionType.REBALANCE:\n        return _allowedActions.canRebalance\n    elif _action == ActionType.TRANSFER:\n        return _allowedActions.canTransfer\n    elif _action == ActionType.SWAP:\n        return _allowedActions.canSwap\n    elif _action == ActionType.CONVERSION:\n        return _allowedActions.canConvert\n    elif _action == ActionType.ADD_LIQ:\n        return _allowedActions.canAddLiq\n    elif _action == ActionType.REMOVE_LIQ:\n        return _allowedActions.canRemoveLiq\n    elif _action == ActionType.CLAIM_REWARDS:\n        return _allowedActions.canClaimRewards\n    elif _action == ActionType.BORROW:\n        return _allowedActions.canBorrow\n    elif _action == ActionType.REPAY:\n        return _allowedActions.canRepay\n    else:\n        return True # no action specified\n\n\n##########################\n# Subscription + Tx Fees #\n##########################\n\n\n# subscriptions\n\n\n@view\n@external\ndef getAgentSubscriptionStatus(_agent: address) -> SubPaymentInfo:\n    cd: CoreData = self._getCoreData()\n    na: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    na, agentSub = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, _agent, self.agentSettings[_agent].paidThroughBlock, 0, cd.oracleRegistry)\n    return agentSub\n\n\n@view\n@external\ndef getProtocolSubscriptionStatus() -> SubPaymentInfo:\n    cd: CoreData = self._getCoreData()\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    na: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, na = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, empty(address), 0, self.protocolSub.paidThroughBlock, cd.oracleRegistry)\n    return protocolSub\n\n\n@view\n@external\ndef canMakeSubscriptionPayments(_agent: address) -> (bool, bool):\n    cd: CoreData = self._getCoreData()\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, _agent, self.agentSettings[_agent].paidThroughBlock, self.protocolSub.paidThroughBlock, cd.oracleRegistry)\n    return self._checkIfSufficientFunds(protocolSub.asset, protocolSub.amount, agentSub.asset, agentSub.amount, cd)\n\n\n@external\ndef handleSubscriptionsAndPermissions(\n    _agent: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n    _cd: CoreData,\n) -> (SubPaymentInfo, SubPaymentInfo):\n    \"\"\"\n    @notice Handles the subscription and permission data for the given agent and action\n    @param _agent The address of the agent\n    @param _action The action to handle\n    @param _assets The assets to check\n    @param _legoIds The legos to check\n    @param _cd The core data\n    @return protocolSub The protocol subscription data\n    @return agentSub The agent subscription data\n    \"\"\"\n    assert msg.sender == self.wallet # dev: no perms\n\n    # check if agent can perform action with assets and legos\n    userAgentData: AgentInfo = empty(AgentInfo)\n    if _agent != empty(address):\n        userAgentData = self.agentSettings[_agent]\n        assert self._canAgentAccess(userAgentData, _action, _assets, _legoIds) # dev: agent not allowed\n\n    userProtocolData: ProtocolSub = self.protocolSub\n\n    # get latest sub data for agent and protocol\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = staticcall PriceSheets(_cd.priceSheets).getCombinedSubData(_cd.wallet, _agent, userAgentData.paidThroughBlock, userProtocolData.paidThroughBlock, _cd.oracleRegistry)\n\n    # check if sufficient funds\n    canPayProtocol: bool = False\n    canPayAgent: bool = False\n    canPayProtocol, canPayAgent = self._checkIfSufficientFunds(protocolSub.asset, protocolSub.amount, agentSub.asset, agentSub.amount, _cd)\n    assert canPayProtocol # dev: insufficient balance for protocol subscription payment\n    assert canPayAgent # dev: insufficient balance for agent subscription payment\n\n    # update and save new data\n    if protocolSub.didChange:\n        userProtocolData.paidThroughBlock = protocolSub.paidThroughBlock\n        self.protocolSub = userProtocolData\n    if agentSub.didChange:\n        userAgentData.paidThroughBlock = agentSub.paidThroughBlock\n        self.agentSettings[_agent] = userAgentData\n\n    # actual payments will happen from wallet\n    return protocolSub, agentSub\n\n\n####################\n# Random Utilities #\n####################\n\n\n@view\n@internal\ndef _getCoreData() -> CoreData:\n    addyRegistry: address = ADDY_REGISTRY\n    wallet: address = self.wallet\n    return CoreData(\n        owner=own.owner,\n        wallet=wallet,\n        walletConfig=self,\n        addyRegistry=addyRegistry,\n        agentFactory=staticcall AddyRegistry(addyRegistry).getAddy(AGENT_FACTORY_ID),\n        legoRegistry=staticcall AddyRegistry(addyRegistry).getAddy(LEGO_REGISTRY_ID),\n        priceSheets=staticcall AddyRegistry(addyRegistry).getAddy(PRICE_SHEETS_ID),\n        oracleRegistry=staticcall AddyRegistry(addyRegistry).getAddy(ORACLE_REGISTRY_ID),\n        trialFundsAsset=staticcall UserWallet(wallet).trialFundsAsset(),\n        trialFundsInitialAmount=staticcall UserWallet(wallet).trialFundsInitialAmount(),\n    )\n\n\n@view\n@internal\ndef _checkIfSufficientFunds(_protocolAsset: address, _protocolAmount: uint256, _agentAsset: address, _agentAmount: uint256, _cd: CoreData) -> (bool, bool):\n    canPayProtocol: bool = True\n    canPayAgent: bool = True\n\n    # check if any of these assets are also trial funds asset\n    trialFundsCurrentBal: uint256 = 0\n    trialFundsDeployed: uint256 = 0\n    if (_protocolAsset != empty(address) and _protocolAsset == _cd.trialFundsAsset) or (_agentAsset != empty(address) and _agentAsset == _cd.trialFundsAsset):\n        trialFundsCurrentBal = staticcall IERC20(_cd.trialFundsAsset).balanceOf(_cd.wallet)\n        trialFundsDeployed = staticcall LegoRegistry(_cd.legoRegistry).getUnderlyingForUser(_cd.wallet, _cd.trialFundsAsset)\n\n    # check if can make protocol payment\n    if _protocolAmount != 0:\n        availBalForProtocol: uint256 = self._getAvailBalAfterTrialFunds(_protocolAsset, _cd.wallet, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, trialFundsCurrentBal, trialFundsDeployed)\n        canPayProtocol = availBalForProtocol >= _protocolAmount\n\n        # update trial funds balance\n        if _protocolAsset != empty(address) and _protocolAsset == _cd.trialFundsAsset:\n            trialFundsCurrentBal -= _protocolAmount\n\n    # check if can make agent payment\n    if _agentAmount != 0:\n        availBalForAgent: uint256 = self._getAvailBalAfterTrialFunds(_agentAsset, _cd.wallet, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, trialFundsCurrentBal, trialFundsDeployed)\n        canPayAgent = availBalForAgent >= _agentAmount\n\n    return canPayProtocol, canPayAgent\n\n\n@view\n@external\ndef getAvailableTxAmount(\n    _asset: address,\n    _wantedAmount: uint256,\n    _shouldCheckTrialFunds: bool,\n    _cd: CoreData = empty(CoreData),\n) -> uint256:\n    \"\"\"\n    @notice Returns the maximum amount that can be sent from the wallet\n    @param _asset The address of the asset to check\n    @param _wantedAmount The amount of the asset to send\n    @param _shouldCheckTrialFunds Whether to check if the asset is a trial funds asset\n    @param _cd The core data\n    @return amount The maximum amount that can be sent\n    \"\"\"\n    cd: CoreData = _cd\n    if cd.wallet == empty(address):\n        cd = self._getCoreData()\n\n    availableAmount: uint256 = staticcall IERC20(_asset).balanceOf(cd.wallet)\n\n    # check if asset is trial funds asset\n    if _shouldCheckTrialFunds and _asset == cd.trialFundsAsset:\n        trialFundsDeployed: uint256 = staticcall LegoRegistry(cd.legoRegistry).getUnderlyingForUser(cd.wallet, _asset)\n        availableAmount = self._getAvailBalAfterTrialFunds(_asset, cd.wallet, cd.trialFundsAsset, cd.trialFundsInitialAmount, availableAmount, trialFundsDeployed)\n\n    # check if any reserve is set\n    reservedAmount: uint256 = self.reserveAssets[_asset]\n    if reservedAmount != 0:\n        assert availableAmount > reservedAmount # dev: insufficient balance after reserve\n        availableAmount -= reservedAmount\n\n    # return min of wanted amount and available amount\n    availableAmount = min(_wantedAmount, availableAmount)\n    assert availableAmount != 0 # dev: no funds available\n\n    return availableAmount\n\n\n@view\n@internal\ndef _getAvailBalAfterTrialFunds(\n    _asset: address,\n    _wallet: address,\n    _trialFundsAsset: address,\n    _trialFundsInitialAmount: uint256,\n    _trialFundsCurrentBal: uint256,\n    _trialFundsDeployed: uint256,\n) -> uint256:\n    if _asset != _trialFundsAsset:\n        return staticcall IERC20(_asset).balanceOf(_wallet)\n\n    # sufficient trial funds already deployed\n    if _trialFundsDeployed >= _trialFundsInitialAmount:\n        return _trialFundsCurrentBal\n\n    lockedAmount: uint256 = _trialFundsInitialAmount - _trialFundsDeployed\n    availAmount: uint256 = 0\n    if _trialFundsCurrentBal > lockedAmount:\n        availAmount = _trialFundsCurrentBal - lockedAmount\n\n    return availAmount\n\n\n##################\n# Yield Tracking #\n##################\n\n\n# deposits\n\n\n@external\ndef updateYieldTrackingOnDeposit(\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmountReceived: uint256,\n    _assetAmountDeposited: uint256,\n    _legoRegistry: address,\n):\n    assert msg.sender == self.wallet # dev: no perms\n\n    if self.isVaultToken[_asset]: # if asset is the vault token (i.e. Ripe collateral)\n        self._updateYieldTrackingOnExit(_asset, _legoRegistry)\n    self._updateYieldTrackingOnDeposit(_vaultToken, _vaultTokenAmountReceived, _assetAmountDeposited, _legoRegistry)\n\n\n@internal\ndef _updateYieldTrackingOnDeposit(\n    _vaultToken: address,\n    _vaultTokenAmountReceived: uint256,\n    _assetAmountDeposited: uint256,\n    _legoRegistry: address,\n):\n    if _vaultToken == empty(address):\n        return\n\n    # validate vault token\n    isVaultToken: bool = self.isVaultToken[_vaultToken]\n    if not isVaultToken and staticcall LegoRegistry(_legoRegistry).isVaultToken(_vaultToken):\n        self.isVaultToken[_vaultToken] = True\n        isVaultToken = True\n\n    if isVaultToken:\n        self.vaultTokenAmounts[_vaultToken] += _vaultTokenAmountReceived\n        self.depositedAmounts[_vaultToken] += _assetAmountDeposited\n\n\n# withdrawals\n\n\n@external\ndef updateYieldTrackingOnWithdrawal(\n    _vaultToken: address,\n    _vaultTokenAmountBurned: uint256,\n    _asset: address,\n    _assetAmountReceived: uint256,\n    _legoRegistry: address,\n) -> uint256:\n    assert msg.sender == self.wallet # dev: no perms\n\n    # if asset is the vault token (i.e. Ripe collateral)\n    if self.isVaultToken[_asset]: \n        self._updateYieldTrackingOnEntry(_asset, _assetAmountReceived, _legoRegistry)\n\n    # check if there are any yield profits\n    assetProfitAmount: uint256 = 0\n    if self.isVaultToken[_vaultToken]:\n        assetProfitAmount = self._updateYieldTrackingOnWithdrawal(_vaultToken, _vaultTokenAmountBurned, _assetAmountReceived, _legoRegistry)\n\n    return assetProfitAmount\n\n\n@internal\ndef _updateYieldTrackingOnWithdrawal(\n    _vaultToken: address,\n    _vaultTokenAmountBurned: uint256,\n    _assetAmountReceived: uint256,\n    _legoRegistry: address,\n) -> uint256:\n    actualVaultTokenBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self.wallet)\n    trackedVaultTokenBalance: uint256 = self.vaultTokenAmounts[_vaultToken]\n\n    # sufficient balance, see if we need to actually ADD to the tracked balance\n    if actualVaultTokenBalance >= trackedVaultTokenBalance:\n        self._updateYieldTrackingOnEntry(_vaultToken, actualVaultTokenBalance - trackedVaultTokenBalance, _legoRegistry)\n        return 0\n\n    # reduce the tracked balance\n    vaultTokenToReduce: uint256 = trackedVaultTokenBalance - actualVaultTokenBalance\n    assetAmountToReduce: uint256 = _assetAmountReceived * vaultTokenToReduce // _vaultTokenAmountBurned\n\n    # adjust vault token amount\n    shouldZeroOut: bool = False\n    if vaultTokenToReduce >= trackedVaultTokenBalance:\n        self.vaultTokenAmounts[_vaultToken] = 0\n        shouldZeroOut = True\n    else:\n        self.vaultTokenAmounts[_vaultToken] -= vaultTokenToReduce\n\n    # handle asset tracking\n    profitAmount: uint256 = 0\n    trackedAssetAmount: uint256 = self.depositedAmounts[_vaultToken]\n    if assetAmountToReduce > trackedAssetAmount:\n        profitAmount = assetAmountToReduce - trackedAssetAmount\n        self.depositedAmounts[_vaultToken] = 0\n    elif shouldZeroOut:\n        self.depositedAmounts[_vaultToken] = 0\n    else:\n        self.depositedAmounts[_vaultToken] -= assetAmountToReduce\n\n    return profitAmount\n\n\n# other\n\n\n@external\ndef updateYieldTrackingOnSwap(_tokenIn: address, _tokenOut: address, _tokenOutAmount: uint256, _legoRegistry: address):\n    assert msg.sender == self.wallet # dev: no perms\n\n    # someone may have swapped out of a vault token\n    if self.isVaultToken[_tokenIn]:\n        self._updateYieldTrackingOnExit(_tokenIn, _legoRegistry)\n\n    # someone may have swapped into a vault token\n    if self.isVaultToken[_tokenOut]:\n        self._updateYieldTrackingOnEntry(_tokenOut, _tokenOutAmount, _legoRegistry)\n\n\n@external\ndef updateYieldTrackingOnEntry(\n    _asset: address,\n    _amount: uint256,\n    _legoRegistry: address,\n):\n    assert msg.sender == self.wallet # dev: no perms\n\n    if self.isVaultToken[_asset]:\n        self._updateYieldTrackingOnEntry(_asset, _amount, _legoRegistry)\n\n\n@internal\ndef _updateYieldTrackingOnEntry(\n    _vaultToken: address,\n    _vaultTokenAmount: uint256,\n    _legoRegistry: address,\n):\n    if _vaultTokenAmount == 0:\n        return\n\n    # get lego details for vault token\n    na: uint256 = 0\n    legoAddr: address = empty(address)\n    na, legoAddr = staticcall LegoRegistry(_legoRegistry).getLegoFromVaultToken(_vaultToken)\n    if legoAddr == empty(address):\n        return\n\n    actualVaultTokenAmount: uint256 = min(_vaultTokenAmount, staticcall IERC20(_vaultToken).balanceOf(self.wallet))\n    if actualVaultTokenAmount != 0:\n        self.vaultTokenAmounts[_vaultToken] += actualVaultTokenAmount\n        self.depositedAmounts[_vaultToken] += staticcall LegoYield(legoAddr).getUnderlyingAmount(_vaultToken, actualVaultTokenAmount)\n\n\n@external\ndef updateYieldTrackingOnExit(_asset: address, _legoRegistry: address):\n    assert msg.sender == self.wallet # dev: no perms\n\n    if self.isVaultToken[_asset]:\n        self._updateYieldTrackingOnExit(_asset, _legoRegistry)\n\n\n@internal\ndef _updateYieldTrackingOnExit(_vaultToken: address, _legoRegistry: address):\n    actualVaultTokenBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self.wallet)\n    trackedVaultTokenBalance: uint256 = self.vaultTokenAmounts[_vaultToken]\n\n    # sufficient balance, see if we need to actually ADD to the tracked balance\n    if actualVaultTokenBalance >= trackedVaultTokenBalance:\n        self._updateYieldTrackingOnEntry(_vaultToken, actualVaultTokenBalance - trackedVaultTokenBalance, _legoRegistry)\n        return\n\n    # reduce the tracked balance\n    vaultTokenToReduce: uint256 = trackedVaultTokenBalance - actualVaultTokenBalance\n\n    # zero out the tracked balance\n    if vaultTokenToReduce >= trackedVaultTokenBalance:\n        self.vaultTokenAmounts[_vaultToken] = 0\n        self.depositedAmounts[_vaultToken] = 0\n\n    else:\n        self.vaultTokenAmounts[_vaultToken] -= vaultTokenToReduce\n\n        # reduce the tracked asset amount\n        trackedAssetAmount: uint256 = self.depositedAmounts[_vaultToken]\n        if trackedAssetAmount != 0:\n            assetAmountToReduce: uint256 = trackedAssetAmount * vaultTokenToReduce // trackedVaultTokenBalance\n            self.depositedAmounts[_vaultToken] -= assetAmountToReduce\n\n\n####################\n# Wallet Migration #\n####################\n\n\n@external\ndef startMigrationOut(\n    _newWallet: address,\n    _assetsToMigrate: DynArray[address, MAX_MIGRATION_ASSETS] = [],\n    _whitelistToMigrate: DynArray[address, MAX_MIGRATION_WHITELIST] = [],\n) -> bool:\n    cd: CoreData = self._getCoreData()\n    assert msg.sender == cd.owner # dev: no perms\n    assert not self.didMigrateOut # dev: already migrated out\n\n    # validate migration\n    newWalletConfig: address = staticcall UserWallet(_newWallet).walletConfig()\n    self._validateAltWalletDuringMigration(_newWallet, newWalletConfig, cd.agentFactory)\n    for r: address in _whitelistToMigrate:\n        assert self.isRecipientAllowed[r] # dev: new wallet has different whitelist\n\n    # recover trial funds first\n    extcall UserWallet(cd.wallet).clawBackTrialFunds() # not asserting True, may have already been done\n\n    # migrate wallet\n    assert extcall UserWallet(cd.wallet).migrateWalletOut(_newWallet, _assetsToMigrate, _whitelistToMigrate) # dev: migration failed\n\n    self.didMigrateOut = True\n    log UserWalletStartMigration(newWallet=_newWallet, numAssetsToMigrate=len(_assetsToMigrate), numWhitelistToMigrate=len(_whitelistToMigrate))\n    return True\n\n\n@external\ndef finishMigrationIn(\n    _whitelistToMigrate: DynArray[address, MAX_MIGRATION_WHITELIST],\n    _assetsMigrated: DynArray[address, MAX_MIGRATION_ASSETS],\n    _vaultTokensMigrated: DynArray[address, MAX_MIGRATION_ASSETS],\n) -> bool:\n    cd: CoreData = self._getCoreData()\n    assert not self.didMigrateIn # dev: already migrated\n\n    # validate migration\n    oldWallet: address = msg.sender\n    oldWalletConfig: address = staticcall UserWallet(oldWallet).walletConfig()\n    self._validateAltWalletDuringMigration(oldWallet, oldWalletConfig, cd.agentFactory)\n\n    # validate valid whitelist\n    if len(_whitelistToMigrate) != 0:\n        for r: address in _whitelistToMigrate:\n            assert staticcall WalletConfig(oldWalletConfig).isRecipientAllowed(r) # dev: old wallet has different whitelist\n            assert self._setWhitelistAddrFromMigration(r) # dev: failed to set whitelist address\n\n    # update yield tracking\n    if len(_vaultTokensMigrated) != 0:\n        for vaultToken: address in _vaultTokensMigrated:\n            self.isVaultToken[vaultToken] = True\n            self.vaultTokenAmounts[vaultToken] += staticcall WalletConfig(oldWalletConfig).vaultTokenAmounts(vaultToken)\n            self.depositedAmounts[vaultToken] += staticcall WalletConfig(oldWalletConfig).depositedAmounts(vaultToken)\n\n    self.didMigrateIn = True\n    log UserWalletFinishMigration(oldWallet=oldWallet, numWhitelistMigrated=len(_whitelistToMigrate), numVaultTokensMigrated=len(_vaultTokensMigrated), numAssetsMigrated=len(_assetsMigrated))\n    return True\n\n\n@view\n@internal\ndef _validateAltWalletDuringMigration(_altWallet: address, _altWalletConfig: address, _agentFactory: address):\n    assert staticcall AgentFactory(_agentFactory).isUserWallet(_altWallet) # dev: must be Underscore wallet\n\n    # make sure owner is the same\n    assert staticcall WalletConfig(_altWalletConfig).owner() == own.owner # dev: alt wallet has different owner\n\n    # cannot have any pending owner changes\n    assert not own._hasPendingOwnerChange() # dev: this wallet has pending owner change\n    assert not staticcall WalletConfig(_altWalletConfig).hasPendingOwnerChange() # dev: alt wallet has pending owner change\n\n    # make sure ambassador is the same\n    assert staticcall WalletConfig(_altWalletConfig).myAmbassador() == self.myAmbassador # dev: ambassador doesn't match\n\n\n##################\n# Agent Settings #\n##################\n\n\n# add or modify agent settings\n\n\n@nonreentrant\n@external\ndef addOrModifyAgent(\n    _agent: address,\n    _allowedAssets: DynArray[address, MAX_ASSETS] = [],\n    _allowedLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n    _allowedActions: AllowedActions = empty(AllowedActions),\n) -> bool:\n    \"\"\"\n    @notice Adds a new agent or modifies an existing agent's permissions\n        If empty arrays are provided, the agent has access to all assets and lego ids\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to add or modify\n    @param _allowedAssets List of assets the agent can interact with\n    @param _allowedLegoIds List of lego IDs the agent can use\n    @param _allowedActions The actions the agent can perform\n    @return bool True if the agent was successfully added or modified\n    \"\"\"\n    owner: address = own.owner\n    assert msg.sender == owner # dev: no perms\n    assert _agent != owner # dev: agent cannot be owner\n    assert _agent != empty(address) # dev: invalid agent\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    agentInfo.isActive = True\n\n    # allowed actions\n    agentInfo.allowedActions = _allowedActions\n    agentInfo.allowedActions.isSet = self._hasAllowedActionsSet(_allowedActions)\n\n    # sanitize other input data\n    agentInfo.allowedAssets, agentInfo.allowedLegoIds = self._sanitizeAgentInputData(_allowedAssets, _allowedLegoIds)\n\n    # get subscription info\n    priceSheets: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(PRICE_SHEETS_ID)\n    subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).getAgentSubPriceData(_agent)\n\n    isNewAgent: bool = (agentInfo.installBlock == 0)\n    if isNewAgent:\n        agentInfo.installBlock = block.number\n        if subInfo.usdValue != 0:\n            agentInfo.paidThroughBlock = block.number + subInfo.trialPeriod\n\n    # may not have had sub setup before\n    elif subInfo.usdValue != 0:\n        agentInfo.paidThroughBlock = max(agentInfo.paidThroughBlock, agentInfo.installBlock + subInfo.trialPeriod)\n\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    if isNewAgent:\n        log AgentAdded(agent=_agent, allowedAssets=len(agentInfo.allowedAssets), allowedLegoIds=len(agentInfo.allowedLegoIds))\n    else:\n        log AgentModified(agent=_agent, allowedAssets=len(agentInfo.allowedAssets), allowedLegoIds=len(agentInfo.allowedLegoIds))\n    return True\n\n\n@view\n@internal\ndef _sanitizeAgentInputData(\n    _allowedAssets: DynArray[address, MAX_ASSETS],\n    _allowedLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (DynArray[address, MAX_ASSETS], DynArray[uint256, MAX_LEGOS]):\n\n    # nothing to do here\n    if len(_allowedAssets) == 0 and len(_allowedLegoIds) == 0:\n        return _allowedAssets, _allowedLegoIds\n\n    # sanitize and dedupe assets\n    cleanAssets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(len(_allowedAssets), bound=MAX_ASSETS):\n        asset: address = _allowedAssets[i]\n        if asset == empty(address):\n            continue\n        if asset not in cleanAssets:\n            cleanAssets.append(asset)\n\n    # validate and dedupe lego ids\n    cleanLegoIds: DynArray[uint256, MAX_LEGOS] = []\n    if len(_allowedLegoIds) != 0:\n        legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(LEGO_REGISTRY_ID)\n        for i: uint256 in range(len(_allowedLegoIds), bound=MAX_LEGOS):\n            legoId: uint256 = _allowedLegoIds[i]\n            if not staticcall LegoRegistry(legoRegistry).isValidLegoId(legoId):\n                continue\n            if legoId not in cleanLegoIds:\n                cleanLegoIds.append(legoId)\n\n    return cleanAssets, cleanLegoIds\n\n\n# disable agent\n\n\n@nonreentrant\n@external\ndef disableAgent(_agent: address) -> bool:\n    \"\"\"\n    @notice Disables an existing agent\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to disable\n    @return bool True if the agent was successfully disabled\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n    agentInfo.isActive = False\n    self.agentSettings[_agent] = agentInfo\n\n    log AgentDisabled(agent=_agent, prevAllowedAssets=len(agentInfo.allowedAssets), prevAllowedLegoIds=len(agentInfo.allowedLegoIds))\n    return True\n\n\n# add lego id for agent\n\n\n@nonreentrant\n@external\ndef addLegoIdForAgent(_agent: address, _legoId: uint256) -> bool:\n    \"\"\"\n    @notice Adds a lego ID to an agent's allowed legos\n    @dev Can only be called by the owner\n    @param _agent The address of the agent\n    @param _legoId The lego ID to add\n    @return bool True if the lego ID was successfully added\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(LEGO_REGISTRY_ID)\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_legoId)\n    assert _legoId not in agentInfo.allowedLegoIds # dev: lego id already saved\n\n    # save data\n    agentInfo.allowedLegoIds.append(_legoId)\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    log LegoIdAddedToAgent(agent=_agent, legoId=_legoId)\n    return True\n\n\n# add asset for agent\n\n\n@nonreentrant\n@external\ndef addAssetForAgent(_agent: address, _asset: address) -> bool:\n    \"\"\"\n    @notice Adds an asset to an agent's allowed assets\n    @dev Can only be called by the owner\n    @param _agent The address of the agent\n    @param _asset The asset address to add\n    @return bool True if the asset was successfully added\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    assert _asset != empty(address) # dev: invalid asset\n    assert _asset not in agentInfo.allowedAssets # dev: asset already saved\n\n    # save data\n    agentInfo.allowedAssets.append(_asset)\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    log AssetAddedToAgent(agent=_agent, asset=_asset)\n    return True\n\n\n# modify allowed actions\n\n\n@nonreentrant\n@external\ndef modifyAllowedActions(_agent: address, _allowedActions: AllowedActions = empty(AllowedActions)) -> bool:\n    \"\"\"\n    @notice Modifies the allowed actions for an agent\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to modify\n    @param _allowedActions The new allowed actions\n    @return bool True if the allowed actions were successfully modified\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    agentInfo.allowedActions = _allowedActions\n    agentInfo.allowedActions.isSet = self._hasAllowedActionsSet(_allowedActions)\n    self.agentSettings[_agent] = agentInfo\n\n    log AllowedActionsModified(agent=_agent, canDeposit=_allowedActions.canDeposit, canWithdraw=_allowedActions.canWithdraw, canRebalance=_allowedActions.canRebalance, canTransfer=_allowedActions.canTransfer, canSwap=_allowedActions.canSwap, canConvert=_allowedActions.canConvert, canAddLiq=_allowedActions.canAddLiq, canRemoveLiq=_allowedActions.canRemoveLiq, canClaimRewards=_allowedActions.canClaimRewards, canBorrow=_allowedActions.canBorrow, canRepay=_allowedActions.canRepay)\n    return True\n\n\n@view\n@internal\ndef _hasAllowedActionsSet(_actions: AllowedActions) -> bool:\n    return _actions.canDeposit or _actions.canWithdraw or _actions.canRebalance or _actions.canTransfer or _actions.canSwap or _actions.canConvert\n\n\n######################\n# Transfer Whitelist #\n######################\n\n\n@view\n@external\ndef canTransferToRecipient(_recipient: address) -> bool:\n    \"\"\"\n    @notice Checks if a transfer to a recipient is allowed\n    @param _recipient The address of the recipient\n    @return bool True if the transfer is allowed, false otherwise\n    \"\"\"\n    if self.isRecipientAllowed[_recipient]:\n        return True\n\n    # pending ownership change, don't even check alt wallet ownership\n    if own._hasPendingOwnerChange():\n        return False\n\n    # if enabled, check if alt wallet has same owner\n    if self.canTransferToAltOwnerWallets:\n        return self._doesWalletHaveSameOwner(_recipient)\n\n    return False\n\n\n@view\n@external\ndef doesWalletHaveSameOwner(_wallet: address) -> bool:\n    return self._doesWalletHaveSameOwner(_wallet)\n\n\n@view\n@internal\ndef _doesWalletHaveSameOwner(_wallet: address) -> bool:\n    \"\"\"\n    @notice Checks if the wallet is an Underscore wallet with the same owner as this wallet\n    @dev This function verifies that:\n        1. The wallet is a valid Underscore wallet\n        2. The wallet config has no pending ownership changes\n        3. The wallet has the same owner as this wallet\n    @param _wallet The address of the wallet to check\n    @return bool True if the wallet is an Underscore wallet with the same owner, False otherwise\n    \"\"\"\n    isSame: bool = False\n\n    # check if wallet is Underscore wallet, if owner is same (no pending ownership changes), transfer is allowed\n    agentFactory: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    if staticcall AgentFactory(agentFactory).isUserWallet(_wallet):\n        walletConfig: address = staticcall UserWallet(_wallet).walletConfig()\n        if not staticcall WalletConfig(walletConfig).hasPendingOwnerChange():\n            isSame = own.owner == staticcall WalletConfig(walletConfig).owner()\n\n    return isSame\n\n\n@external\ndef setCanTransferToAltOwnerWallets(_canTransfer: bool) -> bool:\n    \"\"\"\n    @notice Sets the flag for allowing transfers to other AI wallets (with same owner)\n    @dev Can only be called by the owner\n    @param _canTransfer The new flag value (True or False)\n    @return bool True if the flag was successfully set\n    \"\"\"\n    assert msg.sender == own.owner # dev: only owner can set\n    if self.canTransferToAltOwnerWallets == _canTransfer:\n        return False\n    self.canTransferToAltOwnerWallets = _canTransfer\n    log CanTransferToAltOwnerWalletsSet(canTransfer=_canTransfer)\n    return True\n\n\n@nonreentrant\n@external\ndef addWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Adds an address to the whitelist\n    @dev Can only be called by the owner\n    @param _addr The address to add to the whitelist\n    \"\"\"\n    owner: address = own.owner\n    assert msg.sender == owner # dev: only owner can add whitelist\n\n    assert _addr != empty(address) # dev: invalid addr\n    assert _addr != owner # dev: owner cannot be whitelisted\n    assert _addr != self # dev: wallet config cannot be whitelisted\n    assert _addr != self.wallet # dev: wallet cannot be whitelisted\n    assert not self.isRecipientAllowed[_addr] # dev: already whitelisted\n    assert self.pendingWhitelist[_addr].initiatedBlock == 0 # dev: pending whitelist already exists\n\n    # this uses same delay as ownership change\n    confirmBlock: uint256 = block.number + own.ownershipChangeDelay\n    self.pendingWhitelist[_addr] = PendingWhitelist(\n        initiatedBlock = block.number,\n        confirmBlock = confirmBlock,\n    )\n    log WhitelistAddrPending(addr=_addr, confirmBlock=confirmBlock)\n\n\n@nonreentrant\n@external\ndef confirmWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Confirms a whitelist address\n    @dev Can only be called by the owner\n    @param _addr The address to confirm\n    \"\"\"\n    assert msg.sender == own.owner # dev: only owner can confirm\n\n    data: PendingWhitelist = self.pendingWhitelist[_addr]\n    assert data.initiatedBlock != 0 # dev: no pending whitelist\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n\n    self.pendingWhitelist[_addr] = empty(PendingWhitelist)\n    self.isRecipientAllowed[_addr] = True\n    log WhitelistAddrConfirmed(addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@nonreentrant\n@external\ndef cancelPendingWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Cancels a pending whitelist address\n    @dev Can only be called by the owner or governance\n    @param _addr The address to cancel\n    \"\"\"\n    agentFactory: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    assert msg.sender == own.owner or staticcall AgentFactory(agentFactory).canCancelCriticalAction(msg.sender) # dev: no perms (only owner or governance)\n\n    data: PendingWhitelist = self.pendingWhitelist[_addr]\n    assert data.initiatedBlock != 0 # dev: no pending whitelist\n    self.pendingWhitelist[_addr] = empty(PendingWhitelist)\n    log WhitelistAddrCancelled(addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, cancelledBy=msg.sender)\n\n\n@nonreentrant\n@external\ndef removeWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Removes an address from the whitelist\n    @dev Can only be called by the owner\n    @param _addr The address to remove from the whitelist\n    \"\"\"\n    assert msg.sender == own.owner # dev: only owner can remove whitelist\n    assert self.isRecipientAllowed[_addr] # dev: not on whitelist\n\n    self.isRecipientAllowed[_addr] = False\n    log WhitelistAddrRemoved(addr=_addr)\n\n\n@internal\ndef _setWhitelistAddrFromMigration(_addr: address) -> bool:\n    self.isRecipientAllowed[_addr] = True\n    log WhitelistAddrSetViaMigration(addr=_addr)\n    return True\n\n\n##################\n# Reserve Assets #\n##################\n\n\n@nonreentrant\n@external\ndef setReserveAsset(_asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Sets a reserve asset\n    @dev Can only be called by the owner\n    @param _asset The address of the asset to set\n    @param _amount The amount of the asset to set\n    @return bool True if the reserve asset was successfully set\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n    assert _asset != empty(address) # dev: invalid asset\n    self.reserveAssets[_asset] = _amount\n    log ReserveAssetSet(asset=_asset, amount=_amount)\n    return True\n\n\n@nonreentrant\n@external\ndef setManyReserveAssets(_assets: DynArray[ReserveAsset, MAX_ASSETS]) -> bool:\n    \"\"\"\n    @notice Sets multiple reserve assets\n    @dev Can only be called by the owner\n    @param _assets The array of reserve assets to set\n    @return bool True if the reserve assets were successfully set\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n    assert len(_assets) != 0 # dev: invalid array length\n    for i: uint256 in range(len(_assets), bound=MAX_ASSETS):\n        asset: address = _assets[i].asset\n        amount: uint256 = _assets[i].amount\n        assert asset != empty(address) # dev: invalid asset\n        self.reserveAssets[asset] = amount\n        log ReserveAssetSet(asset=asset, amount=amount)\n\n    return True\n\n\n########################\n# Ambassador Settings #\n########################\n\n\n@view\n@external\ndef getProceedsAddr() -> address:\n    \"\"\"\n    @notice Gets the address where proceeds should be forwarded to (if this wallet is an ambassador)\n    @dev Returns:\n        - empty address if wallet cannot be ambassador\n        - forwarder address if set\n        - wallet address as fallback\n    @return address The address where proceeds should be sent\n    \"\"\"\n    # cannot get proceeds\n    if not self.canWalletBeAmbassador:\n        return empty(address)\n\n    # forwarder set\n    forwarder: address = self.ambassadorForwarder\n    if forwarder != empty(address):\n        return forwarder\n\n    # return wallet\n    return self.wallet\n\n\n@nonreentrant\n@external\ndef setAmbassadorForwarder(_addr: address) -> bool:\n    \"\"\"\n    @notice Sets the forwarder address for the ambassador (where proceeds will be sent)\n    @dev Can only be called by the owner\n    @param _addr The address to forward proceeds to\n    @return bool True if the forwarder was successfully set\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n    if self.ambassadorForwarder == _addr or _addr == self.wallet:\n        return False\n\n    # make sure valid underscore wallet\n    agentFactory: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    if not staticcall UserWallet(_addr).canBeAmbassador() or not staticcall AgentFactory(agentFactory).isUserWallet(_addr):\n        return False\n\n    self.ambassadorForwarder = _addr\n    log AmbassadorForwarderSet(addr=_addr)\n    return True\n\n\n@nonreentrant\n@external\ndef setCanWalletBeAmbassador(_canWalletBeAmbassador: bool) -> bool:\n    \"\"\"\n    @notice Sets the flag for allowing the wallet to be an ambassador\n    @dev Can only be called by the owner\n    @param _canWalletBeAmbassador The new flag value (True or False)\n    @return bool True if the flag was successfully set\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n    if self.canWalletBeAmbassador == _canWalletBeAmbassador:\n        return False\n    self.canWalletBeAmbassador = _canWalletBeAmbassador\n    log CanWalletBeAmbassadorSet(canWalletBeAmbassador=_canWalletBeAmbassador)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address) -> bool:\n    \"\"\"\n    @notice transfers funds from the config contract to the main wallet\n    @dev anyone can call this!\n    @param _asset The address of the asset to recover\n    @return bool True if the funds were recovered successfully\n    \"\"\"\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    wallet: address = self.wallet\n    if empty(address) in [wallet, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(wallet, balance, default_return_value=True) # dev: recovery failed\n    log FundsRecovered(asset=_asset, recipient=wallet, balance=balance)\n    return True\n",
            "sha256sum": "2145ef04924c772e1ec5d94d67b083543e8f5654af767821fe99b8a5dbf8bf66"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/templates/UserWalletConfigTemplate.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "7521f4e6c36309d9c1b53667a6e884346944391f6a44291bfd80a5812335ffe9"
      },
      "args": ""
    },
    "AgentTemplate": {
      "address": "0x76Eb19Ae42c07a7AD50aFD58b579a7c45bd70183",
      "abi": [
        {
          "name": "AgentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeInitiated",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeConfirmed",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeCancelled",
          "inputs": [
            {
              "name": "cancelledOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingOwnerChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeOwnership",
          "inputs": [
            {
              "name": "_newOwner",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOwnershipChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "owner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingOwner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newOwner",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ownershipChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "_ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapActionHash",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            },
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performBatchActions",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                },
                {
                  "name": "swapInstructions",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "amountIn",
                      "type": "uint256"
                    },
                    {
                      "name": "minAmountOut",
                      "type": "uint256"
                    },
                    {
                      "name": "tokenPath",
                      "type": "address[]"
                    },
                    {
                      "name": "poolPath",
                      "type": "address[]"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performBatchActions",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                },
                {
                  "name": "swapInstructions",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "amountIn",
                      "type": "uint256"
                    },
                    {
                      "name": "minAmountOut",
                      "type": "uint256"
                    },
                    {
                      "name": "tokenPath",
                      "type": "address[]"
                    },
                    {
                      "name": "poolPath",
                      "type": "address[]"
                    }
                  ]
                }
              ]
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBatchActionHash",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                },
                {
                  "name": "swapInstructions",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "amountIn",
                      "type": "uint256"
                    },
                    {
                      "name": "minAmountOut",
                      "type": "uint256"
                    },
                    {
                      "name": "tokenPath",
                      "type": "address[]"
                    },
                    {
                      "name": "poolPath",
                      "type": "address[]"
                    }
                  ]
                }
              ]
            },
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "usedSignatures",
          "inputs": [
            {
              "name": "arg0",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_minOwnerChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxOwnerChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Ownership.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AgentFactory:\n    def canCancelCriticalAction(_addr: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct PendingOwner:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent OwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    cancelledBy: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeDelaySet:\n    delayBlocks: uint256\n\n# owner\nowner: public(address) # owner of the wallet\npendingOwner: public(PendingOwner) # pending owner of the wallet\nownershipChangeDelay: public(uint256) # num blocks to wait before owner can be changed\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\n_ADDY_REGISTRY: public(immutable(address))\n\nAGENT_FACTORY_ID: constant(uint256) = 1\n\n\n@deploy\ndef __init__(\n    _owner: address,\n    _addyRegistry: address,\n    _minOwnerChangeDelay: uint256,\n    _maxOwnerChangeDelay: uint256,\n):\n    assert empty(address) not in [_owner, _addyRegistry] # dev: invalid addrs\n    self.owner = _owner\n    _ADDY_REGISTRY = _addyRegistry\n\n    assert _minOwnerChangeDelay < _maxOwnerChangeDelay # dev: invalid delay\n    MIN_OWNER_CHANGE_DELAY = _minOwnerChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxOwnerChangeDelay\n    self.ownershipChangeDelay = _minOwnerChangeDelay\n\n\n####################\n# Ownership Change #\n####################\n\n\n@view\n@external\ndef hasPendingOwnerChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending ownership change\n    @return bool True if there is a pending ownership change, false otherwise\n    \"\"\"\n    return self._hasPendingOwnerChange()\n\n\n@view\n@internal\ndef _hasPendingOwnerChange() -> bool:\n    return self.pendingOwner.confirmBlock != 0\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    \"\"\"\n    @notice Initiates a new ownership change\n    @dev Can only be called by the current owner\n    @param _newOwner The address of the new owner\n    \"\"\"\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingOwner = PendingOwner(\n        newOwner= _newOwner,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log OwnershipChangeInitiated(prevOwner=currentOwner, newOwner=_newOwner, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmOwnershipChange():\n    \"\"\"\n    @notice Confirms the ownership change\n    @dev Can only be called by the new owner\n    \"\"\"\n    data: PendingOwner = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeConfirmed(prevOwner=prevOwner, newOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelOwnershipChange():\n    \"\"\"\n    @notice Cancels the ownership change\n    @dev Can only be called by the current owner or governance\n    \"\"\"\n    agentFactory: address = staticcall AddyRegistry(_ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    assert msg.sender == self.owner or staticcall AgentFactory(agentFactory).canCancelCriticalAction(msg.sender) # dev: no perms (only owner or governance)\n\n    data: PendingOwner = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeCancelled(cancelledOwner=data.newOwner, cancelledBy=msg.sender, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setOwnershipChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the ownership change delay\n    @dev Can only be called by the owner\n    @param _numBlocks The number of blocks to wait before ownership can be changed\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNER_CHANGE_DELAY and _numBlocks <= MAX_OWNER_CHANGE_DELAY # dev: invalid delay\n    self.ownershipChangeDelay = _numBlocks\n    log OwnershipChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "2f0e7c45d64763e64f27ede081332d3ba84c61832ea4721e2123a6cd7654870b"
          },
          "interfaces/UserWalletInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n# struct SwapInstruction:\n#     legoId: uint256\n#     amountIn: uint256\n#     minAmountOut: uint256\n#     tokenPath: DynArray[address, 5]\n#     poolPath: DynArray[address, 5 - 1]\n\n\n# @external\n# def swapTokens(_swapInstructions: DynArray[SwapInstruction, 5]) -> (uint256, uint256, uint256):\n#     ...\n\n\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    ...\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    ...\n\n\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    ...\n\n\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    ...\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    ...\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    ...\n",
            "sha256sum": "b6f85ddff061e77069cceb9d110c05c679a6ea34b68f3ff69c95c1b07d83c453"
          },
          "contracts/core/templates/AgentTemplate.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: own\nexports: own.__interface__\n\nimport contracts.modules.Ownership as own\nfrom interfaces import UserWalletInterface\nfrom ethereum.ercs import IERC20\n\ninterface UserWalletCustom:\n    def swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256): nonpayable\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct Signature:\n    signature: Bytes[65]\n    signer: address\n    expiration: uint256\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct ActionInstruction:\n    usePrevAmountOut: bool\n    action: ActionType\n    legoId: uint256\n    asset: address\n    vault: address\n    amount: uint256\n    altLegoId: uint256\n    altAsset: address\n    altVault: address\n    altAmount: uint256\n    minAmountOut: uint256\n    pool: address\n    proof: bytes32\n    nftAddr: address\n    nftTokenId: uint256\n    tickLower: int24\n    tickUpper: int24\n    minAmountA: uint256\n    minAmountB: uint256\n    minLpAmount: uint256\n    liqToRemove: uint256\n    recipient: address\n    isWethToEthConversion: bool\n    swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]\n\nevent AgentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nusedSignatures: public(HashMap[Bytes[65], bool])\n\n# eip-712\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\nDEPOSIT_TYPE_HASH: constant(bytes32) = keccak256('Deposit(address userWallet,uint256 legoId,address asset,address vault,uint256 amount,uint256 expiration)')\nWITHDRAWAL_TYPE_HASH: constant(bytes32) = keccak256('Withdrawal(address userWallet,uint256 legoId,address asset,address vaultToken,uint256 vaultTokenAmount,uint256 expiration)')\nREBALANCE_TYPE_HASH: constant(bytes32) = keccak256('Rebalance(address userWallet,uint256 fromLegoId,address fromAsset,address fromVaultToken,uint256 toLegoId,address toVault,uint256 fromVaultTokenAmount,uint256 expiration)')\nSWAP_ACTION_TYPE_HASH: constant(bytes32) =  keccak256('Swap(address userWallet,SwapInstruction[] swapInstructions,uint256 expiration)')\nSWAP_INSTRUCTION_TYPE_HASH: constant(bytes32) = keccak256('SwapInstruction(uint256 legoId,uint256 amountIn,uint256 minAmountOut,address[] tokenPath,address[] poolPath)')\nADD_LIQ_TYPE_HASH: constant(bytes32) = keccak256('AddLiquidity(address userWallet,uint256 legoId,address nftAddr,uint256 nftTokenId,address pool,address tokenA,address tokenB,uint256 amountA,uint256 amountB,int24 tickLower,int24 tickUpper,uint256 minAmountA,uint256 minAmountB,uint256 minLpAmount,uint256 expiration)')\nREMOVE_LIQ_TYPE_HASH: constant(bytes32) = keccak256('RemoveLiquidity(address userWallet,uint256 legoId,address nftAddr,uint256 nftTokenId,address pool,address tokenA,address tokenB,uint256 liqToRemove,uint256 minAmountA,uint256 minAmountB,uint256 expiration)')\nTRANSFER_TYPE_HASH: constant(bytes32) = keccak256('Transfer(address userWallet,address recipient,uint256 amount,address asset,uint256 expiration)')\nETH_TO_WETH_TYPE_HASH: constant(bytes32) = keccak256('EthToWeth(address userWallet,uint256 amount,uint256 depositLegoId,address depositVault,uint256 expiration)')\nWETH_TO_ETH_TYPE_HASH: constant(bytes32) = keccak256('WethToEth(address userWallet,uint256 amount,address recipient,uint256 withdrawLegoId,address withdrawVaultToken,uint256 expiration)')\nCLAIM_REWARDS_TYPE_HASH: constant(bytes32) = keccak256('ClaimRewards(address userWallet,uint256 legoId,address market,address rewardToken,uint256 rewardAmount,bytes32 proof,uint256 expiration)')\nBORROW_TYPE_HASH: constant(bytes32) = keccak256('Borrow(address userWallet,uint256 legoId,address borrowAsset,uint256 amount,uint256 expiration)')\nREPAY_TYPE_HASH: constant(bytes32) = keccak256('Repay(address userWallet,uint256 legoId,address paymentAsset,uint256 paymentAmount,uint256 expiration)')\nBATCH_ACTIONS_TYPE_HASH: constant(bytes32) =  keccak256('BatchActions(address userWallet,ActionInstruction[] instructions,uint256 expiration)')\nACTION_INSTRUCTION_TYPE_HASH: constant(bytes32) = keccak256('ActionInstruction(bool usePrevAmountOut,uint256 action,uint256 legoId,address asset,address vault,uint256 amount,uint256 altLegoId,address altAsset,address altVault,uint256 altAmount,uint256 minAmountOut,address pool,bytes32 proof,address nftAddr,uint256 nftTokenId,int24 tickLower,int24 tickUpper,uint256 minAmountA,uint256 minAmountB,uint256 minLpAmount,uint256 liqToRemove,address recipient,bool isWethToEthConversion,SwapInstruction[] swapInstructions)')\n\nMAX_INSTRUCTIONS: constant(uint256) = 20\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nAPI_VERSION: constant(String[28]) = \"0.0.2\"\n\n\n@deploy\ndef __init__(\n    _owner: address,\n    _addyRegistry: address,\n    _minOwnerChangeDelay: uint256,\n    _maxOwnerChangeDelay: uint256,\n):\n    \"\"\"\n    @notice Initializes the Agent contract with owner and registry settings\n    @dev Sets up the initial ownership and registry configuration for the agent\n    @param _owner The address that will own the agent\n    @param _addyRegistry The address of the registry contract\n    @param _minOwnerChangeDelay The minimum delay required for owner changes\n    @param _maxOwnerChangeDelay The maximum delay allowed for owner changes\n    \"\"\"\n    assert empty(address) not in [_owner, _addyRegistry] # dev: invalid addrs\n    own.__init__(_owner, _addyRegistry, _minOwnerChangeDelay, _maxOwnerChangeDelay)\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    return API_VERSION\n\n\n###########\n# Deposit #\n###########\n\n\n@nonreentrant\n@external\ndef depositTokens(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(DEPOSIT_TYPE_HASH, _userWallet, _legoId, _asset, _vault, _amount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).depositTokens(_legoId, _asset, _vault, _amount)\n\n\n############\n# Withdraw #\n############\n\n\n@nonreentrant\n@external\ndef withdrawTokens(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(WITHDRAWAL_TYPE_HASH, _userWallet, _legoId, _asset, _vaultToken, _vaultTokenAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).withdrawTokens(_legoId, _asset, _vaultToken, _vaultTokenAmount)\n\n\n#############\n# Rebalance #\n#############\n\n\n@nonreentrant\n@external\ndef rebalance(\n    _userWallet: address,\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REBALANCE_TYPE_HASH, _userWallet, _fromLegoId, _fromAsset, _fromVaultToken, _toLegoId, _toVault, _fromVaultTokenAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).rebalance(_fromLegoId, _fromAsset, _fromVaultToken, _toLegoId, _toVault, _fromVaultTokenAmount)\n\n\n########\n# Swap #\n########\n\n\n@nonreentrant\n@external\ndef swapTokens(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSwapSignature(self._hashSwapInstructions(_userWallet, _swapInstructions, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletCustom(_userWallet).swapTokens(_swapInstructions)\n\n\n@view\n@internal\ndef _encodeSwapInstruction(_instruction: SwapInstruction) -> Bytes[544]:\n    # Just encode, no hash\n    return abi_encode(\n        SWAP_INSTRUCTION_TYPE_HASH,\n        _instruction.legoId,\n        _instruction.amountIn,\n        _instruction.minAmountOut,\n        _instruction.tokenPath,\n        _instruction.poolPath\n    )\n\n\n@view\n@internal\ndef _encodeSwapInstructions(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> Bytes[2720]:\n    concatenated: Bytes[2720] = empty(Bytes[2720]) # max size for 5 instructions - 5*544\n    for i: uint256 in range(len(_swapInstructions), bound=MAX_SWAP_INSTRUCTIONS):\n        concatenated = convert(\n            concat(\n                concatenated, \n                self._encodeSwapInstruction(_swapInstructions[i])\n            ),\n            Bytes[2720]\n        )\n    return concatenated\n\n\n@view\n@internal\ndef _hashSwapInstructions(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _expiration: uint256,\n) -> Bytes[2880]:\n    # Now we encode everything and hash only once at the end\n    return abi_encode(\n        SWAP_ACTION_TYPE_HASH,\n        _userWallet,\n        self._encodeSwapInstructions(_swapInstructions),\n        _expiration\n    )\n\n\n@internal\ndef _isValidSwapSignature(_encodedValue: Bytes[2880], _sig: Signature):\n    encoded_hash: bytes32 = keccak256(_encodedValue)\n    domain_sep: bytes32 = self._domainSeparator()\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', domain_sep, encoded_hash))\n\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n@view\n@external\ndef getSwapActionHash(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _expiration: uint256,\n) -> bytes32:\n    encodedValue: Bytes[2880] = self._hashSwapInstructions(_userWallet, _swapInstructions, _expiration)\n    encoded_hash: bytes32 = keccak256(encodedValue)\n    return keccak256(concat(b'\\x19\\x01', self._domainSeparator(), encoded_hash))\n\n\n##################\n# Borrow + Repay #\n##################\n\n\n@nonreentrant\n@external\ndef borrow(\n    _userWallet: address,\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(BORROW_TYPE_HASH, _userWallet, _legoId, _borrowAsset, _amount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).borrow(_legoId, _borrowAsset, _amount)\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _userWallet: address,\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REPAY_TYPE_HASH, _userWallet, _legoId, _paymentAsset, _paymentAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).repayDebt(_legoId, _paymentAsset, _paymentAmount)\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _userWallet: address,\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(CLAIM_REWARDS_TYPE_HASH, _userWallet, _legoId, _market, _rewardToken, _rewardAmount, _proof, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    extcall UserWalletInterface(_userWallet).claimRewards(_legoId, _market, _rewardToken, _rewardAmount, _proof)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(ADD_LIQ_TYPE_HASH, _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).addLiquidity(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, bool):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REMOVE_LIQ_TYPE_HASH, _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).removeLiquidity(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB)\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _userWallet: address,\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(TRANSFER_TYPE_HASH, _userWallet, _recipient, _amount, _asset, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).transferFunds(_recipient, _amount, _asset)\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@nonreentrant\n@external\ndef convertEthToWeth(\n    _userWallet: address,\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(ETH_TO_WETH_TYPE_HASH, _userWallet, _amount, _depositLegoId, _depositVault, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).convertEthToWeth(_amount, _depositLegoId, _depositVault)\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(\n    _userWallet: address,\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> uint256:\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(WETH_TO_ETH_TYPE_HASH, _userWallet, _amount, _recipient, _withdrawLegoId, _withdrawVaultToken, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).convertWethToEth(_amount, _recipient, _withdrawLegoId, _withdrawVaultToken)\n\n\n#################\n# Batch Actions #\n#################\n\n\n@nonreentrant\n@external\ndef performBatchActions(\n    _userWallet: address,\n    _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> bool:\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidBatchSignature(self._hashBatchActions(_userWallet, _instructions, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n\n    assert len(_instructions) != 0 # dev: no instructions\n    prevAmountReceived: uint256 = 0\n\n    # not using these vars\n    naAddyA: address = empty(address)\n    naValueA: uint256 = 0\n    naValueB: uint256 = 0\n    naValueC: uint256 = 0\n    naValueD: uint256 = 0\n    naBool: bool = False\n\n    # iterate through instructions\n    for j: uint256 in range(len(_instructions), bound=MAX_INSTRUCTIONS):\n        i: ActionInstruction = _instructions[j]\n\n        # deposit\n        if i.action == ActionType.DEPOSIT:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).depositTokens(i.legoId, i.asset, i.vault, amount)\n\n        # withdraw\n        elif i.action == ActionType.WITHDRAWAL:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            prevAmountReceived, naValueA, naValueB = extcall UserWalletInterface(_userWallet).withdrawTokens(i.legoId, i.asset, i.vault, amount)\n\n        # rebalance\n        elif i.action == ActionType.REBALANCE:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).rebalance(i.legoId, i.asset, i.vault, i.altLegoId, i.altVault, amount)\n\n        # swap\n        elif i.action == ActionType.SWAP:\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                i.swapInstructions[0].amountIn = prevAmountReceived\n            naValueA, prevAmountReceived, naValueB = extcall UserWalletCustom(_userWallet).swapTokens(i.swapInstructions)\n\n        # borrow\n        elif i.action == ActionType.BORROW:\n            naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).borrow(i.legoId, i.asset, i.amount)\n\n        # repay debt\n        elif i.action == ActionType.REPAY:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            extcall UserWalletInterface(_userWallet).repayDebt(i.legoId, i.asset, amount)\n            prevAmountReceived = 0\n\n        # claim rewards\n        elif i.action == ActionType.CLAIM_REWARDS:\n            extcall UserWalletInterface(_userWallet).claimRewards(i.legoId, i.asset, i.altAsset, i.amount, i.proof)\n            prevAmountReceived = 0\n\n        # add liquidity\n        elif i.action == ActionType.ADD_LIQ:\n            amount: uint256 = i.amount # this only goes towards token A amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            prevAmountReceived, naValueA, naValueB, naValueC, naValueD = extcall UserWalletInterface(_userWallet).addLiquidity(i.legoId, i.nftAddr, i.nftTokenId, i.pool, i.asset, i.altAsset, amount, i.altAmount, i.tickLower, i.tickUpper, i.minAmountA, i.minAmountB, i.minLpAmount)\n\n        # remove liquidity\n        elif i.action == ActionType.REMOVE_LIQ:\n            amount: uint256 = i.liqToRemove # this only goes to `_liqToRemove`\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naValueB, naValueC, naBool = extcall UserWalletInterface(_userWallet).removeLiquidity(i.legoId, i.nftAddr, i.nftTokenId, i.pool, i.asset, i.altAsset, amount, i.minAmountA, i.minAmountB)\n            prevAmountReceived = 0\n\n        # transfer\n        elif i.action == ActionType.TRANSFER:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            extcall UserWalletInterface(_userWallet).transferFunds(i.recipient, amount, i.asset)\n            prevAmountReceived = 0\n\n        # conversion\n        elif i.action == ActionType.CONVERSION:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            if i.isWethToEthConversion:\n                prevAmountReceived = extcall UserWalletInterface(_userWallet).convertWethToEth(amount, i.recipient, i.legoId, i.vault)\n            else:\n                prevAmountReceived, naAddyA, naValueB = extcall UserWalletInterface(_userWallet).convertEthToWeth(amount, i.legoId, i.vault)\n                if naValueB != 0:\n                    prevAmountReceived = naValueB\n\n    return True\n\n\n@view\n@internal\ndef _encodeBatchActionInstruction(_instr: ActionInstruction) -> Bytes[3552]:\n    encodedSwapInstructions: Bytes[2720] = self._encodeSwapInstructions(_instr.swapInstructions)\n\n    # Just encode, no hash\n    return abi_encode(\n        ACTION_INSTRUCTION_TYPE_HASH,\n        _instr.usePrevAmountOut,\n        _instr.action,\n        _instr.legoId,\n        _instr.asset,\n        _instr.vault,\n        _instr.amount,\n        _instr.altLegoId,\n        _instr.altAsset,\n        _instr.altVault,\n        _instr.altAmount,\n        _instr.minAmountOut,\n        _instr.pool,\n        _instr.proof,\n        _instr.nftAddr,\n        _instr.nftTokenId,\n        _instr.tickLower,\n        _instr.tickUpper,\n        _instr.minAmountA,\n        _instr.minAmountB,\n        _instr.minLpAmount,\n        _instr.liqToRemove,\n        _instr.recipient,\n        _instr.isWethToEthConversion,\n        encodedSwapInstructions\n    )\n\n\n@view\n@internal\ndef _encodeBatchInstructions(_instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS]) -> Bytes[15360]:\n    concatenated: Bytes[15360] = empty(Bytes[15360]) # max size for 20 instructions - 20*768\n    for i: uint256 in range(len(_instructions), bound=MAX_INSTRUCTIONS):\n        concatenated = convert(\n            concat(\n                concatenated, \n                self._encodeBatchActionInstruction(_instructions[i])\n            ),\n            Bytes[15360]\n        )\n    return concatenated\n\n\n@view\n@internal\ndef _hashBatchActions(_userWallet: address, _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS], _expiration: uint256) -> Bytes[15520]:\n    # Now we encode everything and hash only once at the end\n    return abi_encode(\n        BATCH_ACTIONS_TYPE_HASH,\n        _userWallet,\n        self._encodeBatchInstructions(_instructions),\n        _expiration\n    )\n\n\n@internal\ndef _isValidBatchSignature(_encodedValue: Bytes[15520], _sig: Signature):\n    encoded_hash: bytes32 = keccak256(_encodedValue)\n    domain_sep: bytes32 = self._domainSeparator()\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', domain_sep, encoded_hash))\n\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n@view\n@external\ndef getBatchActionHash(_userWallet: address, _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS], _expiration: uint256) -> bytes32:\n    encodedValue: Bytes[15520] = self._hashBatchActions(_userWallet, _instructions, _expiration)\n    encoded_hash: bytes32 = keccak256(encodedValue)\n    return keccak256(concat(b'\\x19\\x01', self._domainSeparator(), encoded_hash))\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    return keccak256(\n        concat(\n            DOMAIN_TYPE_HASH,\n            keccak256('UnderscoreAgent'),\n            keccak256(API_VERSION),\n            abi_encode(chain.id, self)\n        )\n    )\n\n\n@internal\ndef _isValidSignature(_encodedValue: Bytes[512], _sig: Signature):\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', self._domainSeparator(), keccak256(_encodedValue)))\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address) -> bool:\n    \"\"\"\n    @notice Transfers funds from the agent wallet to the owner\n    @dev Only callable by the owner\n    @param _asset The address of the asset to recover\n    @return bool True if the funds were recovered successfully, False if no funds to recover\n    \"\"\"\n    owner: address = own.owner\n    assert msg.sender == owner # dev: no perms\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [owner, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(owner, balance, default_return_value=True) # dev: recovery failed\n    log AgentFundsRecovered(asset=_asset, recipient=owner, balance=balance)\n    return True\n",
            "sha256sum": "fa81cf28d731c83858f1526066510ee543d18e5aa5d15d2e640e30b72d5d17f3"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/templates/AgentTemplate.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "221a6c5ca40933af26a45c45ddb1b12d8375c6d4b786c7cbae86553ee28239e6"
      },
      "args": ""
    },
    "AgentFactory": {
      "address": "0xd5a1cc447D94114136A5a8828F59d5a1cfe65038",
      "abi": [
        {
          "name": "UserWalletCreated",
          "inputs": [
            {
              "name": "mainAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "configAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "agent",
              "type": "address",
              "indexed": false
            },
            {
              "name": "ambassador",
              "type": "address",
              "indexed": false
            },
            {
              "name": "creator",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentCreated",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "creator",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateInitiated",
          "inputs": [
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "addressType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "addressType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "cancelledTemplate",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "addressType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "shouldWhitelist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldEnforceWhitelistSet",
          "inputs": [
            {
              "name": "shouldEnforce",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NumUserWalletsAllowedSet",
          "inputs": [
            {
              "name": "numAllowed",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NumAgentsAllowedSet",
          "inputs": [
            {
              "name": "numAllowed",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentBlacklistSet",
          "inputs": [
            {
              "name": "agentAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldBlacklist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanCriticalCancelSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canCancel",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TrialFundsDataSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorYieldBonusPaid",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ambassador",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ratio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorBonusRatioSet",
          "inputs": [
            {
              "name": "ratio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentFactoryFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentFactoryActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserWallet",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_ambassador",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_ambassador",
              "type": "address"
            },
            {
              "name": "_shouldUseTrialFunds",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgent",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createAgent",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createAgent",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateUserWalletTemplateUpdate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmUserWalletTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelUserWalletTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserWalletTemplateAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserWalletTemplateInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPendingUserWalletTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingUserWalletTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateUserWalletConfigTemplateUpdate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmUserWalletConfigTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelUserWalletConfigTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserWalletConfigTemplateAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserWalletConfigTemplateInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPendingUserWalletConfigTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingUserWalletConfigTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateAgentTemplateUpdate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAgentTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAgentTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentTemplateAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentTemplateInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPendingAgentTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAgentTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAddressChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWhitelist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldWhitelist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldEnforceWhitelist",
          "inputs": [
            {
              "name": "_shouldEnforce",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumUserWalletsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumUserWalletsAllowed",
          "inputs": [
            {
              "name": "_numAllowed",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumAgentsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumAgentsAllowed",
          "inputs": [
            {
              "name": "_numAllowed",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentBlacklist",
          "inputs": [
            {
              "name": "_agentAddr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canCancelCriticalAction",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanCriticalCancel",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_canCancel",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setTrialFundsData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "clawBackTrialFunds",
          "inputs": [
            {
              "name": "_wallets",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "clawBackTrialFundsLegacy",
          "inputs": [
            {
              "name": "_recoveries",
              "type": "tuple[]",
              "components": [
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "opportunities",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "vaultToken",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "payAmbassadorYieldBonus",
          "inputs": [
            {
              "name": "_ambassador",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAmbassadorBonusRatio",
          "inputs": [
            {
              "name": "_bonusRatio",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateDefaultAgentUpdate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmDefaultAgentUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelDefaultAgentUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDefaultAgentAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDefaultAgentInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPendingDefaultAgentUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingDefaultAgentUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsFromAgentFactory",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserWalletLocal",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserWallets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgentLocal",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAgents",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addressInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddress",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addressChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ambassadorBonusRatio",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserWalletsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAgentsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "whitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "shouldEnforceWhitelist",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentBlacklist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canCriticalCancel",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH_ADDR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_ADDRESS_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_ADDRESS_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_userWalletTemplate",
              "type": "address"
            },
            {
              "name": "_userConfigTemplate",
              "type": "address"
            },
            {
              "name": "_agentTemplate",
              "type": "address"
            },
            {
              "name": "_defaultAgent",
              "type": "address"
            },
            {
              "name": "_minChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/core/AgentFactory.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\n\ninterface MainWallet:\n    def recoverTrialFunds(_opportunities: DynArray[TrialFundsOpp, MAX_LEGOS]) -> bool: nonpayable\n    def clawBackTrialFunds() -> bool: nonpayable\n    def canBeAmbassador() -> bool: view\n    def apiVersion() -> String[28]: view\n\ninterface AddyRegistry:\n    def setIsUserWalletOrAgent(_addr: address, _isThing: bool, _setUserWalletMap: bool) -> bool: nonpayable\n    def isUserWallet(_addr: address) -> bool: view\n    def isAgent(_addr: address) -> bool: view\n\ninterface WalletConfig:\n    def setWallet(_wallet: address) -> bool: nonpayable\n\nflag AddressTypes:\n    USER_WALLET_TEMPLATE\n    USER_WALLET_CONFIG_TEMPLATE\n    AGENT_TEMPLATE\n    DEFAULT_AGENT\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n\nstruct PendingAddress:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct TrialFundsData:\n    asset: address\n    amount: uint256\n\nstruct TrialFundsOpp:\n    legoId: uint256\n    vaultToken: address\n\nstruct TrialFundsRecovery:\n    wallet: address\n    opportunities: DynArray[TrialFundsOpp, MAX_LEGOS]\n\nevent UserWalletCreated:\n    mainAddr: indexed(address)\n    configAddr: indexed(address)\n    owner: indexed(address)\n    agent: address\n    ambassador: address\n    creator: address\n\nevent AgentCreated:\n    agent: indexed(address)\n    owner: indexed(address)\n    creator: address\n\nevent AddressUpdateInitiated:\n    prevAddr: indexed(address)\n    newAddr: indexed(address)\n    confirmBlock: uint256\n    addressType: AddressTypes\n\nevent AddressUpdateConfirmed:\n    prevAddr: indexed(address)\n    newAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    addressType: AddressTypes\n\nevent AddressUpdateCancelled:\n    cancelledTemplate: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    addressType: AddressTypes\n\nevent AddressChangeDelaySet:\n    delayBlocks: uint256\n\nevent WhitelistSet:\n    addr: address\n    shouldWhitelist: bool\n\nevent ShouldEnforceWhitelistSet:\n    shouldEnforce: bool\n\nevent NumUserWalletsAllowedSet:\n    numAllowed: uint256\n\nevent NumAgentsAllowedSet:\n    numAllowed: uint256\n\nevent AgentBlacklistSet:\n    agentAddr: indexed(address)\n    shouldBlacklist: bool\n\nevent CanCriticalCancelSet:\n    addr: indexed(address)\n    canCancel: bool\n\nevent TrialFundsDataSet:\n    asset: indexed(address)\n    amount: uint256\n\nevent AmbassadorYieldBonusPaid:\n    user: indexed(address)\n    ambassador: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    ratio: uint256\n\nevent AmbassadorBonusRatioSet:\n    ratio: uint256\n\nevent AgentFactoryFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent AgentFactoryActivated:\n    isActivated: bool\n\n# user wallets\nisUserWalletLocal: public(HashMap[address, bool])\nnumUserWallets: public(uint256)\n\n# agents\nisAgentLocal: public(HashMap[address, bool])\nnumAgents: public(uint256)\n\n# important addresses (mostly templates)\naddressInfo: public(HashMap[AddressTypes, AddressInfo])\npendingAddress: public(HashMap[AddressTypes, PendingAddress])\naddressChangeDelay: public(uint256)\n\n# ambassador bonus\nambassadorBonusRatio: public(uint256)\n\n# trial funds\ntrialFundsData: public(TrialFundsData)\n\n# limits / controls\nnumUserWalletsAllowed: public(uint256)\nnumAgentsAllowed: public(uint256)\nwhitelist: public(HashMap[address, bool])\nshouldEnforceWhitelist: public(bool)\nagentBlacklist: public(HashMap[address, bool])\ncanCriticalCancel: public(HashMap[address, bool])\n\n# config\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\nWETH_ADDR: public(immutable(address))\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_RECOVERIES: constant(uint256) = 100\nMAX_LEGOS: constant(uint256) = 20\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMIN_ADDRESS_CHANGE_DELAY: public(immutable(uint256))\nMAX_ADDRESS_CHANGE_DELAY: public(immutable(uint256))\n\n\n@deploy\ndef __init__(\n    _addyRegistry: address,\n    _wethAddr: address,\n    _userWalletTemplate: address,\n    _userConfigTemplate: address,\n    _agentTemplate: address,\n    _defaultAgent: address,\n    _minChangeDelay: uint256,\n    _maxChangeDelay: uint256,\n):\n    assert empty(address) not in [_addyRegistry, _wethAddr] # dev: invalid addrs\n    ADDY_REGISTRY = _addyRegistry\n    WETH_ADDR = _wethAddr\n\n    assert _minChangeDelay <= _maxChangeDelay # dev: invalid delay\n    MIN_OWNER_CHANGE_DELAY = _minChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxChangeDelay\n    MIN_ADDRESS_CHANGE_DELAY = _minChangeDelay\n    MAX_ADDRESS_CHANGE_DELAY = _maxChangeDelay\n\n    self.addressChangeDelay = _minChangeDelay\n    self.isActivated = True\n\n    # set user wallet templates\n    if self._isValidAddress(_userWalletTemplate, empty(address)) and self._isValidAddress(_userConfigTemplate, empty(address)):\n        self._setAddress(AddressTypes.USER_WALLET_TEMPLATE, _userWalletTemplate, 1)\n        self._setAddress(AddressTypes.USER_WALLET_CONFIG_TEMPLATE, _userConfigTemplate, 1)\n\n    # set agent template\n    if self._isValidAddress(_agentTemplate, empty(address)):\n        self._setAddress(AddressTypes.AGENT_TEMPLATE, _agentTemplate, 1)\n\n    # set default agent\n    if self._isValidAddress(_defaultAgent, empty(address)):\n        self._setAddress(AddressTypes.DEFAULT_AGENT, _defaultAgent, 1)\n\n    # local gov\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n\n######################\n# Create User Wallet #\n######################\n\n\n@view\n@external\ndef isUserWallet(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is a user wallet within Underscore Protocol\n    @dev Returns True if the address is a user wallet, False otherwise\n    \"\"\"\n    return self._isUserWallet(_addr)\n\n\n@view\n@internal\ndef _isUserWallet(_addr: address) -> bool:\n    isUserWallet: bool = self.isUserWalletLocal[_addr]\n    if isUserWallet:\n        return True\n    return staticcall AddyRegistry(ADDY_REGISTRY).isUserWallet(_addr)\n\n\n@external\ndef createUserWallet(\n    _owner: address = msg.sender,\n    _ambassador: address = empty(address),\n    _shouldUseTrialFunds: bool = True,\n) -> address:\n    \"\"\"\n    @notice Create a new User Wallet with specified owner and optional agent\n    @dev Creates a minimal proxy of the current template and initializes it\n    @param _owner The address that will own the wallet (defaults to msg.sender)\n    @param _ambassador The address of the ambassador who invited the user (defaults to empty address)\n    @param _shouldUseTrialFunds Whether to use trial funds (defaults to True)\n    @return The address of the newly created wallet, or empty address if setup is invalid\n    \"\"\"\n    assert self.isActivated # dev: not activated\n\n    # get templates\n    userWalletTemplate: address = self.addressInfo[AddressTypes.USER_WALLET_TEMPLATE].addr\n    walletConfigTemplate: address = self.addressInfo[AddressTypes.USER_WALLET_CONFIG_TEMPLATE].addr\n    assert empty(address) not in [userWalletTemplate, walletConfigTemplate, _owner] # dev: invalid setup\n\n    # check safety / limits\n    if self.shouldEnforceWhitelist and not self.whitelist[msg.sender]:\n        return empty(address)\n    if self.numUserWallets >= self.numUserWalletsAllowed:\n        return empty(address)\n\n    # validate ambassador\n    ambassador: address = empty(address)\n    if _ambassador != empty(address):\n        assert self._isUserWallet(_ambassador) # dev: ambassador must be Underscore wallet\n        version: String[28] = staticcall MainWallet(_ambassador).apiVersion()\n        if version != \"0.0.1\" and version != \"0.0.2\" and staticcall MainWallet(_ambassador).canBeAmbassador():\n            ambassador = _ambassador\n\n    # initial trial funds asset + amount\n    trialFundsData: TrialFundsData = self.trialFundsData\n    if _shouldUseTrialFunds and trialFundsData.asset != empty(address):\n        trialFundsData.amount = min(trialFundsData.amount, staticcall IERC20(trialFundsData.asset).balanceOf(self))\n\n    # create wallet contracts\n    defaultAgent: address = self.addressInfo[AddressTypes.DEFAULT_AGENT].addr\n    walletConfigAddr: address = create_from_blueprint(walletConfigTemplate, _owner, defaultAgent, ambassador, ADDY_REGISTRY, MIN_OWNER_CHANGE_DELAY, MAX_OWNER_CHANGE_DELAY)\n    mainWalletAddr: address = create_from_blueprint(userWalletTemplate, walletConfigAddr, ADDY_REGISTRY, WETH_ADDR, trialFundsData.asset, trialFundsData.amount)\n    assert extcall WalletConfig(walletConfigAddr).setWallet(mainWalletAddr) # dev: could not set wallet\n\n    # transfer after initialization\n    if trialFundsData.amount != 0:\n        assert extcall IERC20(trialFundsData.asset).transfer(mainWalletAddr, trialFundsData.amount, default_return_value=True) # dev: gift transfer failed\n\n    # update data\n    assert extcall AddyRegistry(ADDY_REGISTRY).setIsUserWalletOrAgent(mainWalletAddr, True, True) # dev: could not set is user wallet\n    self.isUserWalletLocal[mainWalletAddr] = True\n    self.numUserWallets += 1\n\n    log UserWalletCreated(mainAddr=mainWalletAddr, configAddr=walletConfigAddr, owner=_owner, agent=defaultAgent, ambassador=ambassador, creator=msg.sender)\n    return mainWalletAddr\n\n\n################\n# Create Agent #\n################\n\n\n@view\n@external\ndef isAgent(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is an agent within Underscore Protocol\n    @dev Returns True if the address is an agent, False otherwise\n    \"\"\"\n    return self._isAgent(_addr)\n\n\n@view\n@internal\ndef _isAgent(_addr: address) -> bool:\n    isAgent: bool = self.isAgentLocal[_addr]\n    if isAgent:\n        return True\n    return staticcall AddyRegistry(ADDY_REGISTRY).isAgent(_addr)\n\n\n@external\ndef createAgent(_owner: address = msg.sender) -> address:\n    \"\"\"\n    @notice Create a new Agent with specified owner\n    @dev Creates a minimal proxy of the current template and initializes it\n    @param _owner The address that will own the agent (defaults to msg.sender)\n    @return The address of the newly created agent, or empty address if setup is invalid\n    \"\"\"\n    assert self.isActivated # dev: not activated\n\n    agentTemplate: address = self.addressInfo[AddressTypes.AGENT_TEMPLATE].addr\n    assert empty(address) not in [agentTemplate, _owner] # dev: invalid setup\n\n    # check limits\n    if self.shouldEnforceWhitelist and not self.whitelist[msg.sender]:\n        return empty(address)\n    if self.numAgents >= self.numAgentsAllowed:\n        return empty(address)\n\n    # create agent contract\n    agentAddr: address = create_from_blueprint(agentTemplate, _owner, ADDY_REGISTRY, MIN_OWNER_CHANGE_DELAY, MAX_OWNER_CHANGE_DELAY)\n\n    # update data\n    assert extcall AddyRegistry(ADDY_REGISTRY).setIsUserWalletOrAgent(agentAddr, True, False) # dev: could not set is agent\n    self.isAgentLocal[agentAddr] = True\n    self.numAgents += 1\n\n    log AgentCreated(agent=agentAddr, owner=_owner, creator=msg.sender)\n    return agentAddr\n\n\n#############\n# Templates #\n#############\n\n\n# core user wallet\n\n\n@external\ndef initiateUserWalletTemplateUpdate(_newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._initiateAddressUpdate(AddressTypes.USER_WALLET_TEMPLATE, _newAddr, self.addressInfo[AddressTypes.USER_WALLET_TEMPLATE].addr)\n\n\n@external\ndef confirmUserWalletTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._confirmAddressUpdate(AddressTypes.USER_WALLET_TEMPLATE)\n\n\n@external\ndef cancelUserWalletTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._cancelAddressUpdate(AddressTypes.USER_WALLET_TEMPLATE)\n\n\n@view\n@external\ndef getUserWalletTemplateAddr() -> address:\n    return self.addressInfo[AddressTypes.USER_WALLET_TEMPLATE].addr\n\n\n@view\n@external\ndef getUserWalletTemplateInfo() -> AddressInfo:\n    return self.addressInfo[AddressTypes.USER_WALLET_TEMPLATE]\n\n\n@view\n@external\ndef getPendingUserWalletTemplateUpdate() -> PendingAddress:\n    return self.pendingAddress[AddressTypes.USER_WALLET_TEMPLATE]\n\n\n@view\n@external\ndef hasPendingUserWalletTemplateUpdate() -> bool:\n    return self._hasPendingAddressUpdate(AddressTypes.USER_WALLET_TEMPLATE)\n\n\n# user wallet config\n\n\n@external\ndef initiateUserWalletConfigTemplateUpdate(_newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._initiateAddressUpdate(AddressTypes.USER_WALLET_CONFIG_TEMPLATE, _newAddr, self.addressInfo[AddressTypes.USER_WALLET_CONFIG_TEMPLATE].addr)\n\n\n@external\ndef confirmUserWalletConfigTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._confirmAddressUpdate(AddressTypes.USER_WALLET_CONFIG_TEMPLATE)\n\n\n@external\ndef cancelUserWalletConfigTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._cancelAddressUpdate(AddressTypes.USER_WALLET_CONFIG_TEMPLATE)\n\n\n@view\n@external\ndef getUserWalletConfigTemplateAddr() -> address:\n    return self.addressInfo[AddressTypes.USER_WALLET_CONFIG_TEMPLATE].addr\n\n\n@view\n@external\ndef getUserWalletConfigTemplateInfo() -> AddressInfo:\n    return self.addressInfo[AddressTypes.USER_WALLET_CONFIG_TEMPLATE]\n\n\n@view\n@external\ndef getPendingUserWalletConfigTemplateUpdate() -> PendingAddress:\n    return self.pendingAddress[AddressTypes.USER_WALLET_CONFIG_TEMPLATE]\n\n\n@view\n@external\ndef hasPendingUserWalletConfigTemplateUpdate() -> bool:\n    return self._hasPendingAddressUpdate(AddressTypes.USER_WALLET_CONFIG_TEMPLATE)\n\n\n# agent template\n\n\n@external\ndef initiateAgentTemplateUpdate(_newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._initiateAddressUpdate(AddressTypes.AGENT_TEMPLATE, _newAddr, self.addressInfo[AddressTypes.AGENT_TEMPLATE].addr)\n\n\n@external\ndef confirmAgentTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._confirmAddressUpdate(AddressTypes.AGENT_TEMPLATE)\n\n\n@external\ndef cancelAgentTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._cancelAddressUpdate(AddressTypes.AGENT_TEMPLATE)\n\n\n@view\n@external\ndef getAgentTemplateAddr() -> address:\n    return self.addressInfo[AddressTypes.AGENT_TEMPLATE].addr\n\n\n@view\n@external\ndef getAgentTemplateInfo() -> AddressInfo:\n    return self.addressInfo[AddressTypes.AGENT_TEMPLATE]\n\n\n@view\n@external\ndef getPendingAgentTemplateUpdate() -> PendingAddress:\n    return self.pendingAddress[AddressTypes.AGENT_TEMPLATE]\n\n\n@view\n@external\ndef hasPendingAgentTemplateUpdate() -> bool:\n    return self._hasPendingAddressUpdate(AddressTypes.AGENT_TEMPLATE)\n\n\n# shared utilities\n\n\n@view\n@internal\ndef _hasPendingAddressUpdate(_addressType: AddressTypes) -> bool:\n    return self.pendingAddress[_addressType].confirmBlock != 0\n\n\n@view\n@internal\ndef _isValidAddress(_newAddr: address, _oldAddr: address) -> bool:\n    if _newAddr == empty(address) or not _newAddr.is_contract:\n        return False\n    return _newAddr != _oldAddr\n\n\n@internal\ndef _initiateAddressUpdate(_addressType: AddressTypes, _newAddr: address, _oldAddr: address) -> bool:\n    \"\"\"\n    @notice Initiate an address update\n    @dev Only callable by the governor, updates the address change delay\n    @param _addressType The type of address to update\n    @param _newAddr The new address\n    @param _oldAddr The old address\n    @return True if the address update was initiated successfully, False otherwise\n    \"\"\"\n    if not self._isValidAddress(_newAddr, _oldAddr):\n        return False\n\n    confirmBlock: uint256 = block.number + self.addressChangeDelay\n    self.pendingAddress[_addressType] = PendingAddress(\n        newAddr= _newAddr,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log AddressUpdateInitiated(prevAddr=_oldAddr, newAddr=_newAddr, confirmBlock=confirmBlock, addressType=_addressType)\n    return True\n\n\n@internal\ndef _confirmAddressUpdate(_addressType: AddressTypes) -> bool:\n    \"\"\"\n    @notice Confirm an address update\n    @dev Only callable by the governor, updates the address\n    @param _addressType The type of address to update\n    @return True if the address update was confirmed successfully, False otherwise\n    \"\"\"\n    data: PendingAddress = self.pendingAddress[_addressType]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n\n    prevTemplateInfo: AddressInfo = self.addressInfo[_addressType]\n    if not self._isValidAddress(data.newAddr, prevTemplateInfo.addr):\n        self.pendingAddress[_addressType] = empty(PendingAddress)\n        return False\n\n    self._setAddress(_addressType, data.newAddr, prevTemplateInfo.version + 1)\n    self.pendingAddress[_addressType] = empty(PendingAddress)\n    log AddressUpdateConfirmed(prevAddr=prevTemplateInfo.addr, newAddr=data.newAddr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, addressType=_addressType)\n    return True\n\n\n@internal\ndef _setAddress(_addressType: AddressTypes, _newAddr: address, _newVersion: uint256):\n    self.addressInfo[_addressType] = AddressInfo(\n        addr= _newAddr,\n        version= _newVersion,\n        lastModified=block.timestamp,\n    )\n\n\n@internal\ndef _cancelAddressUpdate(_addressType: AddressTypes) -> bool:\n    \"\"\"\n    @notice Cancel an address update\n    @dev Only callable by the governor, cancels the address update\n    @param _addressType The type of address to update\n    @return True if the address update was cancelled successfully, False otherwise\n    \"\"\"\n    data: PendingAddress = self.pendingAddress[_addressType]\n    assert data.confirmBlock != 0 # dev: no pending change\n\n    self.pendingAddress[_addressType] = empty(PendingAddress)\n    log AddressUpdateCancelled(cancelledTemplate=data.newAddr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, addressType=_addressType)\n    return True\n\n\n# time delay config\n\n\n@external\ndef setAddressChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Set the address change delay\n    @dev Only callable by the governor, updates the address change delay\n    @param _numBlocks The new address change delay in blocks\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_ADDRESS_CHANGE_DELAY and _numBlocks <= MAX_ADDRESS_CHANGE_DELAY # dev: invalid delay\n    self.addressChangeDelay = _numBlocks\n    log AddressChangeDelaySet(delayBlocks=_numBlocks)\n\n\n###################\n# Safety / Limits #\n###################\n\n\n# who can create wallets / agents\n\n\n@external\ndef setWhitelist(_addr: address, _shouldWhitelist: bool) -> bool:\n    \"\"\"\n    @notice Set the whitelist status for a given address\n    @dev Only callable by the governor, updates the whitelist state\n    @param _addr The address to set the whitelist status for\n    @param _shouldWhitelist True to whitelist, False to unwhitelist\n    @return True if the whitelist status was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.whitelist[_addr] = _shouldWhitelist\n    log WhitelistSet(addr=_addr, shouldWhitelist=_shouldWhitelist)\n    return True\n\n\n@external\ndef setShouldEnforceWhitelist(_shouldEnforce: bool) -> bool:\n    \"\"\"\n    @notice Set whether to enforce the whitelist for agent/wallet creation\n    @dev Only callable by the governor, updates the whitelist enforcement state\n    @param _shouldEnforce True to enforce whitelist, False to disable\n    @return True if the whitelist enforcement state was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.shouldEnforceWhitelist = _shouldEnforce\n    log ShouldEnforceWhitelistSet(shouldEnforce=_shouldEnforce)\n    return True\n\n\n# total num allowed (agents / wallets)\n\n\n@external\ndef setNumUserWalletsAllowed(_numAllowed: uint256 = max_value(uint256)) -> bool:\n    \"\"\"\n    @notice Set the maximum number of user wallets allowed\n    @dev Only callable by the governor, updates the maximum number of user wallets\n    @param _numAllowed The new maximum number of user wallets allowed\n    @return True if the maximum number was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.numUserWalletsAllowed = _numAllowed\n    log NumUserWalletsAllowedSet(numAllowed=_numAllowed)\n    return True\n\n\n@external\ndef setNumAgentsAllowed(_numAllowed: uint256 = max_value(uint256)) -> bool:\n    \"\"\"\n    @notice Set the maximum number of agents allowed\n    @dev Only callable by the governor, updates the maximum number of agents\n    @param _numAllowed The new maximum number of agents allowed\n    @return True if the maximum number was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.numAgentsAllowed = _numAllowed\n    log NumAgentsAllowedSet(numAllowed=_numAllowed)\n    return True\n\n\n# agent blacklist\n\n\n@external\ndef setAgentBlacklist(_agentAddr: address, _shouldBlacklist: bool) -> bool:\n    \"\"\"\n    @notice Set the blacklist status for a given agent address\n    @dev Only callable by the governor, updates the blacklist state\n    @param _agentAddr The address to set the blacklist status for\n    @param _shouldBlacklist True to blacklist, False to unblacklist\n    @return True if the blacklist status was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.agentBlacklist[_agentAddr] = _shouldBlacklist\n    log AgentBlacklistSet(agentAddr=_agentAddr, shouldBlacklist=_shouldBlacklist)\n    return True\n\n\n# cancel critical actions (on behalf of users)\n\n\n@view\n@external\ndef canCancelCriticalAction(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address can perform critical cancellations\n    @dev Returns true if the address is whitelisted or the governor\n    \"\"\"\n    return self.canCriticalCancel[_addr] or gov._canGovern(_addr)\n\n\n@external\ndef setCanCriticalCancel(_addr: address, _canCancel: bool) -> bool:\n    \"\"\"\n    @notice Set whether an address can perform critical cancellations\n    @dev Only callable by the governor, updates the critical cancel state\n    @param _addr The address to set the critical cancel state for\n    @param _canCancel True to allow permissions for critical cancel, False to disallow\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if _addr == empty(address) or self.canCriticalCancel[_addr] == _canCancel or gov._canGovern(_addr):\n        return False\n\n    self.canCriticalCancel[_addr] = _canCancel\n    log CanCriticalCancelSet(addr=_addr, canCancel=_canCancel)\n    return True\n\n\n###############\n# Trial Funds #\n###############\n\n\n@external\ndef setTrialFundsData(_asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Set the trial funds asset and amount for future wallet deployments\n    @dev Only callable by the governor, updates the trial funds data\n    @param _asset The address of the asset to set\n    @param _amount The amount of the asset to set\n    @return True if the data was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not _asset.is_contract or _asset == empty(address) or _amount == 0:\n        return False\n\n    self.trialFundsData = TrialFundsData(\n        asset=_asset,\n        amount=_amount,\n    )\n    log TrialFundsDataSet(asset=_asset, amount=_amount)\n    return True\n\n\n@external\ndef clawBackTrialFunds(_wallets: DynArray[address, MAX_RECOVERIES]) -> bool:\n    \"\"\"\n    @notice Claw back trial funds from a list of wallets\n    @dev Only callable by the governor or critical cancel address, transfers funds back here\n    @param _wallets The list of wallets to claw back funds from\n    @return True if the funds were successfully clawed back, False otherwise\n    \"\"\"\n    assert self.canCriticalCancel[msg.sender] or gov._canGovern(msg.sender) # dev: no perms\n    for w: address in _wallets:\n        assert extcall MainWallet(w).clawBackTrialFunds() # dev: clawback failed\n    return True\n\n\n@external\ndef clawBackTrialFundsLegacy(_recoveries: DynArray[TrialFundsRecovery, MAX_RECOVERIES]) -> bool:\n    assert self.canCriticalCancel[msg.sender] or gov._canGovern(msg.sender) # dev: no perms\n    for r: TrialFundsRecovery in _recoveries:\n        assert extcall MainWallet(r.wallet).recoverTrialFunds(r.opportunities) # dev: recovery failed\n    return True\n\n\n####################\n# Ambassador Bonus #\n####################\n\n\n@external\ndef payAmbassadorYieldBonus(_ambassador: address, _asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Pay an ambassador yield bonus\n    @dev Only callable by a wallet, transfers bonus to ambassador\n    @param _ambassador The address of the ambassador to pay the bonus to\n    @param _asset The address of the asset to pay the bonus from\n    @param _amount The amount of the bonus to pay\n    \"\"\"\n    if not self.isActivated:\n        return False\n\n    # make sure have correct inputs\n    if _ambassador == empty(address) or _asset == empty(address) or _amount == 0:\n        return False\n\n    # make sure sender is a wallet\n    wallet: address = msg.sender\n    if not self._isUserWallet(wallet):\n        return False\n\n    # check if bonus ratio is set\n    ambassadorBonusRatio: uint256 = self.ambassadorBonusRatio\n    if ambassadorBonusRatio == 0:\n        return False\n\n    # calculate bonus amount, transfer to ambassador\n    bonusAmount: uint256 = min(_amount * ambassadorBonusRatio // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if bonusAmount == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_ambassador, bonusAmount, default_return_value=True) # dev: bonus transfer failed\n    log AmbassadorYieldBonusPaid(user=wallet, ambassador=_ambassador, asset=_asset, amount=bonusAmount, ratio=ambassadorBonusRatio)\n    return True\n\n\n@external\ndef setAmbassadorBonusRatio(_bonusRatio: uint256) -> bool:\n    \"\"\"\n    @notice Set the bonus ratio for ambassadors\n    @dev Only callable by governor\n    @param _bonusRatio The bonus ratio for ambassadors\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _bonusRatio <= HUNDRED_PERCENT # dev: invalid ratio\n    self.ambassadorBonusRatio = _bonusRatio\n    log AmbassadorBonusRatioSet(ratio=_bonusRatio)\n    return True\n\n\n#################\n# Default Agent #\n#################\n\n\n@external\ndef initiateDefaultAgentUpdate(_newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._isAgent(_newAddr):\n        return False\n    return self._initiateAddressUpdate(AddressTypes.DEFAULT_AGENT, _newAddr, self.addressInfo[AddressTypes.DEFAULT_AGENT].addr)\n\n\n@external\ndef confirmDefaultAgentUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._isAgent(self.pendingAddress[AddressTypes.DEFAULT_AGENT].newAddr):\n        return False\n    return self._confirmAddressUpdate(AddressTypes.DEFAULT_AGENT)\n\n\n@external\ndef cancelDefaultAgentUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._cancelAddressUpdate(AddressTypes.DEFAULT_AGENT)\n\n\n@view\n@external\ndef getDefaultAgentAddr() -> address:\n    return self.addressInfo[AddressTypes.DEFAULT_AGENT].addr\n\n\n@view\n@external\ndef getDefaultAgentInfo() -> AddressInfo:\n    return self.addressInfo[AddressTypes.DEFAULT_AGENT]\n\n\n@view\n@external\ndef getPendingDefaultAgentUpdate() -> PendingAddress:\n    return self.pendingAddress[AddressTypes.DEFAULT_AGENT]\n\n\n@view\n@external\ndef hasPendingDefaultAgentUpdate() -> bool:\n    return self._hasPendingAddressUpdate(AddressTypes.DEFAULT_AGENT)\n\n\n####################################\n# Recover Funds From Agent Factory #\n####################################\n\n\n@external\ndef recoverFundsFromAgentFactory(_asset: address, _recipient: address) -> bool:\n    \"\"\"\n    @notice Recover funds from the factory\n    @dev Only callable by the governor, transfers funds to the recipient\n    @param _asset The address of the asset to recover\n    @param _recipient The address to send the funds to\n    @return True if the funds were successfully recovered, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AgentFactoryFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n    return True\n\n\n############\n# Activate #\n############\n\n\n@external\ndef activate(_shouldActivate: bool):\n    \"\"\"\n    @notice Enable or disable the factory's ability to create new wallets\n    @dev Only callable by the governor, toggles isActivated state\n    @param _shouldActivate True to activate the factory, False to deactivate\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.isActivated = _shouldActivate\n    log AgentFactoryActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "b7c742ffa8af0d70c132d3b17f8b59a3db89decec0b72aa842b047a4f15a13b5"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AgentFactory.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "a1e2251d630e7102b4852cb732e3661b11584335cbe43a94969065616aa4465f"
      },
      "args": "0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae0000000000000000000000004200000000000000000000000000000000000006000000000000000000000000e43d5bd11a2a6a9348efc516ad9ac3d32164a5a000000000000000000000000061293f1bf484d20dcc841175b4e4a0f46c26658c00000000000000000000000076eb19ae42c07a7ad50afd58b579a7c45bd70183000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "LegoRegistry": {
      "address": "0x8D8593FE154d14976352FA2CE30322EcDF99C72a",
      "abi": [
        {
          "name": "LegoHelperSet",
          "inputs": [
            {
              "name": "helperAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewPendingAddyCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdatePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisablePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewLego",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            },
            {
              "name": "_legoType",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewLegoRegistration",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingNewLego",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoUpdate",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmLegoUpdate",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingLegoUpdate",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoDisable",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmLegoDisable",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingLegoDisable",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoChangeDelayToMin",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numLegosRaw",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoInfo",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoDescription",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegos",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastLegoAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastLegoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokensForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoHelper",
          "inputs": [
            {
              "name": "_helperAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoHelper",
          "inputs": [
            {
              "name": "_helperAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingLegoType",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoIdToType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoHelper",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_minLegoChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxLegoChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/Registry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nstruct AddyInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddy:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddyPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddyConfirmed:\n    addr: indexed(address)\n    addyId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewPendingAddyCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdatePending:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdateConfirmed:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyUpdateCancelled:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisablePending:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisableConfirmed:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyDisableCancelled:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyChangeDelaySet:\n    delayBlocks: uint256\n    registry: String[28]\n\n# core registry\naddyInfo: public(HashMap[uint256, AddyInfo])\naddyToId: public(HashMap[address, uint256])\nnumAddys: public(uint256)\n\n# pending changes\npendingNewAddy: public(HashMap[address, PendingNewAddy]) # addr -> pending new addy\npendingAddyUpdate: public(HashMap[uint256, PendingAddyUpdate]) # addyId -> pending addy update\npendingAddyDisable: public(HashMap[uint256, PendingAddyDisable]) # addyId -> pending addy disable\naddyChangeDelay: public(uint256)\n\nMIN_ADDY_CHANGE_DELAY: public(immutable(uint256))\nMAX_ADDY_CHANGE_DELAY: public(immutable(uint256))\nREGISTRY_STR: public(immutable(String[28]))\n\n\n@deploy\ndef __init__(_minAddyChangeDelay: uint256, _maxAddyChangeDelay: uint256, _registryStr: String[28]):\n    assert _minAddyChangeDelay < _maxAddyChangeDelay # dev: invalid delay\n    MIN_ADDY_CHANGE_DELAY = _minAddyChangeDelay\n    MAX_ADDY_CHANGE_DELAY = _maxAddyChangeDelay\n\n    REGISTRY_STR = _registryStr\n\n    # start at 1 index\n    self.numAddys = 1\n\n\n############\n# New Addy #\n############\n\n\n@view\n@external\ndef isValidNewAddy(_addr: address) -> bool:\n    return self._isValidNewAddy(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddy(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addyToId[_addr] == 0\n\n\n@internal\ndef _registerNewAddy(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new address in the registry\n    @dev This function sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address to be registered\n    @param _description A short description of the address (max 64 characters)\n    @return True if the registration was successfully initiated, False if the address is invalid\n    \"\"\"\n    if not self._isValidNewAddy(_addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingNewAddy[_addr] = PendingNewAddy(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddyPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmNewAddy(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending address registration after the required delay period\n    @dev This function finalizes the registration by assigning an ID and storing the address info\n    @param _addr The address to confirm registration for\n    @return The assigned ID for the registered address, or 0 if confirmation fails\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    if not self._isValidNewAddy(_addr):\n        self.pendingNewAddy[_addr] = empty(PendingNewAddy) # clear pending\n        return 0\n\n    # register new addy\n    addyId: uint256 = self.numAddys\n    self.addyToId[_addr] = addyId\n    self.numAddys = addyId + 1\n    self.addyInfo[addyId] = AddyInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n\n    log NewAddyConfirmed(addr=_addr, addyId=addyId, description=data.description, registry=REGISTRY_STR)\n    return addyId\n\n\n@internal\ndef _cancelPendingNewAddy(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending address registration\n    @dev This function removes the pending registration and emits a cancellation event\n    @param _addr The address whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n    log NewPendingAddyCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n###############\n# Update Addy #\n###############\n\n\n@view\n@external\ndef isValidAddyUpdate(_addyId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddyUpdate(_addyId, _newAddr, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyUpdate(_addyId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    if not self._isValidNewAddy(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@internal\ndef _updateAddyAddr(_addyId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered address\n    @dev This function sets up a pending update that requires confirmation after a delay period\n    @param _addyId The ID of the address to update\n    @param _newAddr The new address to set\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyUpdate(_addyId, _newAddr, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyUpdate[_addyId] = PendingAddyUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyUpdatePending(addyId=_addyId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address update after the required delay period\n    @dev This function finalizes the update by updating the address info and version\n    @param _addyId The ID of the address to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyUpdate(_addyId, pendingData.newAddr, prevAddr):\n        self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = pendingData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[pendingData.newAddr] = _addyId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n\n    log AddyUpdateConfirmed(addyId=_addyId, description=data.description, newAddr=pendingData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address update\n    @dev This function removes the pending update and emits a cancellation event\n    @param _addyId The ID of the address whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyUpdateCancelled(addyId=_addyId, description=prevData.description, newAddr=pendingData.newAddr, prevAddr=prevData.addr, initiatedBlock=pendingData.initiatedBlock, confirmBlock=pendingData.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Disable Addy #\n################\n\n\n@view\n@external\ndef isValidAddyDisable(_addyId: uint256) -> bool:\n    return self._isValidAddyDisable(_addyId, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyDisable(_addyId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@internal\ndef _disableAddyAddr(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered address\n    @dev This function sets up a pending disable that requires confirmation after a delay period\n    @param _addyId The ID of the address to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyDisable(_addyId, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyDisable[_addyId] = PendingAddyDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyDisablePending(addyId=_addyId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address disable after the required delay period\n    @dev This function finalizes the disable by clearing the address and updating version\n    @param _addyId The ID of the address to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyDisable(_addyId, prevAddr):\n        self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n\n    log AddyDisableConfirmed(addyId=_addyId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address disable\n    @dev This function removes the pending disable and emits a cancellation event\n    @param _addyId The ID of the address whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    data: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyDisableCancelled(addyId=_addyId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Change Delay #\n################\n\n\n@internal\ndef _setAddyChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for address changes\n    @dev The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert _numBlocks >= MIN_ADDY_CHANGE_DELAY and _numBlocks <= MAX_ADDY_CHANGE_DELAY # dev: invalid delay\n    self.addyChangeDelay = _numBlocks\n    log AddyChangeDelaySet(delayBlocks=_numBlocks, registry=REGISTRY_STR)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidAddyAddr(_addr: address) -> bool:\n    return self._isValidAddyAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddyAddr(_addr: address) -> bool:\n    return self.addyToId[_addr] != 0\n\n\n@view\n@external\ndef isValidAddyId(_addyId: uint256) -> bool:\n    return self._isValidAddyId(_addyId)\n\n\n@view\n@internal\ndef _isValidAddyId(_addyId: uint256) -> bool:\n    return _addyId != 0 and _addyId < self.numAddys\n\n\n# addy getters\n\n\n@view\n@external\ndef getAddyId(_addr: address) -> uint256:\n    return self._getAddyId(_addr)\n\n\n@view\n@internal\ndef _getAddyId(_addr: address) -> uint256:\n    return self.addyToId[_addr]\n\n\n@view\n@external\ndef getAddy(_addyId: uint256) -> address:\n    return self._getAddy(_addyId)\n\n\n@view\n@internal\ndef _getAddy(_addyId: uint256) -> address:\n    return self.addyInfo[_addyId].addr\n\n\n@view\n@external\ndef getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self._getAddyInfo(_addyId)\n\n\n@view\n@internal\ndef _getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self.addyInfo[_addyId]\n\n\n@view\n@external\ndef getAddyDescription(_addyId: uint256) -> String[64]:\n    return self._getAddyDescription(_addyId)\n\n\n@view\n@internal\ndef _getAddyDescription(_addyId: uint256) -> String[64]:\n    return self.addyInfo[_addyId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumAddys() -> uint256:\n    return self._getNumAddys()\n\n\n@view\n@internal\ndef _getNumAddys() -> uint256:\n    return self.numAddys - 1\n\n\n@view\n@external\ndef getLastAddyAddr() -> address:\n    return self._getLastAddyAddr()\n\n\n@view\n@internal\ndef _getLastAddyAddr() -> address:\n    lastIndex: uint256 = self.numAddys - 1\n    return self.addyInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastAddyId() -> uint256:\n    return self._getLastAddyId()\n\n\n@view\n@internal\ndef _getLastAddyId() -> uint256:\n    return self.numAddys - 1\n",
            "sha256sum": "460d2db094c5b32c0788cc51d7e857c0e7e2f223f570937c46cb97599441b29e"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/core/registries/LegoRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\ninitializes: registry\n\nexports: gov.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Registry as registry\n\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\nflag LegoType:\n    YIELD_OPP\n    DEX\n\nstruct VaultTokenInfo:\n    legoId: uint256\n    vaultToken: address\n\nevent LegoHelperSet:\n    helperAddr: indexed(address)\n\n# lego types\npendingLegoType: public(HashMap[address, LegoType]) # addr -> pending lego type\nlegoIdToType: public(HashMap[uint256, LegoType]) # legoId -> lego type\n\nlegoHelper: public(address)\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_VAULTS_FOR_USER: constant(uint256) = 30\n\n\n@deploy\ndef __init__(\n    _addyRegistry: address,\n    _minLegoChangeDelay: uint256,\n    _maxLegoChangeDelay: uint256,\n):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n\n    # initialize gov\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n    # initialize registry\n    registry.__init__(_minLegoChangeDelay, _maxLegoChangeDelay, \"LegoRegistry.vy\")\n\n\n@view\n@external\ndef isYieldLego(_legoId: uint256) -> bool:\n    return self.legoIdToType[_legoId] == LegoType.YIELD_OPP\n\n\n#################\n# Register Lego #\n#################\n\n\n@view\n@external\ndef isValidNewLegoAddr(_addr: address) -> bool:\n    return registry._isValidNewAddy(_addr)\n\n\n@external\ndef registerNewLego(_addr: address, _description: String[64], _legoType: LegoType) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new Lego\n    @dev Only callable by governor. Sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address of the Lego to register\n    @param _description A short description of the Lego (max 64 characters)\n    @param _legoType The type of Lego (YIELD_OPP or DEX)\n    @return True if the registration was successfully initiated, False if the Lego is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    isPending: bool = registry._registerNewAddy(_addr, _description)\n    if isPending:\n        self.pendingLegoType[_addr] = _legoType\n    return isPending\n\n\n@external\ndef confirmNewLegoRegistration(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending Lego registration after the required delay period\n    @dev Only callable by governor. Finalizes the registration by assigning an ID and setting the Lego type\n    @param _addr The address of the Lego to confirm registration for\n    @return The assigned ID for the registered Lego, or 0 if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    legoId: uint256 = registry._confirmNewAddy(_addr)\n    if legoId == 0:\n        self.pendingLegoType[_addr] = empty(LegoType)\n        return 0\n\n    # set lego id\n    assert extcall LegoCommon(_addr).setLegoId(legoId) # dev: set id failed\n\n    # set lego type\n    legoType: LegoType = self.pendingLegoType[_addr]\n    self.legoIdToType[legoId] = legoType\n    self.pendingLegoType[_addr] = empty(LegoType)\n\n    return legoId\n\n\n@external\ndef cancelPendingNewLego(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending Lego registration\n    @dev Only callable by governor. Removes the pending registration and emits a cancellation event\n    @param _addr The address of the Lego whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingNewAddy(_addr)\n\n\n###############\n# Update Lego #\n###############\n\n\n@view\n@external\ndef isValidLegoUpdate(_legoId: uint256, _newAddr: address) -> bool:\n    return registry._isValidAddyUpdate(_legoId, _newAddr, registry.addyInfo[_legoId].addr)\n\n\n@external\ndef updateLegoAddr(_legoId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered Lego\n    @dev Only callable by governor. Sets up a pending update that requires confirmation after a delay period\n    @param _legoId The ID of the Lego to update\n    @param _newAddr The new address to set for the Lego\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._updateAddyAddr(_legoId, _newAddr)\n\n\n@external\ndef confirmLegoUpdate(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending Lego address update after the required delay period\n    @dev Only callable by governor. Finalizes the update by updating the address and setting the Lego ID\n    @param _legoId The ID of the Lego to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    didUpdate: bool = registry._confirmAddyUpdate(_legoId)\n    if didUpdate:\n        legoAddr: address = registry.addyInfo[_legoId].addr\n        assert extcall LegoCommon(legoAddr).setLegoId(_legoId) # dev: set id failed\n    return didUpdate\n\n\n@external\ndef cancelPendingLegoUpdate(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending Lego address update\n    @dev Only callable by governor. Removes the pending update and emits a cancellation event\n    @param _legoId The ID of the Lego whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingAddyUpdate(_legoId)\n\n\n################\n# Disable Lego #\n################\n\n\n@view\n@external\ndef isValidLegoDisable(_legoId: uint256) -> bool:\n    return registry._isValidAddyDisable(_legoId, registry.addyInfo[_legoId].addr)\n\n\n@external\ndef disableLegoAddr(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered Lego\n    @dev Only callable by governor. Sets up a pending disable that requires confirmation after a delay period\n    @param _legoId The ID of the Lego to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._disableAddyAddr(_legoId)\n\n\n@external\ndef confirmLegoDisable(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending Lego disable after the required delay period\n    @dev Only callable by governor. Finalizes the disable by clearing the Lego address\n    @param _legoId The ID of the Lego to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddyDisable(_legoId)\n\n\n@external\ndef cancelPendingLegoDisable(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending Lego disable\n    @dev Only callable by governor. Removes the pending disable and emits a cancellation event\n    @param _legoId The ID of the Lego whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingAddyDisable(_legoId)\n\n\n#####################\n# Lego Change Delay #\n#####################\n\n\n@external\ndef setLegoChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for Lego changes\n    @dev Only callable by governor. The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._setAddyChangeDelay(_numBlocks)\n\n\n@view\n@external\ndef legoChangeDelay() -> uint256:\n    return registry.addyChangeDelay\n\n\n@external\ndef setLegoChangeDelayToMin() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._setAddyChangeDelay(registry.MIN_ADDY_CHANGE_DELAY)\n\n\n#################\n# Views / Utils #\n#################\n\n\n@view\n@external\ndef numLegosRaw() -> uint256:\n    return registry.numAddys\n\n\n# is valid\n\n\n@view\n@external\ndef isValidLegoAddr(_addr: address) -> bool:\n    return registry._isValidAddyAddr(_addr)\n\n\n@view\n@external\ndef isValidLegoId(_legoId: uint256) -> bool:\n    return registry._isValidAddyId(_legoId)\n\n\n# lego getters\n\n\n@view\n@external\ndef getLegoId(_addr: address) -> uint256:\n    return registry._getAddyId(_addr)\n\n\n@view\n@external\ndef getLegoAddr(_legoId: uint256) -> address:\n    return registry._getAddy(_legoId)\n\n\n@view\n@external\ndef getLegoInfo(_legoId: uint256) -> registry.AddyInfo:\n    return registry.addyInfo[_legoId]\n\n\n@view\n@external\ndef getLegoDescription(_legoId: uint256) -> String[64]:\n    return registry.addyInfo[_legoId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumLegos() -> uint256:\n    return registry._getNumAddys()\n\n\n@view\n@external\ndef getLastLegoAddr() -> address:\n    return registry._getLastAddyAddr()\n\n\n@view\n@external\ndef getLastLegoId() -> uint256:\n    return registry._getLastAddyId()\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    \"\"\"\n    @notice Get the underlying asset for a vault token\n    @dev Returns empty address if vault token is not registered\n    @param _vaultToken The address of the vault token to query\n    @return The underlying asset address\n    \"\"\"\n    if _vaultToken == empty(address):\n        return empty(address)\n\n    numLegos: uint256 = registry.numAddys\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = self.legoIdToType[i]\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = registry.addyInfo[i].addr\n        asset: address = staticcall LegoYield(legoAddr).getUnderlyingAsset(_vaultToken)\n        if asset != empty(address):\n            return asset\n\n    return empty(address)\n\n\n@view\n@external\ndef getUnderlyingForUser(_user: address, _asset: address) -> uint256:\n    \"\"\"\n    @notice Get the total underlying amount for a user in a given asset\n    @dev Returns 0 if user or asset is empty\n    @param _user The address of the user to query\n    @param _asset The address of the asset to query\n    \"\"\"\n    if empty(address) in [_user, _asset]:\n        return 0\n\n    totalDeposited: uint256 = 0\n    numLegos: uint256 = registry.numAddys\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = self.legoIdToType[i]\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = registry.addyInfo[i].addr\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall LegoYield(legoAddr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            vaultTokenBal: uint256 = staticcall IERC20(vaultToken).balanceOf(_user)\n            if vaultTokenBal != 0:\n                totalDeposited += staticcall LegoYield(legoAddr).getUnderlyingAmount(vaultToken, vaultTokenBal)\n\n    return totalDeposited\n\n\n@view\n@external\ndef getVaultTokensForUser(_user: address, _asset: address) -> DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER]:\n    \"\"\"\n    @notice Get all vault tokens for a user in a given asset\n    @dev Returns empty array if user or asset is empty\n    @param _user The address of the user to query\n    @param _asset The address of the asset to query\n    @return Array of VaultTokenInfo structs containing legoId and vaultToken address\n    \"\"\"\n    if empty(address) in [_user, _asset]:\n        return []\n\n    vaultTokens: DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER] = []\n\n    numLegos: uint256 = registry.numAddys\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = self.legoIdToType[i]\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = registry.addyInfo[i].addr\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall LegoYield(legoAddr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            if staticcall IERC20(vaultToken).balanceOf(_user) != 0:\n                vaultTokens.append(VaultTokenInfo(\n                    legoId=i,\n                    vaultToken=vaultToken\n                ))\n\n    return vaultTokens\n\n\n@view\n@external\ndef getLegoFromVaultToken(_vaultToken: address) -> (uint256, address):\n    \"\"\"\n    @notice Get the lego ID and address for a given vault token\n    @dev Returns (0, empty(address)) if vault token is not valid\n    @param _vaultToken The address of the vault token to query\n    @return The lego ID and address\n    \"\"\"\n    numLegos: uint256 = registry.numAddys\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = self.legoIdToType[i]\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = registry.addyInfo[i].addr\n        if staticcall LegoYield(legoAddr).isVaultToken(_vaultToken):\n            return i, legoAddr\n\n    return 0, empty(address)\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is a registered vault token\n    @dev Returns False if not a vault token\n    @param _vaultToken The address of the vault token to query\n    @return True if the address is a vault token, False otherwise\n    \"\"\"\n    numLegos: uint256 = registry.numAddys\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = self.legoIdToType[i]\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = registry.addyInfo[i].addr\n        if staticcall LegoYield(legoAddr).isVaultToken(_vaultToken):\n            return True\n\n    return False\n\n\n###############\n# Lego Helper #\n###############\n\n\n@view\n@external \ndef isValidLegoHelper(_helperAddr: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be set as the Lego helper\n    @dev Address must be a contract and different from current helper\n    @param _helperAddr The address to validate\n    @return True if address can be set as helper, False otherwise\n    \"\"\"\n    return self._isValidLegoHelper(_helperAddr)\n\n\n@view\n@internal \ndef _isValidLegoHelper(_helperAddr: address) -> bool:\n    if not _helperAddr.is_contract or _helperAddr == empty(address):\n        return False\n    return _helperAddr != self.legoHelper\n\n\n@external\ndef setLegoHelper(_helperAddr: address) -> bool:\n    \"\"\"\n    @notice Set a new Lego helper address\n    @dev Only callable by governor\n    @param _helperAddr The address to set as helper\n    @return True if helper was set successfully, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    if not self._isValidLegoHelper(_helperAddr):\n        return False\n    self.legoHelper = _helperAddr\n    log LegoHelperSet(helperAddr=_helperAddr)\n    return True\n\n",
            "sha256sum": "028c402e77a9669c4d76ec5e0af2e1b3451d9f4975c788a692e16010830c9cff"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/registries/LegoRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "619da03b55d669536495801d7610b822ea052187d0392176f890a7b4babed3aa"
      },
      "args": "0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "OracleRegistry": {
      "address": "0xe133F22aAdC23F9B7ca7A9f16B6D9A0C662Cf90b",
      "abi": [
        {
          "name": "PriorityOraclePartnerIdsModified",
          "inputs": [
            {
              "name": "numIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StaleTimeSet",
          "inputs": [
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewPendingAddyCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdatePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisablePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewOraclePartnerAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewOraclePartner",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewOraclePartnerRegistration",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingNewOraclePartner",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerUpdate",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOraclePartnerUpdate",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingOraclePartnerUpdate",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerDisable",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOraclePartnerDisable",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingOraclePartnerDisable",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oracleChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerChangeDelayToMin",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriorityOraclePartnerIds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "areValidPriorityOraclePartnerIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityOraclePartnerIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidStaleTime",
          "inputs": [
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStaleTime",
          "inputs": [
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numOraclePartnersRaw",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerInfo",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerDescription",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumOraclePartners",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastOraclePartnerAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastOraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priorityOraclePartnerIds",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "staleTime",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_STALE_TIME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_STALE_TIME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_minStaleTime",
              "type": "uint256"
            },
            {
              "name": "_maxStaleTime",
              "type": "uint256"
            },
            {
              "name": "_minOracleChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxOracleChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/Registry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nstruct AddyInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddy:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddyPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddyConfirmed:\n    addr: indexed(address)\n    addyId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewPendingAddyCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdatePending:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdateConfirmed:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyUpdateCancelled:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisablePending:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisableConfirmed:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyDisableCancelled:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyChangeDelaySet:\n    delayBlocks: uint256\n    registry: String[28]\n\n# core registry\naddyInfo: public(HashMap[uint256, AddyInfo])\naddyToId: public(HashMap[address, uint256])\nnumAddys: public(uint256)\n\n# pending changes\npendingNewAddy: public(HashMap[address, PendingNewAddy]) # addr -> pending new addy\npendingAddyUpdate: public(HashMap[uint256, PendingAddyUpdate]) # addyId -> pending addy update\npendingAddyDisable: public(HashMap[uint256, PendingAddyDisable]) # addyId -> pending addy disable\naddyChangeDelay: public(uint256)\n\nMIN_ADDY_CHANGE_DELAY: public(immutable(uint256))\nMAX_ADDY_CHANGE_DELAY: public(immutable(uint256))\nREGISTRY_STR: public(immutable(String[28]))\n\n\n@deploy\ndef __init__(_minAddyChangeDelay: uint256, _maxAddyChangeDelay: uint256, _registryStr: String[28]):\n    assert _minAddyChangeDelay < _maxAddyChangeDelay # dev: invalid delay\n    MIN_ADDY_CHANGE_DELAY = _minAddyChangeDelay\n    MAX_ADDY_CHANGE_DELAY = _maxAddyChangeDelay\n\n    REGISTRY_STR = _registryStr\n\n    # start at 1 index\n    self.numAddys = 1\n\n\n############\n# New Addy #\n############\n\n\n@view\n@external\ndef isValidNewAddy(_addr: address) -> bool:\n    return self._isValidNewAddy(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddy(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addyToId[_addr] == 0\n\n\n@internal\ndef _registerNewAddy(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new address in the registry\n    @dev This function sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address to be registered\n    @param _description A short description of the address (max 64 characters)\n    @return True if the registration was successfully initiated, False if the address is invalid\n    \"\"\"\n    if not self._isValidNewAddy(_addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingNewAddy[_addr] = PendingNewAddy(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddyPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmNewAddy(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending address registration after the required delay period\n    @dev This function finalizes the registration by assigning an ID and storing the address info\n    @param _addr The address to confirm registration for\n    @return The assigned ID for the registered address, or 0 if confirmation fails\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    if not self._isValidNewAddy(_addr):\n        self.pendingNewAddy[_addr] = empty(PendingNewAddy) # clear pending\n        return 0\n\n    # register new addy\n    addyId: uint256 = self.numAddys\n    self.addyToId[_addr] = addyId\n    self.numAddys = addyId + 1\n    self.addyInfo[addyId] = AddyInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n\n    log NewAddyConfirmed(addr=_addr, addyId=addyId, description=data.description, registry=REGISTRY_STR)\n    return addyId\n\n\n@internal\ndef _cancelPendingNewAddy(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending address registration\n    @dev This function removes the pending registration and emits a cancellation event\n    @param _addr The address whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n    log NewPendingAddyCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n###############\n# Update Addy #\n###############\n\n\n@view\n@external\ndef isValidAddyUpdate(_addyId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddyUpdate(_addyId, _newAddr, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyUpdate(_addyId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    if not self._isValidNewAddy(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@internal\ndef _updateAddyAddr(_addyId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered address\n    @dev This function sets up a pending update that requires confirmation after a delay period\n    @param _addyId The ID of the address to update\n    @param _newAddr The new address to set\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyUpdate(_addyId, _newAddr, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyUpdate[_addyId] = PendingAddyUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyUpdatePending(addyId=_addyId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address update after the required delay period\n    @dev This function finalizes the update by updating the address info and version\n    @param _addyId The ID of the address to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyUpdate(_addyId, pendingData.newAddr, prevAddr):\n        self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = pendingData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[pendingData.newAddr] = _addyId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n\n    log AddyUpdateConfirmed(addyId=_addyId, description=data.description, newAddr=pendingData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address update\n    @dev This function removes the pending update and emits a cancellation event\n    @param _addyId The ID of the address whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyUpdateCancelled(addyId=_addyId, description=prevData.description, newAddr=pendingData.newAddr, prevAddr=prevData.addr, initiatedBlock=pendingData.initiatedBlock, confirmBlock=pendingData.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Disable Addy #\n################\n\n\n@view\n@external\ndef isValidAddyDisable(_addyId: uint256) -> bool:\n    return self._isValidAddyDisable(_addyId, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyDisable(_addyId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@internal\ndef _disableAddyAddr(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered address\n    @dev This function sets up a pending disable that requires confirmation after a delay period\n    @param _addyId The ID of the address to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyDisable(_addyId, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyDisable[_addyId] = PendingAddyDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyDisablePending(addyId=_addyId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address disable after the required delay period\n    @dev This function finalizes the disable by clearing the address and updating version\n    @param _addyId The ID of the address to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyDisable(_addyId, prevAddr):\n        self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n\n    log AddyDisableConfirmed(addyId=_addyId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address disable\n    @dev This function removes the pending disable and emits a cancellation event\n    @param _addyId The ID of the address whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    data: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyDisableCancelled(addyId=_addyId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Change Delay #\n################\n\n\n@internal\ndef _setAddyChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for address changes\n    @dev The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert _numBlocks >= MIN_ADDY_CHANGE_DELAY and _numBlocks <= MAX_ADDY_CHANGE_DELAY # dev: invalid delay\n    self.addyChangeDelay = _numBlocks\n    log AddyChangeDelaySet(delayBlocks=_numBlocks, registry=REGISTRY_STR)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidAddyAddr(_addr: address) -> bool:\n    return self._isValidAddyAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddyAddr(_addr: address) -> bool:\n    return self.addyToId[_addr] != 0\n\n\n@view\n@external\ndef isValidAddyId(_addyId: uint256) -> bool:\n    return self._isValidAddyId(_addyId)\n\n\n@view\n@internal\ndef _isValidAddyId(_addyId: uint256) -> bool:\n    return _addyId != 0 and _addyId < self.numAddys\n\n\n# addy getters\n\n\n@view\n@external\ndef getAddyId(_addr: address) -> uint256:\n    return self._getAddyId(_addr)\n\n\n@view\n@internal\ndef _getAddyId(_addr: address) -> uint256:\n    return self.addyToId[_addr]\n\n\n@view\n@external\ndef getAddy(_addyId: uint256) -> address:\n    return self._getAddy(_addyId)\n\n\n@view\n@internal\ndef _getAddy(_addyId: uint256) -> address:\n    return self.addyInfo[_addyId].addr\n\n\n@view\n@external\ndef getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self._getAddyInfo(_addyId)\n\n\n@view\n@internal\ndef _getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self.addyInfo[_addyId]\n\n\n@view\n@external\ndef getAddyDescription(_addyId: uint256) -> String[64]:\n    return self._getAddyDescription(_addyId)\n\n\n@view\n@internal\ndef _getAddyDescription(_addyId: uint256) -> String[64]:\n    return self.addyInfo[_addyId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumAddys() -> uint256:\n    return self._getNumAddys()\n\n\n@view\n@internal\ndef _getNumAddys() -> uint256:\n    return self.numAddys - 1\n\n\n@view\n@external\ndef getLastAddyAddr() -> address:\n    return self._getLastAddyAddr()\n\n\n@view\n@internal\ndef _getLastAddyAddr() -> address:\n    lastIndex: uint256 = self.numAddys - 1\n    return self.addyInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastAddyId() -> uint256:\n    return self._getLastAddyId()\n\n\n@view\n@internal\ndef _getLastAddyId() -> uint256:\n    return self.numAddys - 1\n",
            "sha256sum": "460d2db094c5b32c0788cc51d7e857c0e7e2f223f570937c46cb97599441b29e"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/core/registries/OracleRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\ninitializes: registry\n\nexports: gov.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Registry as registry\n\nfrom ethereum.ercs import IERC20Detailed\nimport interfaces.OraclePartnerInterface as OraclePartner\n\nevent PriorityOraclePartnerIdsModified:\n    numIds: uint256\n\nevent StaleTimeSet:\n    staleTime: uint256\n\n# custom config\npriorityOraclePartnerIds: public(DynArray[uint256, MAX_PRIORITY_PARTNERS])\nstaleTime: public(uint256)\n\nETH: public(immutable(address))\nMIN_STALE_TIME: public(immutable(uint256))\nMAX_STALE_TIME: public(immutable(uint256))\n\nMAX_PRIORITY_PARTNERS: constant(uint256) = 10\n\n\n@deploy\ndef __init__(\n    _addyRegistry: address,\n    _ethAddr: address,\n    _minStaleTime: uint256,\n    _maxStaleTime: uint256,\n    _minOracleChangeDelay: uint256,\n    _maxOracleChangeDelay: uint256,\n):\n    assert empty(address) not in [_addyRegistry, _ethAddr] # dev: invalid addrs\n\n    # initialize gov\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n    # initialize registry\n    registry.__init__(_minOracleChangeDelay, _maxOracleChangeDelay, \"OracleRegistry.vy\")\n\n    ETH = _ethAddr\n    MIN_STALE_TIME = _minStaleTime\n    MAX_STALE_TIME = _maxStaleTime\n\n\n#########\n# Price #\n#########\n\n\n@view\n@external\ndef getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Get the USD price of an asset from registered oracle partners\n    @dev Checks priority partners first, then others. Returns 0 if no valid price found.\n    @param _asset The address of the asset to get price for\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The asset price in USD with 18 decimals\n    \"\"\"\n    if _asset == empty(address):\n        return 0\n    return self._getPrice(_asset, _shouldRaise)\n\n\n@view\n@internal\ndef _getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    price: uint256 = 0\n    hasFeedConfig: bool = False\n    alreadyLooked: DynArray[uint256, MAX_PRIORITY_PARTNERS] = []\n    staleTime: uint256 = self.staleTime\n\n    # go thru priority partners first\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self.priorityOraclePartnerIds\n    for i: uint256 in range(len(priorityIds), bound=MAX_PRIORITY_PARTNERS):\n        pid: uint256 = priorityIds[i]\n        hasFeed: bool = False\n        price, hasFeed = self._getPriceFromOraclePartner(pid, _asset, staleTime)\n        if price != 0:\n            break\n        if hasFeed:\n            hasFeedConfig = True\n        alreadyLooked.append(pid)\n\n    # go thru rest of oracle partners\n    if price == 0:\n        numSources: uint256 = registry.numAddys\n        for id: uint256 in range(1, numSources, bound=max_value(uint256)):\n            if id in alreadyLooked:\n                continue\n            hasFeed: bool = False\n            price, hasFeed = self._getPriceFromOraclePartner(id, _asset, staleTime)\n            if price != 0:\n                break\n            if hasFeed:\n                hasFeedConfig = True\n\n    # raise exception if feed exists but no price\n    if price == 0 and hasFeedConfig and _shouldRaise:\n        raise \"has price config, no price\"\n\n    return price\n\n\n@view\n@internal\ndef _getPriceFromOraclePartner(_pid: uint256, _asset: address, _staleTime: uint256) -> (uint256, bool):\n    oraclePartner: address = registry._getAddy(_pid)\n    if oraclePartner == empty(address):\n        return 0, False\n    return staticcall OraclePartner(oraclePartner).getPriceAndHasFeed(_asset, _staleTime, self)\n\n\n# other utils\n\n\n@view\n@external\ndef getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the USD value of a given amount of an asset\n    @dev Accounts for asset decimals in calculation. Returns 0 if no valid price.\n    @param _asset The address of the asset\n    @param _amount The amount of the asset\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The USD value with 18 decimals\n    \"\"\"\n    if _amount == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return price * _amount // (10 ** decimals)\n\n\n@view\n@external\ndef getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the amount of an asset worth a given USD value\n    @dev Accounts for asset decimals in calculation. Returns 0 if no valid price.\n    @param _asset The address of the asset\n    @param _usdValue The USD value to convert to asset amount (18 decimals)\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The amount of the asset\n    \"\"\"\n    if _usdValue == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return _usdValue * (10 ** decimals) // price\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    \"\"\"\n    @notice Check if any oracle partner has a price feed for the asset\n    @dev Iterates through all registered oracle partners\n    @param _asset The address of the asset to check\n    @return True if a price feed exists, False otherwise\n    \"\"\"\n    numSources: uint256 = registry.numAddys\n    for id: uint256 in range(1, numSources, bound=max_value(uint256)):\n        oraclePartner: address = registry._getAddy(id)\n        if oraclePartner == empty(address):\n            continue\n        if staticcall OraclePartner(oraclePartner).hasPriceFeed(_asset):\n            return True\n    return False\n\n\n@view\n@external\ndef getEthUsdValue(_amount: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the USD value of a given amount of ETH\n    @dev Uses ETH price feed. Returns 0 if no valid price.\n    @param _amount The amount of ETH in wei\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The USD value with 18 decimals\n    \"\"\"\n    if _amount == 0:\n        return 0\n    return self._getPrice(ETH, _shouldRaise) * _amount // (10 ** 18)\n\n\n@view\n@external\ndef getEthAmount(_usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the amount of ETH worth a given USD value\n    @dev Uses ETH price feed. Returns 0 if no valid price.\n    @param _usdValue The USD value to convert to ETH amount (18 decimals)\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The amount of ETH in wei\n    \"\"\"\n    if _usdValue == 0:\n        return 0\n    price: uint256 = self._getPrice(ETH, _shouldRaise)\n    if price == 0:\n        return 0\n    return _usdValue * (10 ** 18) // price\n\n\n###########################\n# Register Oracle Partner #\n###########################\n\n\n@view\n@external\ndef isValidNewOraclePartnerAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Checks if an address can be registered as a new Oracle Partner\n    @dev Validates that the address is a contract and not already registered\n    @param _addr The address to validate\n    @return True if the address can be registered, False otherwise\n    \"\"\"\n    return registry._isValidNewAddy(_addr)\n\n\n@external\ndef registerNewOraclePartner(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new Oracle Partner\n    @dev Only callable by governor. Sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address of the Oracle Partner to register\n    @param _description A short description of the Oracle Partner (max 64 characters)\n    @return True if the registration was successfully initiated, False if the Oracle Partner is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._registerNewAddy(_addr, _description)\n\n\n@external\ndef confirmNewOraclePartnerRegistration(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending Oracle Partner registration after the required delay period\n    @dev Only callable by governor. Finalizes the registration by assigning an ID and setting the Oracle Partner ID\n    @param _addr The address of the Oracle Partner to confirm registration for\n    @return The assigned ID for the registered Oracle Partner, or 0 if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    oraclePartnerId: uint256 = registry._confirmNewAddy(_addr)\n    if oraclePartnerId != 0:\n        assert extcall OraclePartner(_addr).setOraclePartnerId(oraclePartnerId) # dev: set id failed\n    return oraclePartnerId\n\n\n@external\ndef cancelPendingNewOraclePartner(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending Oracle Partner registration\n    @dev Only callable by governor. Removes the pending registration and emits a cancellation event\n    @param _addr The address of the Oracle Partner whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingNewAddy(_addr)\n\n\n#########################\n# Update Oracle Partner #\n#########################\n\n\n@view\n@external\ndef isValidOraclePartnerUpdate(_oracleId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Checks if an Oracle Partner address can be updated\n    @dev Validates that the Oracle Partner ID exists and the new address is valid\n    @param _oracleId The ID of the Oracle Partner to update\n    @param _newAddr The new address to set\n    @return True if the update is valid, False otherwise\n    \"\"\"\n    return registry._isValidAddyUpdate(_oracleId, _newAddr, registry.addyInfo[_oracleId].addr)\n\n\n@external\ndef updateOraclePartnerAddr(_oracleId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered Oracle Partner\n    @dev Only callable by governor. Sets up a pending update that requires confirmation after a delay period\n    @param _oracleId The ID of the Oracle Partner to update\n    @param _newAddr The new address to set for the Oracle Partner\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._updateAddyAddr(_oracleId, _newAddr)\n\n\n@external\ndef confirmOraclePartnerUpdate(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending Oracle Partner address update after the required delay period\n    @dev Only callable by governor. Finalizes the update by updating the address and setting the Oracle Partner ID\n    @param _oracleId The ID of the Oracle Partner to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    didUpdate: bool = registry._confirmAddyUpdate(_oracleId)\n    if didUpdate:\n        oraclePartnerAddr: address = registry.addyInfo[_oracleId].addr\n        assert extcall OraclePartner(oraclePartnerAddr).setOraclePartnerId(_oracleId) # dev: set id failed\n    return didUpdate\n\n\n@external\ndef cancelPendingOraclePartnerUpdate(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending Oracle Partner address update\n    @dev Only callable by governor. Removes the pending update and emits a cancellation event\n    @param _oracleId The ID of the Oracle Partner whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingAddyUpdate(_oracleId)\n\n\n##########################\n# Disable Oracle Partner #\n##########################\n\n\n@view\n@external\ndef isValidOraclePartnerDisable(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Checks if an Oracle Partner can be disabled\n    @dev Validates that the Oracle Partner ID exists and is not already disabled\n    @param _oracleId The ID of the Oracle Partner to check\n    @return True if the Oracle Partner can be disabled, False otherwise\n    \"\"\"\n    return registry._isValidAddyDisable(_oracleId, registry.addyInfo[_oracleId].addr)\n\n\n@external\ndef disableOraclePartnerAddr(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered Oracle Partner\n    @dev Only callable by governor. Sets up a pending disable that requires confirmation after a delay period\n    @param _oracleId The ID of the Oracle Partner to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._disableAddyAddr(_oracleId)\n\n\n@external\ndef confirmOraclePartnerDisable(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending Oracle Partner disable after the required delay period\n    @dev Only callable by governor. Finalizes the disable by clearing the Oracle Partner address\n    @param _oracleId The ID of the Oracle Partner to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddyDisable(_oracleId)\n\n\n@external\ndef cancelPendingOraclePartnerDisable(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending Oracle Partner disable\n    @dev Only callable by governor. Removes the pending disable and emits a cancellation event\n    @param _oracleId The ID of the Oracle Partner whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingAddyDisable(_oracleId)\n\n\n#########################\n# Oracle Partner Change #\n#########################\n\n\n@external\ndef setOraclePartnerChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for Oracle Partner changes\n    @dev Only callable by governor. The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._setAddyChangeDelay(_numBlocks)\n\n\n@view\n@external\ndef oracleChangeDelay() -> uint256:\n    return registry.addyChangeDelay\n\n\n@external\ndef setOraclePartnerChangeDelayToMin() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._setAddyChangeDelay(registry.MIN_ADDY_CHANGE_DELAY)\n\n\n############################\n# Priority Oracle Partners #\n############################\n\n\n@view \n@external \ndef getPriorityOraclePartnerIds() -> DynArray[uint256, MAX_PRIORITY_PARTNERS]:\n    \"\"\"\n    @notice Get the list of priority oracle partner IDs\n    @dev Returns ordered list of IDs that are checked first for prices\n    @return Array of oracle partner IDs in priority order\n    \"\"\"\n    return self.priorityOraclePartnerIds\n\n\n@view\n@internal\ndef _sanitizePriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> DynArray[uint256, MAX_PRIORITY_PARTNERS]:\n    sanitizedIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = []\n    for i: uint256 in range(len(_priorityIds), bound=MAX_PRIORITY_PARTNERS):\n        pid: uint256 = _priorityIds[i]\n        if not registry._isValidAddyId(pid):\n            continue\n        if pid in sanitizedIds:\n            continue\n        sanitizedIds.append(pid)\n    return sanitizedIds\n\n\n@view\n@external\ndef areValidPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    \"\"\"\n    @notice Check if a list of priority oracle partner IDs is valid\n    @dev Validates IDs exist and are not duplicated\n    @param _priorityIds Array of oracle partner IDs to validate\n    @return True if all IDs are valid, False otherwise\n    \"\"\"\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self._sanitizePriorityOraclePartnerIds(_priorityIds)\n    return self._areValidPriorityOraclePartnerIds(priorityIds)\n\n\n@view\n@internal\ndef _areValidPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    return len(_priorityIds) != 0\n\n\n@external\ndef setPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    \"\"\"\n    @notice Set the list of priority oracle partner IDs\n    @dev Only callable by governor when registry is activated\n    @param _priorityIds Array of oracle partner IDs in desired priority order\n    @return True if priority list was set successfully, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self._sanitizePriorityOraclePartnerIds(_priorityIds)\n    if not self._areValidPriorityOraclePartnerIds(priorityIds):\n        return False\n\n    self.priorityOraclePartnerIds = priorityIds\n    log PriorityOraclePartnerIdsModified(numIds=len(priorityIds))\n    return True\n\n\n##############\n# Stale Time #\n##############\n\n\n@view\n@external\ndef isValidStaleTime(_staleTime: uint256) -> bool:\n    \"\"\"\n    @notice Check if a stale time value is valid\n    @dev Validates against minimum and maximum allowed stale times\n    @param _staleTime The stale time in seconds to validate\n    @return True if stale time is valid, False otherwise\n    \"\"\"\n    return self._isValidStaleTime(_staleTime)\n\n\n@view\n@internal\ndef _isValidStaleTime(_staleTime: uint256) -> bool:\n    return _staleTime >= MIN_STALE_TIME and _staleTime <= MAX_STALE_TIME\n\n\n@external\ndef setStaleTime(_staleTime: uint256) -> bool:\n    \"\"\"\n    @notice Set the stale time for price feeds\n    @dev Only callable by governor when registry is activated\n    @param _staleTime The stale time in seconds\n    @return True if stale time was set successfully, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    if not self._isValidStaleTime(_staleTime):\n        return False\n\n    self.staleTime = _staleTime\n    log StaleTimeSet(staleTime=_staleTime)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n@view\n@external\ndef numOraclePartnersRaw() -> uint256:\n    return registry.numAddys\n\n\n# is valid\n\n\n@view\n@external\ndef isValidOraclePartnerAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address is a registered oracle partner\n    @dev Returns true if address has a non-zero oracle partner ID\n    @param _addr The address to check\n    @return True if address is a registered oracle partner, False otherwise\n    \"\"\"\n    return registry._isValidAddyAddr(_addr)\n\n\n@view\n@external\ndef isValidOraclePartnerId(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Check if an oracle partner ID is valid\n    @dev ID must be non-zero and less than total number of oracle partners\n    @param _oracleId The ID to check\n    @return True if ID is valid, False otherwise\n    \"\"\"\n    return registry._isValidAddyId(_oracleId)\n\n\n# oracle partner getters\n\n\n@view\n@external\ndef getOraclePartnerId(_addr: address) -> uint256:\n    \"\"\"\n    @notice Get the ID of an oracle partner from its address\n    @dev Returns 0 if address is not registered\n    @param _addr The address to query\n    @return The oracle partner ID associated with the address\n    \"\"\"\n    return registry._getAddyId(_addr)\n\n\n@view\n@external\ndef getOraclePartnerAddr(_oracleId: uint256) -> address:\n    \"\"\"\n    @notice Get the address of an oracle partner from its ID\n    @dev Returns empty address if ID is invalid or partner is disabled\n    @param _oracleId The ID to query\n    @return The address associated with the oracle partner ID\n    \"\"\"\n    return registry._getAddy(_oracleId)\n\n\n@view\n@external\ndef getOraclePartnerInfo(_oracleId: uint256) -> registry.AddyInfo:\n    \"\"\"\n    @notice Get all information about an oracle partner\n    @dev Returns complete OraclePartnerInfo struct including address, version, timestamp and description\n    @param _oracleId The ID to query\n    @return OraclePartnerInfo struct containing all oracle partner information\n    \"\"\"\n    return registry.addyInfo[_oracleId]\n\n\n@view\n@external\ndef getOraclePartnerDescription(_oracleId: uint256) -> String[64]:\n    \"\"\"\n    @notice Get the description of an oracle partner\n    @dev Returns empty string if ID is invalid\n    @param _oracleId The ID to query\n    @return The description associated with the oracle partner ID\n    \"\"\"\n    return registry.addyInfo[_oracleId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumOraclePartners() -> uint256:\n    \"\"\"\n    @notice Get the total number of registered oracle partners\n    @dev Returns number of partners minus 1 since indexing starts at 1\n    @return The total number of registered oracle partners\n    \"\"\"\n    return registry._getNumAddys()\n\n\n@view\n@external\ndef getLastOraclePartnerAddr() -> address:\n    \"\"\"\n    @notice Get the address of the most recently registered oracle partner\n    @dev Returns the address at index (numOraclePartners - 1)\n    @return The address of the last registered oracle partner\n    \"\"\"\n    return registry._getLastAddyAddr()\n\n\n@view\n@external\ndef getLastOraclePartnerId() -> uint256:\n    \"\"\"\n    @notice Get the ID of the most recently registered oracle partner\n    @dev Returns numOraclePartners - 1 since indexing starts at 1\n    @return The ID of the last registered oracle partner\n    \"\"\"\n    return registry._getLastAddyId()\n",
            "sha256sum": "c6cd93015c0961322bde82eda88cd3c27037cc47bb2c405e3ae5291e110f10ab"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/registries/OracleRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "ea25f55df290ba3bdcfb02162b102534a447839f2eca35a83ddd9abd4acccd9d"
      },
      "args": "0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000003f48000000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "PriceSheets": {
      "address": "0xD15331Cf355B5D8EF017c1FD49516b95593FA6aA",
      "abi": [
        {
          "name": "AgentSubPriceSet",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAgentSubPriceSet",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "effectiveBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolSubPriceSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentSubPriceRemoved",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolSubPriceRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentSubPricingEnabled",
          "inputs": [
            {
              "name": "isEnabled",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolTxPriceSheetSet",
          "inputs": [
            {
              "name": "yieldFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimRewardsFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolTxPriceSheetRemoved",
          "inputs": [
            {
              "name": "yieldFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimRewardsFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolRecipientSet",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorRatioSet",
          "inputs": [
            {
              "name": "ratio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSheetsActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCombinedSubData",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_agentPaidThru",
              "type": "uint256"
            },
            {
              "name": "_protocolPaidThru",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentSubPriceData",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidSubPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finalizePendingAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentSubPricingEnabled",
          "inputs": [
            {
              "name": "_isEnabled",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolSubPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeProtocolSubPrice",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTransactionFeeDataWithAmbassadorRatio",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTransactionFeeData",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidTxPriceSheet",
          "inputs": [
            {
              "name": "_yieldFee",
              "type": "uint256"
            },
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_claimRewardsFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolTxPriceSheet",
          "inputs": [
            {
              "name": "_yieldFee",
              "type": "uint256"
            },
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_claimRewardsFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeProtocolTxPriceSheet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolRecipient",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriceChangeDelay",
          "inputs": [
            {
              "name": "_delayBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAmbassadorRatio",
          "inputs": [
            {
              "name": "_ratio",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolRecipient",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolTxPriceData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "yieldFee",
                  "type": "uint256"
                },
                {
                  "name": "swapFee",
                  "type": "uint256"
                },
                {
                  "name": "claimRewardsFee",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolSubPriceData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgentSubPricingEnabled",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentSubPriceData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAgentSubPrices",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "subInfo",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "asset",
                      "type": "address"
                    },
                    {
                      "name": "usdValue",
                      "type": "uint256"
                    },
                    {
                      "name": "trialPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "payPeriod",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "effectiveBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priceChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ambassadorRatio",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_TRIAL_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_TRIAL_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_PAY_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_PAY_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_PRICE_CHANGE_BUFFER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_minTrialPeriod",
              "type": "uint256"
            },
            {
              "name": "_maxTrialPeriod",
              "type": "uint256"
            },
            {
              "name": "_minPayPeriod",
              "type": "uint256"
            },
            {
              "name": "_maxPayPeriod",
              "type": "uint256"
            },
            {
              "name": "_minPriceChangeBuffer",
              "type": "uint256"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/core/PriceSheets.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\nimport contracts.modules.LocalGov as gov\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n    def governance() -> address: view\n\ninterface OracleRegistry:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AgentFactory:\n    def isAgent(_agent: address) -> bool: view\n\ninterface Agent:\n    def owner() -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct TxPriceSheet:\n    yieldFee: uint256\n    swapFee: uint256\n    claimRewardsFee: uint256\n\nstruct SubscriptionInfo:\n    asset: address\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct PendingSubPrice:\n    subInfo: SubscriptionInfo\n    effectiveBlock: uint256\n\nevent AgentSubPriceSet:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent PendingAgentSubPriceSet:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n    effectiveBlock: uint256\n\nevent ProtocolSubPriceSet:\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent AgentSubPriceRemoved:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent ProtocolSubPriceRemoved:\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent AgentSubPricingEnabled:\n    isEnabled: bool\n\nevent ProtocolTxPriceSheetSet:\n    yieldFee: uint256\n    swapFee: uint256\n    claimRewardsFee: uint256\n\nevent ProtocolTxPriceSheetRemoved:\n    yieldFee: uint256\n    swapFee: uint256\n    claimRewardsFee: uint256\n\nevent ProtocolRecipientSet:\n    recipient: indexed(address)\n\nevent PriceChangeDelaySet:\n    delayBlocks: uint256\n\nevent AmbassadorRatioSet:\n    ratio: uint256\n\nevent PriceSheetsActivated:\n    isActivated: bool\n\n# protocol pricing\nprotocolRecipient: public(address) # protocol recipient\nprotocolTxPriceData: public(TxPriceSheet) # protocol transaction pricing\nprotocolSubPriceData: public(SubscriptionInfo) # protocol subscription pricing\n\n# agent pricing\nisAgentSubPricingEnabled: public(bool)\nagentSubPriceData: public(HashMap[address, SubscriptionInfo]) # agent -> subscription pricing\n\n# pending price changes\npendingAgentSubPrices: public(HashMap[address, PendingSubPrice])\npriceChangeDelay: public(uint256) # number of blocks that must pass before price changes take effect\n\n# ambassador settings\nambassadorRatio: public(uint256) # ratio of ambassador proceeds\n\n# config\nADDY_REGISTRY: public(immutable(address))\nisActivated: public(bool)\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\n\nMIN_TRIAL_PERIOD: public(immutable(uint256))\nMAX_TRIAL_PERIOD: public(immutable(uint256))\nMIN_PAY_PERIOD: public(immutable(uint256))\nMAX_PAY_PERIOD: public(immutable(uint256))\nMIN_PRICE_CHANGE_BUFFER: public(immutable(uint256))\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_TX_FEE: constant(uint256) = 20_00 # 20.00%\n\n\n@deploy\ndef __init__(\n    _minTrialPeriod: uint256,\n    _maxTrialPeriod: uint256,\n    _minPayPeriod: uint256,\n    _maxPayPeriod: uint256,\n    _minPriceChangeBuffer: uint256,\n    _addyRegistry: address,\n):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    self.protocolRecipient = staticcall AddyRegistry(_addyRegistry).governance()\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n    ADDY_REGISTRY = _addyRegistry\n    MIN_TRIAL_PERIOD = _minTrialPeriod\n    MAX_TRIAL_PERIOD = _maxTrialPeriod\n    MIN_PAY_PERIOD = _minPayPeriod\n    MAX_PAY_PERIOD = _maxPayPeriod\n    MIN_PRICE_CHANGE_BUFFER = _minPriceChangeBuffer\n\n\n@view\n@internal\ndef _isRegisteredAgent(_agent: address) -> bool:\n    agentFactory: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    return staticcall AgentFactory(agentFactory).isAgent(_agent)\n\n\n######################\n# Subscription Utils #\n######################\n\n\n@view\n@external\ndef getCombinedSubData(_user: address, _agent: address, _agentPaidThru: uint256, _protocolPaidThru: uint256, _oracleRegistry: address) -> (SubPaymentInfo, SubPaymentInfo):\n    \"\"\"\n    @notice Get combined subscription data for an agent and protocol\n    @dev Returns a struct containing payment amounts and paid through blocks for both agent and protocol\n    @param _user The address of the user\n    @param _agent The address of the agent\n    @param _agentPaidThru The paid through block for the agent\n    @param _protocolPaidThru The paid through block for the protocol\n    @param _oracleRegistry The address of the oracle registry\n    @return protocolData struct containing payment amounts and paid through blocks for the protocol\n    @return agentData struct containing payment amounts and paid through blocks for the agent\n    \"\"\"\n    # NOTE: in future, we may have different pricing tiers depending on the `_user`\n\n    # protocol sub info\n    protocolData: SubPaymentInfo = self._updatePaidThroughBlock(_protocolPaidThru, self.protocolSubPriceData, _oracleRegistry)\n    if protocolData.amount != 0:\n        protocolData.recipient = self.protocolRecipient\n\n    # agent sub info\n    agentData: SubPaymentInfo = empty(SubPaymentInfo)\n    if _agent != empty(address):\n        agentData = self._updatePaidThroughBlock(_agentPaidThru, self.agentSubPriceData[_agent], _oracleRegistry)\n        agentData.recipient = _agent\n\n    return protocolData, agentData\n\n\n@view\n@internal\ndef _updatePaidThroughBlock(_paidThroughBlock: uint256, _subData: SubscriptionInfo, _oracleRegistry: address) -> SubPaymentInfo:\n    data: SubPaymentInfo = empty(SubPaymentInfo)\n    data.paidThroughBlock = _paidThroughBlock\n\n    # subscription was added (since last checked)\n    if _paidThroughBlock == 0 and _subData.usdValue != 0:\n        data.paidThroughBlock = block.number + _subData.trialPeriod\n        data.didChange = True\n\n    # subscription was removed (since last checked)\n    elif _paidThroughBlock != 0 and _subData.usdValue == 0:\n        data.paidThroughBlock = 0\n        data.didChange = True\n\n    # check if subscription needs to be paid\n    if data.paidThroughBlock != 0 and block.number > data.paidThroughBlock:\n        data.amount = staticcall OracleRegistry(_oracleRegistry).getAssetAmount(_subData.asset, _subData.usdValue)\n\n        # if something fails with price feed, allow transaction through.\n        # it's on agent developer to make sure price feed is working, so they can get paid\n        if data.amount != 0:\n            data.paidThroughBlock = block.number + _subData.payPeriod\n            data.usdValue = _subData.usdValue\n            data.asset = _subData.asset\n            data.didChange = True\n\n    return data\n\n\n######################\n# Agent Subscription #\n######################\n\n\n@view\n@external\ndef getAgentSubPriceData(_agent: address) -> SubscriptionInfo:\n    \"\"\"\n    @notice Get the subscription pricing data for a specific agent\n    @dev Returns empty SubscriptionInfo if agent subscription pricing is disabled\n    @param _agent The address of the agent to query\n    @return SubscriptionInfo struct containing subscription details\n    \"\"\"\n    if not self.isAgentSubPricingEnabled:\n        return empty(SubscriptionInfo)\n    return self.agentSubPriceData[_agent]\n\n\n# set agent sub price\n\n\n@view\n@external\ndef isValidSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Check if subscription price parameters are valid\n    @dev Validates asset, USD value, trial period, and pay period against constraints\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if all parameters are valid\n    \"\"\"\n    return self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod)\n\n\n@view\n@internal\ndef _isValidSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    if _asset == empty(address):\n        return False\n\n    if _payPeriod < MIN_PAY_PERIOD or _payPeriod > MAX_PAY_PERIOD:\n        return False\n\n    if _trialPeriod < MIN_TRIAL_PERIOD or _trialPeriod > MAX_TRIAL_PERIOD:\n        return False\n\n    return _usdValue != 0\n\n\n@external\ndef setAgentSubPrice(_agent: address, _asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Set subscription pricing for a specific agent\n    @dev Creates a pending subscription price change that can be finalized after priceChangeDelay blocks\n    @param _agent The address of the agent\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if pending subscription price was set successfully\n    \"\"\"\n    assert self._isRegisteredAgent(_agent) # dev: agent not registered\n    isAgentOwner: bool = staticcall Agent(_agent).owner() == msg.sender\n    assert isAgentOwner or gov._canGovern(msg.sender) # dev: no perms\n\n    if isAgentOwner:\n        assert self.isActivated # dev: not active\n\n    # validation\n    assert _agent != empty(address) # dev: invalid agent\n    if not self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod):\n        return False\n\n    # create pending subscription price\n    subInfo: SubscriptionInfo = SubscriptionInfo(\n        asset=_asset,\n        usdValue=_usdValue,\n        trialPeriod=_trialPeriod,\n        payPeriod=_payPeriod,\n    )\n\n    # set price change immediately if delay is 0\n    priceChangeDelay: uint256 = self.priceChangeDelay\n    if priceChangeDelay == 0:\n        self._setAgentSubPrice(_agent, subInfo)\n        return True\n\n    # set pending price change\n    effectiveBlock: uint256 = block.number + priceChangeDelay\n    self.pendingAgentSubPrices[_agent] = PendingSubPrice(subInfo=subInfo, effectiveBlock=effectiveBlock)\n    log PendingAgentSubPriceSet(agent=_agent, asset=_asset, usdValue=_usdValue, trialPeriod=_trialPeriod, payPeriod=_payPeriod, effectiveBlock=effectiveBlock)\n\n    return True\n\n\n# finalize agent sub price\n\n\n@external\ndef finalizePendingAgentSubPrice(_agent: address) -> bool:\n    \"\"\"\n    @notice Finalize a pending subscription price for an agent\n    @dev Can only be called after priceChangeDelay blocks have passed since the pending change was created\n    @param _agent The address of the agent\n    @return bool True if subscription price was finalized successfully\n    \"\"\"\n    assert self.isActivated # dev: not active\n\n    pendingPrice: PendingSubPrice = self.pendingAgentSubPrices[_agent]\n    assert pendingPrice.effectiveBlock != 0 and block.number >= pendingPrice.effectiveBlock # dev: time delay not reached\n    self.pendingAgentSubPrices[_agent] = empty(PendingSubPrice)\n\n    # apply pending subscription price\n    self._setAgentSubPrice(_agent, pendingPrice.subInfo)\n    return True\n\n\n@internal\ndef _setAgentSubPrice(_agent: address, _subInfo: SubscriptionInfo):\n    self.agentSubPriceData[_agent] = _subInfo\n    log AgentSubPriceSet(agent=_agent, asset=_subInfo.asset, usdValue=_subInfo.usdValue, trialPeriod=_subInfo.trialPeriod, payPeriod=_subInfo.payPeriod)\n\n\n# removing agent sub price\n\n\n@external\ndef removeAgentSubPrice(_agent: address) -> bool:\n    \"\"\"\n    @notice Remove subscription pricing for a specific agent\n    @dev Only callable by governor\n    @param _agent The address of the agent\n    @return bool True if agent subscription price was removed successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self._isRegisteredAgent(_agent) # dev: agent not registered\n\n    prevInfo: SubscriptionInfo = self.agentSubPriceData[_agent]\n    if empty(address) in [prevInfo.asset, _agent]:\n        return False\n\n    self.agentSubPriceData[_agent] = empty(SubscriptionInfo)\n    log AgentSubPriceRemoved(agent=_agent, asset=prevInfo.asset, usdValue=prevInfo.usdValue, trialPeriod=prevInfo.trialPeriod, payPeriod=prevInfo.payPeriod)\n    return True\n\n\n# enable / disable agent sub pricing\n\n\n@external\ndef setAgentSubPricingEnabled(_isEnabled: bool) -> bool:\n    \"\"\"\n    @notice Enable or disable agent subscription pricing\n    @dev Only callable by governor\n    @param _isEnabled True to enable, False to disable\n    @return bool True if agent subscription pricing state was changed successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert _isEnabled != self.isAgentSubPricingEnabled # dev: no change\n    self.isAgentSubPricingEnabled = _isEnabled\n    log AgentSubPricingEnabled(isEnabled=_isEnabled)\n    return True\n\n\n#########################\n# Protocol Subscription #\n#########################\n\n\n# set protocol sub price\n\n\n@external\ndef setProtocolSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Set subscription pricing for the protocol\n    @dev Only callable by governor\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if protocol subscription price was set successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # validation\n    if not self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod):\n        return False\n\n    # save data\n    self.protocolSubPriceData = SubscriptionInfo(\n        asset=_asset,\n        usdValue=_usdValue,\n        trialPeriod=_trialPeriod,\n        payPeriod=_payPeriod,\n    )\n\n    log ProtocolSubPriceSet(asset=_asset, usdValue=_usdValue, trialPeriod=_trialPeriod, payPeriod=_payPeriod)\n    return True\n\n\n# removing protocol sub price\n\n\n@external\ndef removeProtocolSubPrice() -> bool:\n    \"\"\"\n    @notice Remove subscription pricing for the protocol\n    @dev Only callable by governor\n    @return bool True if protocol subscription price was removed successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevInfo: SubscriptionInfo = self.protocolSubPriceData\n    if prevInfo.asset == empty(address):\n        return False\n\n    self.protocolSubPriceData = empty(SubscriptionInfo)\n    log ProtocolSubPriceRemoved(asset=prevInfo.asset, usdValue=prevInfo.usdValue, trialPeriod=prevInfo.trialPeriod, payPeriod=prevInfo.payPeriod)\n    return True\n\n\n####################\n# Protocol Tx Fees #\n####################\n\n\n# utilities\n\n\n@view\n@external\ndef getTransactionFeeDataWithAmbassadorRatio(_user: address, _action: ActionType) -> (uint256, address, uint256):\n    \"\"\"\n    @notice Get transaction fee data for the protocol\n    @dev Returns a tuple containing the fee amount and recipient address for the protocol\n    @param _user The address of the user\n    @param _action The type of action being performed\n    @return feeAmount The fee amount for the action\n    @return recipient The recipient address for the fee\n    @return ambassadorRatio The ratio of ambassador proceeds\n    \"\"\"\n    # NOTE: in future, we may have different pricing tiers depending on the `_user`\n    return self._getTxFeeForAction(_action, self.protocolTxPriceData), self.protocolRecipient, self.ambassadorRatio\n\n\n@view\n@external\ndef getTransactionFeeData(_user: address, _action: ActionType) -> (uint256, address):\n    # NOTE: this function is still used by legacy wallets\n    return self._getTxFeeForAction(_action, self.protocolTxPriceData), self.protocolRecipient\n\n\n@view\n@internal\ndef _getTxFeeForAction(_action: ActionType, _prices: TxPriceSheet) -> uint256:\n    if _action == ActionType.WITHDRAWAL:\n        return _prices.yieldFee\n    elif _action == ActionType.SWAP:\n        return _prices.swapFee\n    elif _action == ActionType.CLAIM_REWARDS:\n        return _prices.claimRewardsFee\n    else:\n        return 0\n\n\n# set protocol tx price sheet\n\n\n@view\n@external\ndef isValidTxPriceSheet(\n    _yieldFee: uint256,\n    _swapFee: uint256,\n    _claimRewardsFee: uint256,\n) -> bool:\n    \"\"\"\n    @notice Check if transaction price sheet parameters are valid\n    @dev Validates fee percentages against constraints\n    @param _yieldFee The fee percentage for yield profit\n    @param _swapFee The fee percentage for swaps\n    @param _claimRewardsFee The fee percentage for claiming rewards\n    @return bool True if all parameters are valid\n    \"\"\"\n    return self._isValidTxPriceSheet(_yieldFee, _swapFee, _claimRewardsFee)\n\n\n@view\n@internal\ndef _isValidTxPriceSheet(\n    _yieldFee: uint256,\n    _swapFee: uint256,\n    _claimRewardsFee: uint256,\n) -> bool:\n    return _yieldFee <= MAX_TX_FEE and _swapFee <= MAX_TX_FEE and _claimRewardsFee <= MAX_TX_FEE\n\n\n@external\ndef setProtocolTxPriceSheet(\n    _yieldFee: uint256,\n    _swapFee: uint256,\n    _claimRewardsFee: uint256,\n) -> bool:\n    \"\"\"\n    @notice Set transaction price sheet for the protocol\n    @dev Only callable by governor\n    @param _yieldFee The fee percentage for yield profit\n    @param _swapFee The fee percentage for swaps\n    @param _claimRewardsFee The fee percentage for claiming rewards\n    @return bool True if protocol price sheet was set successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # validation\n    if not self._isValidTxPriceSheet(_yieldFee, _swapFee, _claimRewardsFee):\n        return False\n\n    # save data\n    self.protocolTxPriceData = TxPriceSheet(\n        yieldFee=_yieldFee,\n        swapFee=_swapFee,\n        claimRewardsFee=_claimRewardsFee,\n    )\n\n    log ProtocolTxPriceSheetSet(yieldFee=_yieldFee, swapFee=_swapFee, claimRewardsFee=_claimRewardsFee)\n    return True\n\n\n# remove protocol tx price sheet\n\n\n@external\ndef removeProtocolTxPriceSheet() -> bool:\n    \"\"\"\n    @notice Remove transaction price sheet for the protocol\n    @dev Only callable by governor\n    @return bool True if protocol price sheet was removed successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevInfo: TxPriceSheet = self.protocolTxPriceData\n    self.protocolTxPriceData = empty(TxPriceSheet)\n    log ProtocolTxPriceSheetRemoved(yieldFee=prevInfo.yieldFee, swapFee=prevInfo.swapFee, claimRewardsFee=prevInfo.claimRewardsFee)\n    return True\n\n\n######################\n# Protocol Recipient #\n######################\n\n\n@external\ndef setProtocolRecipient(_recipient: address) -> bool:\n    \"\"\"\n    @notice Set the recipient address for protocol fees\n    @dev Only callable by governor\n    @param _recipient The address to receive protocol fees\n    @return bool True if protocol recipient was set successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _recipient != empty(address) # dev: invalid recipient\n    self.protocolRecipient = _recipient\n    log ProtocolRecipientSet(recipient=_recipient)\n    return True\n\n\n######################\n# Price Change Delay #\n######################\n\n\n@external\ndef setPriceChangeDelay(_delayBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Set the number of blocks required before price changes take effect\n    @dev Only callable by governor\n    @param _delayBlocks The number of blocks to wait before price changes take effect\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _delayBlocks == 0 or _delayBlocks >= MIN_PRICE_CHANGE_BUFFER # dev: invalid delay\n    self.priceChangeDelay = _delayBlocks\n    log PriceChangeDelaySet(delayBlocks=_delayBlocks)\n    return True\n\n\n#######################\n# Ambassador Settings #\n#######################\n\n\n@external\ndef setAmbassadorRatio(_ratio: uint256) -> bool:\n    \"\"\"\n    @notice Set the ratio of ambassador proceeds\n    @dev Only callable by governor\n    @param _ratio The ratio of ambassador proceeds\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _ratio <= HUNDRED_PERCENT # dev: invalid ratio\n    self.ambassadorRatio = _ratio\n    log AmbassadorRatioSet(ratio=_ratio)\n    return True\n\n\n############\n# Activate #\n############\n\n\n@external\ndef activate(_shouldActivate: bool):\n    \"\"\"\n    @notice Activate or deactivate the price sheets registry\n    @dev Only callable by governor. When deactivated, most functions cannot be called.\n    @param _shouldActivate True to activate, False to deactivate\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log PriceSheetsActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "4dbd2a5a82044bc6f04add970ac8fe69e3a9305e56be63ff6a6be776089ec6a7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/PriceSheets.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "2c61ab2e90f12b93edf021acfbd26d175de9165144f8e8b8c22dd1360b48d0e7"
      },
      "args": "000000000000000000000000000000000000000000000000000000000000a8c0000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000000000000000003b8260000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "ChainlinkFeeds": {
      "address": "0x605c6ab843d65dD14b00CEB33f445D7f9bbb7930",
      "abi": [
        {
          "name": "ChainlinkFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "chainlinkFeed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getConfiguredAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getChainlinkData",
          "inputs": [
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getChainlinkData",
          "inputs": [
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableChainlinkPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "feed",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "needsEthToUsd",
                  "type": "bool"
                },
                {
                  "name": "needsBtcToUsd",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "BTC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_btcAddr",
              "type": "address"
            },
            {
              "name": "_ethUsdFeed",
              "type": "address"
            },
            {
              "name": "_btcUsdFeed",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/OracleAssetData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "ebfec365e231ba18d5a0509682ce49c61d855719b832216297c6db33665c7be8"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/oracles/ChainlinkFeeds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: OraclePartner\ninitializes: gov\ninitializes: oad\nexports: gov.__interface__\nexports: oad.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.OracleAssetData as oad\nimport interfaces.OraclePartnerInterface as OraclePartner\n\ninterface ChainlinkFeed:\n    def latestRoundData() -> ChainlinkRound: view\n    def decimals() -> uint8: view \n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nstruct ChainlinkConfig:\n    feed: address\n    decimals: uint256\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n\nevent ChainlinkFeedAdded:\n    asset: indexed(address)\n    chainlinkFeed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n\nevent ChainlinkFeedDisabled:\n    asset: indexed(address)\n\n# chainlink config\nfeedConfig: public(HashMap[address, ChainlinkConfig])\n\n# general config\noraclePartnerId: public(uint256)\nADDY_REGISTRY: public(immutable(address))\n\n# default assets\nWETH: public(immutable(address))\nETH: public(immutable(address))\nBTC: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\n\n\n@deploy\ndef __init__(\n    _wethAddr: address,\n    _ethAddr: address,\n    _btcAddr: address,\n    _ethUsdFeed: address,\n    _btcUsdFeed: address,\n    _addyRegistry: address,\n):\n    assert empty(address) not in [_wethAddr, _ethAddr, _btcAddr, _addyRegistry] # dev: invalid addrs\n    ADDY_REGISTRY = _addyRegistry\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    oad.__init__()\n\n    # set default assets\n    WETH = _wethAddr\n    ETH = _ethAddr\n    BTC = _btcAddr\n\n    # set default feeds\n    if _ethUsdFeed != empty(address):\n        assert self._setChainlinkFeed(ETH, _ethUsdFeed, False, False)\n        assert self._setChainlinkFeed(WETH, _ethUsdFeed, False, False)\n    if _btcUsdFeed != empty(address):\n        assert self._setChainlinkFeed(BTC, _btcUsdFeed, False, False)\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    config: ChainlinkConfig = self.feedConfig[_asset]\n    if config.feed == empty(address):\n        return 0\n    return self._getPrice(config.feed, config.decimals, config.needsEthToUsd, config.needsBtcToUsd, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    config: ChainlinkConfig = self.feedConfig[_asset]\n    if config.feed == empty(address):\n        return 0, False\n    return self._getPrice(config.feed, config.decimals, config.needsEthToUsd, config.needsBtcToUsd, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(\n    _feed: address, \n    _decimals: uint256,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n    _staleTime: uint256,\n) -> uint256:\n    price: uint256 = self._getChainlinkData(_feed, _decimals, _staleTime)\n    if price == 0:\n        return 0\n\n    # if price needs ETH -> USD conversion\n    if _needsEthToUsd:\n        ethConfig: ChainlinkConfig = self.feedConfig[ETH]\n        ethUsdPrice: uint256 = self._getChainlinkData(ethConfig.feed, ethConfig.decimals, _staleTime)\n        price = price * ethUsdPrice // (10 ** NORMALIZED_DECIMALS)\n\n    # if price needs BTC -> USD conversion\n    elif _needsBtcToUsd:\n        btcConfig: ChainlinkConfig = self.feedConfig[BTC]\n        btcUsdPrice: uint256 = self._getChainlinkData(btcConfig.feed, btcConfig.decimals, _staleTime)\n        price = price * btcUsdPrice // (10 ** NORMALIZED_DECIMALS)\n\n    return price\n\n\n@view\n@external\ndef getChainlinkData(_feed: address, _decimals: uint256, _staleTime: uint256 = 0) -> uint256:\n    return self._getChainlinkData(_feed, _decimals, _staleTime)\n\n\n@view\n@internal\ndef _getChainlinkData(_feed: address, _decimals: uint256, _staleTime: uint256) -> uint256:\n    oracle: ChainlinkRound = staticcall ChainlinkFeed(_feed).latestRoundData()\n\n    # NOTE: choosing to fail gracefully in Underscore\n\n    # oracle has no price\n    if oracle.answer <= 0:\n        return 0\n\n    # bad decimals\n    if _decimals > NORMALIZED_DECIMALS:\n        return 0\n\n    # price is too stale\n    if _staleTime != 0 and block.timestamp - oracle.updatedAt > _staleTime:\n        return 0\n\n    # handle decimal normalization\n    price: uint256 = convert(oracle.answer, uint256)\n    decimals: uint256 = _decimals\n    if decimals < NORMALIZED_DECIMALS:\n        decimals = NORMALIZED_DECIMALS - decimals\n        price = price * (10 ** decimals)\n\n    return price\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self._hasPriceFeed(_asset)\n\n\n@view\n@internal\ndef _hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset].feed != empty(address)\n\n\n#####################\n# Config Price Feed #\n#####################\n\n\n# set price feed\n\n\n@view\n@external\ndef isValidChainlinkFeed(\n    _asset: address, \n    _feed: address,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n) -> bool:\n    decimals: uint256 = convert(staticcall ChainlinkFeed(_feed).decimals(), uint256)\n    return self._isValidChainlinkFeed(_asset, _feed, decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n@view\n@internal\ndef _isValidChainlinkFeed(\n    _asset: address, \n    _feed: address,\n    _decimals: uint256,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n) -> bool:\n    if empty(address) in [_asset, _feed]:\n        return False\n    if _needsEthToUsd and _needsBtcToUsd:\n        return False\n    return self._getPrice(_feed, _decimals, _needsEthToUsd, _needsBtcToUsd, 0) != 0\n\n\n@external\ndef setChainlinkFeed(\n    _asset: address, \n    _feed: address, \n    _needsEthToUsd: bool = False,\n    _needsBtcToUsd: bool = False,\n) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setChainlinkFeed(_asset, _feed, _needsEthToUsd, _needsBtcToUsd)\n\n\n@internal\ndef _setChainlinkFeed(\n    _asset: address, \n    _feed: address, \n    _needsEthToUsd: bool = False,\n    _needsBtcToUsd: bool = False,\n) -> bool:\n    decimals: uint256 = convert(staticcall ChainlinkFeed(_feed).decimals(), uint256)\n    if not self._isValidChainlinkFeed(_asset, _feed, decimals, _needsEthToUsd, _needsBtcToUsd):\n        return False\n\n    self.feedConfig[_asset] = ChainlinkConfig(\n        feed=_feed,\n        decimals=decimals,\n        needsEthToUsd=_needsEthToUsd,\n        needsBtcToUsd=_needsBtcToUsd,\n    )\n    oad._addAsset(_asset)\n    log ChainlinkFeedAdded(asset=_asset, chainlinkFeed=_feed, needsEthToUsd=_needsEthToUsd, needsBtcToUsd=_needsBtcToUsd)\n    return True\n\n\n# disable price feed\n\n\n@external\ndef disableChainlinkPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _asset not in [ETH, WETH, BTC] # dev: cannot disable default feeds\n    if not self._hasPriceFeed(_asset):\n        return False\n    self.feedConfig[_asset] = empty(ChainlinkConfig)\n    oad._removeAsset(_asset)\n    log ChainlinkFeedDisabled(asset=_asset)\n    return True\n\n\n##########\n# Config #\n##########\n\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4) # dev: no perms\n    prevId: uint256 = self.oraclePartnerId\n    assert prevId == 0 or prevId == _oracleId # dev: invalid oracle id\n    self.oraclePartnerId = _oracleId\n    return True\n",
            "sha256sum": "b1fd2dd114a6e5f6df9d20c16aaec756c731fa578137002acfcf4a65426caab6"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/oracles/ChainlinkFeeds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "5962d5b6bfe3b188f39feb1324a6e5397c57dbb1ac2fb84f422cfdfce46c209e"
      },
      "args": "0000000000000000000000004200000000000000000000000000000000000006000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb00000000000000000000000071041dddad3595f9ced3dccfbe3d1f4b0a16bb7000000000000000000000000064c911996d3c6ac71f9b455b1e8e7266bcbd848f0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "PythFeeds": {
      "address": "0x415a2fe1e591619c6c12Df09eAEc8a598224F9fE",
      "abi": [
        {
          "name": "PythFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feedId",
              "type": "bytes32",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PythFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PythPriceUpdated",
          "inputs": [
            {
              "name": "payload",
              "type": "bytes",
              "indexed": false
            },
            {
              "name": "feeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EthRecoveredFromPyth",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getConfiguredAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePythPrices",
          "inputs": [
            {
              "name": "_payloads",
              "type": "bytes[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPythFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPythFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disablePythPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidEthRecovery",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverEthBalance",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "PYTH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_pyth",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/OracleAssetData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "ebfec365e231ba18d5a0509682ce49c61d855719b832216297c6db33665c7be8"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/oracles/PythFeeds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: OraclePartner\ninitializes: gov\ninitializes: oad\nexports: gov.__interface__\nexports: oad.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.OracleAssetData as oad\nimport interfaces.OraclePartnerInterface as OraclePartner\n\ninterface PythNetwork:\n    def getPriceUnsafe(_priceFeedId: bytes32) -> PythPrice: view\n    def priceFeedExists(_priceFeedId: bytes32) -> bool: view\n    def getUpdateFee(_payLoad: Bytes[2048]) -> uint256: view\n    def updatePriceFeeds(_payLoad: Bytes[2048]): payable\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct PythPrice:\n    price: int64\n    confidence: uint64\n    exponent: int32\n    publishTime: uint64\n\nevent PythFeedAdded:\n    asset: indexed(address)\n    feedId: indexed(bytes32)\n\nevent PythFeedDisabled:\n    asset: indexed(address)\n\nevent PythPriceUpdated:\n    payload: Bytes[2048]\n    feeAmount: uint256\n    caller: indexed(address)\n\nevent EthRecoveredFromPyth:\n    recipient: indexed(address)\n    amount: uint256\n\n# pyth config\nPYTH: public(immutable(address))\nfeedConfig: public(HashMap[address, bytes32])\n\n# general config\noraclePartnerId: public(uint256)\nADDY_REGISTRY: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\nMAX_PRICE_UPDATES: constant(uint256) = 15\n\n\n@deploy\ndef __init__(_pyth: address, _addyRegistry: address):\n    assert empty(address) not in [_pyth, _addyRegistry] # dev: invalid addrs\n    PYTH = _pyth\n    ADDY_REGISTRY = _addyRegistry\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    oad.__init__()\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0\n    return self._getPrice(feedId, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0, False\n    return self._getPrice(feedId, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(_feedId: bytes32, _staleTime: uint256) -> uint256:\n    priceData: PythPrice = staticcall PythNetwork(PYTH).getPriceUnsafe(_feedId)\n\n    # NOTE: choosing to fail gracefully in Underscore\n\n    # no price\n    if priceData.price <= 0:\n        return 0\n\n    # price is too stale\n    publishTime: uint256 = convert(priceData.publishTime, uint256)\n    if _staleTime != 0 and block.timestamp - publishTime > _staleTime:\n        return 0\n\n    price: uint256 = convert(priceData.price, uint256)\n    confidence: uint256 = convert(priceData.confidence, uint256)\n    scale: uint256 = 10 ** NORMALIZED_DECIMALS\n    exponent: uint256 = 0\n\n    # negative exponent: multiply by 10^(18-|exponent|)\n    if priceData.exponent < 0:\n        exponent = convert(-priceData.exponent, uint256)\n        price = price * scale // (10 ** exponent)\n        confidence = confidence * scale // (10 ** exponent)\n\n    # positive exponent: multiply by 10^(18+exponent)\n    else:\n        exponent = convert(priceData.exponent, uint256)\n        price = price * scale * (10 ** exponent)\n        confidence = confidence * scale * (10 ** exponent)\n\n    # invalid price\n    if confidence >= price:\n        return 0\n\n    return price - confidence\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self._hasPriceFeed(_asset)\n\n\n@view\n@internal\ndef _hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset] != empty(bytes32)\n\n\n################\n# Update Price #\n################\n\n\n@external\ndef updatePythPrices(_payloads: DynArray[Bytes[2048], MAX_PRICE_UPDATES]):\n    for i: uint256 in range(len(_payloads), bound=MAX_PRICE_UPDATES):\n        p: Bytes[2048] = _payloads[i]\n        feeAmount: uint256 = staticcall PythNetwork(PYTH).getUpdateFee(p)\n        assert self.balance >= feeAmount # dev: insufficient balance\n        extcall PythNetwork(PYTH).updatePriceFeeds(p, value=feeAmount)\n        log PythPriceUpdated(payload=p, feeAmount=feeAmount, caller=msg.sender)\n\n\n#####################\n# Config Price Feed #\n#####################\n\n\n# set price feed\n\n\n@view\n@external\ndef isValidPythFeed(_asset: address, _feedId: bytes32) -> bool:\n    return self._isValidPythFeed(_asset, _feedId)\n\n\n@view\n@internal\ndef _isValidPythFeed(_asset: address, _feedId: bytes32) -> bool:\n    if _asset == empty(address):\n        return False\n    return staticcall PythNetwork(PYTH).priceFeedExists(_feedId)\n\n\n@external\ndef setPythFeed(_asset: address, _feedId: bytes32) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._isValidPythFeed(_asset, _feedId):\n        return False\n    self.feedConfig[_asset] = _feedId\n    oad._addAsset(_asset)\n    log PythFeedAdded(asset=_asset, feedId=_feedId)\n    return True\n\n\n# disable price feed\n\n\n@external\ndef disablePythPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._hasPriceFeed(_asset):\n        return False\n    self.feedConfig[_asset] = empty(bytes32)\n    oad._removeAsset(_asset)\n    log PythFeedDisabled(asset=_asset)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@view\n@external\ndef isValidEthRecovery(_recipient: address) -> bool:\n    return self._isValidEthRecovery(_recipient, self.balance)\n\n\n@view\n@internal\ndef _isValidEthRecovery(_recipient: address, _balance: uint256) -> bool:\n    return _recipient != empty(address) and _balance != 0\n\n\n@external\ndef recoverEthBalance(_recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    balance: uint256 = self.balance\n    if not self._isValidEthRecovery(_recipient, balance):\n        return False\n    send(_recipient, balance)\n    log EthRecoveredFromPyth(recipient=_recipient, amount=balance)\n    return True\n\n\n##########\n# Config #\n##########\n\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4) # dev: no perms\n    prevId: uint256 = self.oraclePartnerId\n    assert prevId == 0 or prevId == _oracleId # dev: invalid oracle id\n    self.oraclePartnerId = _oracleId\n    return True\n",
            "sha256sum": "ba2a1487114df51aaa0ebde35b26d18aba9c3b9af65d3565abfbe19412ab3088"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/oracles/PythFeeds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "136c69192320af8a4e61d673546310f6432408cefb9bd9b69a44ea9d11c07177"
      },
      "args": "0000000000000000000000008250f4af4b972684f7b336503e2d6dfedeb1487a0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "StorkFeeds": {
      "address": "0xD47D74C56c17Bf3B7236e8a7eb97D3194c3d477c",
      "abi": [
        {
          "name": "StorkFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feedId",
              "type": "bytes32",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StorkFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StorkPriceUpdated",
          "inputs": [
            {
              "name": "payload",
              "type": "bytes",
              "indexed": false
            },
            {
              "name": "feeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EthRecoveredFromStork",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getConfiguredAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateStorkPrices",
          "inputs": [
            {
              "name": "_payloads",
              "type": "bytes[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidStorkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStorkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableStorkPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidEthRecovery",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverEthBalance",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "STORK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_stork",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/OracleAssetData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "ebfec365e231ba18d5a0509682ce49c61d855719b832216297c6db33665c7be8"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/oracles/StorkFeeds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: OraclePartner\ninitializes: gov\ninitializes: oad\nexports: gov.__interface__\nexports: oad.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.OracleAssetData as oad\nimport interfaces.OraclePartnerInterface as OraclePartner\n\ninterface StorkNetwork:\n    def getTemporalNumericValueUnsafeV1(_priceFeedId: bytes32) -> TemporalNumericValue: view\n    def updateTemporalNumericValuesV1(_payLoad: Bytes[2048]): payable\n    def getUpdateFeeV1(_payLoad: Bytes[2048]) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct TemporalNumericValue:\n    timestampNs: uint64\n    quantizedValue: uint256\n\nevent StorkFeedAdded:\n    asset: indexed(address)\n    feedId: indexed(bytes32)\n\nevent StorkFeedDisabled:\n    asset: indexed(address)\n\nevent StorkPriceUpdated:\n    payload: Bytes[2048]\n    feeAmount: uint256\n    caller: indexed(address)\n\nevent EthRecoveredFromStork:\n    recipient: indexed(address)\n    amount: uint256\n\n# stork config\nSTORK: public(immutable(address))\nfeedConfig: public(HashMap[address, bytes32])\n\n# general config\noraclePartnerId: public(uint256)\nADDY_REGISTRY: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\nMAX_PRICE_UPDATES: constant(uint256) = 15\n\n\n@deploy\ndef __init__(_stork: address, _addyRegistry: address):\n    assert empty(address) not in [_stork, _addyRegistry] # dev: invalid addrs\n    STORK = _stork\n    ADDY_REGISTRY = _addyRegistry\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    oad.__init__()\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0\n    return self._getPrice(feedId, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0, False\n    return self._getPrice(feedId, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(_feedId: bytes32, _staleTime: uint256) -> uint256:\n    priceData: TemporalNumericValue = staticcall StorkNetwork(STORK).getTemporalNumericValueUnsafeV1(_feedId)\n\n    # NOTE: choosing to fail gracefully in Underscore\n\n    # no price\n    if priceData.quantizedValue == 0:\n        return 0\n\n    # price is too stale\n    publishTime: uint256 = convert(priceData.timestampNs, uint256) // 1_000_000_000\n    if _staleTime != 0 and block.timestamp - publishTime > _staleTime:\n        return 0\n\n    return priceData.quantizedValue\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self._hasPriceFeed(_asset)\n\n\n@view\n@internal\ndef _hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset] != empty(bytes32)\n\n\n################\n# Update Price #\n################\n\n\n@external\ndef updateStorkPrices(_payloads: DynArray[Bytes[2048], MAX_PRICE_UPDATES]):\n    for i: uint256 in range(len(_payloads), bound=MAX_PRICE_UPDATES):\n        p: Bytes[2048] = _payloads[i]\n        feeAmount: uint256 = staticcall StorkNetwork(STORK).getUpdateFeeV1(p)\n        assert self.balance >= feeAmount # dev: insufficient balance\n        extcall StorkNetwork(STORK).updateTemporalNumericValuesV1(p, value=feeAmount)\n        log StorkPriceUpdated(payload=p, feeAmount=feeAmount, caller=msg.sender)\n\n\n#####################\n# Config Price Feed #\n#####################\n\n\n# set price feed\n\n\n@view\n@external\ndef isValidStorkFeed(_asset: address, _feedId: bytes32) -> bool:\n    return self._isValidStorkFeed(_asset, _feedId)\n\n\n@view\n@internal\ndef _isValidStorkFeed(_asset: address, _feedId: bytes32) -> bool:\n    if _asset == empty(address):\n        return False\n    priceData: TemporalNumericValue = staticcall StorkNetwork(STORK).getTemporalNumericValueUnsafeV1(_feedId)\n    return priceData.timestampNs != 0\n\n\n@external\ndef setStorkFeed(_asset: address, _feedId: bytes32) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._isValidStorkFeed(_asset, _feedId):\n        return False\n    self.feedConfig[_asset] = _feedId\n    oad._addAsset(_asset)\n    log StorkFeedAdded(asset=_asset, feedId=_feedId)\n    return True\n\n\n# disable price feed\n\n\n@external\ndef disableStorkPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._hasPriceFeed(_asset):\n        return False\n    self.feedConfig[_asset] = empty(bytes32)\n    oad._removeAsset(_asset)\n    log StorkFeedDisabled(asset=_asset)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@view\n@external\ndef isValidEthRecovery(_recipient: address) -> bool:\n    return self._isValidEthRecovery(_recipient, self.balance)\n\n\n@view\n@internal\ndef _isValidEthRecovery(_recipient: address, _balance: uint256) -> bool:\n    return _recipient != empty(address) and _balance != 0\n\n\n@external\ndef recoverEthBalance(_recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    balance: uint256 = self.balance\n    if not self._isValidEthRecovery(_recipient, balance):\n        return False\n    send(_recipient, balance)\n    log EthRecoveredFromStork(recipient=_recipient, amount=balance)\n    return True\n\n\n##########\n# Config #\n##########\n\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4) # dev: no perms\n    prevId: uint256 = self.oraclePartnerId\n    assert prevId == 0 or prevId == _oracleId # dev: invalid oracle id\n    self.oraclePartnerId = _oracleId\n    return True\n",
            "sha256sum": "201ae4139c9529d1072725376d2d2058738be6d49d3d40445b2a2920e0652d4e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/oracles/StorkFeeds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "11048087899003d89aaf390008984caaedb3629dde1f69944b3293533aeac027"
      },
      "args": "000000000000000000000000647dfd812bc1e116c6992cb2bc353b2112176fd60000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoAaveV3": {
      "address": "0x8c94cfC11A9340e45032e5021881cc312993Bf15",
      "abi": [
        {
          "name": "AaveV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3LegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3Activated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ADDRESS_PROVIDER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_aaveV3",
              "type": "address"
            },
            {
              "name": "_addressProvider",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoAaveV3.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface AaveProtocolDataProvider:\n    def getReserveTokensAddresses(_asset: address) -> (address, address, address): view\n    def getAllATokens() -> DynArray[TokenData, MAX_ATOKENS]: view\n    def getTotalDebt(_asset: address) -> uint256: view\n\ninterface AaveV3Pool:\n    def supply(_asset: address, _amount: uint256, _onBehalfOf: address, _referralCode: uint16): nonpayable\n    def withdraw(_asset: address, _amount: uint256, _to: address): nonpayable\n\ninterface AToken:\n    def UNDERLYING_ASSET_ADDRESS() -> address: view\n    def totalSupply() -> uint256: view\n\ninterface AaveV3AddressProvider:\n    def getPoolDataProvider() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct TokenData:\n    symbol: String[32]\n    tokenAddress: address\n\nevent AaveV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent AaveV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent AaveV3FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent AaveV3LegoIdSet:\n    legoId: uint256\n\nevent AaveV3Activated:\n    isActivated: bool\n\n# aave v3\nAAVE_V3_POOL: public(immutable(address))\nAAVE_V3_ADDRESS_PROVIDER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nMAX_ATOKENS: constant(uint256) = 40\n\n\n@deploy\ndef __init__(_aaveV3: address, _addressProvider: address, _addyRegistry: address):\n    assert empty(address) not in [_aaveV3, _addressProvider, _addyRegistry] # dev: invalid addrs\n    AAVE_V3_POOL = _aaveV3\n    AAVE_V3_ADDRESS_PROVIDER = _addressProvider\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AAVE_V3_POOL, AAVE_V3_ADDRESS_PROVIDER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@internal\ndef _getPoolDataProvider() -> address:\n    return staticcall AaveV3AddressProvider(AAVE_V3_ADDRESS_PROVIDER).getPoolDataProvider()\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidAToken(_vaultToken, self._getPoolDataProvider())\n\n\n@view\n@internal\ndef _isValidAToken(_aToken: address, _dataProvider: address) -> bool:\n    aTokens: DynArray[TokenData, MAX_ATOKENS] = staticcall AaveProtocolDataProvider(_dataProvider).getAllATokens()\n    for i: uint256 in range(len(aTokens), bound=MAX_ATOKENS):\n        if aTokens[i].tokenAddress == _aToken:\n            return True\n    return False\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken, self._getPoolDataProvider())\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address, _dataProvider: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidAToken(_vaultToken, _dataProvider):\n        asset = staticcall AToken(_vaultToken).UNDERLYING_ASSET_ADDRESS()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    # treated as 1:1\n    return _assetAmount\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken, self._getPoolDataProvider())\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall AToken(_vaultToken).totalSupply()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    dataProvider: address = self._getPoolDataProvider()\n    asset: address = self._getUnderlyingAsset(_vaultToken, dataProvider)\n    if asset == empty(address):\n        return 0 # invalid vault token\n    return staticcall AaveProtocolDataProvider(dataProvider).getTotalDebt(asset)\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    vaultToken: address = self._getVaultToken(_asset, _vault)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preRecipientVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    extcall AaveV3Pool(AAVE_V3_POOL).supply(_asset, depositAmount, _recipient, 0)\n\n    # validate vault token transfer\n    newRecipientVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient)\n    vaultTokenAmountReceived: uint256 = newRecipientVaultBalance - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log AaveV3Deposit(sender=msg.sender, asset=_asset, vaultToken=vaultToken, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, vaultToken, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n@view\n@internal\ndef _getVaultToken(_asset: address, _vault: address) -> address:\n    vault: address = _vault\n    if _vault != empty(address):\n        vault = yld.assetOpportunities[_asset][1] # only one opportunity for aave v3\n    assert yld.indexOfAssetOpportunity[_asset][vault] != 0 # dev: asset + vault not supported\n    return vault\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    vaultToken: address = self._getVaultToken(_asset, _vaultToken)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n    preRecipientAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall AaveV3Pool(AAVE_V3_POOL).withdraw(_asset, max_value(uint256), _recipient)\n\n    # validate asset transfer\n    newRecipientAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n    assetAmountReceived: uint256 = newRecipientAssetBalance - preRecipientAssetBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log AaveV3Withdrawal(sender=msg.sender, asset=_asset, vaultToken=vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    # Aave has no rewards on Base\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # Aave has no rewards on Base\n    return False\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    dataProvider: address = self._getPoolDataProvider()\n    vaultToken: address = (staticcall AaveProtocolDataProvider(dataProvider).getReserveTokensAddresses(_asset))[0]\n    assert vaultToken != empty(address) # dev: invalid asset\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, vaultToken)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    vaultToken: address = yld.assetOpportunities[_asset][1] # only one opportunity for aave v3\n    yld._removeAssetOpportunity(_asset, vaultToken)\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AaveV3FundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log AaveV3LegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log AaveV3Activated(isActivated=_shouldActivate)",
            "sha256sum": "f56f0952d282b19afe4c71dd0fc10c3b70d4d0703999cf980e2cea7eed4fe598"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoAaveV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "994585851c491e0cd9abb6962fcae87ff723da486d04875e66a347c1c2e65359"
      },
      "args": "000000000000000000000000a238dd80c259a72e81d7e4664a9801593f98d1c5000000000000000000000000e20fcbdbffc4dd138ce8b2e6fbb6cb49777ad64d0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoCompoundV3": {
      "address": "0xF86d1D68C951d163aBc383C508740df6ddED500C",
      "abi": [
        {
          "name": "CompoundV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3RewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3LegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3Activated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCompRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_CONFIGURATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_configurator",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "contracts/legos/yield/LegoCompoundV3.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\n\n# `hasClaimableRewards()` is not a view function, sadly due to compound v3 constraints\n# keeping here to uncomment to test all other functions\n# implements: LegoCommon \n# from interfaces import LegoCommon\n\ninterface CompoundV3:\n    def withdrawTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def supplyTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def totalSupply() -> uint256: view\n    def totalBorrow() -> uint256: view\n    def baseToken() -> address: view\n\ninterface CompoundV3Rewards:\n    def getRewardOwed(_comet: address, _user: address) -> RewardOwed: nonpayable\n    def claim(_comet: address, _user: address, _shouldAccrue: bool): nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface CompoundV3Configurator:\n    def factory(_cometAsset: address) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct RewardOwed:\n    token: address\n    owed: uint256\n\nevent CompoundV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent CompoundV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent CompoundV3FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent CompoundV3RewardsAddrSet:\n    addr: address\n\nevent CompoundV3LegoIdSet:\n    legoId: uint256\n\nevent CompoundV3Activated:\n    isActivated: bool\n\n# compound v3\ncompoundRewards: public(address)\nCOMPOUND_V3_CONFIGURATOR: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\n\n@deploy\ndef __init__(_configurator: address, _addyRegistry: address):\n    assert empty(address) not in [_configurator, _addyRegistry] # dev: invalid addrs\n    COMPOUND_V3_CONFIGURATOR = _configurator\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [COMPOUND_V3_CONFIGURATOR]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidCometAddr(_vaultToken)\n\n\n@view\n@internal\ndef _isValidCometAddr(_cometAddr: address) -> bool:\n    return staticcall CompoundV3Configurator(COMPOUND_V3_CONFIGURATOR).factory(_cometAddr) != empty(address)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidCometAddr(_vaultToken):\n        asset = staticcall CompoundV3(_vaultToken).baseToken()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    # treated as 1:1\n    return _assetAmount\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV3(_vaultToken).totalSupply()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV3(_vaultToken).totalBorrow()\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preRecipientVaultBalance: uint256 = staticcall IERC20(_vault).balanceOf(_recipient)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    extcall CompoundV3(_vault).supplyTo(_recipient, _asset, depositAmount) # dev: could not deposit into compound v3\n\n    # validate vault token transfer\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vault).balanceOf(_recipient) - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log CompoundV3Deposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preRecipientBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall CompoundV3(_vaultToken).withdrawTo(_recipient, _asset, max_value(uint256)) # dev: could not withdraw from compound v3\n\n    # validate received asset , transfer back to user\n    assetAmountReceived: uint256 = staticcall IERC20(_asset).balanceOf(_recipient) - preRecipientBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log CompoundV3Withdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    compRewards: address = self.compoundRewards\n    assert compRewards != empty(address) # dev: no comp rewards addr set\n    if _market != empty(address):\n        extcall CompoundV3Rewards(compRewards).claim(_market, _user, True)\n    else:\n        self._hasClaimableOrShouldClaim(_user, True, compRewards)\n\n\n# sadly, this is not a view function because of `getRewardOwed()`\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return self._hasClaimableOrShouldClaim(_user, False, self.compoundRewards)\n\n\n@internal\ndef _hasClaimableOrShouldClaim(_user: address, _shouldClaim: bool, _compRewards: address) -> bool:\n    hasClaimable: bool = False\n    numAssets: uint256 = yld.numAssets\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = yld.assets[i]\n        comet: address = yld.assetOpportunities[asset][1] # only a single \"vault token\" (comet) per asset\n\n        rewardOwed: RewardOwed = extcall CompoundV3Rewards(_compRewards).getRewardOwed(comet, _user)\n        if rewardOwed.owed != 0:\n            hasClaimable = True\n            if _shouldClaim:\n                extcall CompoundV3Rewards(_compRewards).claim(comet, _user, True)\n            else:\n                break\n\n    return hasClaimable\n\n\n# set rewards addr\n\n\n@external\ndef setCompRewardsAddr(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.compoundRewards = _addr\n    log CompoundV3RewardsAddrSet(addr=_addr)\n    return True\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log CompoundV3FundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log CompoundV3LegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log CompoundV3Activated(isActivated=_shouldActivate)\n",
            "sha256sum": "88387c7ca1510d757d33a096f6b1d84be60ab056ed30e95f23aec789f49f81d9"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoCompoundV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "f48dfff8df6ceb9863429d77361dddbced338906edb480a6315ade2ef05aeabd"
      },
      "args": "00000000000000000000000045939657d1ca34a8fa39a924b71d28fe8431e5810000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoEuler": {
      "address": "0xB2a1cdC1D896eE37cD432b591FeC2664294286FB",
      "abi": [
        {
          "name": "EulerDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setEulerRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EVAULT_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EARN_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_evaultFactory",
              "type": "address"
            },
            {
              "name": "_earnFactory",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoEuler.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface Erc4626Interface:\n    def redeem(_vaultTokenAmount: uint256, _recipient: address, _owner: address) -> uint256: nonpayable\n    def deposit(_assetAmount: uint256, _recipient: address) -> uint256: nonpayable\n    def convertToAssets(_vaultTokenAmount: uint256) -> uint256: view\n    def convertToShares(_assetAmount: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def asset() -> address: view\n\ninterface EulerRewardsDistributor:\n    def claim(_users: DynArray[address, 10], _rewardTokens: DynArray[address, 10], _claimAmounts: DynArray[uint256, 10], _proofs: DynArray[bytes32, 10]): nonpayable\n    def operators(_user: address, _operator: address) -> bool: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface EulerEarnFactory:\n    def isValidDeployment(_vault: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface EulerEvaultFactory:\n    def isProxy(_vault: address) -> bool: view\n\ninterface EulerVault:\n    def totalBorrows() -> uint256: view\n\nevent EulerDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent EulerWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent EulerFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent EulerRewardsAddrSet:\n    addr: address\n\nevent EulerLegoIdSet:\n    legoId: uint256\n\nevent EulerActivated:\n    isActivated: bool\n\n# euler\neulerRewards: public(address)\nEULER_EVAULT_FACTORY: public(immutable(address))\nEULER_EARN_FACTORY: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nLEGO_ACCESS_ABI: constant(String[64]) = \"toggleOperator(address,address)\"\n\n\n@deploy\ndef __init__(_evaultFactory: address, _earnFactory: address, _addyRegistry: address):\n    assert empty(address) not in [_evaultFactory, _earnFactory, _addyRegistry] # dev: invalid addrs\n    EULER_EVAULT_FACTORY = _evaultFactory\n    EULER_EARN_FACTORY = _earnFactory\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [EULER_EVAULT_FACTORY, EULER_EARN_FACTORY]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    eulerRewards: address = self.eulerRewards\n    if staticcall EulerRewardsDistributor(eulerRewards).operators(_user, self):\n        return empty(address), empty(String[64]), 0\n    else:\n        return eulerRewards, LEGO_ACCESS_ABI, 2\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidEulerVault(_vaultToken)\n\n\n@view\n@internal\ndef _isValidEulerVault(_vaultToken: address) -> bool:\n    return staticcall EulerEvaultFactory(EULER_EVAULT_FACTORY).isProxy(_vaultToken) or staticcall EulerEarnFactory(EULER_EARN_FACTORY).isValidDeployment(_vaultToken)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidEulerVault(_vaultToken):\n        asset = staticcall Erc4626Interface(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall Erc4626Interface(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall EulerVault(_vaultToken).totalBorrows()\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    vaultTokenAmountReceived: uint256 = extcall Erc4626Interface(_vault).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log EulerDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    transferVaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert transferVaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, transferVaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    vaultTokenAmount: uint256 = min(transferVaultTokenAmount, staticcall IERC20(_vaultToken).balanceOf(self))\n    assetAmountReceived: uint256 = extcall Erc4626Interface(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log EulerWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    eulerRewards: address = self.eulerRewards\n    assert eulerRewards != empty(address) # dev: no euler rewards addr set\n    if _rewardToken == empty(address):\n        return\n    extcall EulerRewardsDistributor(eulerRewards).claim([_user], [_rewardToken], [_rewardAmount], [_proof])\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setEulerRewardsAddr(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.eulerRewards = _addr\n    log EulerRewardsAddrSet(addr=_addr)\n    return True\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log EulerFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log EulerLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log EulerActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "b6d1219695ec12cdbf337628601e1cdb32a614bbe07fbf51fed1529999d2317b"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoEuler.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "275d7d7d0033859de2db1e5b59cc527640e5278b73755f3d43fbaee6bac36d24"
      },
      "args": "0000000000000000000000007f321498a801a191a93c840750ed637149ddf8d000000000000000000000000072bbdb652f2aec9056115644efccdd1986f51f150000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoFluid": {
      "address": "0xc4a864F5543D3CDB06D5F3419c18315f2cDe9675",
      "abi": [
        {
          "name": "FluidDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_RESOLVER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_fluidResolver",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoFluid.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface Erc4626Interface:\n    def redeem(_vaultTokenAmount: uint256, _recipient: address, _owner: address) -> uint256: nonpayable\n    def deposit(_assetAmount: uint256, _recipient: address) -> uint256: nonpayable\n    def convertToAssets(_vaultTokenAmount: uint256) -> uint256: view\n    def convertToShares(_assetAmount: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def asset() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface FluidLendingResolver:\n    def getAllFTokens() -> DynArray[address, MAX_FTOKENS]: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nevent FluidDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent FluidWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent FluidFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent FluidLegoIdSet:\n    legoId: uint256\n\nevent FluidActivated:\n    isActivated: bool\n\n# fluid\nFLUID_RESOLVER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nMAX_FTOKENS: constant(uint256) = 50\n\n\n@deploy\ndef __init__(_fluidResolver: address, _addyRegistry: address):\n    assert empty(address) not in [_fluidResolver, _addyRegistry] # dev: invalid addrs\n    FLUID_RESOLVER = _fluidResolver\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [FLUID_RESOLVER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidFToken(_vaultToken)\n\n\n@view\n@internal\ndef _isValidFToken(_fToken: address) -> bool:\n    fTokens: DynArray[address, MAX_FTOKENS] = staticcall FluidLendingResolver(FLUID_RESOLVER).getAllFTokens()\n    return _fToken in fTokens\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidFToken(_vaultToken):\n        asset = staticcall Erc4626Interface(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall Erc4626Interface(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return 0 # TODO\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    vaultTokenAmountReceived: uint256 = extcall Erc4626Interface(_vault).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log FluidDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    transferVaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert transferVaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, transferVaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    vaultTokenAmount: uint256 = min(transferVaultTokenAmount, staticcall IERC20(_vaultToken).balanceOf(self))\n    assetAmountReceived: uint256 = extcall Erc4626Interface(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log FluidWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log FluidFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log FluidLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log FluidActivated(isActivated=_shouldActivate)",
            "sha256sum": "dde64d8e43ca3d7bbacdcd8fff5d76193196d107b0d2bf3c3fdc2ae7f7c01580"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoFluid.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "fe5906d0f6b1b5f684ee35fcfbded8fbb1887734c9766c557c30b05766663a8d"
      },
      "args": "0000000000000000000000003af6fbec4a2fe517f56e402c65e3f4c3e18c1d860000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoMoonwell": {
      "address": "0x3890573c04A13d1D982104c7DaDb17F66cb1aE6c",
      "abi": [
        {
          "name": "MoonwellDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_COMPTROLLER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_moonwellComptroller",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoMoonwell.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface CompoundV2:\n    def redeem(_ctokenAmount: uint256) -> uint256: nonpayable\n    def mint(_amount: uint256) -> uint256: nonpayable\n    def exchangeRateStored() -> uint256: view\n    def totalBorrows() -> uint256: view\n    def totalSupply() -> uint256: view\n    def underlying() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface MoonwellComptroller:\n    def getAllMarkets() -> DynArray[address, MAX_MARKETS]: view\n    def claimReward(_holder: address): nonpayable\n    def rewardDistributor() -> address: view\n\ninterface MoonwellRewardDistributor:\n    def getOutstandingRewardsForUser(_user: address) -> DynArray[RewardWithMToken, MAX_MARKETS]: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface WethContract:\n    def deposit(): payable\n\nstruct RewardWithMToken:\n    mToken: address\n    rewards: DynArray[RewardInfo, MAX_ASSETS]\n\nstruct RewardInfo:\n    emissionToken: address\n    totalAmount: uint256\n    supplySide: uint256\n    borrowSide: uint256\n\nevent MoonwellDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MoonwellWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent MoonwellFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent MoonwellLegoIdSet:\n    legoId: uint256\n\nevent MoonwellActivated:\n    isActivated: bool\n\n# moonwell\nMOONWELL_COMPTROLLER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\nWETH: public(immutable(address))\n\nMAX_MARKETS: constant(uint256) = 50\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(_moonwellComptroller: address, _addyRegistry: address, _wethAddr: address):\n    assert empty(address) not in [_moonwellComptroller, _addyRegistry, _wethAddr] # dev: invalid addrs\n    MOONWELL_COMPTROLLER = _moonwellComptroller\n    ADDY_REGISTRY = _addyRegistry\n    WETH = _wethAddr\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MOONWELL_COMPTROLLER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidCToken(_vaultToken)\n\n\n@view\n@internal\ndef _isValidCToken(_cToken: address) -> bool:\n    compMarkets: DynArray[address, MAX_MARKETS] = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).getAllMarkets()\n    return _cToken in compMarkets\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidCToken(_vaultToken):\n        asset = staticcall CompoundV2(_vaultToken).underlying()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return _vaultTokenAmount * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return _assetAmount * (10 ** 18) // staticcall CompoundV2(_vaultToken).exchangeRateStored()\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV2(_vaultToken).totalSupply() * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV2(_vaultToken).totalBorrows()\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vault).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    assert extcall CompoundV2(_vault).mint(depositAmount) == 0 # dev: could not deposit into moonwell\n\n    # validate received vault tokens, transfer back to user\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vault).balanceOf(self) - preLegoVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n    assert extcall IERC20(_vault).transfer(_recipient, vaultTokenAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log MoonwellDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assert extcall CompoundV2(_vaultToken).redeem(max_value(uint256)) == 0 # dev: could not withdraw from moonwell\n\n    # when withdrawing weth, they give eth\n    if _asset == WETH:\n        extcall WethContract(WETH).deposit(value=self.balance)\n\n    # validate received asset , transfer back to user\n    assetAmountReceived: uint256 = staticcall IERC20(_asset).balanceOf(self) - preLegoBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n    assert extcall IERC20(_asset).transfer(_recipient, assetAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log MoonwellWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    extcall MoonwellComptroller(MOONWELL_COMPTROLLER).claimReward(_user)\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    rewardDistributor: address = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).rewardDistributor()\n    rewardsWithMToken: DynArray[RewardWithMToken, MAX_MARKETS] = staticcall MoonwellRewardDistributor(rewardDistributor).getOutstandingRewardsForUser(_user)\n    for i: uint256 in range(len(rewardsWithMToken), bound=MAX_MARKETS):\n        rewardsInfo: DynArray[RewardInfo, MAX_ASSETS] = rewardsWithMToken[i].rewards\n        for j: uint256 in range(len(rewardsInfo), bound=MAX_ASSETS):\n            if rewardsInfo[j].totalAmount > 0:\n                return True\n    return False\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid vault and/or asset\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log MoonwellFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log MoonwellLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log MoonwellActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "7f6a247c62ef24164abbed5c8a28dab9faa7fd747713e8f4cc43b57966165fbc"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoMoonwell.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "5bf2f0822a2b553b46fd71e655a4ee4901212327ef291a3bf89fc71370f57956"
      },
      "args": "000000000000000000000000fbb21d0380bee3312b33c4353c8936a0f13ef26c0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae0000000000000000000000004200000000000000000000000000000000000006"
    }
  }
}