{
  "contracts": {
    "AddyRegistry": {
      "address": "0x7BcD6d471D1A068012A79347C7a944d1Df01a1AE",
      "abi": [
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewPendingAddyCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdatePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisablePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddy",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyUpdate",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyDisable",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyId",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddy",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyInfo",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyDescription",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddyAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddyId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyToId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddy",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddyUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddyDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_ADDY_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_ADDY_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "REGISTRY_STR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setIsUserWalletOrAgent",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_isThing",
              "type": "bool"
            },
            {
              "name": "_setUserWalletMap",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewAddy",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddy",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingNewAddy",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAddyAddr",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddyUpdate",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAddyUpdate",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableAddyAddr",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddyDisable",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAddyDisable",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAddyChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAddyChangeDelayToMin",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserWallet",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgent",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minGovChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxGovChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_minRegistryChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/Registry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nstruct AddyInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddy:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddyPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddyConfirmed:\n    addr: indexed(address)\n    addyId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewPendingAddyCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdatePending:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdateConfirmed:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyUpdateCancelled:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisablePending:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisableConfirmed:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyDisableCancelled:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyChangeDelaySet:\n    delayBlocks: uint256\n    registry: String[28]\n\n# core registry\naddyInfo: public(HashMap[uint256, AddyInfo])\naddyToId: public(HashMap[address, uint256])\nnumAddys: public(uint256)\n\n# pending changes\npendingNewAddy: public(HashMap[address, PendingNewAddy]) # addr -> pending new addy\npendingAddyUpdate: public(HashMap[uint256, PendingAddyUpdate]) # addyId -> pending addy update\npendingAddyDisable: public(HashMap[uint256, PendingAddyDisable]) # addyId -> pending addy disable\naddyChangeDelay: public(uint256)\n\nMIN_ADDY_CHANGE_DELAY: public(immutable(uint256))\nMAX_ADDY_CHANGE_DELAY: public(immutable(uint256))\nREGISTRY_STR: public(immutable(String[28]))\n\n\n@deploy\ndef __init__(_minAddyChangeDelay: uint256, _maxAddyChangeDelay: uint256, _registryStr: String[28]):\n    assert _minAddyChangeDelay < _maxAddyChangeDelay # dev: invalid delay\n    MIN_ADDY_CHANGE_DELAY = _minAddyChangeDelay\n    MAX_ADDY_CHANGE_DELAY = _maxAddyChangeDelay\n\n    REGISTRY_STR = _registryStr\n\n    # start at 1 index\n    self.numAddys = 1\n\n\n############\n# New Addy #\n############\n\n\n@view\n@external\ndef isValidNewAddy(_addr: address) -> bool:\n    return self._isValidNewAddy(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddy(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addyToId[_addr] == 0\n\n\n@internal\ndef _registerNewAddy(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new address in the registry\n    @dev This function sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address to be registered\n    @param _description A short description of the address (max 64 characters)\n    @return True if the registration was successfully initiated, False if the address is invalid\n    \"\"\"\n    if not self._isValidNewAddy(_addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingNewAddy[_addr] = PendingNewAddy(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddyPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmNewAddy(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending address registration after the required delay period\n    @dev This function finalizes the registration by assigning an ID and storing the address info\n    @param _addr The address to confirm registration for\n    @return The assigned ID for the registered address, or 0 if confirmation fails\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    if not self._isValidNewAddy(_addr):\n        self.pendingNewAddy[_addr] = empty(PendingNewAddy) # clear pending\n        return 0\n\n    # register new addy\n    addyId: uint256 = self.numAddys\n    self.addyToId[_addr] = addyId\n    self.numAddys = addyId + 1\n    self.addyInfo[addyId] = AddyInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n\n    log NewAddyConfirmed(addr=_addr, addyId=addyId, description=data.description, registry=REGISTRY_STR)\n    return addyId\n\n\n@internal\ndef _cancelPendingNewAddy(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending address registration\n    @dev This function removes the pending registration and emits a cancellation event\n    @param _addr The address whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n    log NewPendingAddyCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n###############\n# Update Addy #\n###############\n\n\n@view\n@external\ndef isValidAddyUpdate(_addyId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddyUpdate(_addyId, _newAddr, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyUpdate(_addyId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    if not self._isValidNewAddy(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@internal\ndef _updateAddyAddr(_addyId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered address\n    @dev This function sets up a pending update that requires confirmation after a delay period\n    @param _addyId The ID of the address to update\n    @param _newAddr The new address to set\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyUpdate(_addyId, _newAddr, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyUpdate[_addyId] = PendingAddyUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyUpdatePending(addyId=_addyId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address update after the required delay period\n    @dev This function finalizes the update by updating the address info and version\n    @param _addyId The ID of the address to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyUpdate(_addyId, pendingData.newAddr, prevAddr):\n        self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = pendingData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[pendingData.newAddr] = _addyId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n\n    log AddyUpdateConfirmed(addyId=_addyId, description=data.description, newAddr=pendingData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address update\n    @dev This function removes the pending update and emits a cancellation event\n    @param _addyId The ID of the address whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyUpdateCancelled(addyId=_addyId, description=prevData.description, newAddr=pendingData.newAddr, prevAddr=prevData.addr, initiatedBlock=pendingData.initiatedBlock, confirmBlock=pendingData.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Disable Addy #\n################\n\n\n@view\n@external\ndef isValidAddyDisable(_addyId: uint256) -> bool:\n    return self._isValidAddyDisable(_addyId, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyDisable(_addyId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@internal\ndef _disableAddyAddr(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered address\n    @dev This function sets up a pending disable that requires confirmation after a delay period\n    @param _addyId The ID of the address to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyDisable(_addyId, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyDisable[_addyId] = PendingAddyDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyDisablePending(addyId=_addyId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address disable after the required delay period\n    @dev This function finalizes the disable by clearing the address and updating version\n    @param _addyId The ID of the address to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyDisable(_addyId, prevAddr):\n        self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n\n    log AddyDisableConfirmed(addyId=_addyId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address disable\n    @dev This function removes the pending disable and emits a cancellation event\n    @param _addyId The ID of the address whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    data: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyDisableCancelled(addyId=_addyId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Change Delay #\n################\n\n\n@internal\ndef _setAddyChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for address changes\n    @dev The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert _numBlocks >= MIN_ADDY_CHANGE_DELAY and _numBlocks <= MAX_ADDY_CHANGE_DELAY # dev: invalid delay\n    self.addyChangeDelay = _numBlocks\n    log AddyChangeDelaySet(delayBlocks=_numBlocks, registry=REGISTRY_STR)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidAddyAddr(_addr: address) -> bool:\n    return self._isValidAddyAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddyAddr(_addr: address) -> bool:\n    return self.addyToId[_addr] != 0\n\n\n@view\n@external\ndef isValidAddyId(_addyId: uint256) -> bool:\n    return self._isValidAddyId(_addyId)\n\n\n@view\n@internal\ndef _isValidAddyId(_addyId: uint256) -> bool:\n    return _addyId != 0 and _addyId < self.numAddys\n\n\n# addy getters\n\n\n@view\n@external\ndef getAddyId(_addr: address) -> uint256:\n    return self._getAddyId(_addr)\n\n\n@view\n@internal\ndef _getAddyId(_addr: address) -> uint256:\n    return self.addyToId[_addr]\n\n\n@view\n@external\ndef getAddy(_addyId: uint256) -> address:\n    return self._getAddy(_addyId)\n\n\n@view\n@internal\ndef _getAddy(_addyId: uint256) -> address:\n    return self.addyInfo[_addyId].addr\n\n\n@view\n@external\ndef getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self._getAddyInfo(_addyId)\n\n\n@view\n@internal\ndef _getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self.addyInfo[_addyId]\n\n\n@view\n@external\ndef getAddyDescription(_addyId: uint256) -> String[64]:\n    return self._getAddyDescription(_addyId)\n\n\n@view\n@internal\ndef _getAddyDescription(_addyId: uint256) -> String[64]:\n    return self.addyInfo[_addyId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumAddys() -> uint256:\n    return self._getNumAddys()\n\n\n@view\n@internal\ndef _getNumAddys() -> uint256:\n    return self.numAddys - 1\n\n\n@view\n@external\ndef getLastAddyAddr() -> address:\n    return self._getLastAddyAddr()\n\n\n@view\n@internal\ndef _getLastAddyAddr() -> address:\n    lastIndex: uint256 = self.numAddys - 1\n    return self.addyInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastAddyId() -> uint256:\n    return self._getLastAddyId()\n\n\n@view\n@internal\ndef _getLastAddyId() -> uint256:\n    return self.numAddys - 1\n",
            "sha256sum": "460d2db094c5b32c0788cc51d7e857c0e7e2f223f570937c46cb97599441b29e"
          },
          "contracts/core/registries/AddyRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\ninitializes: registry\n\nexports: gov.__interface__\nexports: registry.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Registry as registry\n\n# wallets / agents\nisUserWallet: public(HashMap[address, bool])\nisAgent: public(HashMap[address, bool])\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n    _minRegistryChangeDelay: uint256,\n    _maxRegistryChangeDelay: uint256,\n):\n    # initialize gov\n    gov.__init__(_initialGov, empty(address), _minGovChangeDelay, _maxGovChangeDelay)\n\n    # initialize registry\n    registry.__init__(_minRegistryChangeDelay, _maxRegistryChangeDelay, \"AddyRegistry.vy\")\n\n\n@external\ndef setIsUserWalletOrAgent(_addr: address, _isThing: bool, _setUserWalletMap: bool) -> bool:\n    assert registry._isValidAddyAddr(msg.sender) # dev: sender unknown\n    assert msg.sender == registry._getAddy(1) # dev: sender must be agent factory\n    if _addr == empty(address) or not _addr.is_contract: \n        return False\n    if _setUserWalletMap:\n        self.isUserWallet[_addr] = _isThing\n    else:\n        self.isAgent[_addr] = _isThing\n    return True\n\n\n############\n# New Addy #\n############\n\n\n@external\ndef registerNewAddy(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new address\n    @dev Only callable by governance. Sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address to register\n    @param _description A short description of the address (max 64 characters)\n    @return True if the registration was successfully initiated, False if the address is invalid\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._registerNewAddy(_addr, _description)\n\n\n@external\ndef confirmNewAddy(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending address registration after the required delay period\n    @dev Only callable by governance. Finalizes the registration by assigning an ID\n    @param _addr The address to confirm registration for\n    @return The assigned ID for the registered address, or 0 if confirmation fails\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmNewAddy(_addr)\n\n\n@external\ndef cancelPendingNewAddy(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending address registration\n    @dev Only callable by governance. Removes the pending registration and emits a cancellation event\n    @param _addr The address whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelPendingNewAddy(_addr)\n\n\n###############\n# Update Addy #\n###############\n\n\n@external\ndef updateAddyAddr(_addyId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered address\n    @dev Only callable by governance. Sets up a pending update that requires confirmation after a delay period\n    @param _addyId The ID of the address to update\n    @param _newAddr The new address to set\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._updateAddyAddr(_addyId, _newAddr)\n\n\n@external\ndef confirmAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address update after the required delay period\n    @dev Only callable by governance. Finalizes the update by updating the address info\n    @param _addyId The ID of the address to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmAddyUpdate(_addyId)\n\n\n@external\ndef cancelPendingAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address update\n    @dev Only callable by governance. Removes the pending update and emits a cancellation event\n    @param _addyId The ID of the address whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelPendingAddyUpdate(_addyId)\n\n\n################\n# Disable Addy #\n################\n\n\n@external\ndef disableAddyAddr(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered address\n    @dev Only callable by governance. Sets up a pending disable that requires confirmation after a delay period\n    @param _addyId The ID of the address to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._disableAddyAddr(_addyId)\n\n\n@external\ndef confirmAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address disable after the required delay period\n    @dev Only callable by governance. Finalizes the disable by clearing the address\n    @param _addyId The ID of the address to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmAddyDisable(_addyId)\n\n\n@external\ndef cancelPendingAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address disable\n    @dev Only callable by governance. Removes the pending disable and emits a cancellation event\n    @param _addyId The ID of the address whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelPendingAddyDisable(_addyId)\n\n\n################\n# Change Delay #\n################\n\n\n@external\ndef setAddyChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for address changes\n    @dev Only callable by governance. The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._setAddyChangeDelay(_numBlocks)\n\n\n@external\ndef setAddyChangeDelayToMin() -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._setAddyChangeDelay(registry.MIN_ADDY_CHANGE_DELAY)",
            "sha256sum": "77894bee6f9e3d1bb1ba2cc75d800df7d5e9859165b8af057ec18cc464f86e65"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/registries/AddyRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "b1e6d09dbd152641c55ee138c8f163779228a9cfe445e6e1d369aa7a48258cee"
      },
      "args": "0000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "UserWalletTemplate": {
      "address": "0xe43D5bD11a2A6A9348EFC516ad9Ac3D32164A5A0",
      "abi": [
        {
          "name": "UserWalletDeposit",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletWithdrawal",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundVaultTokenAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletSwap",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "swapAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "toAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletBorrow",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "borrowAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "borrowAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletRepayDebt",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "paymentAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "paymentAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "remainingDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletLiquidityAdded",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "liqAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletLiquidityRemoved",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": false
            },
            {
              "name": "removedAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "removedAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "refundedLpAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletFundsTransferred",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletRewardsClaimed",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": false
            },
            {
              "name": "market",
              "type": "address",
              "indexed": false
            },
            {
              "name": "rewardToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "rewardAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "proof",
              "type": "bytes32",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletEthConvertedToWeth",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "paidEth",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "weth",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletWethConvertedToEth",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "weth",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletSubscriptionPaid",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "paidThroughBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTransactionFeePaid",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "protocolRecipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "protocolAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ambassadorRecipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ambassadorAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "fee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "action",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTrialFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountRecovered",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "remainingAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletNftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canBeAmbassador",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "clawBackTrialFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "migrateWalletOut",
          "inputs": [
            {
              "name": "_newWallet",
              "type": "address"
            },
            {
              "name": "_assetsToMigrate",
              "type": "address[]"
            },
            {
              "name": "_whitelistToMigrate",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "walletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsAsset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsInitialAmount",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "wethAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_walletConfig",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_trialFundsAsset",
              "type": "address"
            },
            {
              "name": "_trialFundsInitialAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "interfaces/LegoCredit.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (address, uint256, uint256):\n    ...\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (address, uint256, uint256, uint256):\n    ...\n",
            "sha256sum": "d7579ab6500e6022fa9cb561479c40d062438d29e002dcc5f66036eea7dc0856"
          },
          "interfaces/UserWalletInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n# struct SwapInstruction:\n#     legoId: uint256\n#     amountIn: uint256\n#     minAmountOut: uint256\n#     tokenPath: DynArray[address, 5]\n#     poolPath: DynArray[address, 5 - 1]\n\n\n# @external\n# def swapTokens(_swapInstructions: DynArray[SwapInstruction, 5]) -> (uint256, uint256, uint256):\n#     ...\n\n\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    ...\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    ...\n\n\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    ...\n\n\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    ...\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    ...\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    ...\n",
            "sha256sum": "b6f85ddff061e77069cceb9d110c05c679a6ea34b68f3ff69c95c1b07d83c453"
          },
          "contracts/core/templates/UserWalletTemplate.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n# pragma optimize codesize\n\nimplements: UserWalletInterface\nfrom interfaces import LegoDex\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\nfrom interfaces import LegoCredit\nfrom interfaces import UserWalletInterface\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC721\n\ninterface WalletConfig:\n    def finishMigrationIn(_whitelistToMigrate: DynArray[address, MAX_MIGRATION_WHITELIST], _assetsMigrated: DynArray[address, MAX_MIGRATION_ASSETS], _vaultTokensMigrated: DynArray[address, MAX_MIGRATION_ASSETS]) -> bool: nonpayable\n    def handleSubscriptionsAndPermissions(_agent: address, _action: ActionType, _assets: DynArray[address, MAX_ASSETS], _legoIds: DynArray[uint256, MAX_LEGOS], _cd: CoreData) -> (SubPaymentInfo, SubPaymentInfo): nonpayable\n    def updateYieldTrackingOnWithdrawal(_vaultToken: address, _vaultTokenAmountBurned: uint256, _asset: address, _assetAmountReceived: uint256, _legoRegistry: address) -> uint256: nonpayable\n    def updateYieldTrackingOnDeposit(_asset: address, _vaultToken: address, _vaultTokenAmountReceived: uint256, _assetAmountDeposited: uint256, _legoRegistry: address): nonpayable\n    def getAvailableTxAmount(_asset: address, _wantedAmount: uint256, _shouldCheckTrialFunds: bool, _cd: CoreData = empty(CoreData)) -> uint256: view\n    def updateYieldTrackingOnSwap(_tokenIn: address, _tokenOut: address, _tokenOutAmount: uint256, _legoRegistry: address): nonpayable\n    def updateYieldTrackingOnEntry(_asset: address, _amount: uint256, _legoRegistry: address): nonpayable\n    def updateYieldTrackingOnExit(_asset: address, _legoRegistry: address): nonpayable\n    def canTransferToRecipient(_recipient: address) -> bool: view\n    def isVaultToken(_asset: address) -> bool: view\n    def canWalletBeAmbassador() -> bool: view\n    def getProceedsAddr() -> address: view\n    def myAmbassador() -> address: view\n    def owner() -> address: view\n\ninterface LegoRegistry:\n    def getVaultTokensForUser(_user: address, _asset: address) -> DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER]: view\n    def getUnderlyingForUser(_user: address, _asset: address) -> uint256: view\n    def getUnderlyingAsset(_vaultToken: address) -> address: view\n    def getLegoAddr(_legoId: uint256) -> address: view\n\ninterface AgentFactory:\n    def payAmbassadorYieldBonus(_ambassador: address, _asset: address, _amount: uint256) -> bool: nonpayable\n    def agentBlacklist(_agentAddr: address) -> bool: view\n    def isUserWallet(_wallet: address) -> bool: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getEthUsdValue(_amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface WethContract:\n    def withdraw(_amount: uint256): nonpayable\n    def deposit(): payable\n\ninterface PriceSheets:\n    def getTransactionFeeDataWithAmbassadorRatio(_user: address, _action: ActionType) -> (uint256, address, uint256): view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface UserWallet:\n    def walletConfig() -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct CoreData:\n    owner: address\n    wallet: address\n    walletConfig: address\n    addyRegistry: address\n    agentFactory: address\n    legoRegistry: address\n    priceSheets: address\n    oracleRegistry: address\n    trialFundsAsset: address\n    trialFundsInitialAmount: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct VaultTokenInfo:\n    legoId: uint256\n    vaultToken: address\n\nevent UserWalletDeposit:\n    signer: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    vaultTokenAmountReceived: uint256\n    refundAssetAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletWithdrawal:\n    signer: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    vaultTokenAmountBurned: uint256\n    refundVaultTokenAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletSwap:\n    signer: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    swapAmount: uint256\n    toAmount: uint256\n    refundAssetAmount: uint256\n    usdValue: uint256\n    numTokens: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletBorrow:\n    signer: indexed(address)\n    borrowAsset: indexed(address)\n    borrowAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletRepayDebt:\n    signer: indexed(address)\n    paymentAsset: indexed(address)\n    paymentAmount: uint256\n    usdValue: uint256\n    remainingDebt: uint256\n    legoId: uint256\n    legoAddr: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletLiquidityAdded:\n    signer: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    liqAmountA: uint256\n    liqAmountB: uint256\n    liquidityAdded: uint256\n    pool: address\n    usdValue: uint256\n    refundAssetAmountA: uint256\n    refundAssetAmountB: uint256\n    nftTokenId: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletLiquidityRemoved:\n    signer: indexed(address)\n    tokenA: indexed(address)\n    tokenB: address\n    removedAmountA: uint256\n    removedAmountB: uint256\n    usdValue: uint256\n    isDepleted: bool\n    liquidityRemoved: uint256\n    lpToken: indexed(address)\n    refundedLpAmount: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletFundsTransferred:\n    signer: indexed(address)\n    recipient: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    usdValue: uint256\n    isSignerAgent: bool\n\nevent UserWalletRewardsClaimed:\n    signer: address\n    market: address\n    rewardToken: address\n    rewardAmount: uint256\n    usdValue: uint256\n    proof: bytes32\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletEthConvertedToWeth:\n    signer: indexed(address)\n    amount: uint256\n    paidEth: uint256\n    weth: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletWethConvertedToEth:\n    signer: indexed(address)\n    amount: uint256\n    weth: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletSubscriptionPaid:\n    recipient: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    isAgent: bool\n\nevent UserWalletTransactionFeePaid:\n    asset: indexed(address)\n    protocolRecipient: indexed(address)\n    protocolAmount: uint256\n    ambassadorRecipient: indexed(address)\n    ambassadorAmount: uint256\n    fee: uint256\n    action: ActionType\n\nevent UserWalletTrialFundsRecovered:\n    asset: indexed(address)\n    amountRecovered: uint256\n    remainingAmount: uint256\n\nevent UserWalletNftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    owner: indexed(address)\n\n# core \nwalletConfig: public(address)\n\n# trial funds info\ntrialFundsAsset: public(address)\ntrialFundsInitialAmount: public(uint256)\n\n# config\nwethAddr: public(address)\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\nLEGO_REGISTRY_ID: constant(uint256) = 2\nPRICE_SHEETS_ID: constant(uint256) = 3\nORACLE_REGISTRY_ID: constant(uint256) = 4\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_ASSETS: constant(uint256) = 25\nMAX_LEGOS: constant(uint256) = 20\nMAX_VAULTS_FOR_USER: constant(uint256) = 30\nMAX_MIGRATION_ASSETS: constant(uint256) = 40\nMAX_MIGRATION_WHITELIST: constant(uint256) = 20\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UnderscoreErc721\"\nAPI_VERSION: constant(String[28]) = \"0.0.3\"\n\nADDY_REGISTRY: public(immutable(address))\n\n\n@deploy\ndef __init__(\n    _walletConfig: address,\n    _addyRegistry: address,\n    _wethAddr: address,\n    _trialFundsAsset: address,\n    _trialFundsInitialAmount: uint256,\n):\n    \"\"\"\n    @notice Initializes a new UserWallet contract with required configuration parameters\n    @dev Sets up the wallet with its configuration, registry addresses, and optional trial funds\n    @param _walletConfig Address of the wallet configuration contract that manages permissions and settings\n    @param _addyRegistry Address of the registry contract that stores core protocol addresses\n    @param _wethAddr Address of the WETH contract for ETH wrapping/unwrapping functionality\n    @param _trialFundsAsset Address of the asset used for trial funds (can be empty)\n    @param _trialFundsInitialAmount Initial amount of trial funds to be held (can be 0)\n    \"\"\"\n    assert empty(address) not in [_walletConfig, _addyRegistry, _wethAddr] # dev: invalid addrs\n    self.walletConfig = _walletConfig\n    self.wethAddr = _wethAddr\n    ADDY_REGISTRY = _addyRegistry\n\n    # trial funds info\n    if _trialFundsAsset != empty(address) and _trialFundsInitialAmount != 0:   \n        self.trialFundsAsset = _trialFundsAsset\n        self.trialFundsInitialAmount = _trialFundsInitialAmount\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    \"\"\"\n    @notice Returns the current API version of the contract\n    @dev Returns a constant string representing the contract version\n    @return String[28] The API version string\n    \"\"\"\n    return API_VERSION\n\n\n@view\n@external\ndef canBeAmbassador() -> bool:\n    \"\"\"\n    @notice Checks if the current wallet can be an ambassador\n    @dev Returns True if the wallet is a valid ambassador, False otherwise\n    @return bool True if the wallet can be an ambassador, False otherwise\n    \"\"\"\n    return staticcall WalletConfig(self.walletConfig).canWalletBeAmbassador()\n\n\n###########\n# Deposit #\n###########\n\n\n@nonreentrant\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    \"\"\"\n    @notice Deposits tokens into a specified lego integration and vault\n    @param _legoId The ID of the lego to use for deposit\n    @param _asset The address of the token to deposit\n    @param _vault The target vault address\n    @param _amount The amount to deposit (defaults to max)\n    @return uint256 The amount of assets deposited\n    @return address The vault token address\n    @return uint256 The amount of vault tokens received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.DEPOSIT, [_asset], [_legoId], cd)\n    return self._depositTokens(msg.sender, _legoId, _asset, _vault, _amount, isSignerAgent, cd)\n\n\n@internal\ndef _depositTokens(\n    _signer: address,\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256,\n    _isSignerAgent: bool,\n    _cd: CoreData,\n) -> (uint256, address, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # finalize amount\n    amount: uint256 = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_asset, _amount, False, _cd)\n    assert extcall IERC20(_asset).approve(legoAddr, amount, default_return_value=True) # dev: approval failed\n\n    # deposit into lego partner\n    assetAmountDeposited: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    refundAssetAmount: uint256 = 0\n    usdValue: uint256 = 0\n    assetAmountDeposited, vaultToken, vaultTokenAmountReceived, refundAssetAmount, usdValue = extcall LegoYield(legoAddr).depositTokens(_asset, amount, _vault, self)\n    assert extcall IERC20(_asset).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # update yield tracking\n    extcall WalletConfig(_cd.walletConfig).updateYieldTrackingOnDeposit(_asset, vaultToken, vaultTokenAmountReceived, assetAmountDeposited, _cd.legoRegistry)\n\n    log UserWalletDeposit(signer=_signer, asset=_asset, vaultToken=vaultToken, assetAmountDeposited=assetAmountDeposited, vaultTokenAmountReceived=vaultTokenAmountReceived, refundAssetAmount=refundAssetAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return assetAmountDeposited, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@nonreentrant\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    \"\"\"\n    @notice Withdraws tokens from a specified lego integration and vault\n    @param _legoId The ID of the lego to use for withdrawal\n    @param _asset The address of the token to withdraw\n    @param _vaultToken The vault token address\n    @param _vaultTokenAmount The amount of vault tokens to withdraw (defaults to max)\n    @return uint256 The amount of assets received\n    @return uint256 The amount of vault tokens burned\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.WITHDRAWAL, [_asset], [_legoId], cd)\n    return self._withdrawTokens(msg.sender, _legoId, _asset, _vaultToken, _vaultTokenAmount, isSignerAgent, True, cd)\n\n\n@internal\ndef _withdrawTokens(\n    _signer: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256,\n    _isSignerAgent: bool,\n    _shouldHandleFees: bool,\n    _cd: CoreData,\n) -> (uint256, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # finalize amount, this will look at vault token balance (not always 1:1 with underlying asset)\n    withdrawAmount: uint256 = _vaultTokenAmount\n    if _vaultToken != empty(address):\n        withdrawAmount = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_vaultToken, _vaultTokenAmount, False, _cd)\n\n        # some vault tokens require max value approval (comp v3)\n        assert extcall IERC20(_vaultToken).approve(legoAddr, max_value(uint256), default_return_value=True) # dev: approval failed\n\n    assert withdrawAmount != 0 # dev: nothing to withdraw\n\n    # withdraw from lego partner\n    assetAmountReceived: uint256 = 0\n    vaultTokenAmountBurned: uint256 = 0\n    refundVaultTokenAmount: uint256 = 0\n    usdValue: uint256 = 0\n    assetAmountReceived, vaultTokenAmountBurned, refundVaultTokenAmount, usdValue = extcall LegoYield(legoAddr).withdrawTokens(_asset, withdrawAmount, _vaultToken, self)\n\n    # zero out approvals\n    if _vaultToken != empty(address):\n        assert extcall IERC20(_vaultToken).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # handle yield profit\n    assetProfitAmount: uint256 = extcall WalletConfig(_cd.walletConfig).updateYieldTrackingOnWithdrawal(_vaultToken, vaultTokenAmountBurned, _asset, assetAmountReceived, _cd.legoRegistry)\n    if _shouldHandleFees and assetProfitAmount != 0:\n        sentProfit: uint256 = self._handleTransactionFees(ActionType.WITHDRAWAL, _asset, assetProfitAmount, _cd.priceSheets, _cd.agentFactory)\n        assetAmountReceived -= sentProfit\n\n    log UserWalletWithdrawal(signer=_signer, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, vaultTokenAmountBurned=vaultTokenAmountBurned, refundVaultTokenAmount=refundVaultTokenAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return assetAmountReceived, vaultTokenAmountBurned, usdValue\n\n\n#############\n# Rebalance #\n#############\n\n\n@nonreentrant\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    \"\"\"\n    @notice Withdraws tokens from one lego and deposits them into another (always same asset)\n    @param _fromLegoId The ID of the source lego\n    @param _fromAsset The address of the token to rebalance\n    @param _fromVaultToken The source vault token address\n    @param _toLegoId The ID of the destination lego\n    @param _toVault The destination vault address\n    @param _fromVaultTokenAmount The vault token amount to rebalance (defaults to max)\n    @return uint256 The amount of assets deposited in the destination vault\n    @return address The destination vault token address\n    @return uint256 The amount of destination vault tokens received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REBALANCE, [_fromAsset], [_fromLegoId, _toLegoId], cd)\n\n    # withdraw from the first lego\n    assetAmountReceived: uint256 = 0\n    na: uint256 = 0\n    withdrawUsdValue: uint256 = 0\n    assetAmountReceived, na, withdrawUsdValue = self._withdrawTokens(msg.sender, _fromLegoId, _fromAsset, _fromVaultToken, _fromVaultTokenAmount, isSignerAgent, True, cd)\n\n    # deposit the received assets into the second lego\n    assetAmountDeposited: uint256 = 0\n    newVaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    depositUsdValue: uint256 = 0\n    assetAmountDeposited, newVaultToken, vaultTokenAmountReceived, depositUsdValue = self._depositTokens(msg.sender, _toLegoId, _fromAsset, _toVault, assetAmountReceived, isSignerAgent, cd)\n\n    usdValue: uint256 = max(withdrawUsdValue, depositUsdValue)\n    return assetAmountDeposited, newVaultToken, vaultTokenAmountReceived, usdValue\n\n\n########\n# Swap #\n########\n\n\n@nonreentrant\n@external\ndef swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256):\n    \"\"\"\n    @notice Swaps tokens between lego integrations\n    @param _swapInstructions The instructions for the swaps\n    @return uint256 The amount of assets deposited\n    @return uint256 The amount of assets received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    numSwapInstructions: uint256 = len(_swapInstructions)\n    assert numSwapInstructions != 0 # dev: no swaps\n\n    cd: CoreData = self._getCoreData()\n\n    # get high level swap info to check permissions\n    tokenIn: address = empty(address)\n    tokenOut: address = empty(address)\n    initialAmountIn: uint256 = 0\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    tokenIn, tokenOut, initialAmountIn, legoIds = self._getHighLevelSwapInfo(numSwapInstructions, _swapInstructions, cd)\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.SWAP, [tokenIn, tokenOut], legoIds, cd)\n\n    # check if swap token is trial funds asset\n    isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(tokenIn, cd.trialFundsAsset, cd.legoRegistry)\n\n    # perform swap instructions\n    amountIn: uint256 = initialAmountIn\n    lastTokenOut: address = empty(address)\n    lastTokenOutAmount: uint256 = 0\n    lastUsdValue: uint256 = 0\n    for j: uint256 in range(numSwapInstructions, bound=MAX_SWAP_INSTRUCTIONS):\n        i: SwapInstruction = _swapInstructions[j]\n\n        # from lego to lego, must follow the same token path\n        if lastTokenOut != empty(address):\n            newTokenIn: address = i.tokenPath[0]\n            assert lastTokenOut == newTokenIn # dev: invalid token path\n            amountIn = min(lastTokenOutAmount, staticcall IERC20(newTokenIn).balanceOf(self))\n\n        lastTokenOut, lastTokenOutAmount, lastUsdValue = self._performSwapInstruction(i.legoId, amountIn, i.minAmountOut, i.tokenPath, i.poolPath, msg.sender, isSignerAgent, cd.legoRegistry, cd.oracleRegistry)\n\n    # make sure they still have enough trial funds\n    self._checkTrialFundsPostTx(isTrialFundsVaultToken, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n\n     # yield tracking\n    extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnSwap(tokenIn, lastTokenOut, lastTokenOutAmount, cd.legoRegistry)\n\n    # handle tx fees\n    if isSignerAgent:\n        self._handleTransactionFees(ActionType.SWAP, lastTokenOut, lastTokenOutAmount, cd.priceSheets, cd.agentFactory)\n\n    return initialAmountIn, lastTokenOutAmount, lastUsdValue\n\n\n@internal\ndef _performSwapInstruction(\n    _legoId: uint256,\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _signer: address,\n    _isSignerAgent: bool,\n    _legoRegistry: address,\n    _oracleRegistry: address,\n) -> (address, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # get token in and token out\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[len(_tokenPath) - 1]\n\n    # approve token in\n    assert extcall IERC20(tokenIn).approve(legoAddr, _amountIn, default_return_value=True) # dev: approval failed\n\n    # swap assets via lego partner\n    tokenInAmount: uint256 = 0\n    tokenOutAmount: uint256 = 0\n    refundTokenInAmount: uint256 = 0\n    usdValue: uint256 = 0\n    tokenInAmount, tokenOutAmount, refundTokenInAmount, usdValue = extcall LegoDex(legoAddr).swapTokens(_amountIn, _minAmountOut, _tokenPath, _poolPath, self, _oracleRegistry)\n\n    # reset approvals\n    assert extcall IERC20(tokenIn).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log UserWalletSwap(signer=_signer, tokenIn=tokenIn, tokenOut=tokenOut, swapAmount=tokenInAmount, toAmount=tokenOutAmount, refundAssetAmount=refundTokenInAmount, usdValue=usdValue, numTokens=len(_tokenPath), legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return tokenOut, tokenOutAmount, usdValue\n\n\n@view\n@internal\ndef _getHighLevelSwapInfo(\n    _numSwapInstructions: uint256,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _cd: CoreData,\n) -> (address, address, uint256, DynArray[uint256, MAX_LEGOS]):   \n    firstRoutePath: DynArray[address, MAX_TOKEN_PATH] = _swapInstructions[0].tokenPath\n    firstRouteNumTokens: uint256 = len(firstRoutePath)\n    assert firstRouteNumTokens >= 2 # dev: invalid token path\n\n    # finalize token in and token out\n    tokenIn: address = firstRoutePath[0]\n    tokenOut: address = empty(address)\n    if _numSwapInstructions == 1:\n        tokenOut = firstRoutePath[firstRouteNumTokens - 1]\n\n    else:\n        lastRoutePath: DynArray[address, MAX_TOKEN_PATH] = _swapInstructions[_numSwapInstructions - 1].tokenPath\n        lastRouteNumTokens: uint256 = len(lastRoutePath)\n        assert lastRouteNumTokens >= 2 # dev: invalid token path\n        tokenOut = lastRoutePath[lastRouteNumTokens - 1]\n\n    assert empty(address) not in [tokenIn, tokenOut] # dev: invalid token path\n\n    # get lego ids\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    for i: uint256 in range(_numSwapInstructions, bound=MAX_SWAP_INSTRUCTIONS):\n        legoId: uint256 = _swapInstructions[i].legoId\n        if legoId not in legoIds:\n            legoIds.append(legoId)\n\n    # finalize amount in\n    amountIn: uint256 = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(tokenIn, _swapInstructions[0].amountIn, True, _cd)\n\n    return tokenIn, tokenOut, amountIn, legoIds\n\n\n##################\n# Borrow + Repay #\n##################\n\n\n# borrow\n\n\n@nonreentrant\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    \"\"\"\n    @notice Borrows an asset from a lego integration\n    @param _legoId The ID of the lego to borrow from\n    @param _borrowAsset The address of the asset to borrow\n    @param _amount The amount of the asset to borrow\n    @return address The address of the asset borrowed\n    @return uint256 The amount of the asset borrowed\n    @return uint256 The usd value of the borrowing\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.BORROW, [_borrowAsset], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego can perform this action\n    self._checkLegoAccessForAction(legoAddr)\n\n    # borrow via lego partner\n    borrowAsset: address = empty(address)\n    borrowAmount: uint256 = 0\n    usdValue: uint256 = 0\n    borrowAsset, borrowAmount, usdValue = extcall LegoCredit(legoAddr).borrow(_borrowAsset, _amount, self, cd.oracleRegistry)\n\n    log UserWalletBorrow(signer=msg.sender, borrowAsset=borrowAsset, borrowAmount=borrowAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return borrowAsset, borrowAmount, usdValue\n\n\n# repay debt\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    \"\"\"\n    @notice Repays debt for a lego integration\n    @param _legoId The ID of the lego to repay debt for\n    @param _paymentAsset The address of the asset to use for repayment\n    @param _paymentAmount The amount of the asset to use for repayment\n    @return address The address of the asset used for repayment\n    @return uint256 The amount of the asset used for repayment\n    @return uint256 The usd value of the repayment\n    @return uint256 The remaining debt\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REPAY, [_paymentAsset], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego can perform this action\n    self._checkLegoAccessForAction(legoAddr)\n\n    # finalize amount\n    paymentAmount: uint256 = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_paymentAsset, _paymentAmount, True, cd)\n\n    # check if payment asset is trial funds asset\n    isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(_paymentAsset, cd.trialFundsAsset, cd.legoRegistry)\n\n    # repay debt via lego partner\n    paymentAsset: address = empty(address)\n    usdValue: uint256 = 0\n    remainingDebt: uint256 = 0\n    assert extcall IERC20(_paymentAsset).approve(legoAddr, paymentAmount, default_return_value=True) # dev: approval failed\n    paymentAsset, paymentAmount, usdValue, remainingDebt = extcall LegoCredit(legoAddr).repayDebt(_paymentAsset, paymentAmount, self, cd.oracleRegistry)\n    assert extcall IERC20(_paymentAsset).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # make sure they still have enough trial funds\n    self._checkTrialFundsPostTx(isTrialFundsVaultToken, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n\n    # yield tracking -- paying back debt with vault token\n    extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnExit(_paymentAsset, cd.legoRegistry)\n\n    log UserWalletRepayDebt(signer=msg.sender, paymentAsset=paymentAsset, paymentAmount=paymentAmount, usdValue=usdValue, remainingDebt=remainingDebt, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return paymentAsset, paymentAmount, usdValue, remainingDebt\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    \"\"\"\n    @notice Claims rewards from a lego integration\n    @param _legoId The lego ID to claim rewards from\n    @param _market The market to claim rewards from\n    @param _rewardToken The reward token to claim\n    @param _rewardAmount The reward amount to claim\n    @param _proof The proof to verify the rewards\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CLAIM_REWARDS, [_rewardToken], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego has access to claim rewards\n    self._checkLegoAccessForAction(legoAddr)\n\n    # pre reward balance\n    preRewardBalance: uint256 = 0\n    if _rewardToken != empty(address):\n        preRewardBalance = staticcall IERC20(_rewardToken).balanceOf(self)\n\n    # claim rewards\n    extcall LegoCommon(legoAddr).claimRewards(self, _market, _rewardToken, _rewardAmount, _proof)\n\n    # post reward balance\n    postRewardBalance: uint256 = 0\n    if _rewardToken != empty(address):\n        postRewardBalance = staticcall IERC20(_rewardToken).balanceOf(self)\n    rewardAmount: uint256 = postRewardBalance - preRewardBalance\n\n    # handle tx fees\n    if isSignerAgent:\n        self._handleTransactionFees(ActionType.CLAIM_REWARDS, _rewardToken, rewardAmount, cd.priceSheets, cd.agentFactory)\n\n    usdValue: uint256 = 0\n    if rewardAmount != 0:\n        usdValue = staticcall OracleRegistry(cd.oracleRegistry).getUsdValue(_rewardToken, rewardAmount)\n    log UserWalletRewardsClaimed(signer=msg.sender, market=_market, rewardToken=_rewardToken, rewardAmount=rewardAmount, usdValue=usdValue, proof=_proof, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    \"\"\"\n    @notice Adds liquidity to a pool\n    @param _legoId The ID of the lego to use for adding liquidity\n    @param _nftAddr The address of the NFT token contract\n    @param _nftTokenId The ID of the NFT token to use for adding liquidity\n    @param _pool The address of the pool to add liquidity to\n    @param _tokenA The address of the first token to add liquidity\n    @param _tokenB The address of the second token to add liquidity\n    @param _amountA The amount of the first token to add liquidity\n    @param _amountB The amount of the second token to add liquidity\n    @param _tickLower The lower tick of the liquidity range\n    @param _tickUpper The upper tick of the liquidity range\n    @param _minAmountA The minimum amount of the first token to add liquidity\n    @param _minAmountB The minimum amount of the second token to add liquidity\n    @param _minLpAmount The minimum amount of lp token amount to receive\n    @return uint256 The amount of liquidity added\n    @return uint256 The amount of the first token added\n    @return uint256 The amount of the second token added\n    @return uint256 The usd value of the liquidity added\n    @return uint256 The ID of the NFT token used for adding liquidity\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.ADD_LIQ, [_tokenA, _tokenB], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # token a\n    amountA: uint256 = 0\n    isTrialFundsVaultTokenA: bool = False\n    if _amountA != 0:\n        amountA = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_tokenA, _amountA, True, cd)\n        assert extcall IERC20(_tokenA).approve(legoAddr, amountA, default_return_value=True) # dev: approval failed\n        isTrialFundsVaultTokenA = self._isTrialFundsVaultToken(_tokenA, cd.trialFundsAsset, cd.legoRegistry)\n\n    # token b\n    amountB: uint256 = 0\n    isTrialFundsVaultTokenB: bool = False\n    if _amountB != 0:\n        amountB = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_tokenB, _amountB, True, cd)\n        assert extcall IERC20(_tokenB).approve(legoAddr, amountB, default_return_value=True) # dev: approval failed\n        isTrialFundsVaultTokenB = self._isTrialFundsVaultToken(_tokenB, cd.trialFundsAsset, cd.legoRegistry)\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # add liquidity via lego partner\n    liquidityAdded: uint256 = 0\n    liqAmountA: uint256 = 0\n    liqAmountB: uint256 = 0\n    usdValue: uint256 = 0\n    refundAssetAmountA: uint256 = 0\n    refundAssetAmountB: uint256 = 0\n    nftTokenId: uint256 = 0\n    liquidityAdded, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, nftTokenId = extcall LegoDex(legoAddr).addLiquidity(_nftTokenId, _pool, _tokenA, _tokenB, _tickLower, _tickUpper, amountA, amountB, _minAmountA, _minAmountB, _minLpAmount, self, cd.oracleRegistry)\n\n    # validate the nft came back\n    if hasNftLiqPosition:\n        assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n\n    # token a\n    self._checkTrialFundsPostTx(isTrialFundsVaultTokenA, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n    if amountA != 0:\n        assert extcall IERC20(_tokenA).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n        extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnExit(_tokenA, cd.legoRegistry)\n\n    # token b\n    self._checkTrialFundsPostTx(isTrialFundsVaultTokenB, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n    if amountB != 0:\n        assert extcall IERC20(_tokenB).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n        extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnExit(_tokenB, cd.legoRegistry)\n\n    log UserWalletLiquidityAdded(signer=msg.sender, tokenA=_tokenA, tokenB=_tokenB, liqAmountA=liqAmountA, liqAmountB=liqAmountB, liquidityAdded=liquidityAdded, pool=_pool, usdValue=usdValue, refundAssetAmountA=refundAssetAmountA, refundAssetAmountB=refundAssetAmountB, nftTokenId=nftTokenId, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return liquidityAdded, liqAmountA, liqAmountB, usdValue, nftTokenId\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    \"\"\"\n    @notice Removes liquidity from a pool\n    @param _legoId The ID of the lego to use for removing liquidity\n    @param _nftAddr The address of the NFT token contract\n    @param _nftTokenId The ID of the NFT token to use for removing liquidity\n    @param _pool The address of the pool to remove liquidity from\n    @param _tokenA The address of the first token to remove liquidity\n    @param _tokenB The address of the second token to remove liquidity\n    @param _liqToRemove The amount of liquidity to remove\n    @param _minAmountA The minimum amount of the first token to remove liquidity\n    @param _minAmountB The minimum amount of the second token to remove liquidity\n    @return uint256 The amount of the first token removed\n    @return uint256 The amount of the second token removed\n    @return uint256 The usd value of the liquidity removed\n    @return bool True if the liquidity moved to lego contract was depleted, false otherwise\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REMOVE_LIQ, [_tokenA, _tokenB], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    lpToken: address = empty(address)\n    liqToRemove: uint256 = _liqToRemove\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # handle lp token\n    else:\n        lpToken = staticcall LegoDex(legoAddr).getLpToken(_pool)\n        liqToRemove = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(lpToken, liqToRemove, False, cd)\n        assert extcall IERC20(lpToken).approve(legoAddr, liqToRemove, default_return_value=True) # dev: approval failed\n\n    # remove liquidity via lego partner\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    usdValue: uint256 = 0\n    liquidityRemoved: uint256 = 0\n    refundedLpAmount: uint256 = 0\n    isDepleted: bool = False\n    amountA, amountB, usdValue, liquidityRemoved, refundedLpAmount, isDepleted = extcall LegoDex(legoAddr).removeLiquidity(_nftTokenId, _pool, _tokenA, _tokenB, lpToken, liqToRemove, _minAmountA, _minAmountB, self, cd.oracleRegistry)\n\n    # validate the nft came back, reset lp token approvals\n    if hasNftLiqPosition:\n        if not isDepleted:\n            assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n    else:\n        assert extcall IERC20(lpToken).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # yield tracking -- if vault tokens are what is removed from liquidity\n    extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnEntry(_tokenA, amountA, cd.legoRegistry)\n    extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnEntry(_tokenB, amountB, cd.legoRegistry)\n\n    log UserWalletLiquidityRemoved(signer=msg.sender, tokenA=_tokenA, tokenB=_tokenB, removedAmountA=amountA, removedAmountB=amountB, usdValue=usdValue, isDepleted=isDepleted, liquidityRemoved=liquidityRemoved, lpToken=lpToken, refundedLpAmount=refundedLpAmount, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return amountA, amountB, usdValue, isDepleted\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    \"\"\"\n    @notice Transfers funds to a specified recipient\n    @dev Handles both ETH and token transfers with optional amount specification\n    @param _recipient The address to receive the funds\n    @param _amount The amount to transfer (defaults to max)\n    @param _asset The token address (empty for ETH)\n    @return uint256 The amount of funds transferred\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.TRANSFER, [_asset], [], cd)\n    return self._transferFunds(msg.sender, _recipient, _amount, _asset, isSignerAgent, cd)\n\n\n@internal\ndef _transferFunds(\n    _signer: address,\n    _recipient: address,\n    _amount: uint256,\n    _asset: address,\n    _isSignerAgent: bool,\n    _cd: CoreData,\n) -> (uint256, uint256):\n    transferAmount: uint256 = 0\n    usdValue: uint256 = 0\n\n    # validate recipient\n    if _recipient != _cd.owner:\n        assert staticcall WalletConfig(_cd.walletConfig).canTransferToRecipient(_recipient) # dev: recipient not allowed\n\n    # handle eth\n    if _asset == empty(address):\n        transferAmount = min(_amount, self.balance)\n        assert transferAmount != 0 # dev: nothing to transfer\n        send(_recipient, transferAmount)\n        usdValue = staticcall OracleRegistry(_cd.oracleRegistry).getEthUsdValue(transferAmount)\n\n    # erc20 tokens\n    else:\n\n        # check if vault token of trial funds asset\n        isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(_asset, _cd.trialFundsAsset, _cd.legoRegistry)\n        transferAmount = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_asset, _amount, True, _cd)\n\n        assert extcall IERC20(_asset).transfer(_recipient, transferAmount, default_return_value=True) # dev: transfer failed\n        usdValue = staticcall OracleRegistry(_cd.oracleRegistry).getUsdValue(_asset, transferAmount)\n\n        # make sure they still have enough trial funds\n        self._checkTrialFundsPostTx(isTrialFundsVaultToken, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, _cd.legoRegistry)\n\n        # yield tracking -- transferring out vault token\n        extcall WalletConfig(_cd.walletConfig).updateYieldTrackingOnExit(_asset, _cd.legoRegistry)\n\n    log UserWalletFundsTransferred(signer=_signer, recipient=_recipient, asset=_asset, amount=transferAmount, usdValue=usdValue, isSignerAgent=_isSignerAgent)\n    return transferAmount, usdValue\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@nonreentrant\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    \"\"\"\n    @notice Converts ETH to WETH and optionally deposits into a lego integration and vault\n    @param _amount The amount of ETH to convert (defaults to max)\n    @param _depositLegoId The lego ID to use for deposit (optional)\n    @param _depositVault The vault address for deposit (optional)\n    @return uint256 The amount of assets deposited (if deposit performed)\n    @return address The vault token address (if deposit performed)\n    @return uint256 The amount of vault tokens received (if deposit performed)\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    weth: address = self.wethAddr\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CONVERSION, [weth], [_depositLegoId], cd)\n\n    # convert eth to weth\n    amount: uint256 = min(_amount, self.balance)\n    assert amount != 0 # dev: nothing to convert\n    extcall WethContract(weth).deposit(value=amount)\n    log UserWalletEthConvertedToWeth(signer=msg.sender, amount=amount, paidEth=msg.value, weth=weth, isSignerAgent=isSignerAgent)\n\n    # deposit weth into lego partner\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    if _depositLegoId != 0:\n        depositUsdValue: uint256 = 0\n        amount, vaultToken, vaultTokenAmountReceived, depositUsdValue = self._depositTokens(msg.sender, _depositLegoId, weth, _depositVault, amount, isSignerAgent, cd)\n\n    return amount, vaultToken, vaultTokenAmountReceived\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    \"\"\"\n    @notice Converts WETH to ETH and optionally withdraws from a vault first\n    @param _amount The amount of WETH to convert (defaults to max)\n    @param _recipient The address to receive the ETH (optional)\n    @param _withdrawLegoId The lego ID to withdraw from (optional)\n    @param _withdrawVaultToken The vault token to withdraw (optional)\n    @return uint256 The amount of ETH received\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    weth: address = self.wethAddr\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CONVERSION, [weth], [_withdrawLegoId], cd)\n\n    # withdraw weth from lego partner (if applicable)\n    amount: uint256 = _amount\n    usdValue: uint256 = 0\n    if _withdrawLegoId != 0:\n        _na: uint256 = 0\n        amount, _na, usdValue = self._withdrawTokens(msg.sender, _withdrawLegoId, weth, _withdrawVaultToken, _amount, isSignerAgent, True, cd)\n\n    # convert weth to eth\n    amount = min(amount, staticcall IERC20(weth).balanceOf(self))\n    assert amount != 0 # dev: nothing to convert\n    extcall WethContract(weth).withdraw(amount)\n    log UserWalletWethConvertedToEth(signer=msg.sender, amount=amount, weth=weth, isSignerAgent=isSignerAgent)\n\n    # transfer eth to recipient (if applicable)\n    if _recipient != empty(address):\n        amount, usdValue = self._transferFunds(msg.sender, _recipient, amount, empty(address), isSignerAgent, cd)\n\n    return amount\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@internal\ndef _getCoreData() -> CoreData:\n    addyRegistry: address = ADDY_REGISTRY\n    walletConfig: address = self.walletConfig\n    return CoreData(\n        owner=staticcall WalletConfig(walletConfig).owner(),\n        wallet=self,\n        walletConfig=walletConfig,\n        addyRegistry=addyRegistry,\n        agentFactory=staticcall AddyRegistry(addyRegistry).getAddy(AGENT_FACTORY_ID),\n        legoRegistry=staticcall AddyRegistry(addyRegistry).getAddy(LEGO_REGISTRY_ID),\n        priceSheets=staticcall AddyRegistry(addyRegistry).getAddy(PRICE_SHEETS_ID),\n        oracleRegistry=staticcall AddyRegistry(addyRegistry).getAddy(ORACLE_REGISTRY_ID),\n        trialFundsAsset=self.trialFundsAsset,\n        trialFundsInitialAmount=self.trialFundsInitialAmount,\n    )\n\n\n# payments (subscriptions, transaction fees)\n\n\n@internal\ndef _checkPermsAndHandleSubs(\n    _signer: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n    _cd: CoreData,\n) -> bool:\n    agent: address = _signer\n    if _signer == _cd.owner:\n        agent = empty(address)\n\n    # check if agent is blacklisted\n    if agent != empty(address):\n        assert not staticcall AgentFactory(_cd.agentFactory).agentBlacklist(agent) # dev: agent is blacklisted\n\n    # handle subscriptions and permissions\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = extcall WalletConfig(_cd.walletConfig).handleSubscriptionsAndPermissions(agent, _action, _assets, _legoIds, _cd)\n\n    # handle protocol subscription payment\n    if protocolSub.amount != 0:\n        assert extcall IERC20(protocolSub.asset).transfer(protocolSub.recipient, protocolSub.amount, default_return_value=True) # dev: protocol subscription payment failed\n        log UserWalletSubscriptionPaid(recipient=protocolSub.recipient, asset=protocolSub.asset, amount=protocolSub.amount, usdValue=protocolSub.usdValue, paidThroughBlock=protocolSub.paidThroughBlock, isAgent=False)\n\n    # handle agent subscription payment\n    if agentSub.amount != 0:\n        assert extcall IERC20(agentSub.asset).transfer(agentSub.recipient, agentSub.amount, default_return_value=True) # dev: agent subscription payment failed\n        log UserWalletSubscriptionPaid(recipient=agent, asset=agentSub.asset, amount=agentSub.amount, usdValue=agentSub.usdValue, paidThroughBlock=agentSub.paidThroughBlock, isAgent=True)\n\n    return agent != empty(address)\n\n\n@internal\ndef _handleTransactionFees(\n    _action: ActionType,\n    _asset: address,\n    _amount: uint256,\n    _priceSheets: address,\n    _agentFactory: address,\n) -> uint256:\n    if _amount == 0 or _asset == empty(address):\n        return 0\n\n    # pay ambassador yield bonus first (we do early return once we get into tx fees)\n    ambassadorRecipient: address = empty(address)\n    if _action == ActionType.WITHDRAWAL:\n        ambassadorRecipient = self._getAmbassadorProceedsAddr(empty(address))\n        extcall AgentFactory(_agentFactory).payAmbassadorYieldBonus(ambassadorRecipient, _asset, _amount)\n\n    # get transaction fees\n    fee: uint256 = 0\n    protocolRecipient: address = empty(address)\n    ambassadorRatio: uint256 = 0\n    fee, protocolRecipient, ambassadorRatio = staticcall PriceSheets(_priceSheets).getTransactionFeeDataWithAmbassadorRatio(self, _action)\n    if fee == 0 or protocolRecipient == empty(address):\n        return 0\n\n    adjFee: uint256 = min(fee, HUNDRED_PERCENT)\n    feeTotalAmount: uint256 = min(_amount * adjFee // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if feeTotalAmount == 0:\n        return 0\n\n    protocolAmount: uint256 = feeTotalAmount\n    ambassadorAmount: uint256 = 0\n\n    # pay ambassador proceeds\n    if ambassadorRatio != 0:\n        ambassadorRecipient = self._getAmbassadorProceedsAddr(ambassadorRecipient)\n        ambassadorAmount = self._payAmbassadorTxFee(_asset, protocolAmount, ambassadorRatio, ambassadorRecipient)\n        if ambassadorAmount != 0:\n            protocolAmount = min(protocolAmount - ambassadorAmount, staticcall IERC20(_asset).balanceOf(self))\n\n    # pay protocol proceeds\n    if protocolAmount != 0:\n        assert extcall IERC20(_asset).transfer(protocolRecipient, protocolAmount, default_return_value=True) # dev: protocol tx fee payment failed\n\n    log UserWalletTransactionFeePaid(asset=_asset, protocolRecipient=protocolRecipient, protocolAmount=protocolAmount, ambassadorRecipient=ambassadorRecipient, ambassadorAmount=ambassadorAmount, fee=fee, action=_action)\n    return feeTotalAmount\n\n\n# ambassador\n\n\n@view\n@internal\ndef _getAmbassadorProceedsAddr(_maybeAmbassador: address) -> address:\n    if _maybeAmbassador != empty(address):\n        return _maybeAmbassador\n\n    myAmbassador: address = staticcall WalletConfig(self.walletConfig).myAmbassador()\n    if myAmbassador == empty(address):\n        return empty(address)\n    ambassadorWalletConfig: address = staticcall UserWallet(myAmbassador).walletConfig()\n    return staticcall WalletConfig(ambassadorWalletConfig).getProceedsAddr()\n\n\n@internal\ndef _payAmbassadorTxFee(\n    _asset: address,\n    _amount: uint256,\n    _ambassadorRatio: uint256,\n    _ambassadorAddr: address,\n) -> uint256:\n    if _ambassadorAddr == empty(address):\n        return 0\n\n    ambassadorRatio: uint256 = min(_ambassadorRatio, HUNDRED_PERCENT)\n    amount: uint256 = min(_amount * ambassadorRatio // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if amount != 0:\n        assert extcall IERC20(_asset).transfer(_ambassadorAddr, amount, default_return_value=True) # dev: ambassador tx fee payment failed\n\n    return min(_amount, amount)\n\n\n# allow lego to perform action\n\n\n@internal\ndef _checkLegoAccessForAction(_legoAddr: address):\n    targetAddr: address = empty(address)\n    accessAbi: String[64] = empty(String[64])\n    numInputs: uint256 = 0\n    targetAddr, accessAbi, numInputs = staticcall LegoCommon(_legoAddr).getAccessForLego(self)\n\n    # nothing to do here\n    if targetAddr == empty(address):\n        return\n\n    method_abi: bytes4 = convert(slice(keccak256(accessAbi), 0, 4), bytes4)\n    success: bool = False\n    response: Bytes[32] = b\"\"\n\n    # assumes input is: lego addr (operator)\n    if numInputs == 1:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    # assumes input (and order) is: user addr (owner), lego addr (operator)\n    elif numInputs == 2:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    # assumes input (and order) is: user addr (owner), lego addr (operator), allowed bool\n    elif numInputs == 3:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n                convert(True, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    assert success # dev: failed to set operator\n\n\n# trial funds\n\n\n@view\n@internal\ndef _isTrialFundsVaultToken(_asset: address, _trialFundsAsset: address, _legoRegistry: address) -> bool:\n    if _trialFundsAsset == empty(address) or _asset == _trialFundsAsset:\n        return False\n    return _trialFundsAsset == staticcall LegoRegistry(_legoRegistry).getUnderlyingAsset(_asset)\n\n\n@view\n@internal\ndef _checkTrialFundsPostTx(_isTrialFundsVaultToken: bool, _trialFundsAsset: address, _trialFundsInitialAmount: uint256, _legoRegistry: address):\n    if not _isTrialFundsVaultToken:\n        return\n    postUnderlying: uint256 = staticcall LegoRegistry(_legoRegistry).getUnderlyingForUser(self, _trialFundsAsset)\n    assert postUnderlying >= _trialFundsInitialAmount # dev: cannot transfer trial funds vault token\n\n\n@external\ndef clawBackTrialFunds() -> bool:\n    \"\"\"\n    @notice Claw back trial funds from the wallet by withdrawing from vault tokens and transferring to the agent factory\n    @dev This function can only be called by the agent factory, owner, or wallet config. It will:\n        1. Check if there are trial funds to recover\n        2. Calculate target recovery amount with 2% buffer\n        3. Transfer any available balance directly\n        4. Withdraw from vault tokens if needed\n        5. Update trial funds tracking data\n    @return bool True if trial funds were clawed back successfully, False otherwise\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    assert msg.sender in [cd.agentFactory, cd.owner, cd.walletConfig] # dev: no perms\n\n    # make sure something to recover\n    if cd.trialFundsAsset == empty(address) or cd.trialFundsInitialAmount == 0:\n        return False\n\n    # account for extra dust / yield\n    targetRecoveryAmount: uint256 = cd.trialFundsInitialAmount * 101_00 // HUNDRED_PERCENT # 1% buffer\n    amountRecovered: uint256 = 0\n\n    # transfer any available balance\n    balanceAvail: uint256 = staticcall IERC20(cd.trialFundsAsset).balanceOf(self)\n    if balanceAvail != 0:\n        availableAmount: uint256 = min(balanceAvail, targetRecoveryAmount)\n        assert extcall IERC20(cd.trialFundsAsset).transfer(cd.agentFactory, availableAmount, default_return_value=True) # dev: trial funds transfer failed\n        amountRecovered += availableAmount\n        targetRecoveryAmount -= availableAmount\n\n    if targetRecoveryAmount == 0:\n        return True\n\n    # iterate through vault tokens (related to trial funds)\n    trialFundsVaultTokens: DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER] = staticcall LegoRegistry(cd.legoRegistry).getVaultTokensForUser(self, cd.trialFundsAsset)\n    for v: VaultTokenInfo in trialFundsVaultTokens:\n        assetAmountReceived: uint256 = 0\n        na1: uint256 = 0\n        na2: uint256 = 0\n        assetAmountReceived, na1, na2 = self._withdrawTokens(cd.agentFactory, v.legoId, cd.trialFundsAsset, v.vaultToken, max_value(uint256), False, False, cd)\n\n        # recover funds\n        transferAmount: uint256 = min(assetAmountReceived, targetRecoveryAmount)\n        assert extcall IERC20(cd.trialFundsAsset).transfer(cd.agentFactory, transferAmount, default_return_value=True) # dev: trial funds transfer failed\n        amountRecovered += transferAmount\n        targetRecoveryAmount -= transferAmount\n\n        # reached target recovery amount, deposit any extra balance back lego\n        if targetRecoveryAmount == 0:\n            depositAmount: uint256 = min(assetAmountReceived - transferAmount, staticcall IERC20(cd.trialFundsAsset).balanceOf(self))\n            if depositAmount != 0:\n                self._depositTokens(msg.sender, v.legoId, cd.trialFundsAsset, v.vaultToken, depositAmount, False, cd)\n            break\n\n    if amountRecovered == 0:\n        return False\n\n    # update trial funds data\n    newTrialFundsInitialAmount: uint256 = cd.trialFundsInitialAmount - min(cd.trialFundsInitialAmount, amountRecovered)\n    self.trialFundsInitialAmount = newTrialFundsInitialAmount\n    if newTrialFundsInitialAmount == 0:\n        self.trialFundsAsset = empty(address)\n\n    log UserWalletTrialFundsRecovered(asset=cd.trialFundsAsset, amountRecovered=amountRecovered, remainingAmount=newTrialFundsInitialAmount)\n    return True\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256) -> bool:\n    \"\"\"\n    @notice Recovers an NFT from the wallet\n    @param _collection The address of the NFT collection\n    @param _nftTokenId The ID of the NFT to recover\n    @return bool True if the NFT was recovered successfully, False otherwise\n    \"\"\"\n    owner: address = staticcall WalletConfig(self.walletConfig).owner()\n    assert msg.sender == owner # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, owner, _nftTokenId)\n    log UserWalletNftRecovered(collection=_collection, nftTokenId=_nftTokenId, owner=owner)\n    return True\n\n\n# wallet migration\n\n\n@external\ndef migrateWalletOut(\n    _newWallet: address,\n    _assetsToMigrate: DynArray[address, MAX_MIGRATION_ASSETS],\n    _whitelistToMigrate: DynArray[address, MAX_MIGRATION_WHITELIST],\n) -> bool:\n    \"\"\"\n    @notice Migrates a wallet to a new wallet\n    @param _newWallet The address of the new wallet\n    @param _assetsToMigrate The assets to migrate\n    @param _whitelistToMigrate The whitelist to migrate\n    @return bool True if the migration was successful, False otherwise\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    assert msg.sender == cd.walletConfig # dev: only wallet config can call this\n    assert staticcall AgentFactory(cd.agentFactory).isUserWallet(_newWallet) # dev: must be Underscore wallet\n\n    # eth\n    if self.balance != 0:\n        send(_newWallet, self.balance)\n\n    assetsMigrated: DynArray[address, MAX_MIGRATION_ASSETS] = []\n    vaultTokensMigrated: DynArray[address, MAX_MIGRATION_ASSETS] = []\n\n    # erc20 tokens\n    for asset: address in _assetsToMigrate:\n        if asset == empty(address):\n            continue\n\n        assetBal: uint256 = staticcall IERC20(asset).balanceOf(self)\n        if assetBal == 0:\n            continue\n\n        assert extcall IERC20(asset).transfer(_newWallet, assetBal, default_return_value=True) # dev: asset transfer failed\n        if staticcall WalletConfig(cd.walletConfig).isVaultToken(asset):\n            vaultTokensMigrated.append(asset)\n        else:\n            assetsMigrated.append(asset)\n\n    # finish migration of new wallet\n    newWalletConfig: address = staticcall UserWallet(_newWallet).walletConfig()\n    assert extcall WalletConfig(newWalletConfig).finishMigrationIn(_whitelistToMigrate, assetsMigrated, vaultTokensMigrated) # dev: migration failed\n\n    # update yield tracking for this wallet\n    if len(vaultTokensMigrated) != 0:\n        for vaultToken: address in vaultTokensMigrated:\n            extcall WalletConfig(cd.walletConfig).updateYieldTrackingOnExit(vaultToken, cd.legoRegistry)\n\n    return True\n",
            "sha256sum": "80e4eea98ba2b6fdfdc90d2b68d99a1935d4de55dad5a211b51a5d286daee56d"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/templates/UserWalletTemplate.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "36875a4312171e5448643193da4235ac19bade0f9911802dc6f0eb5baca7196e"
      },
      "args": ""
    },
    "UserWalletConfigTemplate": {
      "address": "0x61293F1bF484d20dcc841175b4E4A0F46c26658c",
      "abi": [
        {
          "name": "AgentAdded",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "allowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "allowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentModified",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "allowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "allowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentDisabled",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAllowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevAllowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoIdAddedToAgent",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetAddedToAgent",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AllowedActionsModified",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRebalance",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canTransfer",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSwap",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canConvert",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canAddLiq",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRemoveLiq",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canClaimRewards",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canBorrow",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRepay",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanTransferToAltOwnerWalletsSet",
          "inputs": [
            {
              "name": "canTransfer",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrCancelled",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrRemoved",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrSetViaMigration",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ReserveAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanWalletBeAmbassadorSet",
          "inputs": [
            {
              "name": "canWalletBeAmbassador",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorForwarderSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletStartMigration",
          "inputs": [
            {
              "name": "newWallet",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numAssetsToMigrate",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numWhitelistToMigrate",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletFinishMigration",
          "inputs": [
            {
              "name": "oldWallet",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numWhitelistMigrated",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numVaultTokensMigrated",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numAssetsMigrated",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeInitiated",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeConfirmed",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeCancelled",
          "inputs": [
            {
              "name": "cancelledOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingOwnerChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeOwnership",
          "inputs": [
            {
              "name": "_newOwner",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOwnershipChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "owner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingOwner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newOwner",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ownershipChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "_ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWallet",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgentActive",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canAgentAccess",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            },
            {
              "name": "_legoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentSubscriptionStatus",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getProtocolSubscriptionStatus",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMakeSubscriptionPayments",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "handleSubscriptionsAndPermissions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            },
            {
              "name": "_legoIds",
              "type": "uint256[]"
            },
            {
              "name": "_cd",
              "type": "tuple",
              "components": [
                {
                  "name": "owner",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "addyRegistry",
                  "type": "address"
                },
                {
                  "name": "agentFactory",
                  "type": "address"
                },
                {
                  "name": "legoRegistry",
                  "type": "address"
                },
                {
                  "name": "priceSheets",
                  "type": "address"
                },
                {
                  "name": "oracleRegistry",
                  "type": "address"
                },
                {
                  "name": "trialFundsAsset",
                  "type": "address"
                },
                {
                  "name": "trialFundsInitialAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailableTxAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_wantedAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldCheckTrialFunds",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailableTxAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_wantedAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldCheckTrialFunds",
              "type": "bool"
            },
            {
              "name": "_cd",
              "type": "tuple",
              "components": [
                {
                  "name": "owner",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "addyRegistry",
                  "type": "address"
                },
                {
                  "name": "agentFactory",
                  "type": "address"
                },
                {
                  "name": "legoRegistry",
                  "type": "address"
                },
                {
                  "name": "priceSheets",
                  "type": "address"
                },
                {
                  "name": "oracleRegistry",
                  "type": "address"
                },
                {
                  "name": "trialFundsAsset",
                  "type": "address"
                },
                {
                  "name": "trialFundsInitialAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldTrackingOnDeposit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmountReceived",
              "type": "uint256"
            },
            {
              "name": "_assetAmountDeposited",
              "type": "uint256"
            },
            {
              "name": "_legoRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldTrackingOnWithdrawal",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmountBurned",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmountReceived",
              "type": "uint256"
            },
            {
              "name": "_legoRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldTrackingOnSwap",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_tokenOutAmount",
              "type": "uint256"
            },
            {
              "name": "_legoRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldTrackingOnEntry",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_legoRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateYieldTrackingOnExit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_legoRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startMigrationOut",
          "inputs": [
            {
              "name": "_newWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startMigrationOut",
          "inputs": [
            {
              "name": "_newWallet",
              "type": "address"
            },
            {
              "name": "_assetsToMigrate",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startMigrationOut",
          "inputs": [
            {
              "name": "_newWallet",
              "type": "address"
            },
            {
              "name": "_assetsToMigrate",
              "type": "address[]"
            },
            {
              "name": "_whitelistToMigrate",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishMigrationIn",
          "inputs": [
            {
              "name": "_whitelistToMigrate",
              "type": "address[]"
            },
            {
              "name": "_assetsMigrated",
              "type": "address[]"
            },
            {
              "name": "_vaultTokensMigrated",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            },
            {
              "name": "_allowedLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            },
            {
              "name": "_allowedLegoIds",
              "type": "uint256[]"
            },
            {
              "name": "_allowedActions",
              "type": "tuple",
              "components": [
                {
                  "name": "isSet",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRebalance",
                  "type": "bool"
                },
                {
                  "name": "canTransfer",
                  "type": "bool"
                },
                {
                  "name": "canSwap",
                  "type": "bool"
                },
                {
                  "name": "canConvert",
                  "type": "bool"
                },
                {
                  "name": "canAddLiq",
                  "type": "bool"
                },
                {
                  "name": "canRemoveLiq",
                  "type": "bool"
                },
                {
                  "name": "canClaimRewards",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLegoIdForAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetForAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "modifyAllowedActions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "modifyAllowedActions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedActions",
              "type": "tuple",
              "components": [
                {
                  "name": "isSet",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRebalance",
                  "type": "bool"
                },
                {
                  "name": "canTransfer",
                  "type": "bool"
                },
                {
                  "name": "canSwap",
                  "type": "bool"
                },
                {
                  "name": "canConvert",
                  "type": "bool"
                },
                {
                  "name": "canAddLiq",
                  "type": "bool"
                },
                {
                  "name": "canRemoveLiq",
                  "type": "bool"
                },
                {
                  "name": "canClaimRewards",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canTransferToRecipient",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesWalletHaveSameOwner",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanTransferToAltOwnerWallets",
          "inputs": [
            {
              "name": "_canTransfer",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setReserveAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManyReserveAssets",
          "inputs": [
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getProceedsAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAmbassadorForwarder",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanWalletBeAmbassador",
          "inputs": [
            {
              "name": "_canWalletBeAmbassador",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "wallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "didSetWallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolSub",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "installBlock",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "reserveAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentSettings",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "isActive",
                  "type": "bool"
                },
                {
                  "name": "installBlock",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "allowedLegoIds",
                  "type": "uint256[]"
                },
                {
                  "name": "allowedActions",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "isSet",
                      "type": "bool"
                    },
                    {
                      "name": "canDeposit",
                      "type": "bool"
                    },
                    {
                      "name": "canWithdraw",
                      "type": "bool"
                    },
                    {
                      "name": "canRebalance",
                      "type": "bool"
                    },
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canSwap",
                      "type": "bool"
                    },
                    {
                      "name": "canConvert",
                      "type": "bool"
                    },
                    {
                      "name": "canAddLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canRemoveLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "canBorrow",
                      "type": "bool"
                    },
                    {
                      "name": "canRepay",
                      "type": "bool"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRecipientAllowed",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingWhitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canTransferToAltOwnerWallets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canWalletBeAmbassador",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ambassadorForwarder",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "myAmbassador",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "didMigrateIn",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "didMigrateOut",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultTokenAmounts",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "depositedAmounts",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_initialAgent",
              "type": "address"
            },
            {
              "name": "_ambassador",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_minOwnerChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxOwnerChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Ownership.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AgentFactory:\n    def canCancelCriticalAction(_addr: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct PendingOwner:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent OwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    cancelledBy: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeDelaySet:\n    delayBlocks: uint256\n\n# owner\nowner: public(address) # owner of the wallet\npendingOwner: public(PendingOwner) # pending owner of the wallet\nownershipChangeDelay: public(uint256) # num blocks to wait before owner can be changed\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\n_ADDY_REGISTRY: public(immutable(address))\n\nAGENT_FACTORY_ID: constant(uint256) = 1\n\n\n@deploy\ndef __init__(\n    _owner: address,\n    _addyRegistry: address,\n    _minOwnerChangeDelay: uint256,\n    _maxOwnerChangeDelay: uint256,\n):\n    assert empty(address) not in [_owner, _addyRegistry] # dev: invalid addrs\n    self.owner = _owner\n    _ADDY_REGISTRY = _addyRegistry\n\n    assert _minOwnerChangeDelay < _maxOwnerChangeDelay # dev: invalid delay\n    MIN_OWNER_CHANGE_DELAY = _minOwnerChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxOwnerChangeDelay\n    self.ownershipChangeDelay = _minOwnerChangeDelay\n\n\n####################\n# Ownership Change #\n####################\n\n\n@view\n@external\ndef hasPendingOwnerChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending ownership change\n    @return bool True if there is a pending ownership change, false otherwise\n    \"\"\"\n    return self._hasPendingOwnerChange()\n\n\n@view\n@internal\ndef _hasPendingOwnerChange() -> bool:\n    return self.pendingOwner.confirmBlock != 0\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    \"\"\"\n    @notice Initiates a new ownership change\n    @dev Can only be called by the current owner\n    @param _newOwner The address of the new owner\n    \"\"\"\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingOwner = PendingOwner(\n        newOwner= _newOwner,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log OwnershipChangeInitiated(prevOwner=currentOwner, newOwner=_newOwner, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmOwnershipChange():\n    \"\"\"\n    @notice Confirms the ownership change\n    @dev Can only be called by the new owner\n    \"\"\"\n    data: PendingOwner = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeConfirmed(prevOwner=prevOwner, newOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelOwnershipChange():\n    \"\"\"\n    @notice Cancels the ownership change\n    @dev Can only be called by the current owner or governance\n    \"\"\"\n    agentFactory: address = staticcall AddyRegistry(_ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    assert msg.sender == self.owner or staticcall AgentFactory(agentFactory).canCancelCriticalAction(msg.sender) # dev: no perms (only owner or governance)\n\n    data: PendingOwner = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeCancelled(cancelledOwner=data.newOwner, cancelledBy=msg.sender, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setOwnershipChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the ownership change delay\n    @dev Can only be called by the owner\n    @param _numBlocks The number of blocks to wait before ownership can be changed\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNER_CHANGE_DELAY and _numBlocks <= MAX_OWNER_CHANGE_DELAY # dev: invalid delay\n    self.ownershipChangeDelay = _numBlocks\n    log OwnershipChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "2f0e7c45d64763e64f27ede081332d3ba84c61832ea4721e2123a6cd7654870b"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "contracts/core/templates/UserWalletConfigTemplate.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n# pragma optimize codesize\n\ninitializes: own\nexports: own.__interface__\n\nimport contracts.modules.Ownership as own\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\n\ninterface UserWallet:\n    def migrateWalletOut(_newWallet: address, _assetsToMigrate: DynArray[address, MAX_MIGRATION_ASSETS], _whitelistToMigrate: DynArray[address, MAX_MIGRATION_WHITELIST]) -> bool: nonpayable\n    def trialFundsInitialAmount() -> uint256: view\n    def clawBackTrialFunds() -> bool: nonpayable\n    def trialFundsAsset() -> address: view\n    def walletConfig() -> address: view\n    def canBeAmbassador() -> bool: view\n\ninterface WalletConfig:\n    def vaultTokenAmounts(_vaultToken: address) -> uint256: view\n    def depositedAmounts(_vaultToken: address) -> uint256: view\n    def isRecipientAllowed(_addr: address) -> bool: view\n    def hasPendingOwnerChange() -> bool: view\n    def myAmbassador() -> address: view\n    def owner() -> address: view\n\ninterface LegoRegistry:\n    def getLegoFromVaultToken(_vaultToken: address) -> (uint256, address): view\n    def getUnderlyingForUser(_user: address, _asset: address) -> uint256: view\n    def isVaultToken(_vaultToken: address) -> bool: view\n    def isValidLegoId(_legoId: uint256) -> bool: view\n\ninterface PriceSheets:\n    def getCombinedSubData(_user: address, _agent: address, _agentPaidThru: uint256, _protocolPaidThru: uint256, _oracleRegistry: address) -> (SubPaymentInfo, SubPaymentInfo): view\n    def getAgentSubPriceData(_agent: address) -> SubscriptionInfo: view\n    def protocolSubPriceData() -> SubscriptionInfo: view\n\ninterface AgentFactory:\n    def canCancelCriticalAction(_addr: address) -> bool: view\n    def isUserWallet(_wallet: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct AgentInfo:\n    isActive: bool\n    installBlock: uint256\n    paidThroughBlock: uint256\n    allowedAssets: DynArray[address, MAX_ASSETS]\n    allowedLegoIds: DynArray[uint256, MAX_LEGOS]\n    allowedActions: AllowedActions\n\nstruct PendingWhitelist:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct CoreData:\n    owner: address\n    wallet: address\n    walletConfig: address\n    addyRegistry: address\n    agentFactory: address\n    legoRegistry: address\n    priceSheets: address\n    oracleRegistry: address\n    trialFundsAsset: address\n    trialFundsInitialAmount: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct ProtocolSub:\n    installBlock: uint256\n    paidThroughBlock: uint256\n\nstruct AllowedActions:\n    isSet: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRebalance: bool\n    canTransfer: bool\n    canSwap: bool\n    canConvert: bool\n    canAddLiq: bool\n    canRemoveLiq: bool\n    canClaimRewards: bool\n    canBorrow: bool\n    canRepay: bool\n\nstruct ReserveAsset:\n    asset: address\n    amount: uint256\n\nstruct SubscriptionInfo:\n    asset: address\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent AgentAdded:\n    agent: indexed(address)\n    allowedAssets: uint256\n    allowedLegoIds: uint256\n\nevent AgentModified:\n    agent: indexed(address)\n    allowedAssets: uint256\n    allowedLegoIds: uint256\n\nevent AgentDisabled:\n    agent: indexed(address)\n    prevAllowedAssets: uint256\n    prevAllowedLegoIds: uint256\n\nevent LegoIdAddedToAgent:\n    agent: indexed(address)\n    legoId: indexed(uint256)\n\nevent AssetAddedToAgent:\n    agent: indexed(address)\n    asset: indexed(address)\n\nevent AllowedActionsModified:\n    agent: indexed(address)\n    canDeposit: bool\n    canWithdraw: bool\n    canRebalance: bool\n    canTransfer: bool\n    canSwap: bool\n    canConvert: bool\n    canAddLiq: bool\n    canRemoveLiq: bool\n    canClaimRewards: bool\n    canBorrow: bool\n    canRepay: bool\n\nevent CanTransferToAltOwnerWalletsSet:\n    canTransfer: bool\n\nevent WhitelistAddrPending:\n    addr: indexed(address)\n    confirmBlock: uint256\n\nevent WhitelistAddrConfirmed:\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent WhitelistAddrCancelled:\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    cancelledBy: indexed(address)\n\nevent WhitelistAddrRemoved:\n    addr: indexed(address)\n\nevent WhitelistAddrSetViaMigration:\n    addr: indexed(address)\n\nevent ReserveAssetSet:\n    asset: indexed(address)\n    amount: uint256\n\nevent CanWalletBeAmbassadorSet:\n    canWalletBeAmbassador: bool\n\nevent AmbassadorForwarderSet:\n    addr: indexed(address)\n\nevent FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent UserWalletStartMigration:\n    newWallet: indexed(address)\n    numAssetsToMigrate: uint256\n    numWhitelistToMigrate: uint256\n\nevent UserWalletFinishMigration:\n    oldWallet: indexed(address)\n    numWhitelistMigrated: uint256\n    numVaultTokensMigrated: uint256\n    numAssetsMigrated: uint256\n\n# core\nwallet: public(address)\ndidSetWallet: public(bool)\n\n# user settings\nprotocolSub: public(ProtocolSub) # subscription info\nreserveAssets: public(HashMap[address, uint256]) # asset -> reserve amount\nagentSettings: public(HashMap[address, AgentInfo]) # agent -> agent info\n\n# transfer whitelist\nisRecipientAllowed: public(HashMap[address, bool]) # recipient -> is allowed\npendingWhitelist: public(HashMap[address, PendingWhitelist]) # addr -> pending whitelist\ncanTransferToAltOwnerWallets: public(bool)\n\n# ambassador settings\ncanWalletBeAmbassador: public(bool)\nambassadorForwarder: public(address)\nmyAmbassador: public(address) # cannot be edited -- inviter of THIS user wallet\n\n# migration\ndidMigrateIn: public(bool)\ndidMigrateOut: public(bool)\n\n# yield tracking\nisVaultToken: public(HashMap[address, bool]) # asset -> is vault token\nvaultTokenAmounts: public(HashMap[address, uint256]) # vault token -> vault token amount\ndepositedAmounts: public(HashMap[address, uint256]) # vault token -> underlying asset amount\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\nLEGO_REGISTRY_ID: constant(uint256) = 2\nPRICE_SHEETS_ID: constant(uint256) = 3\nORACLE_REGISTRY_ID: constant(uint256) = 4\n\nMAX_MIGRATION_ASSETS: constant(uint256) = 40\nMAX_MIGRATION_WHITELIST: constant(uint256) = 20\nMAX_ASSETS: constant(uint256) = 25\nMAX_LEGOS: constant(uint256) = 20\nAPI_VERSION: constant(String[28]) = \"0.0.3\"\n\nADDY_REGISTRY: public(immutable(address))\n\n\n@deploy\ndef __init__(\n    _owner: address,\n    _initialAgent: address,\n    _ambassador: address,\n    _addyRegistry: address,\n    _minOwnerChangeDelay: uint256,\n    _maxOwnerChangeDelay: uint256,\n):\n    \"\"\"\n    @notice Initializes a new UserWalletConfig contract with ownership and agent settings\n    @dev Sets up the config with owner, registry, and optional initial agent. Also initializes protocol subscription.\n    @param _owner Address of the contract owner who will have administrative privileges\n    @param _initialAgent Address of the initial agent to be set up (can be empty)\n    @param _ambassador Address of the ambassador who invited the user (can be empty)\n    @param _addyRegistry Address of the registry contract that stores core protocol addresses\n    @param _minOwnerChangeDelay Minimum delay in blocks required for ownership changes\n    @param _maxOwnerChangeDelay Maximum delay in blocks allowed for ownership changes\n    \"\"\"\n    assert empty(address) not in [_addyRegistry, _owner] # dev: invalid addrs\n    assert _initialAgent != _owner # dev: agent cannot be owner\n\n    # initialize ownership\n    own.__init__(_owner, _addyRegistry, _minOwnerChangeDelay, _maxOwnerChangeDelay)\n\n    ADDY_REGISTRY = _addyRegistry\n    priceSheets: address = staticcall AddyRegistry(_addyRegistry).getAddy(PRICE_SHEETS_ID)\n\n    # initial agent setup\n    if _initialAgent != empty(address):\n        subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).getAgentSubPriceData(_initialAgent)\n        paidThroughBlock: uint256 = 0\n        if subInfo.usdValue != 0:\n            paidThroughBlock = block.number + subInfo.trialPeriod\n        self.agentSettings[_initialAgent] = AgentInfo(\n            isActive=True,\n            installBlock=block.number,\n            paidThroughBlock=paidThroughBlock,\n            allowedAssets=[],\n            allowedLegoIds=[],\n            allowedActions=empty(AllowedActions),\n        )\n        log AgentAdded(agent=_initialAgent, allowedAssets=0, allowedLegoIds=0)\n\n    # protocol subscription\n    protocolSub: ProtocolSub = empty(ProtocolSub)\n    protocolSub.installBlock = block.number\n    subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).protocolSubPriceData()\n    if subInfo.usdValue != 0:\n        protocolSub.paidThroughBlock = block.number + subInfo.trialPeriod\n    self.protocolSub = protocolSub\n\n    # ambassador settings\n    self.canWalletBeAmbassador = True\n    if _ambassador != empty(address):\n        self.myAmbassador = _ambassador\n\n    self.canTransferToAltOwnerWallets = True\n\n\n@external\ndef setWallet(_wallet: address) -> bool:\n    \"\"\"\n    @notice Sets the associated wallet address for this config contract\n    @dev Can only be called once by the agent factory. Establishes the link between config and wallet.\n    @param _wallet Address of the wallet contract to be associated with this config\n    @return bool True if the wallet was successfully set\n    \"\"\"\n    assert not self.didSetWallet # dev: wallet already set\n    assert _wallet != empty(address) # dev: invalid wallet\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID) # dev: no perms\n    self.wallet = _wallet\n    self.didSetWallet = True\n    return True\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    \"\"\"\n    @notice Returns the current API version of the contract\n    @dev Returns a constant string representing the contract version\n    @return String[28] The API version string\n    \"\"\"\n    return API_VERSION\n\n\n#####################\n# Agent Permissions #\n#####################\n\n\n@view\n@external\ndef isAgentActive(_agent: address) -> bool:\n    return self.agentSettings[_agent].isActive\n\n\n@view\n@external\ndef canAgentAccess(\n    _agent: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n) -> bool:\n    return self._canAgentAccess(self.agentSettings[_agent], _action, _assets, _legoIds)\n\n\n@view\n@internal\ndef _canAgentAccess(\n    _agentInfo: AgentInfo,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n) -> bool:\n    \"\"\"\n    @notice Checks if an agent has permission to perform a specific action with given assets and lego IDs\n    @dev Validates agent's active status, allowed actions, allowed assets, and allowed lego IDs\n    @param _agentInfo The agent's information including permissions and allowed actions\n    @param _action The type of action being attempted\n    @param _assets Array of asset addresses involved in the action\n    @param _legoIds Array of lego IDs involved in the action\n    @return True if the agent has permission to perform the action, False otherwise\n    \"\"\"\n    if not _agentInfo.isActive:\n        return False\n\n    # check allowed actions\n    if not self._canAgentPerformAction(_action, _agentInfo.allowedActions):\n        return False\n\n    # check allowed assets\n    if len(_agentInfo.allowedAssets) != 0:\n        for i: uint256 in range(len(_assets), bound=MAX_ASSETS):\n            asset: address = _assets[i]\n            if asset != empty(address) and asset not in _agentInfo.allowedAssets:\n                return False\n\n    # check allowed lego ids\n    if len(_agentInfo.allowedLegoIds) != 0:\n        for i: uint256 in range(len(_legoIds), bound=MAX_LEGOS):\n            legoId: uint256 = _legoIds[i]\n            if legoId != 0 and legoId not in _agentInfo.allowedLegoIds:\n                return False\n\n    return True\n\n\n@view\n@internal\ndef _canAgentPerformAction(_action: ActionType, _allowedActions: AllowedActions) -> bool:\n    if not _allowedActions.isSet or _action == empty(ActionType):\n        return True\n    if _action == ActionType.DEPOSIT:\n        return _allowedActions.canDeposit\n    elif _action == ActionType.WITHDRAWAL:\n        return _allowedActions.canWithdraw\n    elif _action == ActionType.REBALANCE:\n        return _allowedActions.canRebalance\n    elif _action == ActionType.TRANSFER:\n        return _allowedActions.canTransfer\n    elif _action == ActionType.SWAP:\n        return _allowedActions.canSwap\n    elif _action == ActionType.CONVERSION:\n        return _allowedActions.canConvert\n    elif _action == ActionType.ADD_LIQ:\n        return _allowedActions.canAddLiq\n    elif _action == ActionType.REMOVE_LIQ:\n        return _allowedActions.canRemoveLiq\n    elif _action == ActionType.CLAIM_REWARDS:\n        return _allowedActions.canClaimRewards\n    elif _action == ActionType.BORROW:\n        return _allowedActions.canBorrow\n    elif _action == ActionType.REPAY:\n        return _allowedActions.canRepay\n    else:\n        return True # no action specified\n\n\n##########################\n# Subscription + Tx Fees #\n##########################\n\n\n# subscriptions\n\n\n@view\n@external\ndef getAgentSubscriptionStatus(_agent: address) -> SubPaymentInfo:\n    cd: CoreData = self._getCoreData()\n    na: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    na, agentSub = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, _agent, self.agentSettings[_agent].paidThroughBlock, 0, cd.oracleRegistry)\n    return agentSub\n\n\n@view\n@external\ndef getProtocolSubscriptionStatus() -> SubPaymentInfo:\n    cd: CoreData = self._getCoreData()\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    na: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, na = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, empty(address), 0, self.protocolSub.paidThroughBlock, cd.oracleRegistry)\n    return protocolSub\n\n\n@view\n@external\ndef canMakeSubscriptionPayments(_agent: address) -> (bool, bool):\n    cd: CoreData = self._getCoreData()\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, _agent, self.agentSettings[_agent].paidThroughBlock, self.protocolSub.paidThroughBlock, cd.oracleRegistry)\n    return self._checkIfSufficientFunds(protocolSub.asset, protocolSub.amount, agentSub.asset, agentSub.amount, cd)\n\n\n@external\ndef handleSubscriptionsAndPermissions(\n    _agent: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n    _cd: CoreData,\n) -> (SubPaymentInfo, SubPaymentInfo):\n    \"\"\"\n    @notice Handles the subscription and permission data for the given agent and action\n    @param _agent The address of the agent\n    @param _action The action to handle\n    @param _assets The assets to check\n    @param _legoIds The legos to check\n    @param _cd The core data\n    @return protocolSub The protocol subscription data\n    @return agentSub The agent subscription data\n    \"\"\"\n    assert msg.sender == self.wallet # dev: no perms\n\n    # check if agent can perform action with assets and legos\n    userAgentData: AgentInfo = empty(AgentInfo)\n    if _agent != empty(address):\n        userAgentData = self.agentSettings[_agent]\n        assert self._canAgentAccess(userAgentData, _action, _assets, _legoIds) # dev: agent not allowed\n\n    userProtocolData: ProtocolSub = self.protocolSub\n\n    # get latest sub data for agent and protocol\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = staticcall PriceSheets(_cd.priceSheets).getCombinedSubData(_cd.wallet, _agent, userAgentData.paidThroughBlock, userProtocolData.paidThroughBlock, _cd.oracleRegistry)\n\n    # check if sufficient funds\n    canPayProtocol: bool = False\n    canPayAgent: bool = False\n    canPayProtocol, canPayAgent = self._checkIfSufficientFunds(protocolSub.asset, protocolSub.amount, agentSub.asset, agentSub.amount, _cd)\n    assert canPayProtocol # dev: insufficient balance for protocol subscription payment\n    assert canPayAgent # dev: insufficient balance for agent subscription payment\n\n    # update and save new data\n    if protocolSub.didChange:\n        userProtocolData.paidThroughBlock = protocolSub.paidThroughBlock\n        self.protocolSub = userProtocolData\n    if agentSub.didChange:\n        userAgentData.paidThroughBlock = agentSub.paidThroughBlock\n        self.agentSettings[_agent] = userAgentData\n\n    # actual payments will happen from wallet\n    return protocolSub, agentSub\n\n\n####################\n# Random Utilities #\n####################\n\n\n@view\n@internal\ndef _getCoreData() -> CoreData:\n    addyRegistry: address = ADDY_REGISTRY\n    wallet: address = self.wallet\n    return CoreData(\n        owner=own.owner,\n        wallet=wallet,\n        walletConfig=self,\n        addyRegistry=addyRegistry,\n        agentFactory=staticcall AddyRegistry(addyRegistry).getAddy(AGENT_FACTORY_ID),\n        legoRegistry=staticcall AddyRegistry(addyRegistry).getAddy(LEGO_REGISTRY_ID),\n        priceSheets=staticcall AddyRegistry(addyRegistry).getAddy(PRICE_SHEETS_ID),\n        oracleRegistry=staticcall AddyRegistry(addyRegistry).getAddy(ORACLE_REGISTRY_ID),\n        trialFundsAsset=staticcall UserWallet(wallet).trialFundsAsset(),\n        trialFundsInitialAmount=staticcall UserWallet(wallet).trialFundsInitialAmount(),\n    )\n\n\n@view\n@internal\ndef _checkIfSufficientFunds(_protocolAsset: address, _protocolAmount: uint256, _agentAsset: address, _agentAmount: uint256, _cd: CoreData) -> (bool, bool):\n    canPayProtocol: bool = True\n    canPayAgent: bool = True\n\n    # check if any of these assets are also trial funds asset\n    trialFundsCurrentBal: uint256 = 0\n    trialFundsDeployed: uint256 = 0\n    if (_protocolAsset != empty(address) and _protocolAsset == _cd.trialFundsAsset) or (_agentAsset != empty(address) and _agentAsset == _cd.trialFundsAsset):\n        trialFundsCurrentBal = staticcall IERC20(_cd.trialFundsAsset).balanceOf(_cd.wallet)\n        trialFundsDeployed = staticcall LegoRegistry(_cd.legoRegistry).getUnderlyingForUser(_cd.wallet, _cd.trialFundsAsset)\n\n    # check if can make protocol payment\n    if _protocolAmount != 0:\n        availBalForProtocol: uint256 = self._getAvailBalAfterTrialFunds(_protocolAsset, _cd.wallet, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, trialFundsCurrentBal, trialFundsDeployed)\n        canPayProtocol = availBalForProtocol >= _protocolAmount\n\n        # update trial funds balance\n        if _protocolAsset != empty(address) and _protocolAsset == _cd.trialFundsAsset:\n            trialFundsCurrentBal -= _protocolAmount\n\n    # check if can make agent payment\n    if _agentAmount != 0:\n        availBalForAgent: uint256 = self._getAvailBalAfterTrialFunds(_agentAsset, _cd.wallet, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, trialFundsCurrentBal, trialFundsDeployed)\n        canPayAgent = availBalForAgent >= _agentAmount\n\n    return canPayProtocol, canPayAgent\n\n\n@view\n@external\ndef getAvailableTxAmount(\n    _asset: address,\n    _wantedAmount: uint256,\n    _shouldCheckTrialFunds: bool,\n    _cd: CoreData = empty(CoreData),\n) -> uint256:\n    \"\"\"\n    @notice Returns the maximum amount that can be sent from the wallet\n    @param _asset The address of the asset to check\n    @param _wantedAmount The amount of the asset to send\n    @param _shouldCheckTrialFunds Whether to check if the asset is a trial funds asset\n    @param _cd The core data\n    @return amount The maximum amount that can be sent\n    \"\"\"\n    cd: CoreData = _cd\n    if cd.wallet == empty(address):\n        cd = self._getCoreData()\n\n    availableAmount: uint256 = staticcall IERC20(_asset).balanceOf(cd.wallet)\n\n    # check if asset is trial funds asset\n    if _shouldCheckTrialFunds and _asset == cd.trialFundsAsset:\n        trialFundsDeployed: uint256 = staticcall LegoRegistry(cd.legoRegistry).getUnderlyingForUser(cd.wallet, _asset)\n        availableAmount = self._getAvailBalAfterTrialFunds(_asset, cd.wallet, cd.trialFundsAsset, cd.trialFundsInitialAmount, availableAmount, trialFundsDeployed)\n\n    # check if any reserve is set\n    reservedAmount: uint256 = self.reserveAssets[_asset]\n    if reservedAmount != 0:\n        assert availableAmount > reservedAmount # dev: insufficient balance after reserve\n        availableAmount -= reservedAmount\n\n    # return min of wanted amount and available amount\n    availableAmount = min(_wantedAmount, availableAmount)\n    assert availableAmount != 0 # dev: no funds available\n\n    return availableAmount\n\n\n@view\n@internal\ndef _getAvailBalAfterTrialFunds(\n    _asset: address,\n    _wallet: address,\n    _trialFundsAsset: address,\n    _trialFundsInitialAmount: uint256,\n    _trialFundsCurrentBal: uint256,\n    _trialFundsDeployed: uint256,\n) -> uint256:\n    if _asset != _trialFundsAsset:\n        return staticcall IERC20(_asset).balanceOf(_wallet)\n\n    # sufficient trial funds already deployed\n    if _trialFundsDeployed >= _trialFundsInitialAmount:\n        return _trialFundsCurrentBal\n\n    lockedAmount: uint256 = _trialFundsInitialAmount - _trialFundsDeployed\n    availAmount: uint256 = 0\n    if _trialFundsCurrentBal > lockedAmount:\n        availAmount = _trialFundsCurrentBal - lockedAmount\n\n    return availAmount\n\n\n##################\n# Yield Tracking #\n##################\n\n\n# deposits\n\n\n@external\ndef updateYieldTrackingOnDeposit(\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmountReceived: uint256,\n    _assetAmountDeposited: uint256,\n    _legoRegistry: address,\n):\n    assert msg.sender == self.wallet # dev: no perms\n\n    if self.isVaultToken[_asset]: # if asset is the vault token (i.e. Ripe collateral)\n        self._updateYieldTrackingOnExit(_asset, _legoRegistry)\n    self._updateYieldTrackingOnDeposit(_vaultToken, _vaultTokenAmountReceived, _assetAmountDeposited, _legoRegistry)\n\n\n@internal\ndef _updateYieldTrackingOnDeposit(\n    _vaultToken: address,\n    _vaultTokenAmountReceived: uint256,\n    _assetAmountDeposited: uint256,\n    _legoRegistry: address,\n):\n    if _vaultToken == empty(address):\n        return\n\n    # validate vault token\n    isVaultToken: bool = self.isVaultToken[_vaultToken]\n    if not isVaultToken and staticcall LegoRegistry(_legoRegistry).isVaultToken(_vaultToken):\n        self.isVaultToken[_vaultToken] = True\n        isVaultToken = True\n\n    if isVaultToken:\n        self.vaultTokenAmounts[_vaultToken] += _vaultTokenAmountReceived\n        self.depositedAmounts[_vaultToken] += _assetAmountDeposited\n\n\n# withdrawals\n\n\n@external\ndef updateYieldTrackingOnWithdrawal(\n    _vaultToken: address,\n    _vaultTokenAmountBurned: uint256,\n    _asset: address,\n    _assetAmountReceived: uint256,\n    _legoRegistry: address,\n) -> uint256:\n    assert msg.sender == self.wallet # dev: no perms\n\n    # if asset is the vault token (i.e. Ripe collateral)\n    if self.isVaultToken[_asset]: \n        self._updateYieldTrackingOnEntry(_asset, _assetAmountReceived, _legoRegistry)\n\n    # check if there are any yield profits\n    assetProfitAmount: uint256 = 0\n    if self.isVaultToken[_vaultToken]:\n        assetProfitAmount = self._updateYieldTrackingOnWithdrawal(_vaultToken, _vaultTokenAmountBurned, _assetAmountReceived, _legoRegistry)\n\n    return assetProfitAmount\n\n\n@internal\ndef _updateYieldTrackingOnWithdrawal(\n    _vaultToken: address,\n    _vaultTokenAmountBurned: uint256,\n    _assetAmountReceived: uint256,\n    _legoRegistry: address,\n) -> uint256:\n    actualVaultTokenBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self.wallet)\n    trackedVaultTokenBalance: uint256 = self.vaultTokenAmounts[_vaultToken]\n\n    # sufficient balance, see if we need to actually ADD to the tracked balance\n    if actualVaultTokenBalance >= trackedVaultTokenBalance:\n        self._updateYieldTrackingOnEntry(_vaultToken, actualVaultTokenBalance - trackedVaultTokenBalance, _legoRegistry)\n        return 0\n\n    # reduce the tracked balance\n    vaultTokenToReduce: uint256 = trackedVaultTokenBalance - actualVaultTokenBalance\n    assetAmountToReduce: uint256 = _assetAmountReceived * vaultTokenToReduce // _vaultTokenAmountBurned\n\n    # adjust vault token amount\n    shouldZeroOut: bool = False\n    if vaultTokenToReduce >= trackedVaultTokenBalance:\n        self.vaultTokenAmounts[_vaultToken] = 0\n        shouldZeroOut = True\n    else:\n        self.vaultTokenAmounts[_vaultToken] -= vaultTokenToReduce\n\n    # handle asset tracking\n    profitAmount: uint256 = 0\n    trackedAssetAmount: uint256 = self.depositedAmounts[_vaultToken]\n    if assetAmountToReduce > trackedAssetAmount:\n        profitAmount = assetAmountToReduce - trackedAssetAmount\n        self.depositedAmounts[_vaultToken] = 0\n    elif shouldZeroOut:\n        self.depositedAmounts[_vaultToken] = 0\n    else:\n        self.depositedAmounts[_vaultToken] -= assetAmountToReduce\n\n    return profitAmount\n\n\n# other\n\n\n@external\ndef updateYieldTrackingOnSwap(_tokenIn: address, _tokenOut: address, _tokenOutAmount: uint256, _legoRegistry: address):\n    assert msg.sender == self.wallet # dev: no perms\n\n    # someone may have swapped out of a vault token\n    if self.isVaultToken[_tokenIn]:\n        self._updateYieldTrackingOnExit(_tokenIn, _legoRegistry)\n\n    # someone may have swapped into a vault token\n    if self.isVaultToken[_tokenOut]:\n        self._updateYieldTrackingOnEntry(_tokenOut, _tokenOutAmount, _legoRegistry)\n\n\n@external\ndef updateYieldTrackingOnEntry(\n    _asset: address,\n    _amount: uint256,\n    _legoRegistry: address,\n):\n    assert msg.sender == self.wallet # dev: no perms\n\n    if self.isVaultToken[_asset]:\n        self._updateYieldTrackingOnEntry(_asset, _amount, _legoRegistry)\n\n\n@internal\ndef _updateYieldTrackingOnEntry(\n    _vaultToken: address,\n    _vaultTokenAmount: uint256,\n    _legoRegistry: address,\n):\n    if _vaultTokenAmount == 0:\n        return\n\n    # get lego details for vault token\n    na: uint256 = 0\n    legoAddr: address = empty(address)\n    na, legoAddr = staticcall LegoRegistry(_legoRegistry).getLegoFromVaultToken(_vaultToken)\n    if legoAddr == empty(address):\n        return\n\n    actualVaultTokenAmount: uint256 = min(_vaultTokenAmount, staticcall IERC20(_vaultToken).balanceOf(self.wallet))\n    if actualVaultTokenAmount != 0:\n        self.vaultTokenAmounts[_vaultToken] += actualVaultTokenAmount\n        self.depositedAmounts[_vaultToken] += staticcall LegoYield(legoAddr).getUnderlyingAmount(_vaultToken, actualVaultTokenAmount)\n\n\n@external\ndef updateYieldTrackingOnExit(_asset: address, _legoRegistry: address):\n    assert msg.sender == self.wallet # dev: no perms\n\n    if self.isVaultToken[_asset]:\n        self._updateYieldTrackingOnExit(_asset, _legoRegistry)\n\n\n@internal\ndef _updateYieldTrackingOnExit(_vaultToken: address, _legoRegistry: address):\n    actualVaultTokenBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self.wallet)\n    trackedVaultTokenBalance: uint256 = self.vaultTokenAmounts[_vaultToken]\n\n    # sufficient balance, see if we need to actually ADD to the tracked balance\n    if actualVaultTokenBalance >= trackedVaultTokenBalance:\n        self._updateYieldTrackingOnEntry(_vaultToken, actualVaultTokenBalance - trackedVaultTokenBalance, _legoRegistry)\n        return\n\n    # reduce the tracked balance\n    vaultTokenToReduce: uint256 = trackedVaultTokenBalance - actualVaultTokenBalance\n\n    # zero out the tracked balance\n    if vaultTokenToReduce >= trackedVaultTokenBalance:\n        self.vaultTokenAmounts[_vaultToken] = 0\n        self.depositedAmounts[_vaultToken] = 0\n\n    else:\n        self.vaultTokenAmounts[_vaultToken] -= vaultTokenToReduce\n\n        # reduce the tracked asset amount\n        trackedAssetAmount: uint256 = self.depositedAmounts[_vaultToken]\n        if trackedAssetAmount != 0:\n            assetAmountToReduce: uint256 = trackedAssetAmount * vaultTokenToReduce // trackedVaultTokenBalance\n            self.depositedAmounts[_vaultToken] -= assetAmountToReduce\n\n\n####################\n# Wallet Migration #\n####################\n\n\n@external\ndef startMigrationOut(\n    _newWallet: address,\n    _assetsToMigrate: DynArray[address, MAX_MIGRATION_ASSETS] = [],\n    _whitelistToMigrate: DynArray[address, MAX_MIGRATION_WHITELIST] = [],\n) -> bool:\n    cd: CoreData = self._getCoreData()\n    assert msg.sender == cd.owner # dev: no perms\n    assert not self.didMigrateOut # dev: already migrated out\n\n    # validate migration\n    newWalletConfig: address = staticcall UserWallet(_newWallet).walletConfig()\n    self._validateAltWalletDuringMigration(_newWallet, newWalletConfig, cd.agentFactory)\n    for r: address in _whitelistToMigrate:\n        assert self.isRecipientAllowed[r] # dev: new wallet has different whitelist\n\n    # recover trial funds first\n    extcall UserWallet(cd.wallet).clawBackTrialFunds() # not asserting True, may have already been done\n\n    # migrate wallet\n    assert extcall UserWallet(cd.wallet).migrateWalletOut(_newWallet, _assetsToMigrate, _whitelistToMigrate) # dev: migration failed\n\n    self.didMigrateOut = True\n    log UserWalletStartMigration(newWallet=_newWallet, numAssetsToMigrate=len(_assetsToMigrate), numWhitelistToMigrate=len(_whitelistToMigrate))\n    return True\n\n\n@external\ndef finishMigrationIn(\n    _whitelistToMigrate: DynArray[address, MAX_MIGRATION_WHITELIST],\n    _assetsMigrated: DynArray[address, MAX_MIGRATION_ASSETS],\n    _vaultTokensMigrated: DynArray[address, MAX_MIGRATION_ASSETS],\n) -> bool:\n    cd: CoreData = self._getCoreData()\n    assert not self.didMigrateIn # dev: already migrated\n\n    # validate migration\n    oldWallet: address = msg.sender\n    oldWalletConfig: address = staticcall UserWallet(oldWallet).walletConfig()\n    self._validateAltWalletDuringMigration(oldWallet, oldWalletConfig, cd.agentFactory)\n\n    # validate valid whitelist\n    if len(_whitelistToMigrate) != 0:\n        for r: address in _whitelistToMigrate:\n            assert staticcall WalletConfig(oldWalletConfig).isRecipientAllowed(r) # dev: old wallet has different whitelist\n            assert self._setWhitelistAddrFromMigration(r) # dev: failed to set whitelist address\n\n    # update yield tracking\n    if len(_vaultTokensMigrated) != 0:\n        for vaultToken: address in _vaultTokensMigrated:\n            self.isVaultToken[vaultToken] = True\n            self.vaultTokenAmounts[vaultToken] += staticcall WalletConfig(oldWalletConfig).vaultTokenAmounts(vaultToken)\n            self.depositedAmounts[vaultToken] += staticcall WalletConfig(oldWalletConfig).depositedAmounts(vaultToken)\n\n    self.didMigrateIn = True\n    log UserWalletFinishMigration(oldWallet=oldWallet, numWhitelistMigrated=len(_whitelistToMigrate), numVaultTokensMigrated=len(_vaultTokensMigrated), numAssetsMigrated=len(_assetsMigrated))\n    return True\n\n\n@view\n@internal\ndef _validateAltWalletDuringMigration(_altWallet: address, _altWalletConfig: address, _agentFactory: address):\n    assert staticcall AgentFactory(_agentFactory).isUserWallet(_altWallet) # dev: must be Underscore wallet\n\n    # make sure owner is the same\n    assert staticcall WalletConfig(_altWalletConfig).owner() == own.owner # dev: alt wallet has different owner\n\n    # cannot have any pending owner changes\n    assert not own._hasPendingOwnerChange() # dev: this wallet has pending owner change\n    assert not staticcall WalletConfig(_altWalletConfig).hasPendingOwnerChange() # dev: alt wallet has pending owner change\n\n    # make sure ambassador is the same\n    assert staticcall WalletConfig(_altWalletConfig).myAmbassador() == self.myAmbassador # dev: ambassador doesn't match\n\n\n##################\n# Agent Settings #\n##################\n\n\n# add or modify agent settings\n\n\n@nonreentrant\n@external\ndef addOrModifyAgent(\n    _agent: address,\n    _allowedAssets: DynArray[address, MAX_ASSETS] = [],\n    _allowedLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n    _allowedActions: AllowedActions = empty(AllowedActions),\n) -> bool:\n    \"\"\"\n    @notice Adds a new agent or modifies an existing agent's permissions\n        If empty arrays are provided, the agent has access to all assets and lego ids\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to add or modify\n    @param _allowedAssets List of assets the agent can interact with\n    @param _allowedLegoIds List of lego IDs the agent can use\n    @param _allowedActions The actions the agent can perform\n    @return bool True if the agent was successfully added or modified\n    \"\"\"\n    owner: address = own.owner\n    assert msg.sender == owner # dev: no perms\n    assert _agent != owner # dev: agent cannot be owner\n    assert _agent != empty(address) # dev: invalid agent\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    agentInfo.isActive = True\n\n    # allowed actions\n    agentInfo.allowedActions = _allowedActions\n    agentInfo.allowedActions.isSet = self._hasAllowedActionsSet(_allowedActions)\n\n    # sanitize other input data\n    agentInfo.allowedAssets, agentInfo.allowedLegoIds = self._sanitizeAgentInputData(_allowedAssets, _allowedLegoIds)\n\n    # get subscription info\n    priceSheets: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(PRICE_SHEETS_ID)\n    subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).getAgentSubPriceData(_agent)\n\n    isNewAgent: bool = (agentInfo.installBlock == 0)\n    if isNewAgent:\n        agentInfo.installBlock = block.number\n        if subInfo.usdValue != 0:\n            agentInfo.paidThroughBlock = block.number + subInfo.trialPeriod\n\n    # may not have had sub setup before\n    elif subInfo.usdValue != 0:\n        agentInfo.paidThroughBlock = max(agentInfo.paidThroughBlock, agentInfo.installBlock + subInfo.trialPeriod)\n\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    if isNewAgent:\n        log AgentAdded(agent=_agent, allowedAssets=len(agentInfo.allowedAssets), allowedLegoIds=len(agentInfo.allowedLegoIds))\n    else:\n        log AgentModified(agent=_agent, allowedAssets=len(agentInfo.allowedAssets), allowedLegoIds=len(agentInfo.allowedLegoIds))\n    return True\n\n\n@view\n@internal\ndef _sanitizeAgentInputData(\n    _allowedAssets: DynArray[address, MAX_ASSETS],\n    _allowedLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (DynArray[address, MAX_ASSETS], DynArray[uint256, MAX_LEGOS]):\n\n    # nothing to do here\n    if len(_allowedAssets) == 0 and len(_allowedLegoIds) == 0:\n        return _allowedAssets, _allowedLegoIds\n\n    # sanitize and dedupe assets\n    cleanAssets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(len(_allowedAssets), bound=MAX_ASSETS):\n        asset: address = _allowedAssets[i]\n        if asset == empty(address):\n            continue\n        if asset not in cleanAssets:\n            cleanAssets.append(asset)\n\n    # validate and dedupe lego ids\n    cleanLegoIds: DynArray[uint256, MAX_LEGOS] = []\n    if len(_allowedLegoIds) != 0:\n        legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(LEGO_REGISTRY_ID)\n        for i: uint256 in range(len(_allowedLegoIds), bound=MAX_LEGOS):\n            legoId: uint256 = _allowedLegoIds[i]\n            if not staticcall LegoRegistry(legoRegistry).isValidLegoId(legoId):\n                continue\n            if legoId not in cleanLegoIds:\n                cleanLegoIds.append(legoId)\n\n    return cleanAssets, cleanLegoIds\n\n\n# disable agent\n\n\n@nonreentrant\n@external\ndef disableAgent(_agent: address) -> bool:\n    \"\"\"\n    @notice Disables an existing agent\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to disable\n    @return bool True if the agent was successfully disabled\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n    agentInfo.isActive = False\n    self.agentSettings[_agent] = agentInfo\n\n    log AgentDisabled(agent=_agent, prevAllowedAssets=len(agentInfo.allowedAssets), prevAllowedLegoIds=len(agentInfo.allowedLegoIds))\n    return True\n\n\n# add lego id for agent\n\n\n@nonreentrant\n@external\ndef addLegoIdForAgent(_agent: address, _legoId: uint256) -> bool:\n    \"\"\"\n    @notice Adds a lego ID to an agent's allowed legos\n    @dev Can only be called by the owner\n    @param _agent The address of the agent\n    @param _legoId The lego ID to add\n    @return bool True if the lego ID was successfully added\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(LEGO_REGISTRY_ID)\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_legoId)\n    assert _legoId not in agentInfo.allowedLegoIds # dev: lego id already saved\n\n    # save data\n    agentInfo.allowedLegoIds.append(_legoId)\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    log LegoIdAddedToAgent(agent=_agent, legoId=_legoId)\n    return True\n\n\n# add asset for agent\n\n\n@nonreentrant\n@external\ndef addAssetForAgent(_agent: address, _asset: address) -> bool:\n    \"\"\"\n    @notice Adds an asset to an agent's allowed assets\n    @dev Can only be called by the owner\n    @param _agent The address of the agent\n    @param _asset The asset address to add\n    @return bool True if the asset was successfully added\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    assert _asset != empty(address) # dev: invalid asset\n    assert _asset not in agentInfo.allowedAssets # dev: asset already saved\n\n    # save data\n    agentInfo.allowedAssets.append(_asset)\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    log AssetAddedToAgent(agent=_agent, asset=_asset)\n    return True\n\n\n# modify allowed actions\n\n\n@nonreentrant\n@external\ndef modifyAllowedActions(_agent: address, _allowedActions: AllowedActions = empty(AllowedActions)) -> bool:\n    \"\"\"\n    @notice Modifies the allowed actions for an agent\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to modify\n    @param _allowedActions The new allowed actions\n    @return bool True if the allowed actions were successfully modified\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    agentInfo.allowedActions = _allowedActions\n    agentInfo.allowedActions.isSet = self._hasAllowedActionsSet(_allowedActions)\n    self.agentSettings[_agent] = agentInfo\n\n    log AllowedActionsModified(agent=_agent, canDeposit=_allowedActions.canDeposit, canWithdraw=_allowedActions.canWithdraw, canRebalance=_allowedActions.canRebalance, canTransfer=_allowedActions.canTransfer, canSwap=_allowedActions.canSwap, canConvert=_allowedActions.canConvert, canAddLiq=_allowedActions.canAddLiq, canRemoveLiq=_allowedActions.canRemoveLiq, canClaimRewards=_allowedActions.canClaimRewards, canBorrow=_allowedActions.canBorrow, canRepay=_allowedActions.canRepay)\n    return True\n\n\n@view\n@internal\ndef _hasAllowedActionsSet(_actions: AllowedActions) -> bool:\n    return _actions.canDeposit or _actions.canWithdraw or _actions.canRebalance or _actions.canTransfer or _actions.canSwap or _actions.canConvert\n\n\n######################\n# Transfer Whitelist #\n######################\n\n\n@view\n@external\ndef canTransferToRecipient(_recipient: address) -> bool:\n    \"\"\"\n    @notice Checks if a transfer to a recipient is allowed\n    @param _recipient The address of the recipient\n    @return bool True if the transfer is allowed, false otherwise\n    \"\"\"\n    if self.isRecipientAllowed[_recipient]:\n        return True\n\n    # pending ownership change, don't even check alt wallet ownership\n    if own._hasPendingOwnerChange():\n        return False\n\n    # if enabled, check if alt wallet has same owner\n    if self.canTransferToAltOwnerWallets:\n        return self._doesWalletHaveSameOwner(_recipient)\n\n    return False\n\n\n@view\n@external\ndef doesWalletHaveSameOwner(_wallet: address) -> bool:\n    return self._doesWalletHaveSameOwner(_wallet)\n\n\n@view\n@internal\ndef _doesWalletHaveSameOwner(_wallet: address) -> bool:\n    \"\"\"\n    @notice Checks if the wallet is an Underscore wallet with the same owner as this wallet\n    @dev This function verifies that:\n        1. The wallet is a valid Underscore wallet\n        2. The wallet config has no pending ownership changes\n        3. The wallet has the same owner as this wallet\n    @param _wallet The address of the wallet to check\n    @return bool True if the wallet is an Underscore wallet with the same owner, False otherwise\n    \"\"\"\n    isSame: bool = False\n\n    # check if wallet is Underscore wallet, if owner is same (no pending ownership changes), transfer is allowed\n    agentFactory: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    if staticcall AgentFactory(agentFactory).isUserWallet(_wallet):\n        walletConfig: address = staticcall UserWallet(_wallet).walletConfig()\n        if not staticcall WalletConfig(walletConfig).hasPendingOwnerChange():\n            isSame = own.owner == staticcall WalletConfig(walletConfig).owner()\n\n    return isSame\n\n\n@external\ndef setCanTransferToAltOwnerWallets(_canTransfer: bool) -> bool:\n    \"\"\"\n    @notice Sets the flag for allowing transfers to other AI wallets (with same owner)\n    @dev Can only be called by the owner\n    @param _canTransfer The new flag value (True or False)\n    @return bool True if the flag was successfully set\n    \"\"\"\n    assert msg.sender == own.owner # dev: only owner can set\n    if self.canTransferToAltOwnerWallets == _canTransfer:\n        return False\n    self.canTransferToAltOwnerWallets = _canTransfer\n    log CanTransferToAltOwnerWalletsSet(canTransfer=_canTransfer)\n    return True\n\n\n@nonreentrant\n@external\ndef addWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Adds an address to the whitelist\n    @dev Can only be called by the owner\n    @param _addr The address to add to the whitelist\n    \"\"\"\n    owner: address = own.owner\n    assert msg.sender == owner # dev: only owner can add whitelist\n\n    assert _addr != empty(address) # dev: invalid addr\n    assert _addr != owner # dev: owner cannot be whitelisted\n    assert _addr != self # dev: wallet config cannot be whitelisted\n    assert _addr != self.wallet # dev: wallet cannot be whitelisted\n    assert not self.isRecipientAllowed[_addr] # dev: already whitelisted\n    assert self.pendingWhitelist[_addr].initiatedBlock == 0 # dev: pending whitelist already exists\n\n    # this uses same delay as ownership change\n    confirmBlock: uint256 = block.number + own.ownershipChangeDelay\n    self.pendingWhitelist[_addr] = PendingWhitelist(\n        initiatedBlock = block.number,\n        confirmBlock = confirmBlock,\n    )\n    log WhitelistAddrPending(addr=_addr, confirmBlock=confirmBlock)\n\n\n@nonreentrant\n@external\ndef confirmWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Confirms a whitelist address\n    @dev Can only be called by the owner\n    @param _addr The address to confirm\n    \"\"\"\n    assert msg.sender == own.owner # dev: only owner can confirm\n\n    data: PendingWhitelist = self.pendingWhitelist[_addr]\n    assert data.initiatedBlock != 0 # dev: no pending whitelist\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n\n    self.pendingWhitelist[_addr] = empty(PendingWhitelist)\n    self.isRecipientAllowed[_addr] = True\n    log WhitelistAddrConfirmed(addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@nonreentrant\n@external\ndef cancelPendingWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Cancels a pending whitelist address\n    @dev Can only be called by the owner or governance\n    @param _addr The address to cancel\n    \"\"\"\n    agentFactory: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    assert msg.sender == own.owner or staticcall AgentFactory(agentFactory).canCancelCriticalAction(msg.sender) # dev: no perms (only owner or governance)\n\n    data: PendingWhitelist = self.pendingWhitelist[_addr]\n    assert data.initiatedBlock != 0 # dev: no pending whitelist\n    self.pendingWhitelist[_addr] = empty(PendingWhitelist)\n    log WhitelistAddrCancelled(addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, cancelledBy=msg.sender)\n\n\n@nonreentrant\n@external\ndef removeWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Removes an address from the whitelist\n    @dev Can only be called by the owner\n    @param _addr The address to remove from the whitelist\n    \"\"\"\n    assert msg.sender == own.owner # dev: only owner can remove whitelist\n    assert self.isRecipientAllowed[_addr] # dev: not on whitelist\n\n    self.isRecipientAllowed[_addr] = False\n    log WhitelistAddrRemoved(addr=_addr)\n\n\n@internal\ndef _setWhitelistAddrFromMigration(_addr: address) -> bool:\n    self.isRecipientAllowed[_addr] = True\n    log WhitelistAddrSetViaMigration(addr=_addr)\n    return True\n\n\n##################\n# Reserve Assets #\n##################\n\n\n@nonreentrant\n@external\ndef setReserveAsset(_asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Sets a reserve asset\n    @dev Can only be called by the owner\n    @param _asset The address of the asset to set\n    @param _amount The amount of the asset to set\n    @return bool True if the reserve asset was successfully set\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n    assert _asset != empty(address) # dev: invalid asset\n    self.reserveAssets[_asset] = _amount\n    log ReserveAssetSet(asset=_asset, amount=_amount)\n    return True\n\n\n@nonreentrant\n@external\ndef setManyReserveAssets(_assets: DynArray[ReserveAsset, MAX_ASSETS]) -> bool:\n    \"\"\"\n    @notice Sets multiple reserve assets\n    @dev Can only be called by the owner\n    @param _assets The array of reserve assets to set\n    @return bool True if the reserve assets were successfully set\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n    assert len(_assets) != 0 # dev: invalid array length\n    for i: uint256 in range(len(_assets), bound=MAX_ASSETS):\n        asset: address = _assets[i].asset\n        amount: uint256 = _assets[i].amount\n        assert asset != empty(address) # dev: invalid asset\n        self.reserveAssets[asset] = amount\n        log ReserveAssetSet(asset=asset, amount=amount)\n\n    return True\n\n\n########################\n# Ambassador Settings #\n########################\n\n\n@view\n@external\ndef getProceedsAddr() -> address:\n    \"\"\"\n    @notice Gets the address where proceeds should be forwarded to (if this wallet is an ambassador)\n    @dev Returns:\n        - empty address if wallet cannot be ambassador\n        - forwarder address if set\n        - wallet address as fallback\n    @return address The address where proceeds should be sent\n    \"\"\"\n    # cannot get proceeds\n    if not self.canWalletBeAmbassador:\n        return empty(address)\n\n    # forwarder set\n    forwarder: address = self.ambassadorForwarder\n    if forwarder != empty(address):\n        return forwarder\n\n    # return wallet\n    return self.wallet\n\n\n@nonreentrant\n@external\ndef setAmbassadorForwarder(_addr: address) -> bool:\n    \"\"\"\n    @notice Sets the forwarder address for the ambassador (where proceeds will be sent)\n    @dev Can only be called by the owner\n    @param _addr The address to forward proceeds to\n    @return bool True if the forwarder was successfully set\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n    if self.ambassadorForwarder == _addr or _addr == self.wallet:\n        return False\n\n    # make sure valid underscore wallet\n    agentFactory: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    if not staticcall UserWallet(_addr).canBeAmbassador() or not staticcall AgentFactory(agentFactory).isUserWallet(_addr):\n        return False\n\n    self.ambassadorForwarder = _addr\n    log AmbassadorForwarderSet(addr=_addr)\n    return True\n\n\n@nonreentrant\n@external\ndef setCanWalletBeAmbassador(_canWalletBeAmbassador: bool) -> bool:\n    \"\"\"\n    @notice Sets the flag for allowing the wallet to be an ambassador\n    @dev Can only be called by the owner\n    @param _canWalletBeAmbassador The new flag value (True or False)\n    @return bool True if the flag was successfully set\n    \"\"\"\n    assert msg.sender == own.owner # dev: no perms\n    if self.canWalletBeAmbassador == _canWalletBeAmbassador:\n        return False\n    self.canWalletBeAmbassador = _canWalletBeAmbassador\n    log CanWalletBeAmbassadorSet(canWalletBeAmbassador=_canWalletBeAmbassador)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address) -> bool:\n    \"\"\"\n    @notice transfers funds from the config contract to the main wallet\n    @dev anyone can call this!\n    @param _asset The address of the asset to recover\n    @return bool True if the funds were recovered successfully\n    \"\"\"\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    wallet: address = self.wallet\n    if empty(address) in [wallet, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(wallet, balance, default_return_value=True) # dev: recovery failed\n    log FundsRecovered(asset=_asset, recipient=wallet, balance=balance)\n    return True\n",
            "sha256sum": "2145ef04924c772e1ec5d94d67b083543e8f5654af767821fe99b8a5dbf8bf66"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/templates/UserWalletConfigTemplate.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "7521f4e6c36309d9c1b53667a6e884346944391f6a44291bfd80a5812335ffe9"
      },
      "args": ""
    },
    "AgentTemplate": {
      "address": "0x76Eb19Ae42c07a7AD50aFD58b579a7c45bd70183",
      "abi": [
        {
          "name": "AgentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeInitiated",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeConfirmed",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeCancelled",
          "inputs": [
            {
              "name": "cancelledOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingOwnerChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeOwnership",
          "inputs": [
            {
              "name": "_newOwner",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOwnershipChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "owner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingOwner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newOwner",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ownershipChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "_ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapActionHash",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            },
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performBatchActions",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                },
                {
                  "name": "swapInstructions",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "amountIn",
                      "type": "uint256"
                    },
                    {
                      "name": "minAmountOut",
                      "type": "uint256"
                    },
                    {
                      "name": "tokenPath",
                      "type": "address[]"
                    },
                    {
                      "name": "poolPath",
                      "type": "address[]"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performBatchActions",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                },
                {
                  "name": "swapInstructions",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "amountIn",
                      "type": "uint256"
                    },
                    {
                      "name": "minAmountOut",
                      "type": "uint256"
                    },
                    {
                      "name": "tokenPath",
                      "type": "address[]"
                    },
                    {
                      "name": "poolPath",
                      "type": "address[]"
                    }
                  ]
                }
              ]
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBatchActionHash",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                },
                {
                  "name": "swapInstructions",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "amountIn",
                      "type": "uint256"
                    },
                    {
                      "name": "minAmountOut",
                      "type": "uint256"
                    },
                    {
                      "name": "tokenPath",
                      "type": "address[]"
                    },
                    {
                      "name": "poolPath",
                      "type": "address[]"
                    }
                  ]
                }
              ]
            },
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "usedSignatures",
          "inputs": [
            {
              "name": "arg0",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_minOwnerChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxOwnerChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Ownership.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AgentFactory:\n    def canCancelCriticalAction(_addr: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct PendingOwner:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent OwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    cancelledBy: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeDelaySet:\n    delayBlocks: uint256\n\n# owner\nowner: public(address) # owner of the wallet\npendingOwner: public(PendingOwner) # pending owner of the wallet\nownershipChangeDelay: public(uint256) # num blocks to wait before owner can be changed\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\n_ADDY_REGISTRY: public(immutable(address))\n\nAGENT_FACTORY_ID: constant(uint256) = 1\n\n\n@deploy\ndef __init__(\n    _owner: address,\n    _addyRegistry: address,\n    _minOwnerChangeDelay: uint256,\n    _maxOwnerChangeDelay: uint256,\n):\n    assert empty(address) not in [_owner, _addyRegistry] # dev: invalid addrs\n    self.owner = _owner\n    _ADDY_REGISTRY = _addyRegistry\n\n    assert _minOwnerChangeDelay < _maxOwnerChangeDelay # dev: invalid delay\n    MIN_OWNER_CHANGE_DELAY = _minOwnerChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxOwnerChangeDelay\n    self.ownershipChangeDelay = _minOwnerChangeDelay\n\n\n####################\n# Ownership Change #\n####################\n\n\n@view\n@external\ndef hasPendingOwnerChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending ownership change\n    @return bool True if there is a pending ownership change, false otherwise\n    \"\"\"\n    return self._hasPendingOwnerChange()\n\n\n@view\n@internal\ndef _hasPendingOwnerChange() -> bool:\n    return self.pendingOwner.confirmBlock != 0\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    \"\"\"\n    @notice Initiates a new ownership change\n    @dev Can only be called by the current owner\n    @param _newOwner The address of the new owner\n    \"\"\"\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingOwner = PendingOwner(\n        newOwner= _newOwner,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log OwnershipChangeInitiated(prevOwner=currentOwner, newOwner=_newOwner, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmOwnershipChange():\n    \"\"\"\n    @notice Confirms the ownership change\n    @dev Can only be called by the new owner\n    \"\"\"\n    data: PendingOwner = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeConfirmed(prevOwner=prevOwner, newOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelOwnershipChange():\n    \"\"\"\n    @notice Cancels the ownership change\n    @dev Can only be called by the current owner or governance\n    \"\"\"\n    agentFactory: address = staticcall AddyRegistry(_ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    assert msg.sender == self.owner or staticcall AgentFactory(agentFactory).canCancelCriticalAction(msg.sender) # dev: no perms (only owner or governance)\n\n    data: PendingOwner = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeCancelled(cancelledOwner=data.newOwner, cancelledBy=msg.sender, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setOwnershipChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the ownership change delay\n    @dev Can only be called by the owner\n    @param _numBlocks The number of blocks to wait before ownership can be changed\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNER_CHANGE_DELAY and _numBlocks <= MAX_OWNER_CHANGE_DELAY # dev: invalid delay\n    self.ownershipChangeDelay = _numBlocks\n    log OwnershipChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "2f0e7c45d64763e64f27ede081332d3ba84c61832ea4721e2123a6cd7654870b"
          },
          "interfaces/UserWalletInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n# struct SwapInstruction:\n#     legoId: uint256\n#     amountIn: uint256\n#     minAmountOut: uint256\n#     tokenPath: DynArray[address, 5]\n#     poolPath: DynArray[address, 5 - 1]\n\n\n# @external\n# def swapTokens(_swapInstructions: DynArray[SwapInstruction, 5]) -> (uint256, uint256, uint256):\n#     ...\n\n\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    ...\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    ...\n\n\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    ...\n\n\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    ...\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    ...\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    ...\n",
            "sha256sum": "b6f85ddff061e77069cceb9d110c05c679a6ea34b68f3ff69c95c1b07d83c453"
          },
          "contracts/core/templates/AgentTemplate.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: own\nexports: own.__interface__\n\nimport contracts.modules.Ownership as own\nfrom interfaces import UserWalletInterface\nfrom ethereum.ercs import IERC20\n\ninterface UserWalletCustom:\n    def swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256): nonpayable\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct Signature:\n    signature: Bytes[65]\n    signer: address\n    expiration: uint256\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct ActionInstruction:\n    usePrevAmountOut: bool\n    action: ActionType\n    legoId: uint256\n    asset: address\n    vault: address\n    amount: uint256\n    altLegoId: uint256\n    altAsset: address\n    altVault: address\n    altAmount: uint256\n    minAmountOut: uint256\n    pool: address\n    proof: bytes32\n    nftAddr: address\n    nftTokenId: uint256\n    tickLower: int24\n    tickUpper: int24\n    minAmountA: uint256\n    minAmountB: uint256\n    minLpAmount: uint256\n    liqToRemove: uint256\n    recipient: address\n    isWethToEthConversion: bool\n    swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]\n\nevent AgentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nusedSignatures: public(HashMap[Bytes[65], bool])\n\n# eip-712\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\nDEPOSIT_TYPE_HASH: constant(bytes32) = keccak256('Deposit(address userWallet,uint256 legoId,address asset,address vault,uint256 amount,uint256 expiration)')\nWITHDRAWAL_TYPE_HASH: constant(bytes32) = keccak256('Withdrawal(address userWallet,uint256 legoId,address asset,address vaultToken,uint256 vaultTokenAmount,uint256 expiration)')\nREBALANCE_TYPE_HASH: constant(bytes32) = keccak256('Rebalance(address userWallet,uint256 fromLegoId,address fromAsset,address fromVaultToken,uint256 toLegoId,address toVault,uint256 fromVaultTokenAmount,uint256 expiration)')\nSWAP_ACTION_TYPE_HASH: constant(bytes32) =  keccak256('Swap(address userWallet,SwapInstruction[] swapInstructions,uint256 expiration)')\nSWAP_INSTRUCTION_TYPE_HASH: constant(bytes32) = keccak256('SwapInstruction(uint256 legoId,uint256 amountIn,uint256 minAmountOut,address[] tokenPath,address[] poolPath)')\nADD_LIQ_TYPE_HASH: constant(bytes32) = keccak256('AddLiquidity(address userWallet,uint256 legoId,address nftAddr,uint256 nftTokenId,address pool,address tokenA,address tokenB,uint256 amountA,uint256 amountB,int24 tickLower,int24 tickUpper,uint256 minAmountA,uint256 minAmountB,uint256 minLpAmount,uint256 expiration)')\nREMOVE_LIQ_TYPE_HASH: constant(bytes32) = keccak256('RemoveLiquidity(address userWallet,uint256 legoId,address nftAddr,uint256 nftTokenId,address pool,address tokenA,address tokenB,uint256 liqToRemove,uint256 minAmountA,uint256 minAmountB,uint256 expiration)')\nTRANSFER_TYPE_HASH: constant(bytes32) = keccak256('Transfer(address userWallet,address recipient,uint256 amount,address asset,uint256 expiration)')\nETH_TO_WETH_TYPE_HASH: constant(bytes32) = keccak256('EthToWeth(address userWallet,uint256 amount,uint256 depositLegoId,address depositVault,uint256 expiration)')\nWETH_TO_ETH_TYPE_HASH: constant(bytes32) = keccak256('WethToEth(address userWallet,uint256 amount,address recipient,uint256 withdrawLegoId,address withdrawVaultToken,uint256 expiration)')\nCLAIM_REWARDS_TYPE_HASH: constant(bytes32) = keccak256('ClaimRewards(address userWallet,uint256 legoId,address market,address rewardToken,uint256 rewardAmount,bytes32 proof,uint256 expiration)')\nBORROW_TYPE_HASH: constant(bytes32) = keccak256('Borrow(address userWallet,uint256 legoId,address borrowAsset,uint256 amount,uint256 expiration)')\nREPAY_TYPE_HASH: constant(bytes32) = keccak256('Repay(address userWallet,uint256 legoId,address paymentAsset,uint256 paymentAmount,uint256 expiration)')\nBATCH_ACTIONS_TYPE_HASH: constant(bytes32) =  keccak256('BatchActions(address userWallet,ActionInstruction[] instructions,uint256 expiration)')\nACTION_INSTRUCTION_TYPE_HASH: constant(bytes32) = keccak256('ActionInstruction(bool usePrevAmountOut,uint256 action,uint256 legoId,address asset,address vault,uint256 amount,uint256 altLegoId,address altAsset,address altVault,uint256 altAmount,uint256 minAmountOut,address pool,bytes32 proof,address nftAddr,uint256 nftTokenId,int24 tickLower,int24 tickUpper,uint256 minAmountA,uint256 minAmountB,uint256 minLpAmount,uint256 liqToRemove,address recipient,bool isWethToEthConversion,SwapInstruction[] swapInstructions)')\n\nMAX_INSTRUCTIONS: constant(uint256) = 20\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nAPI_VERSION: constant(String[28]) = \"0.0.2\"\n\n\n@deploy\ndef __init__(\n    _owner: address,\n    _addyRegistry: address,\n    _minOwnerChangeDelay: uint256,\n    _maxOwnerChangeDelay: uint256,\n):\n    \"\"\"\n    @notice Initializes the Agent contract with owner and registry settings\n    @dev Sets up the initial ownership and registry configuration for the agent\n    @param _owner The address that will own the agent\n    @param _addyRegistry The address of the registry contract\n    @param _minOwnerChangeDelay The minimum delay required for owner changes\n    @param _maxOwnerChangeDelay The maximum delay allowed for owner changes\n    \"\"\"\n    assert empty(address) not in [_owner, _addyRegistry] # dev: invalid addrs\n    own.__init__(_owner, _addyRegistry, _minOwnerChangeDelay, _maxOwnerChangeDelay)\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    return API_VERSION\n\n\n###########\n# Deposit #\n###########\n\n\n@nonreentrant\n@external\ndef depositTokens(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(DEPOSIT_TYPE_HASH, _userWallet, _legoId, _asset, _vault, _amount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).depositTokens(_legoId, _asset, _vault, _amount)\n\n\n############\n# Withdraw #\n############\n\n\n@nonreentrant\n@external\ndef withdrawTokens(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(WITHDRAWAL_TYPE_HASH, _userWallet, _legoId, _asset, _vaultToken, _vaultTokenAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).withdrawTokens(_legoId, _asset, _vaultToken, _vaultTokenAmount)\n\n\n#############\n# Rebalance #\n#############\n\n\n@nonreentrant\n@external\ndef rebalance(\n    _userWallet: address,\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REBALANCE_TYPE_HASH, _userWallet, _fromLegoId, _fromAsset, _fromVaultToken, _toLegoId, _toVault, _fromVaultTokenAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).rebalance(_fromLegoId, _fromAsset, _fromVaultToken, _toLegoId, _toVault, _fromVaultTokenAmount)\n\n\n########\n# Swap #\n########\n\n\n@nonreentrant\n@external\ndef swapTokens(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSwapSignature(self._hashSwapInstructions(_userWallet, _swapInstructions, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletCustom(_userWallet).swapTokens(_swapInstructions)\n\n\n@view\n@internal\ndef _encodeSwapInstruction(_instruction: SwapInstruction) -> Bytes[544]:\n    # Just encode, no hash\n    return abi_encode(\n        SWAP_INSTRUCTION_TYPE_HASH,\n        _instruction.legoId,\n        _instruction.amountIn,\n        _instruction.minAmountOut,\n        _instruction.tokenPath,\n        _instruction.poolPath\n    )\n\n\n@view\n@internal\ndef _encodeSwapInstructions(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> Bytes[2720]:\n    concatenated: Bytes[2720] = empty(Bytes[2720]) # max size for 5 instructions - 5*544\n    for i: uint256 in range(len(_swapInstructions), bound=MAX_SWAP_INSTRUCTIONS):\n        concatenated = convert(\n            concat(\n                concatenated, \n                self._encodeSwapInstruction(_swapInstructions[i])\n            ),\n            Bytes[2720]\n        )\n    return concatenated\n\n\n@view\n@internal\ndef _hashSwapInstructions(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _expiration: uint256,\n) -> Bytes[2880]:\n    # Now we encode everything and hash only once at the end\n    return abi_encode(\n        SWAP_ACTION_TYPE_HASH,\n        _userWallet,\n        self._encodeSwapInstructions(_swapInstructions),\n        _expiration\n    )\n\n\n@internal\ndef _isValidSwapSignature(_encodedValue: Bytes[2880], _sig: Signature):\n    encoded_hash: bytes32 = keccak256(_encodedValue)\n    domain_sep: bytes32 = self._domainSeparator()\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', domain_sep, encoded_hash))\n\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n@view\n@external\ndef getSwapActionHash(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _expiration: uint256,\n) -> bytes32:\n    encodedValue: Bytes[2880] = self._hashSwapInstructions(_userWallet, _swapInstructions, _expiration)\n    encoded_hash: bytes32 = keccak256(encodedValue)\n    return keccak256(concat(b'\\x19\\x01', self._domainSeparator(), encoded_hash))\n\n\n##################\n# Borrow + Repay #\n##################\n\n\n@nonreentrant\n@external\ndef borrow(\n    _userWallet: address,\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(BORROW_TYPE_HASH, _userWallet, _legoId, _borrowAsset, _amount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).borrow(_legoId, _borrowAsset, _amount)\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _userWallet: address,\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REPAY_TYPE_HASH, _userWallet, _legoId, _paymentAsset, _paymentAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).repayDebt(_legoId, _paymentAsset, _paymentAmount)\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _userWallet: address,\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(CLAIM_REWARDS_TYPE_HASH, _userWallet, _legoId, _market, _rewardToken, _rewardAmount, _proof, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    extcall UserWalletInterface(_userWallet).claimRewards(_legoId, _market, _rewardToken, _rewardAmount, _proof)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(ADD_LIQ_TYPE_HASH, _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).addLiquidity(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, bool):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REMOVE_LIQ_TYPE_HASH, _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).removeLiquidity(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB)\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _userWallet: address,\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(TRANSFER_TYPE_HASH, _userWallet, _recipient, _amount, _asset, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).transferFunds(_recipient, _amount, _asset)\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@nonreentrant\n@external\ndef convertEthToWeth(\n    _userWallet: address,\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256):\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(ETH_TO_WETH_TYPE_HASH, _userWallet, _amount, _depositLegoId, _depositVault, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).convertEthToWeth(_amount, _depositLegoId, _depositVault)\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(\n    _userWallet: address,\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> uint256:\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(WETH_TO_ETH_TYPE_HASH, _userWallet, _amount, _recipient, _withdrawLegoId, _withdrawVaultToken, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).convertWethToEth(_amount, _recipient, _withdrawLegoId, _withdrawVaultToken)\n\n\n#################\n# Batch Actions #\n#################\n\n\n@nonreentrant\n@external\ndef performBatchActions(\n    _userWallet: address,\n    _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> bool:\n    owner: address = own.owner\n    if msg.sender != owner:\n        self._isValidBatchSignature(self._hashBatchActions(_userWallet, _instructions, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n\n    assert len(_instructions) != 0 # dev: no instructions\n    prevAmountReceived: uint256 = 0\n\n    # not using these vars\n    naAddyA: address = empty(address)\n    naValueA: uint256 = 0\n    naValueB: uint256 = 0\n    naValueC: uint256 = 0\n    naValueD: uint256 = 0\n    naBool: bool = False\n\n    # iterate through instructions\n    for j: uint256 in range(len(_instructions), bound=MAX_INSTRUCTIONS):\n        i: ActionInstruction = _instructions[j]\n\n        # deposit\n        if i.action == ActionType.DEPOSIT:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).depositTokens(i.legoId, i.asset, i.vault, amount)\n\n        # withdraw\n        elif i.action == ActionType.WITHDRAWAL:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            prevAmountReceived, naValueA, naValueB = extcall UserWalletInterface(_userWallet).withdrawTokens(i.legoId, i.asset, i.vault, amount)\n\n        # rebalance\n        elif i.action == ActionType.REBALANCE:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).rebalance(i.legoId, i.asset, i.vault, i.altLegoId, i.altVault, amount)\n\n        # swap\n        elif i.action == ActionType.SWAP:\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                i.swapInstructions[0].amountIn = prevAmountReceived\n            naValueA, prevAmountReceived, naValueB = extcall UserWalletCustom(_userWallet).swapTokens(i.swapInstructions)\n\n        # borrow\n        elif i.action == ActionType.BORROW:\n            naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).borrow(i.legoId, i.asset, i.amount)\n\n        # repay debt\n        elif i.action == ActionType.REPAY:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            extcall UserWalletInterface(_userWallet).repayDebt(i.legoId, i.asset, amount)\n            prevAmountReceived = 0\n\n        # claim rewards\n        elif i.action == ActionType.CLAIM_REWARDS:\n            extcall UserWalletInterface(_userWallet).claimRewards(i.legoId, i.asset, i.altAsset, i.amount, i.proof)\n            prevAmountReceived = 0\n\n        # add liquidity\n        elif i.action == ActionType.ADD_LIQ:\n            amount: uint256 = i.amount # this only goes towards token A amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            prevAmountReceived, naValueA, naValueB, naValueC, naValueD = extcall UserWalletInterface(_userWallet).addLiquidity(i.legoId, i.nftAddr, i.nftTokenId, i.pool, i.asset, i.altAsset, amount, i.altAmount, i.tickLower, i.tickUpper, i.minAmountA, i.minAmountB, i.minLpAmount)\n\n        # remove liquidity\n        elif i.action == ActionType.REMOVE_LIQ:\n            amount: uint256 = i.liqToRemove # this only goes to `_liqToRemove`\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naValueB, naValueC, naBool = extcall UserWalletInterface(_userWallet).removeLiquidity(i.legoId, i.nftAddr, i.nftTokenId, i.pool, i.asset, i.altAsset, amount, i.minAmountA, i.minAmountB)\n            prevAmountReceived = 0\n\n        # transfer\n        elif i.action == ActionType.TRANSFER:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            extcall UserWalletInterface(_userWallet).transferFunds(i.recipient, amount, i.asset)\n            prevAmountReceived = 0\n\n        # conversion\n        elif i.action == ActionType.CONVERSION:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            if i.isWethToEthConversion:\n                prevAmountReceived = extcall UserWalletInterface(_userWallet).convertWethToEth(amount, i.recipient, i.legoId, i.vault)\n            else:\n                prevAmountReceived, naAddyA, naValueB = extcall UserWalletInterface(_userWallet).convertEthToWeth(amount, i.legoId, i.vault)\n                if naValueB != 0:\n                    prevAmountReceived = naValueB\n\n    return True\n\n\n@view\n@internal\ndef _encodeBatchActionInstruction(_instr: ActionInstruction) -> Bytes[3552]:\n    encodedSwapInstructions: Bytes[2720] = self._encodeSwapInstructions(_instr.swapInstructions)\n\n    # Just encode, no hash\n    return abi_encode(\n        ACTION_INSTRUCTION_TYPE_HASH,\n        _instr.usePrevAmountOut,\n        _instr.action,\n        _instr.legoId,\n        _instr.asset,\n        _instr.vault,\n        _instr.amount,\n        _instr.altLegoId,\n        _instr.altAsset,\n        _instr.altVault,\n        _instr.altAmount,\n        _instr.minAmountOut,\n        _instr.pool,\n        _instr.proof,\n        _instr.nftAddr,\n        _instr.nftTokenId,\n        _instr.tickLower,\n        _instr.tickUpper,\n        _instr.minAmountA,\n        _instr.minAmountB,\n        _instr.minLpAmount,\n        _instr.liqToRemove,\n        _instr.recipient,\n        _instr.isWethToEthConversion,\n        encodedSwapInstructions\n    )\n\n\n@view\n@internal\ndef _encodeBatchInstructions(_instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS]) -> Bytes[15360]:\n    concatenated: Bytes[15360] = empty(Bytes[15360]) # max size for 20 instructions - 20*768\n    for i: uint256 in range(len(_instructions), bound=MAX_INSTRUCTIONS):\n        concatenated = convert(\n            concat(\n                concatenated, \n                self._encodeBatchActionInstruction(_instructions[i])\n            ),\n            Bytes[15360]\n        )\n    return concatenated\n\n\n@view\n@internal\ndef _hashBatchActions(_userWallet: address, _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS], _expiration: uint256) -> Bytes[15520]:\n    # Now we encode everything and hash only once at the end\n    return abi_encode(\n        BATCH_ACTIONS_TYPE_HASH,\n        _userWallet,\n        self._encodeBatchInstructions(_instructions),\n        _expiration\n    )\n\n\n@internal\ndef _isValidBatchSignature(_encodedValue: Bytes[15520], _sig: Signature):\n    encoded_hash: bytes32 = keccak256(_encodedValue)\n    domain_sep: bytes32 = self._domainSeparator()\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', domain_sep, encoded_hash))\n\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n@view\n@external\ndef getBatchActionHash(_userWallet: address, _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS], _expiration: uint256) -> bytes32:\n    encodedValue: Bytes[15520] = self._hashBatchActions(_userWallet, _instructions, _expiration)\n    encoded_hash: bytes32 = keccak256(encodedValue)\n    return keccak256(concat(b'\\x19\\x01', self._domainSeparator(), encoded_hash))\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    return keccak256(\n        concat(\n            DOMAIN_TYPE_HASH,\n            keccak256('UnderscoreAgent'),\n            keccak256(API_VERSION),\n            abi_encode(chain.id, self)\n        )\n    )\n\n\n@internal\ndef _isValidSignature(_encodedValue: Bytes[512], _sig: Signature):\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', self._domainSeparator(), keccak256(_encodedValue)))\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address) -> bool:\n    \"\"\"\n    @notice Transfers funds from the agent wallet to the owner\n    @dev Only callable by the owner\n    @param _asset The address of the asset to recover\n    @return bool True if the funds were recovered successfully, False if no funds to recover\n    \"\"\"\n    owner: address = own.owner\n    assert msg.sender == owner # dev: no perms\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [owner, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(owner, balance, default_return_value=True) # dev: recovery failed\n    log AgentFundsRecovered(asset=_asset, recipient=owner, balance=balance)\n    return True\n",
            "sha256sum": "fa81cf28d731c83858f1526066510ee543d18e5aa5d15d2e640e30b72d5d17f3"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/templates/AgentTemplate.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "221a6c5ca40933af26a45c45ddb1b12d8375c6d4b786c7cbae86553ee28239e6"
      },
      "args": ""
    },
    "AgentFactory": {
      "address": "0xd5a1cc447D94114136A5a8828F59d5a1cfe65038",
      "abi": [
        {
          "name": "UserWalletCreated",
          "inputs": [
            {
              "name": "mainAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "configAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "agent",
              "type": "address",
              "indexed": false
            },
            {
              "name": "ambassador",
              "type": "address",
              "indexed": false
            },
            {
              "name": "creator",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentCreated",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "creator",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateInitiated",
          "inputs": [
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "addressType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "addressType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "cancelledTemplate",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "addressType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "shouldWhitelist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldEnforceWhitelistSet",
          "inputs": [
            {
              "name": "shouldEnforce",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NumUserWalletsAllowedSet",
          "inputs": [
            {
              "name": "numAllowed",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NumAgentsAllowedSet",
          "inputs": [
            {
              "name": "numAllowed",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentBlacklistSet",
          "inputs": [
            {
              "name": "agentAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldBlacklist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanCriticalCancelSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canCancel",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TrialFundsDataSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorYieldBonusPaid",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ambassador",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ratio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorBonusRatioSet",
          "inputs": [
            {
              "name": "ratio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentFactoryFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentFactoryActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserWallet",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_ambassador",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_ambassador",
              "type": "address"
            },
            {
              "name": "_shouldUseTrialFunds",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgent",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createAgent",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createAgent",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateUserWalletTemplateUpdate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmUserWalletTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelUserWalletTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserWalletTemplateAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserWalletTemplateInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPendingUserWalletTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingUserWalletTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateUserWalletConfigTemplateUpdate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmUserWalletConfigTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelUserWalletConfigTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserWalletConfigTemplateAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserWalletConfigTemplateInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPendingUserWalletConfigTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingUserWalletConfigTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateAgentTemplateUpdate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAgentTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAgentTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentTemplateAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentTemplateInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPendingAgentTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAgentTemplateUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAddressChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWhitelist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldWhitelist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldEnforceWhitelist",
          "inputs": [
            {
              "name": "_shouldEnforce",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumUserWalletsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumUserWalletsAllowed",
          "inputs": [
            {
              "name": "_numAllowed",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumAgentsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumAgentsAllowed",
          "inputs": [
            {
              "name": "_numAllowed",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentBlacklist",
          "inputs": [
            {
              "name": "_agentAddr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canCancelCriticalAction",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanCriticalCancel",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_canCancel",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setTrialFundsData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "clawBackTrialFunds",
          "inputs": [
            {
              "name": "_wallets",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "clawBackTrialFundsLegacy",
          "inputs": [
            {
              "name": "_recoveries",
              "type": "tuple[]",
              "components": [
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "opportunities",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "legoId",
                      "type": "uint256"
                    },
                    {
                      "name": "vaultToken",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "payAmbassadorYieldBonus",
          "inputs": [
            {
              "name": "_ambassador",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAmbassadorBonusRatio",
          "inputs": [
            {
              "name": "_bonusRatio",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateDefaultAgentUpdate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmDefaultAgentUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelDefaultAgentUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDefaultAgentAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDefaultAgentInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPendingDefaultAgentUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingDefaultAgentUpdate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsFromAgentFactory",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserWalletLocal",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserWallets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgentLocal",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAgents",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addressInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddress",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addressChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ambassadorBonusRatio",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserWalletsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAgentsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "whitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "shouldEnforceWhitelist",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentBlacklist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canCriticalCancel",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH_ADDR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_ADDRESS_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_ADDRESS_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_userWalletTemplate",
              "type": "address"
            },
            {
              "name": "_userConfigTemplate",
              "type": "address"
            },
            {
              "name": "_agentTemplate",
              "type": "address"
            },
            {
              "name": "_defaultAgent",
              "type": "address"
            },
            {
              "name": "_minChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/core/AgentFactory.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\n\ninterface MainWallet:\n    def recoverTrialFunds(_opportunities: DynArray[TrialFundsOpp, MAX_LEGOS]) -> bool: nonpayable\n    def clawBackTrialFunds() -> bool: nonpayable\n    def canBeAmbassador() -> bool: view\n    def apiVersion() -> String[28]: view\n\ninterface AddyRegistry:\n    def setIsUserWalletOrAgent(_addr: address, _isThing: bool, _setUserWalletMap: bool) -> bool: nonpayable\n    def isUserWallet(_addr: address) -> bool: view\n    def isAgent(_addr: address) -> bool: view\n\ninterface WalletConfig:\n    def setWallet(_wallet: address) -> bool: nonpayable\n\nflag AddressTypes:\n    USER_WALLET_TEMPLATE\n    USER_WALLET_CONFIG_TEMPLATE\n    AGENT_TEMPLATE\n    DEFAULT_AGENT\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n\nstruct PendingAddress:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct TrialFundsData:\n    asset: address\n    amount: uint256\n\nstruct TrialFundsOpp:\n    legoId: uint256\n    vaultToken: address\n\nstruct TrialFundsRecovery:\n    wallet: address\n    opportunities: DynArray[TrialFundsOpp, MAX_LEGOS]\n\nevent UserWalletCreated:\n    mainAddr: indexed(address)\n    configAddr: indexed(address)\n    owner: indexed(address)\n    agent: address\n    ambassador: address\n    creator: address\n\nevent AgentCreated:\n    agent: indexed(address)\n    owner: indexed(address)\n    creator: address\n\nevent AddressUpdateInitiated:\n    prevAddr: indexed(address)\n    newAddr: indexed(address)\n    confirmBlock: uint256\n    addressType: AddressTypes\n\nevent AddressUpdateConfirmed:\n    prevAddr: indexed(address)\n    newAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    addressType: AddressTypes\n\nevent AddressUpdateCancelled:\n    cancelledTemplate: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    addressType: AddressTypes\n\nevent AddressChangeDelaySet:\n    delayBlocks: uint256\n\nevent WhitelistSet:\n    addr: address\n    shouldWhitelist: bool\n\nevent ShouldEnforceWhitelistSet:\n    shouldEnforce: bool\n\nevent NumUserWalletsAllowedSet:\n    numAllowed: uint256\n\nevent NumAgentsAllowedSet:\n    numAllowed: uint256\n\nevent AgentBlacklistSet:\n    agentAddr: indexed(address)\n    shouldBlacklist: bool\n\nevent CanCriticalCancelSet:\n    addr: indexed(address)\n    canCancel: bool\n\nevent TrialFundsDataSet:\n    asset: indexed(address)\n    amount: uint256\n\nevent AmbassadorYieldBonusPaid:\n    user: indexed(address)\n    ambassador: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    ratio: uint256\n\nevent AmbassadorBonusRatioSet:\n    ratio: uint256\n\nevent AgentFactoryFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent AgentFactoryActivated:\n    isActivated: bool\n\n# user wallets\nisUserWalletLocal: public(HashMap[address, bool])\nnumUserWallets: public(uint256)\n\n# agents\nisAgentLocal: public(HashMap[address, bool])\nnumAgents: public(uint256)\n\n# important addresses (mostly templates)\naddressInfo: public(HashMap[AddressTypes, AddressInfo])\npendingAddress: public(HashMap[AddressTypes, PendingAddress])\naddressChangeDelay: public(uint256)\n\n# ambassador bonus\nambassadorBonusRatio: public(uint256)\n\n# trial funds\ntrialFundsData: public(TrialFundsData)\n\n# limits / controls\nnumUserWalletsAllowed: public(uint256)\nnumAgentsAllowed: public(uint256)\nwhitelist: public(HashMap[address, bool])\nshouldEnforceWhitelist: public(bool)\nagentBlacklist: public(HashMap[address, bool])\ncanCriticalCancel: public(HashMap[address, bool])\n\n# config\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\nWETH_ADDR: public(immutable(address))\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_RECOVERIES: constant(uint256) = 100\nMAX_LEGOS: constant(uint256) = 20\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMIN_ADDRESS_CHANGE_DELAY: public(immutable(uint256))\nMAX_ADDRESS_CHANGE_DELAY: public(immutable(uint256))\n\n\n@deploy\ndef __init__(\n    _addyRegistry: address,\n    _wethAddr: address,\n    _userWalletTemplate: address,\n    _userConfigTemplate: address,\n    _agentTemplate: address,\n    _defaultAgent: address,\n    _minChangeDelay: uint256,\n    _maxChangeDelay: uint256,\n):\n    assert empty(address) not in [_addyRegistry, _wethAddr] # dev: invalid addrs\n    ADDY_REGISTRY = _addyRegistry\n    WETH_ADDR = _wethAddr\n\n    assert _minChangeDelay <= _maxChangeDelay # dev: invalid delay\n    MIN_OWNER_CHANGE_DELAY = _minChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxChangeDelay\n    MIN_ADDRESS_CHANGE_DELAY = _minChangeDelay\n    MAX_ADDRESS_CHANGE_DELAY = _maxChangeDelay\n\n    self.addressChangeDelay = _minChangeDelay\n    self.isActivated = True\n\n    # set user wallet templates\n    if self._isValidAddress(_userWalletTemplate, empty(address)) and self._isValidAddress(_userConfigTemplate, empty(address)):\n        self._setAddress(AddressTypes.USER_WALLET_TEMPLATE, _userWalletTemplate, 1)\n        self._setAddress(AddressTypes.USER_WALLET_CONFIG_TEMPLATE, _userConfigTemplate, 1)\n\n    # set agent template\n    if self._isValidAddress(_agentTemplate, empty(address)):\n        self._setAddress(AddressTypes.AGENT_TEMPLATE, _agentTemplate, 1)\n\n    # set default agent\n    if self._isValidAddress(_defaultAgent, empty(address)):\n        self._setAddress(AddressTypes.DEFAULT_AGENT, _defaultAgent, 1)\n\n    # local gov\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n\n######################\n# Create User Wallet #\n######################\n\n\n@view\n@external\ndef isUserWallet(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is a user wallet within Underscore Protocol\n    @dev Returns True if the address is a user wallet, False otherwise\n    \"\"\"\n    return self._isUserWallet(_addr)\n\n\n@view\n@internal\ndef _isUserWallet(_addr: address) -> bool:\n    isUserWallet: bool = self.isUserWalletLocal[_addr]\n    if isUserWallet:\n        return True\n    return staticcall AddyRegistry(ADDY_REGISTRY).isUserWallet(_addr)\n\n\n@external\ndef createUserWallet(\n    _owner: address = msg.sender,\n    _ambassador: address = empty(address),\n    _shouldUseTrialFunds: bool = True,\n) -> address:\n    \"\"\"\n    @notice Create a new User Wallet with specified owner and optional agent\n    @dev Creates a minimal proxy of the current template and initializes it\n    @param _owner The address that will own the wallet (defaults to msg.sender)\n    @param _ambassador The address of the ambassador who invited the user (defaults to empty address)\n    @param _shouldUseTrialFunds Whether to use trial funds (defaults to True)\n    @return The address of the newly created wallet, or empty address if setup is invalid\n    \"\"\"\n    assert self.isActivated # dev: not activated\n\n    # get templates\n    userWalletTemplate: address = self.addressInfo[AddressTypes.USER_WALLET_TEMPLATE].addr\n    walletConfigTemplate: address = self.addressInfo[AddressTypes.USER_WALLET_CONFIG_TEMPLATE].addr\n    assert empty(address) not in [userWalletTemplate, walletConfigTemplate, _owner] # dev: invalid setup\n\n    # check safety / limits\n    if self.shouldEnforceWhitelist and not self.whitelist[msg.sender]:\n        return empty(address)\n    if self.numUserWallets >= self.numUserWalletsAllowed:\n        return empty(address)\n\n    # validate ambassador\n    ambassador: address = empty(address)\n    if _ambassador != empty(address):\n        assert self._isUserWallet(_ambassador) # dev: ambassador must be Underscore wallet\n        version: String[28] = staticcall MainWallet(_ambassador).apiVersion()\n        if version != \"0.0.1\" and version != \"0.0.2\" and staticcall MainWallet(_ambassador).canBeAmbassador():\n            ambassador = _ambassador\n\n    # initial trial funds asset + amount\n    trialFundsData: TrialFundsData = self.trialFundsData\n    if _shouldUseTrialFunds and trialFundsData.asset != empty(address):\n        trialFundsData.amount = min(trialFundsData.amount, staticcall IERC20(trialFundsData.asset).balanceOf(self))\n\n    # create wallet contracts\n    defaultAgent: address = self.addressInfo[AddressTypes.DEFAULT_AGENT].addr\n    walletConfigAddr: address = create_from_blueprint(walletConfigTemplate, _owner, defaultAgent, ambassador, ADDY_REGISTRY, MIN_OWNER_CHANGE_DELAY, MAX_OWNER_CHANGE_DELAY)\n    mainWalletAddr: address = create_from_blueprint(userWalletTemplate, walletConfigAddr, ADDY_REGISTRY, WETH_ADDR, trialFundsData.asset, trialFundsData.amount)\n    assert extcall WalletConfig(walletConfigAddr).setWallet(mainWalletAddr) # dev: could not set wallet\n\n    # transfer after initialization\n    if trialFundsData.amount != 0:\n        assert extcall IERC20(trialFundsData.asset).transfer(mainWalletAddr, trialFundsData.amount, default_return_value=True) # dev: gift transfer failed\n\n    # update data\n    assert extcall AddyRegistry(ADDY_REGISTRY).setIsUserWalletOrAgent(mainWalletAddr, True, True) # dev: could not set is user wallet\n    self.isUserWalletLocal[mainWalletAddr] = True\n    self.numUserWallets += 1\n\n    log UserWalletCreated(mainAddr=mainWalletAddr, configAddr=walletConfigAddr, owner=_owner, agent=defaultAgent, ambassador=ambassador, creator=msg.sender)\n    return mainWalletAddr\n\n\n################\n# Create Agent #\n################\n\n\n@view\n@external\ndef isAgent(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is an agent within Underscore Protocol\n    @dev Returns True if the address is an agent, False otherwise\n    \"\"\"\n    return self._isAgent(_addr)\n\n\n@view\n@internal\ndef _isAgent(_addr: address) -> bool:\n    isAgent: bool = self.isAgentLocal[_addr]\n    if isAgent:\n        return True\n    return staticcall AddyRegistry(ADDY_REGISTRY).isAgent(_addr)\n\n\n@external\ndef createAgent(_owner: address = msg.sender) -> address:\n    \"\"\"\n    @notice Create a new Agent with specified owner\n    @dev Creates a minimal proxy of the current template and initializes it\n    @param _owner The address that will own the agent (defaults to msg.sender)\n    @return The address of the newly created agent, or empty address if setup is invalid\n    \"\"\"\n    assert self.isActivated # dev: not activated\n\n    agentTemplate: address = self.addressInfo[AddressTypes.AGENT_TEMPLATE].addr\n    assert empty(address) not in [agentTemplate, _owner] # dev: invalid setup\n\n    # check limits\n    if self.shouldEnforceWhitelist and not self.whitelist[msg.sender]:\n        return empty(address)\n    if self.numAgents >= self.numAgentsAllowed:\n        return empty(address)\n\n    # create agent contract\n    agentAddr: address = create_from_blueprint(agentTemplate, _owner, ADDY_REGISTRY, MIN_OWNER_CHANGE_DELAY, MAX_OWNER_CHANGE_DELAY)\n\n    # update data\n    assert extcall AddyRegistry(ADDY_REGISTRY).setIsUserWalletOrAgent(agentAddr, True, False) # dev: could not set is agent\n    self.isAgentLocal[agentAddr] = True\n    self.numAgents += 1\n\n    log AgentCreated(agent=agentAddr, owner=_owner, creator=msg.sender)\n    return agentAddr\n\n\n#############\n# Templates #\n#############\n\n\n# core user wallet\n\n\n@external\ndef initiateUserWalletTemplateUpdate(_newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._initiateAddressUpdate(AddressTypes.USER_WALLET_TEMPLATE, _newAddr, self.addressInfo[AddressTypes.USER_WALLET_TEMPLATE].addr)\n\n\n@external\ndef confirmUserWalletTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._confirmAddressUpdate(AddressTypes.USER_WALLET_TEMPLATE)\n\n\n@external\ndef cancelUserWalletTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._cancelAddressUpdate(AddressTypes.USER_WALLET_TEMPLATE)\n\n\n@view\n@external\ndef getUserWalletTemplateAddr() -> address:\n    return self.addressInfo[AddressTypes.USER_WALLET_TEMPLATE].addr\n\n\n@view\n@external\ndef getUserWalletTemplateInfo() -> AddressInfo:\n    return self.addressInfo[AddressTypes.USER_WALLET_TEMPLATE]\n\n\n@view\n@external\ndef getPendingUserWalletTemplateUpdate() -> PendingAddress:\n    return self.pendingAddress[AddressTypes.USER_WALLET_TEMPLATE]\n\n\n@view\n@external\ndef hasPendingUserWalletTemplateUpdate() -> bool:\n    return self._hasPendingAddressUpdate(AddressTypes.USER_WALLET_TEMPLATE)\n\n\n# user wallet config\n\n\n@external\ndef initiateUserWalletConfigTemplateUpdate(_newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._initiateAddressUpdate(AddressTypes.USER_WALLET_CONFIG_TEMPLATE, _newAddr, self.addressInfo[AddressTypes.USER_WALLET_CONFIG_TEMPLATE].addr)\n\n\n@external\ndef confirmUserWalletConfigTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._confirmAddressUpdate(AddressTypes.USER_WALLET_CONFIG_TEMPLATE)\n\n\n@external\ndef cancelUserWalletConfigTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._cancelAddressUpdate(AddressTypes.USER_WALLET_CONFIG_TEMPLATE)\n\n\n@view\n@external\ndef getUserWalletConfigTemplateAddr() -> address:\n    return self.addressInfo[AddressTypes.USER_WALLET_CONFIG_TEMPLATE].addr\n\n\n@view\n@external\ndef getUserWalletConfigTemplateInfo() -> AddressInfo:\n    return self.addressInfo[AddressTypes.USER_WALLET_CONFIG_TEMPLATE]\n\n\n@view\n@external\ndef getPendingUserWalletConfigTemplateUpdate() -> PendingAddress:\n    return self.pendingAddress[AddressTypes.USER_WALLET_CONFIG_TEMPLATE]\n\n\n@view\n@external\ndef hasPendingUserWalletConfigTemplateUpdate() -> bool:\n    return self._hasPendingAddressUpdate(AddressTypes.USER_WALLET_CONFIG_TEMPLATE)\n\n\n# agent template\n\n\n@external\ndef initiateAgentTemplateUpdate(_newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._initiateAddressUpdate(AddressTypes.AGENT_TEMPLATE, _newAddr, self.addressInfo[AddressTypes.AGENT_TEMPLATE].addr)\n\n\n@external\ndef confirmAgentTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._confirmAddressUpdate(AddressTypes.AGENT_TEMPLATE)\n\n\n@external\ndef cancelAgentTemplateUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._cancelAddressUpdate(AddressTypes.AGENT_TEMPLATE)\n\n\n@view\n@external\ndef getAgentTemplateAddr() -> address:\n    return self.addressInfo[AddressTypes.AGENT_TEMPLATE].addr\n\n\n@view\n@external\ndef getAgentTemplateInfo() -> AddressInfo:\n    return self.addressInfo[AddressTypes.AGENT_TEMPLATE]\n\n\n@view\n@external\ndef getPendingAgentTemplateUpdate() -> PendingAddress:\n    return self.pendingAddress[AddressTypes.AGENT_TEMPLATE]\n\n\n@view\n@external\ndef hasPendingAgentTemplateUpdate() -> bool:\n    return self._hasPendingAddressUpdate(AddressTypes.AGENT_TEMPLATE)\n\n\n# shared utilities\n\n\n@view\n@internal\ndef _hasPendingAddressUpdate(_addressType: AddressTypes) -> bool:\n    return self.pendingAddress[_addressType].confirmBlock != 0\n\n\n@view\n@internal\ndef _isValidAddress(_newAddr: address, _oldAddr: address) -> bool:\n    if _newAddr == empty(address) or not _newAddr.is_contract:\n        return False\n    return _newAddr != _oldAddr\n\n\n@internal\ndef _initiateAddressUpdate(_addressType: AddressTypes, _newAddr: address, _oldAddr: address) -> bool:\n    \"\"\"\n    @notice Initiate an address update\n    @dev Only callable by the governor, updates the address change delay\n    @param _addressType The type of address to update\n    @param _newAddr The new address\n    @param _oldAddr The old address\n    @return True if the address update was initiated successfully, False otherwise\n    \"\"\"\n    if not self._isValidAddress(_newAddr, _oldAddr):\n        return False\n\n    confirmBlock: uint256 = block.number + self.addressChangeDelay\n    self.pendingAddress[_addressType] = PendingAddress(\n        newAddr= _newAddr,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log AddressUpdateInitiated(prevAddr=_oldAddr, newAddr=_newAddr, confirmBlock=confirmBlock, addressType=_addressType)\n    return True\n\n\n@internal\ndef _confirmAddressUpdate(_addressType: AddressTypes) -> bool:\n    \"\"\"\n    @notice Confirm an address update\n    @dev Only callable by the governor, updates the address\n    @param _addressType The type of address to update\n    @return True if the address update was confirmed successfully, False otherwise\n    \"\"\"\n    data: PendingAddress = self.pendingAddress[_addressType]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n\n    prevTemplateInfo: AddressInfo = self.addressInfo[_addressType]\n    if not self._isValidAddress(data.newAddr, prevTemplateInfo.addr):\n        self.pendingAddress[_addressType] = empty(PendingAddress)\n        return False\n\n    self._setAddress(_addressType, data.newAddr, prevTemplateInfo.version + 1)\n    self.pendingAddress[_addressType] = empty(PendingAddress)\n    log AddressUpdateConfirmed(prevAddr=prevTemplateInfo.addr, newAddr=data.newAddr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, addressType=_addressType)\n    return True\n\n\n@internal\ndef _setAddress(_addressType: AddressTypes, _newAddr: address, _newVersion: uint256):\n    self.addressInfo[_addressType] = AddressInfo(\n        addr= _newAddr,\n        version= _newVersion,\n        lastModified=block.timestamp,\n    )\n\n\n@internal\ndef _cancelAddressUpdate(_addressType: AddressTypes) -> bool:\n    \"\"\"\n    @notice Cancel an address update\n    @dev Only callable by the governor, cancels the address update\n    @param _addressType The type of address to update\n    @return True if the address update was cancelled successfully, False otherwise\n    \"\"\"\n    data: PendingAddress = self.pendingAddress[_addressType]\n    assert data.confirmBlock != 0 # dev: no pending change\n\n    self.pendingAddress[_addressType] = empty(PendingAddress)\n    log AddressUpdateCancelled(cancelledTemplate=data.newAddr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, addressType=_addressType)\n    return True\n\n\n# time delay config\n\n\n@external\ndef setAddressChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Set the address change delay\n    @dev Only callable by the governor, updates the address change delay\n    @param _numBlocks The new address change delay in blocks\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_ADDRESS_CHANGE_DELAY and _numBlocks <= MAX_ADDRESS_CHANGE_DELAY # dev: invalid delay\n    self.addressChangeDelay = _numBlocks\n    log AddressChangeDelaySet(delayBlocks=_numBlocks)\n\n\n###################\n# Safety / Limits #\n###################\n\n\n# who can create wallets / agents\n\n\n@external\ndef setWhitelist(_addr: address, _shouldWhitelist: bool) -> bool:\n    \"\"\"\n    @notice Set the whitelist status for a given address\n    @dev Only callable by the governor, updates the whitelist state\n    @param _addr The address to set the whitelist status for\n    @param _shouldWhitelist True to whitelist, False to unwhitelist\n    @return True if the whitelist status was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.whitelist[_addr] = _shouldWhitelist\n    log WhitelistSet(addr=_addr, shouldWhitelist=_shouldWhitelist)\n    return True\n\n\n@external\ndef setShouldEnforceWhitelist(_shouldEnforce: bool) -> bool:\n    \"\"\"\n    @notice Set whether to enforce the whitelist for agent/wallet creation\n    @dev Only callable by the governor, updates the whitelist enforcement state\n    @param _shouldEnforce True to enforce whitelist, False to disable\n    @return True if the whitelist enforcement state was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.shouldEnforceWhitelist = _shouldEnforce\n    log ShouldEnforceWhitelistSet(shouldEnforce=_shouldEnforce)\n    return True\n\n\n# total num allowed (agents / wallets)\n\n\n@external\ndef setNumUserWalletsAllowed(_numAllowed: uint256 = max_value(uint256)) -> bool:\n    \"\"\"\n    @notice Set the maximum number of user wallets allowed\n    @dev Only callable by the governor, updates the maximum number of user wallets\n    @param _numAllowed The new maximum number of user wallets allowed\n    @return True if the maximum number was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.numUserWalletsAllowed = _numAllowed\n    log NumUserWalletsAllowedSet(numAllowed=_numAllowed)\n    return True\n\n\n@external\ndef setNumAgentsAllowed(_numAllowed: uint256 = max_value(uint256)) -> bool:\n    \"\"\"\n    @notice Set the maximum number of agents allowed\n    @dev Only callable by the governor, updates the maximum number of agents\n    @param _numAllowed The new maximum number of agents allowed\n    @return True if the maximum number was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.numAgentsAllowed = _numAllowed\n    log NumAgentsAllowedSet(numAllowed=_numAllowed)\n    return True\n\n\n# agent blacklist\n\n\n@external\ndef setAgentBlacklist(_agentAddr: address, _shouldBlacklist: bool) -> bool:\n    \"\"\"\n    @notice Set the blacklist status for a given agent address\n    @dev Only callable by the governor, updates the blacklist state\n    @param _agentAddr The address to set the blacklist status for\n    @param _shouldBlacklist True to blacklist, False to unblacklist\n    @return True if the blacklist status was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.agentBlacklist[_agentAddr] = _shouldBlacklist\n    log AgentBlacklistSet(agentAddr=_agentAddr, shouldBlacklist=_shouldBlacklist)\n    return True\n\n\n# cancel critical actions (on behalf of users)\n\n\n@view\n@external\ndef canCancelCriticalAction(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address can perform critical cancellations\n    @dev Returns true if the address is whitelisted or the governor\n    \"\"\"\n    return self.canCriticalCancel[_addr] or gov._canGovern(_addr)\n\n\n@external\ndef setCanCriticalCancel(_addr: address, _canCancel: bool) -> bool:\n    \"\"\"\n    @notice Set whether an address can perform critical cancellations\n    @dev Only callable by the governor, updates the critical cancel state\n    @param _addr The address to set the critical cancel state for\n    @param _canCancel True to allow permissions for critical cancel, False to disallow\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if _addr == empty(address) or self.canCriticalCancel[_addr] == _canCancel or gov._canGovern(_addr):\n        return False\n\n    self.canCriticalCancel[_addr] = _canCancel\n    log CanCriticalCancelSet(addr=_addr, canCancel=_canCancel)\n    return True\n\n\n###############\n# Trial Funds #\n###############\n\n\n@external\ndef setTrialFundsData(_asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Set the trial funds asset and amount for future wallet deployments\n    @dev Only callable by the governor, updates the trial funds data\n    @param _asset The address of the asset to set\n    @param _amount The amount of the asset to set\n    @return True if the data was successfully updated, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not _asset.is_contract or _asset == empty(address) or _amount == 0:\n        return False\n\n    self.trialFundsData = TrialFundsData(\n        asset=_asset,\n        amount=_amount,\n    )\n    log TrialFundsDataSet(asset=_asset, amount=_amount)\n    return True\n\n\n@external\ndef clawBackTrialFunds(_wallets: DynArray[address, MAX_RECOVERIES]) -> bool:\n    \"\"\"\n    @notice Claw back trial funds from a list of wallets\n    @dev Only callable by the governor or critical cancel address, transfers funds back here\n    @param _wallets The list of wallets to claw back funds from\n    @return True if the funds were successfully clawed back, False otherwise\n    \"\"\"\n    assert self.canCriticalCancel[msg.sender] or gov._canGovern(msg.sender) # dev: no perms\n    for w: address in _wallets:\n        assert extcall MainWallet(w).clawBackTrialFunds() # dev: clawback failed\n    return True\n\n\n@external\ndef clawBackTrialFundsLegacy(_recoveries: DynArray[TrialFundsRecovery, MAX_RECOVERIES]) -> bool:\n    assert self.canCriticalCancel[msg.sender] or gov._canGovern(msg.sender) # dev: no perms\n    for r: TrialFundsRecovery in _recoveries:\n        assert extcall MainWallet(r.wallet).recoverTrialFunds(r.opportunities) # dev: recovery failed\n    return True\n\n\n####################\n# Ambassador Bonus #\n####################\n\n\n@external\ndef payAmbassadorYieldBonus(_ambassador: address, _asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Pay an ambassador yield bonus\n    @dev Only callable by a wallet, transfers bonus to ambassador\n    @param _ambassador The address of the ambassador to pay the bonus to\n    @param _asset The address of the asset to pay the bonus from\n    @param _amount The amount of the bonus to pay\n    \"\"\"\n    if not self.isActivated:\n        return False\n\n    # make sure have correct inputs\n    if _ambassador == empty(address) or _asset == empty(address) or _amount == 0:\n        return False\n\n    # make sure sender is a wallet\n    wallet: address = msg.sender\n    if not self._isUserWallet(wallet):\n        return False\n\n    # check if bonus ratio is set\n    ambassadorBonusRatio: uint256 = self.ambassadorBonusRatio\n    if ambassadorBonusRatio == 0:\n        return False\n\n    # calculate bonus amount, transfer to ambassador\n    bonusAmount: uint256 = min(_amount * ambassadorBonusRatio // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if bonusAmount == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_ambassador, bonusAmount, default_return_value=True) # dev: bonus transfer failed\n    log AmbassadorYieldBonusPaid(user=wallet, ambassador=_ambassador, asset=_asset, amount=bonusAmount, ratio=ambassadorBonusRatio)\n    return True\n\n\n@external\ndef setAmbassadorBonusRatio(_bonusRatio: uint256) -> bool:\n    \"\"\"\n    @notice Set the bonus ratio for ambassadors\n    @dev Only callable by governor\n    @param _bonusRatio The bonus ratio for ambassadors\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _bonusRatio <= HUNDRED_PERCENT # dev: invalid ratio\n    self.ambassadorBonusRatio = _bonusRatio\n    log AmbassadorBonusRatioSet(ratio=_bonusRatio)\n    return True\n\n\n#################\n# Default Agent #\n#################\n\n\n@external\ndef initiateDefaultAgentUpdate(_newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._isAgent(_newAddr):\n        return False\n    return self._initiateAddressUpdate(AddressTypes.DEFAULT_AGENT, _newAddr, self.addressInfo[AddressTypes.DEFAULT_AGENT].addr)\n\n\n@external\ndef confirmDefaultAgentUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._isAgent(self.pendingAddress[AddressTypes.DEFAULT_AGENT].newAddr):\n        return False\n    return self._confirmAddressUpdate(AddressTypes.DEFAULT_AGENT)\n\n\n@external\ndef cancelDefaultAgentUpdate() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._cancelAddressUpdate(AddressTypes.DEFAULT_AGENT)\n\n\n@view\n@external\ndef getDefaultAgentAddr() -> address:\n    return self.addressInfo[AddressTypes.DEFAULT_AGENT].addr\n\n\n@view\n@external\ndef getDefaultAgentInfo() -> AddressInfo:\n    return self.addressInfo[AddressTypes.DEFAULT_AGENT]\n\n\n@view\n@external\ndef getPendingDefaultAgentUpdate() -> PendingAddress:\n    return self.pendingAddress[AddressTypes.DEFAULT_AGENT]\n\n\n@view\n@external\ndef hasPendingDefaultAgentUpdate() -> bool:\n    return self._hasPendingAddressUpdate(AddressTypes.DEFAULT_AGENT)\n\n\n####################################\n# Recover Funds From Agent Factory #\n####################################\n\n\n@external\ndef recoverFundsFromAgentFactory(_asset: address, _recipient: address) -> bool:\n    \"\"\"\n    @notice Recover funds from the factory\n    @dev Only callable by the governor, transfers funds to the recipient\n    @param _asset The address of the asset to recover\n    @param _recipient The address to send the funds to\n    @return True if the funds were successfully recovered, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AgentFactoryFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n    return True\n\n\n############\n# Activate #\n############\n\n\n@external\ndef activate(_shouldActivate: bool):\n    \"\"\"\n    @notice Enable or disable the factory's ability to create new wallets\n    @dev Only callable by the governor, toggles isActivated state\n    @param _shouldActivate True to activate the factory, False to deactivate\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    self.isActivated = _shouldActivate\n    log AgentFactoryActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "b7c742ffa8af0d70c132d3b17f8b59a3db89decec0b72aa842b047a4f15a13b5"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AgentFactory.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "a1e2251d630e7102b4852cb732e3661b11584335cbe43a94969065616aa4465f"
      },
      "args": "0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae0000000000000000000000004200000000000000000000000000000000000006000000000000000000000000e43d5bd11a2a6a9348efc516ad9ac3d32164a5a000000000000000000000000061293f1bf484d20dcc841175b4e4a0f46c26658c00000000000000000000000076eb19ae42c07a7ad50afd58b579a7c45bd70183000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "LegoRegistry": {
      "address": "0x8D8593FE154d14976352FA2CE30322EcDF99C72a",
      "abi": [
        {
          "name": "LegoHelperSet",
          "inputs": [
            {
              "name": "helperAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewPendingAddyCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdatePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisablePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isYieldLego",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewLego",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            },
            {
              "name": "_legoType",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewLegoRegistration",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingNewLego",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoUpdate",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmLegoUpdate",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingLegoUpdate",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoDisable",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmLegoDisable",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingLegoDisable",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoChangeDelayToMin",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numLegosRaw",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoInfo",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoDescription",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegos",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastLegoAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastLegoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokensForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoHelper",
          "inputs": [
            {
              "name": "_helperAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoHelper",
          "inputs": [
            {
              "name": "_helperAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingLegoType",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoIdToType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoHelper",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_minLegoChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxLegoChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/Registry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nstruct AddyInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddy:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddyPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddyConfirmed:\n    addr: indexed(address)\n    addyId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewPendingAddyCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdatePending:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdateConfirmed:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyUpdateCancelled:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisablePending:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisableConfirmed:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyDisableCancelled:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyChangeDelaySet:\n    delayBlocks: uint256\n    registry: String[28]\n\n# core registry\naddyInfo: public(HashMap[uint256, AddyInfo])\naddyToId: public(HashMap[address, uint256])\nnumAddys: public(uint256)\n\n# pending changes\npendingNewAddy: public(HashMap[address, PendingNewAddy]) # addr -> pending new addy\npendingAddyUpdate: public(HashMap[uint256, PendingAddyUpdate]) # addyId -> pending addy update\npendingAddyDisable: public(HashMap[uint256, PendingAddyDisable]) # addyId -> pending addy disable\naddyChangeDelay: public(uint256)\n\nMIN_ADDY_CHANGE_DELAY: public(immutable(uint256))\nMAX_ADDY_CHANGE_DELAY: public(immutable(uint256))\nREGISTRY_STR: public(immutable(String[28]))\n\n\n@deploy\ndef __init__(_minAddyChangeDelay: uint256, _maxAddyChangeDelay: uint256, _registryStr: String[28]):\n    assert _minAddyChangeDelay < _maxAddyChangeDelay # dev: invalid delay\n    MIN_ADDY_CHANGE_DELAY = _minAddyChangeDelay\n    MAX_ADDY_CHANGE_DELAY = _maxAddyChangeDelay\n\n    REGISTRY_STR = _registryStr\n\n    # start at 1 index\n    self.numAddys = 1\n\n\n############\n# New Addy #\n############\n\n\n@view\n@external\ndef isValidNewAddy(_addr: address) -> bool:\n    return self._isValidNewAddy(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddy(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addyToId[_addr] == 0\n\n\n@internal\ndef _registerNewAddy(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new address in the registry\n    @dev This function sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address to be registered\n    @param _description A short description of the address (max 64 characters)\n    @return True if the registration was successfully initiated, False if the address is invalid\n    \"\"\"\n    if not self._isValidNewAddy(_addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingNewAddy[_addr] = PendingNewAddy(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddyPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmNewAddy(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending address registration after the required delay period\n    @dev This function finalizes the registration by assigning an ID and storing the address info\n    @param _addr The address to confirm registration for\n    @return The assigned ID for the registered address, or 0 if confirmation fails\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    if not self._isValidNewAddy(_addr):\n        self.pendingNewAddy[_addr] = empty(PendingNewAddy) # clear pending\n        return 0\n\n    # register new addy\n    addyId: uint256 = self.numAddys\n    self.addyToId[_addr] = addyId\n    self.numAddys = addyId + 1\n    self.addyInfo[addyId] = AddyInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n\n    log NewAddyConfirmed(addr=_addr, addyId=addyId, description=data.description, registry=REGISTRY_STR)\n    return addyId\n\n\n@internal\ndef _cancelPendingNewAddy(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending address registration\n    @dev This function removes the pending registration and emits a cancellation event\n    @param _addr The address whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n    log NewPendingAddyCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n###############\n# Update Addy #\n###############\n\n\n@view\n@external\ndef isValidAddyUpdate(_addyId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddyUpdate(_addyId, _newAddr, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyUpdate(_addyId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    if not self._isValidNewAddy(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@internal\ndef _updateAddyAddr(_addyId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered address\n    @dev This function sets up a pending update that requires confirmation after a delay period\n    @param _addyId The ID of the address to update\n    @param _newAddr The new address to set\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyUpdate(_addyId, _newAddr, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyUpdate[_addyId] = PendingAddyUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyUpdatePending(addyId=_addyId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address update after the required delay period\n    @dev This function finalizes the update by updating the address info and version\n    @param _addyId The ID of the address to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyUpdate(_addyId, pendingData.newAddr, prevAddr):\n        self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = pendingData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[pendingData.newAddr] = _addyId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n\n    log AddyUpdateConfirmed(addyId=_addyId, description=data.description, newAddr=pendingData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address update\n    @dev This function removes the pending update and emits a cancellation event\n    @param _addyId The ID of the address whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyUpdateCancelled(addyId=_addyId, description=prevData.description, newAddr=pendingData.newAddr, prevAddr=prevData.addr, initiatedBlock=pendingData.initiatedBlock, confirmBlock=pendingData.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Disable Addy #\n################\n\n\n@view\n@external\ndef isValidAddyDisable(_addyId: uint256) -> bool:\n    return self._isValidAddyDisable(_addyId, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyDisable(_addyId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@internal\ndef _disableAddyAddr(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered address\n    @dev This function sets up a pending disable that requires confirmation after a delay period\n    @param _addyId The ID of the address to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyDisable(_addyId, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyDisable[_addyId] = PendingAddyDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyDisablePending(addyId=_addyId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address disable after the required delay period\n    @dev This function finalizes the disable by clearing the address and updating version\n    @param _addyId The ID of the address to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyDisable(_addyId, prevAddr):\n        self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n\n    log AddyDisableConfirmed(addyId=_addyId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address disable\n    @dev This function removes the pending disable and emits a cancellation event\n    @param _addyId The ID of the address whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    data: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyDisableCancelled(addyId=_addyId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Change Delay #\n################\n\n\n@internal\ndef _setAddyChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for address changes\n    @dev The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert _numBlocks >= MIN_ADDY_CHANGE_DELAY and _numBlocks <= MAX_ADDY_CHANGE_DELAY # dev: invalid delay\n    self.addyChangeDelay = _numBlocks\n    log AddyChangeDelaySet(delayBlocks=_numBlocks, registry=REGISTRY_STR)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidAddyAddr(_addr: address) -> bool:\n    return self._isValidAddyAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddyAddr(_addr: address) -> bool:\n    return self.addyToId[_addr] != 0\n\n\n@view\n@external\ndef isValidAddyId(_addyId: uint256) -> bool:\n    return self._isValidAddyId(_addyId)\n\n\n@view\n@internal\ndef _isValidAddyId(_addyId: uint256) -> bool:\n    return _addyId != 0 and _addyId < self.numAddys\n\n\n# addy getters\n\n\n@view\n@external\ndef getAddyId(_addr: address) -> uint256:\n    return self._getAddyId(_addr)\n\n\n@view\n@internal\ndef _getAddyId(_addr: address) -> uint256:\n    return self.addyToId[_addr]\n\n\n@view\n@external\ndef getAddy(_addyId: uint256) -> address:\n    return self._getAddy(_addyId)\n\n\n@view\n@internal\ndef _getAddy(_addyId: uint256) -> address:\n    return self.addyInfo[_addyId].addr\n\n\n@view\n@external\ndef getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self._getAddyInfo(_addyId)\n\n\n@view\n@internal\ndef _getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self.addyInfo[_addyId]\n\n\n@view\n@external\ndef getAddyDescription(_addyId: uint256) -> String[64]:\n    return self._getAddyDescription(_addyId)\n\n\n@view\n@internal\ndef _getAddyDescription(_addyId: uint256) -> String[64]:\n    return self.addyInfo[_addyId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumAddys() -> uint256:\n    return self._getNumAddys()\n\n\n@view\n@internal\ndef _getNumAddys() -> uint256:\n    return self.numAddys - 1\n\n\n@view\n@external\ndef getLastAddyAddr() -> address:\n    return self._getLastAddyAddr()\n\n\n@view\n@internal\ndef _getLastAddyAddr() -> address:\n    lastIndex: uint256 = self.numAddys - 1\n    return self.addyInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastAddyId() -> uint256:\n    return self._getLastAddyId()\n\n\n@view\n@internal\ndef _getLastAddyId() -> uint256:\n    return self.numAddys - 1\n",
            "sha256sum": "460d2db094c5b32c0788cc51d7e857c0e7e2f223f570937c46cb97599441b29e"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/core/registries/LegoRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\ninitializes: registry\n\nexports: gov.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Registry as registry\n\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\nflag LegoType:\n    YIELD_OPP\n    DEX\n\nstruct VaultTokenInfo:\n    legoId: uint256\n    vaultToken: address\n\nevent LegoHelperSet:\n    helperAddr: indexed(address)\n\n# lego types\npendingLegoType: public(HashMap[address, LegoType]) # addr -> pending lego type\nlegoIdToType: public(HashMap[uint256, LegoType]) # legoId -> lego type\n\nlegoHelper: public(address)\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_VAULTS_FOR_USER: constant(uint256) = 30\n\n\n@deploy\ndef __init__(\n    _addyRegistry: address,\n    _minLegoChangeDelay: uint256,\n    _maxLegoChangeDelay: uint256,\n):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n\n    # initialize gov\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n    # initialize registry\n    registry.__init__(_minLegoChangeDelay, _maxLegoChangeDelay, \"LegoRegistry.vy\")\n\n\n@view\n@external\ndef isYieldLego(_legoId: uint256) -> bool:\n    return self.legoIdToType[_legoId] == LegoType.YIELD_OPP\n\n\n#################\n# Register Lego #\n#################\n\n\n@view\n@external\ndef isValidNewLegoAddr(_addr: address) -> bool:\n    return registry._isValidNewAddy(_addr)\n\n\n@external\ndef registerNewLego(_addr: address, _description: String[64], _legoType: LegoType) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new Lego\n    @dev Only callable by governor. Sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address of the Lego to register\n    @param _description A short description of the Lego (max 64 characters)\n    @param _legoType The type of Lego (YIELD_OPP or DEX)\n    @return True if the registration was successfully initiated, False if the Lego is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    isPending: bool = registry._registerNewAddy(_addr, _description)\n    if isPending:\n        self.pendingLegoType[_addr] = _legoType\n    return isPending\n\n\n@external\ndef confirmNewLegoRegistration(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending Lego registration after the required delay period\n    @dev Only callable by governor. Finalizes the registration by assigning an ID and setting the Lego type\n    @param _addr The address of the Lego to confirm registration for\n    @return The assigned ID for the registered Lego, or 0 if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    legoId: uint256 = registry._confirmNewAddy(_addr)\n    if legoId == 0:\n        self.pendingLegoType[_addr] = empty(LegoType)\n        return 0\n\n    # set lego id\n    assert extcall LegoCommon(_addr).setLegoId(legoId) # dev: set id failed\n\n    # set lego type\n    legoType: LegoType = self.pendingLegoType[_addr]\n    self.legoIdToType[legoId] = legoType\n    self.pendingLegoType[_addr] = empty(LegoType)\n\n    return legoId\n\n\n@external\ndef cancelPendingNewLego(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending Lego registration\n    @dev Only callable by governor. Removes the pending registration and emits a cancellation event\n    @param _addr The address of the Lego whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingNewAddy(_addr)\n\n\n###############\n# Update Lego #\n###############\n\n\n@view\n@external\ndef isValidLegoUpdate(_legoId: uint256, _newAddr: address) -> bool:\n    return registry._isValidAddyUpdate(_legoId, _newAddr, registry.addyInfo[_legoId].addr)\n\n\n@external\ndef updateLegoAddr(_legoId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered Lego\n    @dev Only callable by governor. Sets up a pending update that requires confirmation after a delay period\n    @param _legoId The ID of the Lego to update\n    @param _newAddr The new address to set for the Lego\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._updateAddyAddr(_legoId, _newAddr)\n\n\n@external\ndef confirmLegoUpdate(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending Lego address update after the required delay period\n    @dev Only callable by governor. Finalizes the update by updating the address and setting the Lego ID\n    @param _legoId The ID of the Lego to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    didUpdate: bool = registry._confirmAddyUpdate(_legoId)\n    if didUpdate:\n        legoAddr: address = registry.addyInfo[_legoId].addr\n        assert extcall LegoCommon(legoAddr).setLegoId(_legoId) # dev: set id failed\n    return didUpdate\n\n\n@external\ndef cancelPendingLegoUpdate(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending Lego address update\n    @dev Only callable by governor. Removes the pending update and emits a cancellation event\n    @param _legoId The ID of the Lego whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingAddyUpdate(_legoId)\n\n\n################\n# Disable Lego #\n################\n\n\n@view\n@external\ndef isValidLegoDisable(_legoId: uint256) -> bool:\n    return registry._isValidAddyDisable(_legoId, registry.addyInfo[_legoId].addr)\n\n\n@external\ndef disableLegoAddr(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered Lego\n    @dev Only callable by governor. Sets up a pending disable that requires confirmation after a delay period\n    @param _legoId The ID of the Lego to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._disableAddyAddr(_legoId)\n\n\n@external\ndef confirmLegoDisable(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending Lego disable after the required delay period\n    @dev Only callable by governor. Finalizes the disable by clearing the Lego address\n    @param _legoId The ID of the Lego to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddyDisable(_legoId)\n\n\n@external\ndef cancelPendingLegoDisable(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending Lego disable\n    @dev Only callable by governor. Removes the pending disable and emits a cancellation event\n    @param _legoId The ID of the Lego whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingAddyDisable(_legoId)\n\n\n#####################\n# Lego Change Delay #\n#####################\n\n\n@external\ndef setLegoChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for Lego changes\n    @dev Only callable by governor. The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._setAddyChangeDelay(_numBlocks)\n\n\n@view\n@external\ndef legoChangeDelay() -> uint256:\n    return registry.addyChangeDelay\n\n\n@external\ndef setLegoChangeDelayToMin() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._setAddyChangeDelay(registry.MIN_ADDY_CHANGE_DELAY)\n\n\n#################\n# Views / Utils #\n#################\n\n\n@view\n@external\ndef numLegosRaw() -> uint256:\n    return registry.numAddys\n\n\n# is valid\n\n\n@view\n@external\ndef isValidLegoAddr(_addr: address) -> bool:\n    return registry._isValidAddyAddr(_addr)\n\n\n@view\n@external\ndef isValidLegoId(_legoId: uint256) -> bool:\n    return registry._isValidAddyId(_legoId)\n\n\n# lego getters\n\n\n@view\n@external\ndef getLegoId(_addr: address) -> uint256:\n    return registry._getAddyId(_addr)\n\n\n@view\n@external\ndef getLegoAddr(_legoId: uint256) -> address:\n    return registry._getAddy(_legoId)\n\n\n@view\n@external\ndef getLegoInfo(_legoId: uint256) -> registry.AddyInfo:\n    return registry.addyInfo[_legoId]\n\n\n@view\n@external\ndef getLegoDescription(_legoId: uint256) -> String[64]:\n    return registry.addyInfo[_legoId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumLegos() -> uint256:\n    return registry._getNumAddys()\n\n\n@view\n@external\ndef getLastLegoAddr() -> address:\n    return registry._getLastAddyAddr()\n\n\n@view\n@external\ndef getLastLegoId() -> uint256:\n    return registry._getLastAddyId()\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    \"\"\"\n    @notice Get the underlying asset for a vault token\n    @dev Returns empty address if vault token is not registered\n    @param _vaultToken The address of the vault token to query\n    @return The underlying asset address\n    \"\"\"\n    if _vaultToken == empty(address):\n        return empty(address)\n\n    numLegos: uint256 = registry.numAddys\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = self.legoIdToType[i]\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = registry.addyInfo[i].addr\n        asset: address = staticcall LegoYield(legoAddr).getUnderlyingAsset(_vaultToken)\n        if asset != empty(address):\n            return asset\n\n    return empty(address)\n\n\n@view\n@external\ndef getUnderlyingForUser(_user: address, _asset: address) -> uint256:\n    \"\"\"\n    @notice Get the total underlying amount for a user in a given asset\n    @dev Returns 0 if user or asset is empty\n    @param _user The address of the user to query\n    @param _asset The address of the asset to query\n    \"\"\"\n    if empty(address) in [_user, _asset]:\n        return 0\n\n    totalDeposited: uint256 = 0\n    numLegos: uint256 = registry.numAddys\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = self.legoIdToType[i]\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = registry.addyInfo[i].addr\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall LegoYield(legoAddr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            vaultTokenBal: uint256 = staticcall IERC20(vaultToken).balanceOf(_user)\n            if vaultTokenBal != 0:\n                totalDeposited += staticcall LegoYield(legoAddr).getUnderlyingAmount(vaultToken, vaultTokenBal)\n\n    return totalDeposited\n\n\n@view\n@external\ndef getVaultTokensForUser(_user: address, _asset: address) -> DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER]:\n    \"\"\"\n    @notice Get all vault tokens for a user in a given asset\n    @dev Returns empty array if user or asset is empty\n    @param _user The address of the user to query\n    @param _asset The address of the asset to query\n    @return Array of VaultTokenInfo structs containing legoId and vaultToken address\n    \"\"\"\n    if empty(address) in [_user, _asset]:\n        return []\n\n    vaultTokens: DynArray[VaultTokenInfo, MAX_VAULTS_FOR_USER] = []\n\n    numLegos: uint256 = registry.numAddys\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = self.legoIdToType[i]\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = registry.addyInfo[i].addr\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall LegoYield(legoAddr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            if staticcall IERC20(vaultToken).balanceOf(_user) != 0:\n                vaultTokens.append(VaultTokenInfo(\n                    legoId=i,\n                    vaultToken=vaultToken\n                ))\n\n    return vaultTokens\n\n\n@view\n@external\ndef getLegoFromVaultToken(_vaultToken: address) -> (uint256, address):\n    \"\"\"\n    @notice Get the lego ID and address for a given vault token\n    @dev Returns (0, empty(address)) if vault token is not valid\n    @param _vaultToken The address of the vault token to query\n    @return The lego ID and address\n    \"\"\"\n    numLegos: uint256 = registry.numAddys\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = self.legoIdToType[i]\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = registry.addyInfo[i].addr\n        if staticcall LegoYield(legoAddr).isVaultToken(_vaultToken):\n            return i, legoAddr\n\n    return 0, empty(address)\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is a registered vault token\n    @dev Returns False if not a vault token\n    @param _vaultToken The address of the vault token to query\n    @return True if the address is a vault token, False otherwise\n    \"\"\"\n    numLegos: uint256 = registry.numAddys\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = self.legoIdToType[i]\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = registry.addyInfo[i].addr\n        if staticcall LegoYield(legoAddr).isVaultToken(_vaultToken):\n            return True\n\n    return False\n\n\n###############\n# Lego Helper #\n###############\n\n\n@view\n@external \ndef isValidLegoHelper(_helperAddr: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be set as the Lego helper\n    @dev Address must be a contract and different from current helper\n    @param _helperAddr The address to validate\n    @return True if address can be set as helper, False otherwise\n    \"\"\"\n    return self._isValidLegoHelper(_helperAddr)\n\n\n@view\n@internal \ndef _isValidLegoHelper(_helperAddr: address) -> bool:\n    if not _helperAddr.is_contract or _helperAddr == empty(address):\n        return False\n    return _helperAddr != self.legoHelper\n\n\n@external\ndef setLegoHelper(_helperAddr: address) -> bool:\n    \"\"\"\n    @notice Set a new Lego helper address\n    @dev Only callable by governor\n    @param _helperAddr The address to set as helper\n    @return True if helper was set successfully, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    if not self._isValidLegoHelper(_helperAddr):\n        return False\n    self.legoHelper = _helperAddr\n    log LegoHelperSet(helperAddr=_helperAddr)\n    return True\n\n",
            "sha256sum": "028c402e77a9669c4d76ec5e0af2e1b3451d9f4975c788a692e16010830c9cff"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/registries/LegoRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "619da03b55d669536495801d7610b822ea052187d0392176f890a7b4babed3aa"
      },
      "args": "0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "OracleRegistry": {
      "address": "0xe133F22aAdC23F9B7ca7A9f16B6D9A0C662Cf90b",
      "abi": [
        {
          "name": "PriorityOraclePartnerIdsModified",
          "inputs": [
            {
              "name": "numIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StaleTimeSet",
          "inputs": [
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddyConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewPendingAddyCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdatePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyUpdateCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisablePending",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableConfirmed",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyDisableCancelled",
          "inputs": [
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewOraclePartnerAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewOraclePartner",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewOraclePartnerRegistration",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingNewOraclePartner",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerUpdate",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOraclePartnerUpdate",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingOraclePartnerUpdate",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerDisable",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOraclePartnerDisable",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingOraclePartnerDisable",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oracleChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerChangeDelayToMin",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriorityOraclePartnerIds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "areValidPriorityOraclePartnerIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityOraclePartnerIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidStaleTime",
          "inputs": [
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStaleTime",
          "inputs": [
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numOraclePartnersRaw",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerInfo",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerDescription",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumOraclePartners",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastOraclePartnerAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastOraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priorityOraclePartnerIds",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "staleTime",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_STALE_TIME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_STALE_TIME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_minStaleTime",
              "type": "uint256"
            },
            {
              "name": "_maxStaleTime",
              "type": "uint256"
            },
            {
              "name": "_minOracleChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxOracleChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/Registry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nstruct AddyInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddy:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddyPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddyConfirmed:\n    addr: indexed(address)\n    addyId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewPendingAddyCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdatePending:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdateConfirmed:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyUpdateCancelled:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisablePending:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisableConfirmed:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyDisableCancelled:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyChangeDelaySet:\n    delayBlocks: uint256\n    registry: String[28]\n\n# core registry\naddyInfo: public(HashMap[uint256, AddyInfo])\naddyToId: public(HashMap[address, uint256])\nnumAddys: public(uint256)\n\n# pending changes\npendingNewAddy: public(HashMap[address, PendingNewAddy]) # addr -> pending new addy\npendingAddyUpdate: public(HashMap[uint256, PendingAddyUpdate]) # addyId -> pending addy update\npendingAddyDisable: public(HashMap[uint256, PendingAddyDisable]) # addyId -> pending addy disable\naddyChangeDelay: public(uint256)\n\nMIN_ADDY_CHANGE_DELAY: public(immutable(uint256))\nMAX_ADDY_CHANGE_DELAY: public(immutable(uint256))\nREGISTRY_STR: public(immutable(String[28]))\n\n\n@deploy\ndef __init__(_minAddyChangeDelay: uint256, _maxAddyChangeDelay: uint256, _registryStr: String[28]):\n    assert _minAddyChangeDelay < _maxAddyChangeDelay # dev: invalid delay\n    MIN_ADDY_CHANGE_DELAY = _minAddyChangeDelay\n    MAX_ADDY_CHANGE_DELAY = _maxAddyChangeDelay\n\n    REGISTRY_STR = _registryStr\n\n    # start at 1 index\n    self.numAddys = 1\n\n\n############\n# New Addy #\n############\n\n\n@view\n@external\ndef isValidNewAddy(_addr: address) -> bool:\n    return self._isValidNewAddy(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddy(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addyToId[_addr] == 0\n\n\n@internal\ndef _registerNewAddy(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new address in the registry\n    @dev This function sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address to be registered\n    @param _description A short description of the address (max 64 characters)\n    @return True if the registration was successfully initiated, False if the address is invalid\n    \"\"\"\n    if not self._isValidNewAddy(_addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingNewAddy[_addr] = PendingNewAddy(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddyPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmNewAddy(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending address registration after the required delay period\n    @dev This function finalizes the registration by assigning an ID and storing the address info\n    @param _addr The address to confirm registration for\n    @return The assigned ID for the registered address, or 0 if confirmation fails\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    if not self._isValidNewAddy(_addr):\n        self.pendingNewAddy[_addr] = empty(PendingNewAddy) # clear pending\n        return 0\n\n    # register new addy\n    addyId: uint256 = self.numAddys\n    self.addyToId[_addr] = addyId\n    self.numAddys = addyId + 1\n    self.addyInfo[addyId] = AddyInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n\n    log NewAddyConfirmed(addr=_addr, addyId=addyId, description=data.description, registry=REGISTRY_STR)\n    return addyId\n\n\n@internal\ndef _cancelPendingNewAddy(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending address registration\n    @dev This function removes the pending registration and emits a cancellation event\n    @param _addr The address whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n    log NewPendingAddyCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n###############\n# Update Addy #\n###############\n\n\n@view\n@external\ndef isValidAddyUpdate(_addyId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddyUpdate(_addyId, _newAddr, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyUpdate(_addyId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    if not self._isValidNewAddy(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@internal\ndef _updateAddyAddr(_addyId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered address\n    @dev This function sets up a pending update that requires confirmation after a delay period\n    @param _addyId The ID of the address to update\n    @param _newAddr The new address to set\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyUpdate(_addyId, _newAddr, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyUpdate[_addyId] = PendingAddyUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyUpdatePending(addyId=_addyId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address update after the required delay period\n    @dev This function finalizes the update by updating the address info and version\n    @param _addyId The ID of the address to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyUpdate(_addyId, pendingData.newAddr, prevAddr):\n        self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = pendingData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[pendingData.newAddr] = _addyId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n\n    log AddyUpdateConfirmed(addyId=_addyId, description=data.description, newAddr=pendingData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address update\n    @dev This function removes the pending update and emits a cancellation event\n    @param _addyId The ID of the address whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyUpdateCancelled(addyId=_addyId, description=prevData.description, newAddr=pendingData.newAddr, prevAddr=prevData.addr, initiatedBlock=pendingData.initiatedBlock, confirmBlock=pendingData.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Disable Addy #\n################\n\n\n@view\n@external\ndef isValidAddyDisable(_addyId: uint256) -> bool:\n    return self._isValidAddyDisable(_addyId, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyDisable(_addyId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@internal\ndef _disableAddyAddr(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered address\n    @dev This function sets up a pending disable that requires confirmation after a delay period\n    @param _addyId The ID of the address to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyDisable(_addyId, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyDisable[_addyId] = PendingAddyDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyDisablePending(addyId=_addyId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address disable after the required delay period\n    @dev This function finalizes the disable by clearing the address and updating version\n    @param _addyId The ID of the address to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyDisable(_addyId, prevAddr):\n        self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n\n    log AddyDisableConfirmed(addyId=_addyId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address disable\n    @dev This function removes the pending disable and emits a cancellation event\n    @param _addyId The ID of the address whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    data: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyDisableCancelled(addyId=_addyId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Change Delay #\n################\n\n\n@internal\ndef _setAddyChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for address changes\n    @dev The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert _numBlocks >= MIN_ADDY_CHANGE_DELAY and _numBlocks <= MAX_ADDY_CHANGE_DELAY # dev: invalid delay\n    self.addyChangeDelay = _numBlocks\n    log AddyChangeDelaySet(delayBlocks=_numBlocks, registry=REGISTRY_STR)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidAddyAddr(_addr: address) -> bool:\n    return self._isValidAddyAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddyAddr(_addr: address) -> bool:\n    return self.addyToId[_addr] != 0\n\n\n@view\n@external\ndef isValidAddyId(_addyId: uint256) -> bool:\n    return self._isValidAddyId(_addyId)\n\n\n@view\n@internal\ndef _isValidAddyId(_addyId: uint256) -> bool:\n    return _addyId != 0 and _addyId < self.numAddys\n\n\n# addy getters\n\n\n@view\n@external\ndef getAddyId(_addr: address) -> uint256:\n    return self._getAddyId(_addr)\n\n\n@view\n@internal\ndef _getAddyId(_addr: address) -> uint256:\n    return self.addyToId[_addr]\n\n\n@view\n@external\ndef getAddy(_addyId: uint256) -> address:\n    return self._getAddy(_addyId)\n\n\n@view\n@internal\ndef _getAddy(_addyId: uint256) -> address:\n    return self.addyInfo[_addyId].addr\n\n\n@view\n@external\ndef getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self._getAddyInfo(_addyId)\n\n\n@view\n@internal\ndef _getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self.addyInfo[_addyId]\n\n\n@view\n@external\ndef getAddyDescription(_addyId: uint256) -> String[64]:\n    return self._getAddyDescription(_addyId)\n\n\n@view\n@internal\ndef _getAddyDescription(_addyId: uint256) -> String[64]:\n    return self.addyInfo[_addyId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumAddys() -> uint256:\n    return self._getNumAddys()\n\n\n@view\n@internal\ndef _getNumAddys() -> uint256:\n    return self.numAddys - 1\n\n\n@view\n@external\ndef getLastAddyAddr() -> address:\n    return self._getLastAddyAddr()\n\n\n@view\n@internal\ndef _getLastAddyAddr() -> address:\n    lastIndex: uint256 = self.numAddys - 1\n    return self.addyInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastAddyId() -> uint256:\n    return self._getLastAddyId()\n\n\n@view\n@internal\ndef _getLastAddyId() -> uint256:\n    return self.numAddys - 1\n",
            "sha256sum": "460d2db094c5b32c0788cc51d7e857c0e7e2f223f570937c46cb97599441b29e"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/core/registries/OracleRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\ninitializes: registry\n\nexports: gov.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Registry as registry\n\nfrom ethereum.ercs import IERC20Detailed\nimport interfaces.OraclePartnerInterface as OraclePartner\n\nevent PriorityOraclePartnerIdsModified:\n    numIds: uint256\n\nevent StaleTimeSet:\n    staleTime: uint256\n\n# custom config\npriorityOraclePartnerIds: public(DynArray[uint256, MAX_PRIORITY_PARTNERS])\nstaleTime: public(uint256)\n\nETH: public(immutable(address))\nMIN_STALE_TIME: public(immutable(uint256))\nMAX_STALE_TIME: public(immutable(uint256))\n\nMAX_PRIORITY_PARTNERS: constant(uint256) = 10\n\n\n@deploy\ndef __init__(\n    _addyRegistry: address,\n    _ethAddr: address,\n    _minStaleTime: uint256,\n    _maxStaleTime: uint256,\n    _minOracleChangeDelay: uint256,\n    _maxOracleChangeDelay: uint256,\n):\n    assert empty(address) not in [_addyRegistry, _ethAddr] # dev: invalid addrs\n\n    # initialize gov\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n    # initialize registry\n    registry.__init__(_minOracleChangeDelay, _maxOracleChangeDelay, \"OracleRegistry.vy\")\n\n    ETH = _ethAddr\n    MIN_STALE_TIME = _minStaleTime\n    MAX_STALE_TIME = _maxStaleTime\n\n\n#########\n# Price #\n#########\n\n\n@view\n@external\ndef getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Get the USD price of an asset from registered oracle partners\n    @dev Checks priority partners first, then others. Returns 0 if no valid price found.\n    @param _asset The address of the asset to get price for\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The asset price in USD with 18 decimals\n    \"\"\"\n    if _asset == empty(address):\n        return 0\n    return self._getPrice(_asset, _shouldRaise)\n\n\n@view\n@internal\ndef _getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    price: uint256 = 0\n    hasFeedConfig: bool = False\n    alreadyLooked: DynArray[uint256, MAX_PRIORITY_PARTNERS] = []\n    staleTime: uint256 = self.staleTime\n\n    # go thru priority partners first\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self.priorityOraclePartnerIds\n    for i: uint256 in range(len(priorityIds), bound=MAX_PRIORITY_PARTNERS):\n        pid: uint256 = priorityIds[i]\n        hasFeed: bool = False\n        price, hasFeed = self._getPriceFromOraclePartner(pid, _asset, staleTime)\n        if price != 0:\n            break\n        if hasFeed:\n            hasFeedConfig = True\n        alreadyLooked.append(pid)\n\n    # go thru rest of oracle partners\n    if price == 0:\n        numSources: uint256 = registry.numAddys\n        for id: uint256 in range(1, numSources, bound=max_value(uint256)):\n            if id in alreadyLooked:\n                continue\n            hasFeed: bool = False\n            price, hasFeed = self._getPriceFromOraclePartner(id, _asset, staleTime)\n            if price != 0:\n                break\n            if hasFeed:\n                hasFeedConfig = True\n\n    # raise exception if feed exists but no price\n    if price == 0 and hasFeedConfig and _shouldRaise:\n        raise \"has price config, no price\"\n\n    return price\n\n\n@view\n@internal\ndef _getPriceFromOraclePartner(_pid: uint256, _asset: address, _staleTime: uint256) -> (uint256, bool):\n    oraclePartner: address = registry._getAddy(_pid)\n    if oraclePartner == empty(address):\n        return 0, False\n    return staticcall OraclePartner(oraclePartner).getPriceAndHasFeed(_asset, _staleTime, self)\n\n\n# other utils\n\n\n@view\n@external\ndef getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the USD value of a given amount of an asset\n    @dev Accounts for asset decimals in calculation. Returns 0 if no valid price.\n    @param _asset The address of the asset\n    @param _amount The amount of the asset\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The USD value with 18 decimals\n    \"\"\"\n    if _amount == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return price * _amount // (10 ** decimals)\n\n\n@view\n@external\ndef getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the amount of an asset worth a given USD value\n    @dev Accounts for asset decimals in calculation. Returns 0 if no valid price.\n    @param _asset The address of the asset\n    @param _usdValue The USD value to convert to asset amount (18 decimals)\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The amount of the asset\n    \"\"\"\n    if _usdValue == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return _usdValue * (10 ** decimals) // price\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    \"\"\"\n    @notice Check if any oracle partner has a price feed for the asset\n    @dev Iterates through all registered oracle partners\n    @param _asset The address of the asset to check\n    @return True if a price feed exists, False otherwise\n    \"\"\"\n    numSources: uint256 = registry.numAddys\n    for id: uint256 in range(1, numSources, bound=max_value(uint256)):\n        oraclePartner: address = registry._getAddy(id)\n        if oraclePartner == empty(address):\n            continue\n        if staticcall OraclePartner(oraclePartner).hasPriceFeed(_asset):\n            return True\n    return False\n\n\n@view\n@external\ndef getEthUsdValue(_amount: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the USD value of a given amount of ETH\n    @dev Uses ETH price feed. Returns 0 if no valid price.\n    @param _amount The amount of ETH in wei\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The USD value with 18 decimals\n    \"\"\"\n    if _amount == 0:\n        return 0\n    return self._getPrice(ETH, _shouldRaise) * _amount // (10 ** 18)\n\n\n@view\n@external\ndef getEthAmount(_usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the amount of ETH worth a given USD value\n    @dev Uses ETH price feed. Returns 0 if no valid price.\n    @param _usdValue The USD value to convert to ETH amount (18 decimals)\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The amount of ETH in wei\n    \"\"\"\n    if _usdValue == 0:\n        return 0\n    price: uint256 = self._getPrice(ETH, _shouldRaise)\n    if price == 0:\n        return 0\n    return _usdValue * (10 ** 18) // price\n\n\n###########################\n# Register Oracle Partner #\n###########################\n\n\n@view\n@external\ndef isValidNewOraclePartnerAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Checks if an address can be registered as a new Oracle Partner\n    @dev Validates that the address is a contract and not already registered\n    @param _addr The address to validate\n    @return True if the address can be registered, False otherwise\n    \"\"\"\n    return registry._isValidNewAddy(_addr)\n\n\n@external\ndef registerNewOraclePartner(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new Oracle Partner\n    @dev Only callable by governor. Sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address of the Oracle Partner to register\n    @param _description A short description of the Oracle Partner (max 64 characters)\n    @return True if the registration was successfully initiated, False if the Oracle Partner is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._registerNewAddy(_addr, _description)\n\n\n@external\ndef confirmNewOraclePartnerRegistration(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending Oracle Partner registration after the required delay period\n    @dev Only callable by governor. Finalizes the registration by assigning an ID and setting the Oracle Partner ID\n    @param _addr The address of the Oracle Partner to confirm registration for\n    @return The assigned ID for the registered Oracle Partner, or 0 if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    oraclePartnerId: uint256 = registry._confirmNewAddy(_addr)\n    if oraclePartnerId != 0:\n        assert extcall OraclePartner(_addr).setOraclePartnerId(oraclePartnerId) # dev: set id failed\n    return oraclePartnerId\n\n\n@external\ndef cancelPendingNewOraclePartner(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending Oracle Partner registration\n    @dev Only callable by governor. Removes the pending registration and emits a cancellation event\n    @param _addr The address of the Oracle Partner whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingNewAddy(_addr)\n\n\n#########################\n# Update Oracle Partner #\n#########################\n\n\n@view\n@external\ndef isValidOraclePartnerUpdate(_oracleId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Checks if an Oracle Partner address can be updated\n    @dev Validates that the Oracle Partner ID exists and the new address is valid\n    @param _oracleId The ID of the Oracle Partner to update\n    @param _newAddr The new address to set\n    @return True if the update is valid, False otherwise\n    \"\"\"\n    return registry._isValidAddyUpdate(_oracleId, _newAddr, registry.addyInfo[_oracleId].addr)\n\n\n@external\ndef updateOraclePartnerAddr(_oracleId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered Oracle Partner\n    @dev Only callable by governor. Sets up a pending update that requires confirmation after a delay period\n    @param _oracleId The ID of the Oracle Partner to update\n    @param _newAddr The new address to set for the Oracle Partner\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._updateAddyAddr(_oracleId, _newAddr)\n\n\n@external\ndef confirmOraclePartnerUpdate(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending Oracle Partner address update after the required delay period\n    @dev Only callable by governor. Finalizes the update by updating the address and setting the Oracle Partner ID\n    @param _oracleId The ID of the Oracle Partner to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    didUpdate: bool = registry._confirmAddyUpdate(_oracleId)\n    if didUpdate:\n        oraclePartnerAddr: address = registry.addyInfo[_oracleId].addr\n        assert extcall OraclePartner(oraclePartnerAddr).setOraclePartnerId(_oracleId) # dev: set id failed\n    return didUpdate\n\n\n@external\ndef cancelPendingOraclePartnerUpdate(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending Oracle Partner address update\n    @dev Only callable by governor. Removes the pending update and emits a cancellation event\n    @param _oracleId The ID of the Oracle Partner whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingAddyUpdate(_oracleId)\n\n\n##########################\n# Disable Oracle Partner #\n##########################\n\n\n@view\n@external\ndef isValidOraclePartnerDisable(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Checks if an Oracle Partner can be disabled\n    @dev Validates that the Oracle Partner ID exists and is not already disabled\n    @param _oracleId The ID of the Oracle Partner to check\n    @return True if the Oracle Partner can be disabled, False otherwise\n    \"\"\"\n    return registry._isValidAddyDisable(_oracleId, registry.addyInfo[_oracleId].addr)\n\n\n@external\ndef disableOraclePartnerAddr(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered Oracle Partner\n    @dev Only callable by governor. Sets up a pending disable that requires confirmation after a delay period\n    @param _oracleId The ID of the Oracle Partner to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._disableAddyAddr(_oracleId)\n\n\n@external\ndef confirmOraclePartnerDisable(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending Oracle Partner disable after the required delay period\n    @dev Only callable by governor. Finalizes the disable by clearing the Oracle Partner address\n    @param _oracleId The ID of the Oracle Partner to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddyDisable(_oracleId)\n\n\n@external\ndef cancelPendingOraclePartnerDisable(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending Oracle Partner disable\n    @dev Only callable by governor. Removes the pending disable and emits a cancellation event\n    @param _oracleId The ID of the Oracle Partner whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelPendingAddyDisable(_oracleId)\n\n\n#########################\n# Oracle Partner Change #\n#########################\n\n\n@external\ndef setOraclePartnerChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for Oracle Partner changes\n    @dev Only callable by governor. The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._setAddyChangeDelay(_numBlocks)\n\n\n@view\n@external\ndef oracleChangeDelay() -> uint256:\n    return registry.addyChangeDelay\n\n\n@external\ndef setOraclePartnerChangeDelayToMin() -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._setAddyChangeDelay(registry.MIN_ADDY_CHANGE_DELAY)\n\n\n############################\n# Priority Oracle Partners #\n############################\n\n\n@view \n@external \ndef getPriorityOraclePartnerIds() -> DynArray[uint256, MAX_PRIORITY_PARTNERS]:\n    \"\"\"\n    @notice Get the list of priority oracle partner IDs\n    @dev Returns ordered list of IDs that are checked first for prices\n    @return Array of oracle partner IDs in priority order\n    \"\"\"\n    return self.priorityOraclePartnerIds\n\n\n@view\n@internal\ndef _sanitizePriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> DynArray[uint256, MAX_PRIORITY_PARTNERS]:\n    sanitizedIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = []\n    for i: uint256 in range(len(_priorityIds), bound=MAX_PRIORITY_PARTNERS):\n        pid: uint256 = _priorityIds[i]\n        if not registry._isValidAddyId(pid):\n            continue\n        if pid in sanitizedIds:\n            continue\n        sanitizedIds.append(pid)\n    return sanitizedIds\n\n\n@view\n@external\ndef areValidPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    \"\"\"\n    @notice Check if a list of priority oracle partner IDs is valid\n    @dev Validates IDs exist and are not duplicated\n    @param _priorityIds Array of oracle partner IDs to validate\n    @return True if all IDs are valid, False otherwise\n    \"\"\"\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self._sanitizePriorityOraclePartnerIds(_priorityIds)\n    return self._areValidPriorityOraclePartnerIds(priorityIds)\n\n\n@view\n@internal\ndef _areValidPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    return len(_priorityIds) != 0\n\n\n@external\ndef setPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    \"\"\"\n    @notice Set the list of priority oracle partner IDs\n    @dev Only callable by governor when registry is activated\n    @param _priorityIds Array of oracle partner IDs in desired priority order\n    @return True if priority list was set successfully, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self._sanitizePriorityOraclePartnerIds(_priorityIds)\n    if not self._areValidPriorityOraclePartnerIds(priorityIds):\n        return False\n\n    self.priorityOraclePartnerIds = priorityIds\n    log PriorityOraclePartnerIdsModified(numIds=len(priorityIds))\n    return True\n\n\n##############\n# Stale Time #\n##############\n\n\n@view\n@external\ndef isValidStaleTime(_staleTime: uint256) -> bool:\n    \"\"\"\n    @notice Check if a stale time value is valid\n    @dev Validates against minimum and maximum allowed stale times\n    @param _staleTime The stale time in seconds to validate\n    @return True if stale time is valid, False otherwise\n    \"\"\"\n    return self._isValidStaleTime(_staleTime)\n\n\n@view\n@internal\ndef _isValidStaleTime(_staleTime: uint256) -> bool:\n    return _staleTime >= MIN_STALE_TIME and _staleTime <= MAX_STALE_TIME\n\n\n@external\ndef setStaleTime(_staleTime: uint256) -> bool:\n    \"\"\"\n    @notice Set the stale time for price feeds\n    @dev Only callable by governor when registry is activated\n    @param _staleTime The stale time in seconds\n    @return True if stale time was set successfully, False otherwise\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    if not self._isValidStaleTime(_staleTime):\n        return False\n\n    self.staleTime = _staleTime\n    log StaleTimeSet(staleTime=_staleTime)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n@view\n@external\ndef numOraclePartnersRaw() -> uint256:\n    return registry.numAddys\n\n\n# is valid\n\n\n@view\n@external\ndef isValidOraclePartnerAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address is a registered oracle partner\n    @dev Returns true if address has a non-zero oracle partner ID\n    @param _addr The address to check\n    @return True if address is a registered oracle partner, False otherwise\n    \"\"\"\n    return registry._isValidAddyAddr(_addr)\n\n\n@view\n@external\ndef isValidOraclePartnerId(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Check if an oracle partner ID is valid\n    @dev ID must be non-zero and less than total number of oracle partners\n    @param _oracleId The ID to check\n    @return True if ID is valid, False otherwise\n    \"\"\"\n    return registry._isValidAddyId(_oracleId)\n\n\n# oracle partner getters\n\n\n@view\n@external\ndef getOraclePartnerId(_addr: address) -> uint256:\n    \"\"\"\n    @notice Get the ID of an oracle partner from its address\n    @dev Returns 0 if address is not registered\n    @param _addr The address to query\n    @return The oracle partner ID associated with the address\n    \"\"\"\n    return registry._getAddyId(_addr)\n\n\n@view\n@external\ndef getOraclePartnerAddr(_oracleId: uint256) -> address:\n    \"\"\"\n    @notice Get the address of an oracle partner from its ID\n    @dev Returns empty address if ID is invalid or partner is disabled\n    @param _oracleId The ID to query\n    @return The address associated with the oracle partner ID\n    \"\"\"\n    return registry._getAddy(_oracleId)\n\n\n@view\n@external\ndef getOraclePartnerInfo(_oracleId: uint256) -> registry.AddyInfo:\n    \"\"\"\n    @notice Get all information about an oracle partner\n    @dev Returns complete OraclePartnerInfo struct including address, version, timestamp and description\n    @param _oracleId The ID to query\n    @return OraclePartnerInfo struct containing all oracle partner information\n    \"\"\"\n    return registry.addyInfo[_oracleId]\n\n\n@view\n@external\ndef getOraclePartnerDescription(_oracleId: uint256) -> String[64]:\n    \"\"\"\n    @notice Get the description of an oracle partner\n    @dev Returns empty string if ID is invalid\n    @param _oracleId The ID to query\n    @return The description associated with the oracle partner ID\n    \"\"\"\n    return registry.addyInfo[_oracleId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumOraclePartners() -> uint256:\n    \"\"\"\n    @notice Get the total number of registered oracle partners\n    @dev Returns number of partners minus 1 since indexing starts at 1\n    @return The total number of registered oracle partners\n    \"\"\"\n    return registry._getNumAddys()\n\n\n@view\n@external\ndef getLastOraclePartnerAddr() -> address:\n    \"\"\"\n    @notice Get the address of the most recently registered oracle partner\n    @dev Returns the address at index (numOraclePartners - 1)\n    @return The address of the last registered oracle partner\n    \"\"\"\n    return registry._getLastAddyAddr()\n\n\n@view\n@external\ndef getLastOraclePartnerId() -> uint256:\n    \"\"\"\n    @notice Get the ID of the most recently registered oracle partner\n    @dev Returns numOraclePartners - 1 since indexing starts at 1\n    @return The ID of the last registered oracle partner\n    \"\"\"\n    return registry._getLastAddyId()\n",
            "sha256sum": "c6cd93015c0961322bde82eda88cd3c27037cc47bb2c405e3ae5291e110f10ab"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/registries/OracleRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "ea25f55df290ba3bdcfb02162b102534a447839f2eca35a83ddd9abd4acccd9d"
      },
      "args": "0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000003f48000000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "PriceSheets": {
      "address": "0xD15331Cf355B5D8EF017c1FD49516b95593FA6aA",
      "abi": [
        {
          "name": "AgentSubPriceSet",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAgentSubPriceSet",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "effectiveBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolSubPriceSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentSubPriceRemoved",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolSubPriceRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentSubPricingEnabled",
          "inputs": [
            {
              "name": "isEnabled",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolTxPriceSheetSet",
          "inputs": [
            {
              "name": "yieldFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimRewardsFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolTxPriceSheetRemoved",
          "inputs": [
            {
              "name": "yieldFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimRewardsFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolRecipientSet",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AmbassadorRatioSet",
          "inputs": [
            {
              "name": "ratio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSheetsActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCombinedSubData",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_agentPaidThru",
              "type": "uint256"
            },
            {
              "name": "_protocolPaidThru",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentSubPriceData",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidSubPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finalizePendingAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentSubPricingEnabled",
          "inputs": [
            {
              "name": "_isEnabled",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolSubPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeProtocolSubPrice",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTransactionFeeDataWithAmbassadorRatio",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTransactionFeeData",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidTxPriceSheet",
          "inputs": [
            {
              "name": "_yieldFee",
              "type": "uint256"
            },
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_claimRewardsFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolTxPriceSheet",
          "inputs": [
            {
              "name": "_yieldFee",
              "type": "uint256"
            },
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_claimRewardsFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeProtocolTxPriceSheet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolRecipient",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriceChangeDelay",
          "inputs": [
            {
              "name": "_delayBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAmbassadorRatio",
          "inputs": [
            {
              "name": "_ratio",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolRecipient",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolTxPriceData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "yieldFee",
                  "type": "uint256"
                },
                {
                  "name": "swapFee",
                  "type": "uint256"
                },
                {
                  "name": "claimRewardsFee",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolSubPriceData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgentSubPricingEnabled",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentSubPriceData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAgentSubPrices",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "subInfo",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "asset",
                      "type": "address"
                    },
                    {
                      "name": "usdValue",
                      "type": "uint256"
                    },
                    {
                      "name": "trialPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "payPeriod",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "effectiveBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priceChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ambassadorRatio",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_TRIAL_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_TRIAL_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_PAY_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_PAY_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_PRICE_CHANGE_BUFFER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_minTrialPeriod",
              "type": "uint256"
            },
            {
              "name": "_maxTrialPeriod",
              "type": "uint256"
            },
            {
              "name": "_minPayPeriod",
              "type": "uint256"
            },
            {
              "name": "_maxPayPeriod",
              "type": "uint256"
            },
            {
              "name": "_minPriceChangeBuffer",
              "type": "uint256"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/core/PriceSheets.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\nimport contracts.modules.LocalGov as gov\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n    def governance() -> address: view\n\ninterface OracleRegistry:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AgentFactory:\n    def isAgent(_agent: address) -> bool: view\n\ninterface Agent:\n    def owner() -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct TxPriceSheet:\n    yieldFee: uint256\n    swapFee: uint256\n    claimRewardsFee: uint256\n\nstruct SubscriptionInfo:\n    asset: address\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct PendingSubPrice:\n    subInfo: SubscriptionInfo\n    effectiveBlock: uint256\n\nevent AgentSubPriceSet:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent PendingAgentSubPriceSet:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n    effectiveBlock: uint256\n\nevent ProtocolSubPriceSet:\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent AgentSubPriceRemoved:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent ProtocolSubPriceRemoved:\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent AgentSubPricingEnabled:\n    isEnabled: bool\n\nevent ProtocolTxPriceSheetSet:\n    yieldFee: uint256\n    swapFee: uint256\n    claimRewardsFee: uint256\n\nevent ProtocolTxPriceSheetRemoved:\n    yieldFee: uint256\n    swapFee: uint256\n    claimRewardsFee: uint256\n\nevent ProtocolRecipientSet:\n    recipient: indexed(address)\n\nevent PriceChangeDelaySet:\n    delayBlocks: uint256\n\nevent AmbassadorRatioSet:\n    ratio: uint256\n\nevent PriceSheetsActivated:\n    isActivated: bool\n\n# protocol pricing\nprotocolRecipient: public(address) # protocol recipient\nprotocolTxPriceData: public(TxPriceSheet) # protocol transaction pricing\nprotocolSubPriceData: public(SubscriptionInfo) # protocol subscription pricing\n\n# agent pricing\nisAgentSubPricingEnabled: public(bool)\nagentSubPriceData: public(HashMap[address, SubscriptionInfo]) # agent -> subscription pricing\n\n# pending price changes\npendingAgentSubPrices: public(HashMap[address, PendingSubPrice])\npriceChangeDelay: public(uint256) # number of blocks that must pass before price changes take effect\n\n# ambassador settings\nambassadorRatio: public(uint256) # ratio of ambassador proceeds\n\n# config\nADDY_REGISTRY: public(immutable(address))\nisActivated: public(bool)\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\n\nMIN_TRIAL_PERIOD: public(immutable(uint256))\nMAX_TRIAL_PERIOD: public(immutable(uint256))\nMIN_PAY_PERIOD: public(immutable(uint256))\nMAX_PAY_PERIOD: public(immutable(uint256))\nMIN_PRICE_CHANGE_BUFFER: public(immutable(uint256))\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_TX_FEE: constant(uint256) = 20_00 # 20.00%\n\n\n@deploy\ndef __init__(\n    _minTrialPeriod: uint256,\n    _maxTrialPeriod: uint256,\n    _minPayPeriod: uint256,\n    _maxPayPeriod: uint256,\n    _minPriceChangeBuffer: uint256,\n    _addyRegistry: address,\n):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    self.protocolRecipient = staticcall AddyRegistry(_addyRegistry).governance()\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n    ADDY_REGISTRY = _addyRegistry\n    MIN_TRIAL_PERIOD = _minTrialPeriod\n    MAX_TRIAL_PERIOD = _maxTrialPeriod\n    MIN_PAY_PERIOD = _minPayPeriod\n    MAX_PAY_PERIOD = _maxPayPeriod\n    MIN_PRICE_CHANGE_BUFFER = _minPriceChangeBuffer\n\n\n@view\n@internal\ndef _isRegisteredAgent(_agent: address) -> bool:\n    agentFactory: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    return staticcall AgentFactory(agentFactory).isAgent(_agent)\n\n\n######################\n# Subscription Utils #\n######################\n\n\n@view\n@external\ndef getCombinedSubData(_user: address, _agent: address, _agentPaidThru: uint256, _protocolPaidThru: uint256, _oracleRegistry: address) -> (SubPaymentInfo, SubPaymentInfo):\n    \"\"\"\n    @notice Get combined subscription data for an agent and protocol\n    @dev Returns a struct containing payment amounts and paid through blocks for both agent and protocol\n    @param _user The address of the user\n    @param _agent The address of the agent\n    @param _agentPaidThru The paid through block for the agent\n    @param _protocolPaidThru The paid through block for the protocol\n    @param _oracleRegistry The address of the oracle registry\n    @return protocolData struct containing payment amounts and paid through blocks for the protocol\n    @return agentData struct containing payment amounts and paid through blocks for the agent\n    \"\"\"\n    # NOTE: in future, we may have different pricing tiers depending on the `_user`\n\n    # protocol sub info\n    protocolData: SubPaymentInfo = self._updatePaidThroughBlock(_protocolPaidThru, self.protocolSubPriceData, _oracleRegistry)\n    if protocolData.amount != 0:\n        protocolData.recipient = self.protocolRecipient\n\n    # agent sub info\n    agentData: SubPaymentInfo = empty(SubPaymentInfo)\n    if _agent != empty(address):\n        agentData = self._updatePaidThroughBlock(_agentPaidThru, self.agentSubPriceData[_agent], _oracleRegistry)\n        agentData.recipient = _agent\n\n    return protocolData, agentData\n\n\n@view\n@internal\ndef _updatePaidThroughBlock(_paidThroughBlock: uint256, _subData: SubscriptionInfo, _oracleRegistry: address) -> SubPaymentInfo:\n    data: SubPaymentInfo = empty(SubPaymentInfo)\n    data.paidThroughBlock = _paidThroughBlock\n\n    # subscription was added (since last checked)\n    if _paidThroughBlock == 0 and _subData.usdValue != 0:\n        data.paidThroughBlock = block.number + _subData.trialPeriod\n        data.didChange = True\n\n    # subscription was removed (since last checked)\n    elif _paidThroughBlock != 0 and _subData.usdValue == 0:\n        data.paidThroughBlock = 0\n        data.didChange = True\n\n    # check if subscription needs to be paid\n    if data.paidThroughBlock != 0 and block.number > data.paidThroughBlock:\n        data.amount = staticcall OracleRegistry(_oracleRegistry).getAssetAmount(_subData.asset, _subData.usdValue)\n\n        # if something fails with price feed, allow transaction through.\n        # it's on agent developer to make sure price feed is working, so they can get paid\n        if data.amount != 0:\n            data.paidThroughBlock = block.number + _subData.payPeriod\n            data.usdValue = _subData.usdValue\n            data.asset = _subData.asset\n            data.didChange = True\n\n    return data\n\n\n######################\n# Agent Subscription #\n######################\n\n\n@view\n@external\ndef getAgentSubPriceData(_agent: address) -> SubscriptionInfo:\n    \"\"\"\n    @notice Get the subscription pricing data for a specific agent\n    @dev Returns empty SubscriptionInfo if agent subscription pricing is disabled\n    @param _agent The address of the agent to query\n    @return SubscriptionInfo struct containing subscription details\n    \"\"\"\n    if not self.isAgentSubPricingEnabled:\n        return empty(SubscriptionInfo)\n    return self.agentSubPriceData[_agent]\n\n\n# set agent sub price\n\n\n@view\n@external\ndef isValidSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Check if subscription price parameters are valid\n    @dev Validates asset, USD value, trial period, and pay period against constraints\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if all parameters are valid\n    \"\"\"\n    return self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod)\n\n\n@view\n@internal\ndef _isValidSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    if _asset == empty(address):\n        return False\n\n    if _payPeriod < MIN_PAY_PERIOD or _payPeriod > MAX_PAY_PERIOD:\n        return False\n\n    if _trialPeriod < MIN_TRIAL_PERIOD or _trialPeriod > MAX_TRIAL_PERIOD:\n        return False\n\n    return _usdValue != 0\n\n\n@external\ndef setAgentSubPrice(_agent: address, _asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Set subscription pricing for a specific agent\n    @dev Creates a pending subscription price change that can be finalized after priceChangeDelay blocks\n    @param _agent The address of the agent\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if pending subscription price was set successfully\n    \"\"\"\n    assert self._isRegisteredAgent(_agent) # dev: agent not registered\n    isAgentOwner: bool = staticcall Agent(_agent).owner() == msg.sender\n    assert isAgentOwner or gov._canGovern(msg.sender) # dev: no perms\n\n    if isAgentOwner:\n        assert self.isActivated # dev: not active\n\n    # validation\n    assert _agent != empty(address) # dev: invalid agent\n    if not self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod):\n        return False\n\n    # create pending subscription price\n    subInfo: SubscriptionInfo = SubscriptionInfo(\n        asset=_asset,\n        usdValue=_usdValue,\n        trialPeriod=_trialPeriod,\n        payPeriod=_payPeriod,\n    )\n\n    # set price change immediately if delay is 0\n    priceChangeDelay: uint256 = self.priceChangeDelay\n    if priceChangeDelay == 0:\n        self._setAgentSubPrice(_agent, subInfo)\n        return True\n\n    # set pending price change\n    effectiveBlock: uint256 = block.number + priceChangeDelay\n    self.pendingAgentSubPrices[_agent] = PendingSubPrice(subInfo=subInfo, effectiveBlock=effectiveBlock)\n    log PendingAgentSubPriceSet(agent=_agent, asset=_asset, usdValue=_usdValue, trialPeriod=_trialPeriod, payPeriod=_payPeriod, effectiveBlock=effectiveBlock)\n\n    return True\n\n\n# finalize agent sub price\n\n\n@external\ndef finalizePendingAgentSubPrice(_agent: address) -> bool:\n    \"\"\"\n    @notice Finalize a pending subscription price for an agent\n    @dev Can only be called after priceChangeDelay blocks have passed since the pending change was created\n    @param _agent The address of the agent\n    @return bool True if subscription price was finalized successfully\n    \"\"\"\n    assert self.isActivated # dev: not active\n\n    pendingPrice: PendingSubPrice = self.pendingAgentSubPrices[_agent]\n    assert pendingPrice.effectiveBlock != 0 and block.number >= pendingPrice.effectiveBlock # dev: time delay not reached\n    self.pendingAgentSubPrices[_agent] = empty(PendingSubPrice)\n\n    # apply pending subscription price\n    self._setAgentSubPrice(_agent, pendingPrice.subInfo)\n    return True\n\n\n@internal\ndef _setAgentSubPrice(_agent: address, _subInfo: SubscriptionInfo):\n    self.agentSubPriceData[_agent] = _subInfo\n    log AgentSubPriceSet(agent=_agent, asset=_subInfo.asset, usdValue=_subInfo.usdValue, trialPeriod=_subInfo.trialPeriod, payPeriod=_subInfo.payPeriod)\n\n\n# removing agent sub price\n\n\n@external\ndef removeAgentSubPrice(_agent: address) -> bool:\n    \"\"\"\n    @notice Remove subscription pricing for a specific agent\n    @dev Only callable by governor\n    @param _agent The address of the agent\n    @return bool True if agent subscription price was removed successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self._isRegisteredAgent(_agent) # dev: agent not registered\n\n    prevInfo: SubscriptionInfo = self.agentSubPriceData[_agent]\n    if empty(address) in [prevInfo.asset, _agent]:\n        return False\n\n    self.agentSubPriceData[_agent] = empty(SubscriptionInfo)\n    log AgentSubPriceRemoved(agent=_agent, asset=prevInfo.asset, usdValue=prevInfo.usdValue, trialPeriod=prevInfo.trialPeriod, payPeriod=prevInfo.payPeriod)\n    return True\n\n\n# enable / disable agent sub pricing\n\n\n@external\ndef setAgentSubPricingEnabled(_isEnabled: bool) -> bool:\n    \"\"\"\n    @notice Enable or disable agent subscription pricing\n    @dev Only callable by governor\n    @param _isEnabled True to enable, False to disable\n    @return bool True if agent subscription pricing state was changed successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert _isEnabled != self.isAgentSubPricingEnabled # dev: no change\n    self.isAgentSubPricingEnabled = _isEnabled\n    log AgentSubPricingEnabled(isEnabled=_isEnabled)\n    return True\n\n\n#########################\n# Protocol Subscription #\n#########################\n\n\n# set protocol sub price\n\n\n@external\ndef setProtocolSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Set subscription pricing for the protocol\n    @dev Only callable by governor\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if protocol subscription price was set successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # validation\n    if not self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod):\n        return False\n\n    # save data\n    self.protocolSubPriceData = SubscriptionInfo(\n        asset=_asset,\n        usdValue=_usdValue,\n        trialPeriod=_trialPeriod,\n        payPeriod=_payPeriod,\n    )\n\n    log ProtocolSubPriceSet(asset=_asset, usdValue=_usdValue, trialPeriod=_trialPeriod, payPeriod=_payPeriod)\n    return True\n\n\n# removing protocol sub price\n\n\n@external\ndef removeProtocolSubPrice() -> bool:\n    \"\"\"\n    @notice Remove subscription pricing for the protocol\n    @dev Only callable by governor\n    @return bool True if protocol subscription price was removed successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevInfo: SubscriptionInfo = self.protocolSubPriceData\n    if prevInfo.asset == empty(address):\n        return False\n\n    self.protocolSubPriceData = empty(SubscriptionInfo)\n    log ProtocolSubPriceRemoved(asset=prevInfo.asset, usdValue=prevInfo.usdValue, trialPeriod=prevInfo.trialPeriod, payPeriod=prevInfo.payPeriod)\n    return True\n\n\n####################\n# Protocol Tx Fees #\n####################\n\n\n# utilities\n\n\n@view\n@external\ndef getTransactionFeeDataWithAmbassadorRatio(_user: address, _action: ActionType) -> (uint256, address, uint256):\n    \"\"\"\n    @notice Get transaction fee data for the protocol\n    @dev Returns a tuple containing the fee amount and recipient address for the protocol\n    @param _user The address of the user\n    @param _action The type of action being performed\n    @return feeAmount The fee amount for the action\n    @return recipient The recipient address for the fee\n    @return ambassadorRatio The ratio of ambassador proceeds\n    \"\"\"\n    # NOTE: in future, we may have different pricing tiers depending on the `_user`\n    return self._getTxFeeForAction(_action, self.protocolTxPriceData), self.protocolRecipient, self.ambassadorRatio\n\n\n@view\n@external\ndef getTransactionFeeData(_user: address, _action: ActionType) -> (uint256, address):\n    # NOTE: this function is still used by legacy wallets\n    return self._getTxFeeForAction(_action, self.protocolTxPriceData), self.protocolRecipient\n\n\n@view\n@internal\ndef _getTxFeeForAction(_action: ActionType, _prices: TxPriceSheet) -> uint256:\n    if _action == ActionType.WITHDRAWAL:\n        return _prices.yieldFee\n    elif _action == ActionType.SWAP:\n        return _prices.swapFee\n    elif _action == ActionType.CLAIM_REWARDS:\n        return _prices.claimRewardsFee\n    else:\n        return 0\n\n\n# set protocol tx price sheet\n\n\n@view\n@external\ndef isValidTxPriceSheet(\n    _yieldFee: uint256,\n    _swapFee: uint256,\n    _claimRewardsFee: uint256,\n) -> bool:\n    \"\"\"\n    @notice Check if transaction price sheet parameters are valid\n    @dev Validates fee percentages against constraints\n    @param _yieldFee The fee percentage for yield profit\n    @param _swapFee The fee percentage for swaps\n    @param _claimRewardsFee The fee percentage for claiming rewards\n    @return bool True if all parameters are valid\n    \"\"\"\n    return self._isValidTxPriceSheet(_yieldFee, _swapFee, _claimRewardsFee)\n\n\n@view\n@internal\ndef _isValidTxPriceSheet(\n    _yieldFee: uint256,\n    _swapFee: uint256,\n    _claimRewardsFee: uint256,\n) -> bool:\n    return _yieldFee <= MAX_TX_FEE and _swapFee <= MAX_TX_FEE and _claimRewardsFee <= MAX_TX_FEE\n\n\n@external\ndef setProtocolTxPriceSheet(\n    _yieldFee: uint256,\n    _swapFee: uint256,\n    _claimRewardsFee: uint256,\n) -> bool:\n    \"\"\"\n    @notice Set transaction price sheet for the protocol\n    @dev Only callable by governor\n    @param _yieldFee The fee percentage for yield profit\n    @param _swapFee The fee percentage for swaps\n    @param _claimRewardsFee The fee percentage for claiming rewards\n    @return bool True if protocol price sheet was set successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # validation\n    if not self._isValidTxPriceSheet(_yieldFee, _swapFee, _claimRewardsFee):\n        return False\n\n    # save data\n    self.protocolTxPriceData = TxPriceSheet(\n        yieldFee=_yieldFee,\n        swapFee=_swapFee,\n        claimRewardsFee=_claimRewardsFee,\n    )\n\n    log ProtocolTxPriceSheetSet(yieldFee=_yieldFee, swapFee=_swapFee, claimRewardsFee=_claimRewardsFee)\n    return True\n\n\n# remove protocol tx price sheet\n\n\n@external\ndef removeProtocolTxPriceSheet() -> bool:\n    \"\"\"\n    @notice Remove transaction price sheet for the protocol\n    @dev Only callable by governor\n    @return bool True if protocol price sheet was removed successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevInfo: TxPriceSheet = self.protocolTxPriceData\n    self.protocolTxPriceData = empty(TxPriceSheet)\n    log ProtocolTxPriceSheetRemoved(yieldFee=prevInfo.yieldFee, swapFee=prevInfo.swapFee, claimRewardsFee=prevInfo.claimRewardsFee)\n    return True\n\n\n######################\n# Protocol Recipient #\n######################\n\n\n@external\ndef setProtocolRecipient(_recipient: address) -> bool:\n    \"\"\"\n    @notice Set the recipient address for protocol fees\n    @dev Only callable by governor\n    @param _recipient The address to receive protocol fees\n    @return bool True if protocol recipient was set successfully\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _recipient != empty(address) # dev: invalid recipient\n    self.protocolRecipient = _recipient\n    log ProtocolRecipientSet(recipient=_recipient)\n    return True\n\n\n######################\n# Price Change Delay #\n######################\n\n\n@external\ndef setPriceChangeDelay(_delayBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Set the number of blocks required before price changes take effect\n    @dev Only callable by governor\n    @param _delayBlocks The number of blocks to wait before price changes take effect\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _delayBlocks == 0 or _delayBlocks >= MIN_PRICE_CHANGE_BUFFER # dev: invalid delay\n    self.priceChangeDelay = _delayBlocks\n    log PriceChangeDelaySet(delayBlocks=_delayBlocks)\n    return True\n\n\n#######################\n# Ambassador Settings #\n#######################\n\n\n@external\ndef setAmbassadorRatio(_ratio: uint256) -> bool:\n    \"\"\"\n    @notice Set the ratio of ambassador proceeds\n    @dev Only callable by governor\n    @param _ratio The ratio of ambassador proceeds\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _ratio <= HUNDRED_PERCENT # dev: invalid ratio\n    self.ambassadorRatio = _ratio\n    log AmbassadorRatioSet(ratio=_ratio)\n    return True\n\n\n############\n# Activate #\n############\n\n\n@external\ndef activate(_shouldActivate: bool):\n    \"\"\"\n    @notice Activate or deactivate the price sheets registry\n    @dev Only callable by governor. When deactivated, most functions cannot be called.\n    @param _shouldActivate True to activate, False to deactivate\n    \"\"\"\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log PriceSheetsActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "4dbd2a5a82044bc6f04add970ac8fe69e3a9305e56be63ff6a6be776089ec6a7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/PriceSheets.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "2c61ab2e90f12b93edf021acfbd26d175de9165144f8e8b8c22dd1360b48d0e7"
      },
      "args": "000000000000000000000000000000000000000000000000000000000000a8c0000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000000000000000003b8260000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "ChainlinkFeeds": {
      "address": "0x605c6ab843d65dD14b00CEB33f445D7f9bbb7930",
      "abi": [
        {
          "name": "ChainlinkFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "chainlinkFeed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getConfiguredAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getChainlinkData",
          "inputs": [
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getChainlinkData",
          "inputs": [
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setChainlinkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableChainlinkPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "feed",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "needsEthToUsd",
                  "type": "bool"
                },
                {
                  "name": "needsBtcToUsd",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "BTC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_btcAddr",
              "type": "address"
            },
            {
              "name": "_ethUsdFeed",
              "type": "address"
            },
            {
              "name": "_btcUsdFeed",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/OracleAssetData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "ebfec365e231ba18d5a0509682ce49c61d855719b832216297c6db33665c7be8"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/oracles/ChainlinkFeeds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: OraclePartner\ninitializes: gov\ninitializes: oad\nexports: gov.__interface__\nexports: oad.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.OracleAssetData as oad\nimport interfaces.OraclePartnerInterface as OraclePartner\n\ninterface ChainlinkFeed:\n    def latestRoundData() -> ChainlinkRound: view\n    def decimals() -> uint8: view \n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nstruct ChainlinkConfig:\n    feed: address\n    decimals: uint256\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n\nevent ChainlinkFeedAdded:\n    asset: indexed(address)\n    chainlinkFeed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n\nevent ChainlinkFeedDisabled:\n    asset: indexed(address)\n\n# chainlink config\nfeedConfig: public(HashMap[address, ChainlinkConfig])\n\n# general config\noraclePartnerId: public(uint256)\nADDY_REGISTRY: public(immutable(address))\n\n# default assets\nWETH: public(immutable(address))\nETH: public(immutable(address))\nBTC: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\n\n\n@deploy\ndef __init__(\n    _wethAddr: address,\n    _ethAddr: address,\n    _btcAddr: address,\n    _ethUsdFeed: address,\n    _btcUsdFeed: address,\n    _addyRegistry: address,\n):\n    assert empty(address) not in [_wethAddr, _ethAddr, _btcAddr, _addyRegistry] # dev: invalid addrs\n    ADDY_REGISTRY = _addyRegistry\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    oad.__init__()\n\n    # set default assets\n    WETH = _wethAddr\n    ETH = _ethAddr\n    BTC = _btcAddr\n\n    # set default feeds\n    if _ethUsdFeed != empty(address):\n        assert self._setChainlinkFeed(ETH, _ethUsdFeed, False, False)\n        assert self._setChainlinkFeed(WETH, _ethUsdFeed, False, False)\n    if _btcUsdFeed != empty(address):\n        assert self._setChainlinkFeed(BTC, _btcUsdFeed, False, False)\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    config: ChainlinkConfig = self.feedConfig[_asset]\n    if config.feed == empty(address):\n        return 0\n    return self._getPrice(config.feed, config.decimals, config.needsEthToUsd, config.needsBtcToUsd, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    config: ChainlinkConfig = self.feedConfig[_asset]\n    if config.feed == empty(address):\n        return 0, False\n    return self._getPrice(config.feed, config.decimals, config.needsEthToUsd, config.needsBtcToUsd, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(\n    _feed: address, \n    _decimals: uint256,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n    _staleTime: uint256,\n) -> uint256:\n    price: uint256 = self._getChainlinkData(_feed, _decimals, _staleTime)\n    if price == 0:\n        return 0\n\n    # if price needs ETH -> USD conversion\n    if _needsEthToUsd:\n        ethConfig: ChainlinkConfig = self.feedConfig[ETH]\n        ethUsdPrice: uint256 = self._getChainlinkData(ethConfig.feed, ethConfig.decimals, _staleTime)\n        price = price * ethUsdPrice // (10 ** NORMALIZED_DECIMALS)\n\n    # if price needs BTC -> USD conversion\n    elif _needsBtcToUsd:\n        btcConfig: ChainlinkConfig = self.feedConfig[BTC]\n        btcUsdPrice: uint256 = self._getChainlinkData(btcConfig.feed, btcConfig.decimals, _staleTime)\n        price = price * btcUsdPrice // (10 ** NORMALIZED_DECIMALS)\n\n    return price\n\n\n@view\n@external\ndef getChainlinkData(_feed: address, _decimals: uint256, _staleTime: uint256 = 0) -> uint256:\n    return self._getChainlinkData(_feed, _decimals, _staleTime)\n\n\n@view\n@internal\ndef _getChainlinkData(_feed: address, _decimals: uint256, _staleTime: uint256) -> uint256:\n    oracle: ChainlinkRound = staticcall ChainlinkFeed(_feed).latestRoundData()\n\n    # NOTE: choosing to fail gracefully in Underscore\n\n    # oracle has no price\n    if oracle.answer <= 0:\n        return 0\n\n    # bad decimals\n    if _decimals > NORMALIZED_DECIMALS:\n        return 0\n\n    # price is too stale\n    if _staleTime != 0 and block.timestamp - oracle.updatedAt > _staleTime:\n        return 0\n\n    # handle decimal normalization\n    price: uint256 = convert(oracle.answer, uint256)\n    decimals: uint256 = _decimals\n    if decimals < NORMALIZED_DECIMALS:\n        decimals = NORMALIZED_DECIMALS - decimals\n        price = price * (10 ** decimals)\n\n    return price\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self._hasPriceFeed(_asset)\n\n\n@view\n@internal\ndef _hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset].feed != empty(address)\n\n\n#####################\n# Config Price Feed #\n#####################\n\n\n# set price feed\n\n\n@view\n@external\ndef isValidChainlinkFeed(\n    _asset: address, \n    _feed: address,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n) -> bool:\n    decimals: uint256 = convert(staticcall ChainlinkFeed(_feed).decimals(), uint256)\n    return self._isValidChainlinkFeed(_asset, _feed, decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n@view\n@internal\ndef _isValidChainlinkFeed(\n    _asset: address, \n    _feed: address,\n    _decimals: uint256,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n) -> bool:\n    if empty(address) in [_asset, _feed]:\n        return False\n    if _needsEthToUsd and _needsBtcToUsd:\n        return False\n    return self._getPrice(_feed, _decimals, _needsEthToUsd, _needsBtcToUsd, 0) != 0\n\n\n@external\ndef setChainlinkFeed(\n    _asset: address, \n    _feed: address, \n    _needsEthToUsd: bool = False,\n    _needsBtcToUsd: bool = False,\n) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setChainlinkFeed(_asset, _feed, _needsEthToUsd, _needsBtcToUsd)\n\n\n@internal\ndef _setChainlinkFeed(\n    _asset: address, \n    _feed: address, \n    _needsEthToUsd: bool = False,\n    _needsBtcToUsd: bool = False,\n) -> bool:\n    decimals: uint256 = convert(staticcall ChainlinkFeed(_feed).decimals(), uint256)\n    if not self._isValidChainlinkFeed(_asset, _feed, decimals, _needsEthToUsd, _needsBtcToUsd):\n        return False\n\n    self.feedConfig[_asset] = ChainlinkConfig(\n        feed=_feed,\n        decimals=decimals,\n        needsEthToUsd=_needsEthToUsd,\n        needsBtcToUsd=_needsBtcToUsd,\n    )\n    oad._addAsset(_asset)\n    log ChainlinkFeedAdded(asset=_asset, chainlinkFeed=_feed, needsEthToUsd=_needsEthToUsd, needsBtcToUsd=_needsBtcToUsd)\n    return True\n\n\n# disable price feed\n\n\n@external\ndef disableChainlinkPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _asset not in [ETH, WETH, BTC] # dev: cannot disable default feeds\n    if not self._hasPriceFeed(_asset):\n        return False\n    self.feedConfig[_asset] = empty(ChainlinkConfig)\n    oad._removeAsset(_asset)\n    log ChainlinkFeedDisabled(asset=_asset)\n    return True\n\n\n##########\n# Config #\n##########\n\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4) # dev: no perms\n    prevId: uint256 = self.oraclePartnerId\n    assert prevId == 0 or prevId == _oracleId # dev: invalid oracle id\n    self.oraclePartnerId = _oracleId\n    return True\n",
            "sha256sum": "b1fd2dd114a6e5f6df9d20c16aaec756c731fa578137002acfcf4a65426caab6"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/oracles/ChainlinkFeeds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "5962d5b6bfe3b188f39feb1324a6e5397c57dbb1ac2fb84f422cfdfce46c209e"
      },
      "args": "0000000000000000000000004200000000000000000000000000000000000006000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb00000000000000000000000071041dddad3595f9ced3dccfbe3d1f4b0a16bb7000000000000000000000000064c911996d3c6ac71f9b455b1e8e7266bcbd848f0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "PythFeeds": {
      "address": "0x415a2fe1e591619c6c12Df09eAEc8a598224F9fE",
      "abi": [
        {
          "name": "PythFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feedId",
              "type": "bytes32",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PythFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PythPriceUpdated",
          "inputs": [
            {
              "name": "payload",
              "type": "bytes",
              "indexed": false
            },
            {
              "name": "feeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EthRecoveredFromPyth",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getConfiguredAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePythPrices",
          "inputs": [
            {
              "name": "_payloads",
              "type": "bytes[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidPythFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPythFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disablePythPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidEthRecovery",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverEthBalance",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "PYTH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_pyth",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/OracleAssetData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "ebfec365e231ba18d5a0509682ce49c61d855719b832216297c6db33665c7be8"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/oracles/PythFeeds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: OraclePartner\ninitializes: gov\ninitializes: oad\nexports: gov.__interface__\nexports: oad.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.OracleAssetData as oad\nimport interfaces.OraclePartnerInterface as OraclePartner\n\ninterface PythNetwork:\n    def getPriceUnsafe(_priceFeedId: bytes32) -> PythPrice: view\n    def priceFeedExists(_priceFeedId: bytes32) -> bool: view\n    def getUpdateFee(_payLoad: Bytes[2048]) -> uint256: view\n    def updatePriceFeeds(_payLoad: Bytes[2048]): payable\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct PythPrice:\n    price: int64\n    confidence: uint64\n    exponent: int32\n    publishTime: uint64\n\nevent PythFeedAdded:\n    asset: indexed(address)\n    feedId: indexed(bytes32)\n\nevent PythFeedDisabled:\n    asset: indexed(address)\n\nevent PythPriceUpdated:\n    payload: Bytes[2048]\n    feeAmount: uint256\n    caller: indexed(address)\n\nevent EthRecoveredFromPyth:\n    recipient: indexed(address)\n    amount: uint256\n\n# pyth config\nPYTH: public(immutable(address))\nfeedConfig: public(HashMap[address, bytes32])\n\n# general config\noraclePartnerId: public(uint256)\nADDY_REGISTRY: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\nMAX_PRICE_UPDATES: constant(uint256) = 15\n\n\n@deploy\ndef __init__(_pyth: address, _addyRegistry: address):\n    assert empty(address) not in [_pyth, _addyRegistry] # dev: invalid addrs\n    PYTH = _pyth\n    ADDY_REGISTRY = _addyRegistry\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    oad.__init__()\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0\n    return self._getPrice(feedId, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0, False\n    return self._getPrice(feedId, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(_feedId: bytes32, _staleTime: uint256) -> uint256:\n    priceData: PythPrice = staticcall PythNetwork(PYTH).getPriceUnsafe(_feedId)\n\n    # NOTE: choosing to fail gracefully in Underscore\n\n    # no price\n    if priceData.price <= 0:\n        return 0\n\n    # price is too stale\n    publishTime: uint256 = convert(priceData.publishTime, uint256)\n    if _staleTime != 0 and block.timestamp - publishTime > _staleTime:\n        return 0\n\n    price: uint256 = convert(priceData.price, uint256)\n    confidence: uint256 = convert(priceData.confidence, uint256)\n    scale: uint256 = 10 ** NORMALIZED_DECIMALS\n    exponent: uint256 = 0\n\n    # negative exponent: multiply by 10^(18-|exponent|)\n    if priceData.exponent < 0:\n        exponent = convert(-priceData.exponent, uint256)\n        price = price * scale // (10 ** exponent)\n        confidence = confidence * scale // (10 ** exponent)\n\n    # positive exponent: multiply by 10^(18+exponent)\n    else:\n        exponent = convert(priceData.exponent, uint256)\n        price = price * scale * (10 ** exponent)\n        confidence = confidence * scale * (10 ** exponent)\n\n    # invalid price\n    if confidence >= price:\n        return 0\n\n    return price - confidence\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self._hasPriceFeed(_asset)\n\n\n@view\n@internal\ndef _hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset] != empty(bytes32)\n\n\n################\n# Update Price #\n################\n\n\n@external\ndef updatePythPrices(_payloads: DynArray[Bytes[2048], MAX_PRICE_UPDATES]):\n    for i: uint256 in range(len(_payloads), bound=MAX_PRICE_UPDATES):\n        p: Bytes[2048] = _payloads[i]\n        feeAmount: uint256 = staticcall PythNetwork(PYTH).getUpdateFee(p)\n        assert self.balance >= feeAmount # dev: insufficient balance\n        extcall PythNetwork(PYTH).updatePriceFeeds(p, value=feeAmount)\n        log PythPriceUpdated(payload=p, feeAmount=feeAmount, caller=msg.sender)\n\n\n#####################\n# Config Price Feed #\n#####################\n\n\n# set price feed\n\n\n@view\n@external\ndef isValidPythFeed(_asset: address, _feedId: bytes32) -> bool:\n    return self._isValidPythFeed(_asset, _feedId)\n\n\n@view\n@internal\ndef _isValidPythFeed(_asset: address, _feedId: bytes32) -> bool:\n    if _asset == empty(address):\n        return False\n    return staticcall PythNetwork(PYTH).priceFeedExists(_feedId)\n\n\n@external\ndef setPythFeed(_asset: address, _feedId: bytes32) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._isValidPythFeed(_asset, _feedId):\n        return False\n    self.feedConfig[_asset] = _feedId\n    oad._addAsset(_asset)\n    log PythFeedAdded(asset=_asset, feedId=_feedId)\n    return True\n\n\n# disable price feed\n\n\n@external\ndef disablePythPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._hasPriceFeed(_asset):\n        return False\n    self.feedConfig[_asset] = empty(bytes32)\n    oad._removeAsset(_asset)\n    log PythFeedDisabled(asset=_asset)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@view\n@external\ndef isValidEthRecovery(_recipient: address) -> bool:\n    return self._isValidEthRecovery(_recipient, self.balance)\n\n\n@view\n@internal\ndef _isValidEthRecovery(_recipient: address, _balance: uint256) -> bool:\n    return _recipient != empty(address) and _balance != 0\n\n\n@external\ndef recoverEthBalance(_recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    balance: uint256 = self.balance\n    if not self._isValidEthRecovery(_recipient, balance):\n        return False\n    send(_recipient, balance)\n    log EthRecoveredFromPyth(recipient=_recipient, amount=balance)\n    return True\n\n\n##########\n# Config #\n##########\n\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4) # dev: no perms\n    prevId: uint256 = self.oraclePartnerId\n    assert prevId == 0 or prevId == _oracleId # dev: invalid oracle id\n    self.oraclePartnerId = _oracleId\n    return True\n",
            "sha256sum": "ba2a1487114df51aaa0ebde35b26d18aba9c3b9af65d3565abfbe19412ab3088"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/oracles/PythFeeds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "136c69192320af8a4e61d673546310f6432408cefb9bd9b69a44ea9d11c07177"
      },
      "args": "0000000000000000000000008250f4af4b972684f7b336503e2d6dfedeb1487a0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "StorkFeeds": {
      "address": "0xD47D74C56c17Bf3B7236e8a7eb97D3194c3d477c",
      "abi": [
        {
          "name": "StorkFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feedId",
              "type": "bytes32",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StorkFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StorkPriceUpdated",
          "inputs": [
            {
              "name": "payload",
              "type": "bytes",
              "indexed": false
            },
            {
              "name": "feeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EthRecoveredFromStork",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getConfiguredAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateStorkPrices",
          "inputs": [
            {
              "name": "_payloads",
              "type": "bytes[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidStorkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStorkFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_feedId",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableStorkPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidEthRecovery",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverEthBalance",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "STORK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_stork",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "contracts/modules/OracleAssetData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "ebfec365e231ba18d5a0509682ce49c61d855719b832216297c6db33665c7be8"
          },
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/oracles/StorkFeeds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: OraclePartner\ninitializes: gov\ninitializes: oad\nexports: gov.__interface__\nexports: oad.__interface__\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.OracleAssetData as oad\nimport interfaces.OraclePartnerInterface as OraclePartner\n\ninterface StorkNetwork:\n    def getTemporalNumericValueUnsafeV1(_priceFeedId: bytes32) -> TemporalNumericValue: view\n    def updateTemporalNumericValuesV1(_payLoad: Bytes[2048]): payable\n    def getUpdateFeeV1(_payLoad: Bytes[2048]) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct TemporalNumericValue:\n    timestampNs: uint64\n    quantizedValue: uint256\n\nevent StorkFeedAdded:\n    asset: indexed(address)\n    feedId: indexed(bytes32)\n\nevent StorkFeedDisabled:\n    asset: indexed(address)\n\nevent StorkPriceUpdated:\n    payload: Bytes[2048]\n    feeAmount: uint256\n    caller: indexed(address)\n\nevent EthRecoveredFromStork:\n    recipient: indexed(address)\n    amount: uint256\n\n# stork config\nSTORK: public(immutable(address))\nfeedConfig: public(HashMap[address, bytes32])\n\n# general config\noraclePartnerId: public(uint256)\nADDY_REGISTRY: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\nMAX_PRICE_UPDATES: constant(uint256) = 15\n\n\n@deploy\ndef __init__(_stork: address, _addyRegistry: address):\n    assert empty(address) not in [_stork, _addyRegistry] # dev: invalid addrs\n    STORK = _stork\n    ADDY_REGISTRY = _addyRegistry\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    oad.__init__()\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0\n    return self._getPrice(feedId, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    feedId: bytes32 = self.feedConfig[_asset]\n    if feedId == empty(bytes32):\n        return 0, False\n    return self._getPrice(feedId, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(_feedId: bytes32, _staleTime: uint256) -> uint256:\n    priceData: TemporalNumericValue = staticcall StorkNetwork(STORK).getTemporalNumericValueUnsafeV1(_feedId)\n\n    # NOTE: choosing to fail gracefully in Underscore\n\n    # no price\n    if priceData.quantizedValue == 0:\n        return 0\n\n    # price is too stale\n    publishTime: uint256 = convert(priceData.timestampNs, uint256) // 1_000_000_000\n    if _staleTime != 0 and block.timestamp - publishTime > _staleTime:\n        return 0\n\n    return priceData.quantizedValue\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self._hasPriceFeed(_asset)\n\n\n@view\n@internal\ndef _hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset] != empty(bytes32)\n\n\n################\n# Update Price #\n################\n\n\n@external\ndef updateStorkPrices(_payloads: DynArray[Bytes[2048], MAX_PRICE_UPDATES]):\n    for i: uint256 in range(len(_payloads), bound=MAX_PRICE_UPDATES):\n        p: Bytes[2048] = _payloads[i]\n        feeAmount: uint256 = staticcall StorkNetwork(STORK).getUpdateFeeV1(p)\n        assert self.balance >= feeAmount # dev: insufficient balance\n        extcall StorkNetwork(STORK).updateTemporalNumericValuesV1(p, value=feeAmount)\n        log StorkPriceUpdated(payload=p, feeAmount=feeAmount, caller=msg.sender)\n\n\n#####################\n# Config Price Feed #\n#####################\n\n\n# set price feed\n\n\n@view\n@external\ndef isValidStorkFeed(_asset: address, _feedId: bytes32) -> bool:\n    return self._isValidStorkFeed(_asset, _feedId)\n\n\n@view\n@internal\ndef _isValidStorkFeed(_asset: address, _feedId: bytes32) -> bool:\n    if _asset == empty(address):\n        return False\n    priceData: TemporalNumericValue = staticcall StorkNetwork(STORK).getTemporalNumericValueUnsafeV1(_feedId)\n    return priceData.timestampNs != 0\n\n\n@external\ndef setStorkFeed(_asset: address, _feedId: bytes32) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._isValidStorkFeed(_asset, _feedId):\n        return False\n    self.feedConfig[_asset] = _feedId\n    oad._addAsset(_asset)\n    log StorkFeedAdded(asset=_asset, feedId=_feedId)\n    return True\n\n\n# disable price feed\n\n\n@external\ndef disableStorkPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    if not self._hasPriceFeed(_asset):\n        return False\n    self.feedConfig[_asset] = empty(bytes32)\n    oad._removeAsset(_asset)\n    log StorkFeedDisabled(asset=_asset)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@view\n@external\ndef isValidEthRecovery(_recipient: address) -> bool:\n    return self._isValidEthRecovery(_recipient, self.balance)\n\n\n@view\n@internal\ndef _isValidEthRecovery(_recipient: address, _balance: uint256) -> bool:\n    return _recipient != empty(address) and _balance != 0\n\n\n@external\ndef recoverEthBalance(_recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    balance: uint256 = self.balance\n    if not self._isValidEthRecovery(_recipient, balance):\n        return False\n    send(_recipient, balance)\n    log EthRecoveredFromStork(recipient=_recipient, amount=balance)\n    return True\n\n\n##########\n# Config #\n##########\n\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4) # dev: no perms\n    prevId: uint256 = self.oraclePartnerId\n    assert prevId == 0 or prevId == _oracleId # dev: invalid oracle id\n    self.oraclePartnerId = _oracleId\n    return True\n",
            "sha256sum": "201ae4139c9529d1072725376d2d2058738be6d49d3d40445b2a2920e0652d4e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/oracles/StorkFeeds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "11048087899003d89aaf390008984caaedb3629dde1f69944b3293533aeac027"
      },
      "args": "000000000000000000000000647dfd812bc1e116c6992cb2bc353b2112176fd60000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoAaveV3": {
      "address": "0x8c94cfC11A9340e45032e5021881cc312993Bf15",
      "abi": [
        {
          "name": "AaveV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3LegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AaveV3Activated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_POOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ADDRESS_PROVIDER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_aaveV3",
              "type": "address"
            },
            {
              "name": "_addressProvider",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoAaveV3.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface AaveProtocolDataProvider:\n    def getReserveTokensAddresses(_asset: address) -> (address, address, address): view\n    def getAllATokens() -> DynArray[TokenData, MAX_ATOKENS]: view\n    def getTotalDebt(_asset: address) -> uint256: view\n\ninterface AaveV3Pool:\n    def supply(_asset: address, _amount: uint256, _onBehalfOf: address, _referralCode: uint16): nonpayable\n    def withdraw(_asset: address, _amount: uint256, _to: address): nonpayable\n\ninterface AToken:\n    def UNDERLYING_ASSET_ADDRESS() -> address: view\n    def totalSupply() -> uint256: view\n\ninterface AaveV3AddressProvider:\n    def getPoolDataProvider() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct TokenData:\n    symbol: String[32]\n    tokenAddress: address\n\nevent AaveV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent AaveV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent AaveV3FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent AaveV3LegoIdSet:\n    legoId: uint256\n\nevent AaveV3Activated:\n    isActivated: bool\n\n# aave v3\nAAVE_V3_POOL: public(immutable(address))\nAAVE_V3_ADDRESS_PROVIDER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nMAX_ATOKENS: constant(uint256) = 40\n\n\n@deploy\ndef __init__(_aaveV3: address, _addressProvider: address, _addyRegistry: address):\n    assert empty(address) not in [_aaveV3, _addressProvider, _addyRegistry] # dev: invalid addrs\n    AAVE_V3_POOL = _aaveV3\n    AAVE_V3_ADDRESS_PROVIDER = _addressProvider\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AAVE_V3_POOL, AAVE_V3_ADDRESS_PROVIDER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n@view\n@internal\ndef _getPoolDataProvider() -> address:\n    return staticcall AaveV3AddressProvider(AAVE_V3_ADDRESS_PROVIDER).getPoolDataProvider()\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidAToken(_vaultToken, self._getPoolDataProvider())\n\n\n@view\n@internal\ndef _isValidAToken(_aToken: address, _dataProvider: address) -> bool:\n    aTokens: DynArray[TokenData, MAX_ATOKENS] = staticcall AaveProtocolDataProvider(_dataProvider).getAllATokens()\n    for i: uint256 in range(len(aTokens), bound=MAX_ATOKENS):\n        if aTokens[i].tokenAddress == _aToken:\n            return True\n    return False\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken, self._getPoolDataProvider())\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address, _dataProvider: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidAToken(_vaultToken, _dataProvider):\n        asset = staticcall AToken(_vaultToken).UNDERLYING_ASSET_ADDRESS()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    # treated as 1:1\n    return _assetAmount\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken, self._getPoolDataProvider())\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall AToken(_vaultToken).totalSupply()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    dataProvider: address = self._getPoolDataProvider()\n    asset: address = self._getUnderlyingAsset(_vaultToken, dataProvider)\n    if asset == empty(address):\n        return 0 # invalid vault token\n    return staticcall AaveProtocolDataProvider(dataProvider).getTotalDebt(asset)\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    vaultToken: address = self._getVaultToken(_asset, _vault)\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preRecipientVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    extcall AaveV3Pool(AAVE_V3_POOL).supply(_asset, depositAmount, _recipient, 0)\n\n    # validate vault token transfer\n    newRecipientVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient)\n    vaultTokenAmountReceived: uint256 = newRecipientVaultBalance - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log AaveV3Deposit(sender=msg.sender, asset=_asset, vaultToken=vaultToken, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, vaultToken, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n@view\n@internal\ndef _getVaultToken(_asset: address, _vault: address) -> address:\n    vault: address = _vault\n    if _vault != empty(address):\n        vault = yld.assetOpportunities[_asset][1] # only one opportunity for aave v3\n    assert yld.indexOfAssetOpportunity[_asset][vault] != 0 # dev: asset + vault not supported\n    return vault\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    vaultToken: address = self._getVaultToken(_asset, _vaultToken)\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n    preRecipientAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall AaveV3Pool(AAVE_V3_POOL).withdraw(_asset, max_value(uint256), _recipient)\n\n    # validate asset transfer\n    newRecipientAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n    assetAmountReceived: uint256 = newRecipientAssetBalance - preRecipientAssetBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log AaveV3Withdrawal(sender=msg.sender, asset=_asset, vaultToken=vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    # Aave has no rewards on Base\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # Aave has no rewards on Base\n    return False\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    dataProvider: address = self._getPoolDataProvider()\n    vaultToken: address = (staticcall AaveProtocolDataProvider(dataProvider).getReserveTokensAddresses(_asset))[0]\n    assert vaultToken != empty(address) # dev: invalid asset\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, vaultToken)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    vaultToken: address = yld.assetOpportunities[_asset][1] # only one opportunity for aave v3\n    yld._removeAssetOpportunity(_asset, vaultToken)\n    assert extcall IERC20(_asset).approve(AAVE_V3_POOL, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AaveV3FundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log AaveV3LegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log AaveV3Activated(isActivated=_shouldActivate)",
            "sha256sum": "f56f0952d282b19afe4c71dd0fc10c3b70d4d0703999cf980e2cea7eed4fe598"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoAaveV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "994585851c491e0cd9abb6962fcae87ff723da486d04875e66a347c1c2e65359"
      },
      "args": "000000000000000000000000a238dd80c259a72e81d7e4664a9801593f98d1c5000000000000000000000000e20fcbdbffc4dd138ce8b2e6fbb6cb49777ad64d0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoCompoundV3": {
      "address": "0xF86d1D68C951d163aBc383C508740df6ddED500C",
      "abi": [
        {
          "name": "CompoundV3Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3Withdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3RewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3LegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CompoundV3Activated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCompRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_CONFIGURATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_configurator",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "contracts/legos/yield/LegoCompoundV3.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\n\n# `hasClaimableRewards()` is not a view function, sadly due to compound v3 constraints\n# keeping here to uncomment to test all other functions\n# implements: LegoCommon \n# from interfaces import LegoCommon\n\ninterface CompoundV3:\n    def withdrawTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def supplyTo(_recipient: address, _asset: address, _amount: uint256): nonpayable\n    def totalSupply() -> uint256: view\n    def totalBorrow() -> uint256: view\n    def baseToken() -> address: view\n\ninterface CompoundV3Rewards:\n    def getRewardOwed(_comet: address, _user: address) -> RewardOwed: nonpayable\n    def claim(_comet: address, _user: address, _shouldAccrue: bool): nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface CompoundV3Configurator:\n    def factory(_cometAsset: address) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct RewardOwed:\n    token: address\n    owed: uint256\n\nevent CompoundV3Deposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent CompoundV3Withdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent CompoundV3FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent CompoundV3RewardsAddrSet:\n    addr: address\n\nevent CompoundV3LegoIdSet:\n    legoId: uint256\n\nevent CompoundV3Activated:\n    isActivated: bool\n\n# compound v3\ncompoundRewards: public(address)\nCOMPOUND_V3_CONFIGURATOR: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\n\n@deploy\ndef __init__(_configurator: address, _addyRegistry: address):\n    assert empty(address) not in [_configurator, _addyRegistry] # dev: invalid addrs\n    COMPOUND_V3_CONFIGURATOR = _configurator\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [COMPOUND_V3_CONFIGURATOR]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidCometAddr(_vaultToken)\n\n\n@view\n@internal\ndef _isValidCometAddr(_cometAddr: address) -> bool:\n    return staticcall CompoundV3Configurator(COMPOUND_V3_CONFIGURATOR).factory(_cometAddr) != empty(address)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidCometAddr(_vaultToken):\n        asset = staticcall CompoundV3(_vaultToken).baseToken()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treated as 1:1\n    return _vaultTokenAmount\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    # treated as 1:1\n    return _assetAmount\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV3(_vaultToken).totalSupply()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV3(_vaultToken).totalBorrow()\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preRecipientVaultBalance: uint256 = staticcall IERC20(_vault).balanceOf(_recipient)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    extcall CompoundV3(_vault).supplyTo(_recipient, _asset, depositAmount) # dev: could not deposit into compound v3\n\n    # validate vault token transfer\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vault).balanceOf(_recipient) - preRecipientVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log CompoundV3Deposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preRecipientBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    extcall CompoundV3(_vaultToken).withdrawTo(_recipient, _asset, max_value(uint256)) # dev: could not withdraw from compound v3\n\n    # validate received asset , transfer back to user\n    assetAmountReceived: uint256 = staticcall IERC20(_asset).balanceOf(_recipient) - preRecipientBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log CompoundV3Withdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    compRewards: address = self.compoundRewards\n    assert compRewards != empty(address) # dev: no comp rewards addr set\n    if _market != empty(address):\n        extcall CompoundV3Rewards(compRewards).claim(_market, _user, True)\n    else:\n        self._hasClaimableOrShouldClaim(_user, True, compRewards)\n\n\n# sadly, this is not a view function because of `getRewardOwed()`\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return self._hasClaimableOrShouldClaim(_user, False, self.compoundRewards)\n\n\n@internal\ndef _hasClaimableOrShouldClaim(_user: address, _shouldClaim: bool, _compRewards: address) -> bool:\n    hasClaimable: bool = False\n    numAssets: uint256 = yld.numAssets\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = yld.assets[i]\n        comet: address = yld.assetOpportunities[asset][1] # only a single \"vault token\" (comet) per asset\n\n        rewardOwed: RewardOwed = extcall CompoundV3Rewards(_compRewards).getRewardOwed(comet, _user)\n        if rewardOwed.owed != 0:\n            hasClaimable = True\n            if _shouldClaim:\n                extcall CompoundV3Rewards(_compRewards).claim(comet, _user, True)\n            else:\n                break\n\n    return hasClaimable\n\n\n# set rewards addr\n\n\n@external\ndef setCompRewardsAddr(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.compoundRewards = _addr\n    log CompoundV3RewardsAddrSet(addr=_addr)\n    return True\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log CompoundV3FundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log CompoundV3LegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log CompoundV3Activated(isActivated=_shouldActivate)\n",
            "sha256sum": "88387c7ca1510d757d33a096f6b1d84be60ab056ed30e95f23aec789f49f81d9"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoCompoundV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "f48dfff8df6ceb9863429d77361dddbced338906edb480a6315ade2ef05aeabd"
      },
      "args": "00000000000000000000000045939657d1ca34a8fa39a924b71d28fe8431e5810000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoEuler": {
      "address": "0xB2a1cdC1D896eE37cD432b591FeC2664294286FB",
      "abi": [
        {
          "name": "EulerDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EulerActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setEulerRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EVAULT_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_EARN_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_evaultFactory",
              "type": "address"
            },
            {
              "name": "_earnFactory",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoEuler.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface Erc4626Interface:\n    def redeem(_vaultTokenAmount: uint256, _recipient: address, _owner: address) -> uint256: nonpayable\n    def deposit(_assetAmount: uint256, _recipient: address) -> uint256: nonpayable\n    def convertToAssets(_vaultTokenAmount: uint256) -> uint256: view\n    def convertToShares(_assetAmount: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def asset() -> address: view\n\ninterface EulerRewardsDistributor:\n    def claim(_users: DynArray[address, 10], _rewardTokens: DynArray[address, 10], _claimAmounts: DynArray[uint256, 10], _proofs: DynArray[bytes32, 10]): nonpayable\n    def operators(_user: address, _operator: address) -> bool: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface EulerEarnFactory:\n    def isValidDeployment(_vault: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface EulerEvaultFactory:\n    def isProxy(_vault: address) -> bool: view\n\ninterface EulerVault:\n    def totalBorrows() -> uint256: view\n\nevent EulerDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent EulerWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent EulerFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent EulerRewardsAddrSet:\n    addr: address\n\nevent EulerLegoIdSet:\n    legoId: uint256\n\nevent EulerActivated:\n    isActivated: bool\n\n# euler\neulerRewards: public(address)\nEULER_EVAULT_FACTORY: public(immutable(address))\nEULER_EARN_FACTORY: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nLEGO_ACCESS_ABI: constant(String[64]) = \"toggleOperator(address,address)\"\n\n\n@deploy\ndef __init__(_evaultFactory: address, _earnFactory: address, _addyRegistry: address):\n    assert empty(address) not in [_evaultFactory, _earnFactory, _addyRegistry] # dev: invalid addrs\n    EULER_EVAULT_FACTORY = _evaultFactory\n    EULER_EARN_FACTORY = _earnFactory\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [EULER_EVAULT_FACTORY, EULER_EARN_FACTORY]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    eulerRewards: address = self.eulerRewards\n    if staticcall EulerRewardsDistributor(eulerRewards).operators(_user, self):\n        return empty(address), empty(String[64]), 0\n    else:\n        return eulerRewards, LEGO_ACCESS_ABI, 2\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidEulerVault(_vaultToken)\n\n\n@view\n@internal\ndef _isValidEulerVault(_vaultToken: address) -> bool:\n    return staticcall EulerEvaultFactory(EULER_EVAULT_FACTORY).isProxy(_vaultToken) or staticcall EulerEarnFactory(EULER_EARN_FACTORY).isValidDeployment(_vaultToken)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidEulerVault(_vaultToken):\n        asset = staticcall Erc4626Interface(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall Erc4626Interface(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall EulerVault(_vaultToken).totalBorrows()\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    vaultTokenAmountReceived: uint256 = extcall Erc4626Interface(_vault).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log EulerDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    transferVaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert transferVaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, transferVaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    vaultTokenAmount: uint256 = min(transferVaultTokenAmount, staticcall IERC20(_vaultToken).balanceOf(self))\n    assetAmountReceived: uint256 = extcall Erc4626Interface(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log EulerWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    eulerRewards: address = self.eulerRewards\n    assert eulerRewards != empty(address) # dev: no euler rewards addr set\n    if _rewardToken == empty(address):\n        return\n    extcall EulerRewardsDistributor(eulerRewards).claim([_user], [_rewardToken], [_rewardAmount], [_proof])\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setEulerRewardsAddr(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.eulerRewards = _addr\n    log EulerRewardsAddrSet(addr=_addr)\n    return True\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log EulerFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log EulerLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log EulerActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "b6d1219695ec12cdbf337628601e1cdb32a614bbe07fbf51fed1529999d2317b"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoEuler.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "275d7d7d0033859de2db1e5b59cc527640e5278b73755f3d43fbaee6bac36d24"
      },
      "args": "0000000000000000000000007f321498a801a191a93c840750ed637149ddf8d000000000000000000000000072bbdb652f2aec9056115644efccdd1986f51f150000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoFluid": {
      "address": "0xc4a864F5543D3CDB06D5F3419c18315f2cDe9675",
      "abi": [
        {
          "name": "FluidDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FluidActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_RESOLVER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_fluidResolver",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoFluid.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface Erc4626Interface:\n    def redeem(_vaultTokenAmount: uint256, _recipient: address, _owner: address) -> uint256: nonpayable\n    def deposit(_assetAmount: uint256, _recipient: address) -> uint256: nonpayable\n    def convertToAssets(_vaultTokenAmount: uint256) -> uint256: view\n    def convertToShares(_assetAmount: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def asset() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface FluidLendingResolver:\n    def getAllFTokens() -> DynArray[address, MAX_FTOKENS]: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nevent FluidDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent FluidWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent FluidFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent FluidLegoIdSet:\n    legoId: uint256\n\nevent FluidActivated:\n    isActivated: bool\n\n# fluid\nFLUID_RESOLVER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nMAX_FTOKENS: constant(uint256) = 50\n\n\n@deploy\ndef __init__(_fluidResolver: address, _addyRegistry: address):\n    assert empty(address) not in [_fluidResolver, _addyRegistry] # dev: invalid addrs\n    FLUID_RESOLVER = _fluidResolver\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [FLUID_RESOLVER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidFToken(_vaultToken)\n\n\n@view\n@internal\ndef _isValidFToken(_fToken: address) -> bool:\n    fTokens: DynArray[address, MAX_FTOKENS] = staticcall FluidLendingResolver(FLUID_RESOLVER).getAllFTokens()\n    return _fToken in fTokens\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidFToken(_vaultToken):\n        asset = staticcall Erc4626Interface(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall Erc4626Interface(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return 0 # TODO\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    vaultTokenAmountReceived: uint256 = extcall Erc4626Interface(_vault).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log FluidDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    transferVaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert transferVaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, transferVaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    vaultTokenAmount: uint256 = min(transferVaultTokenAmount, staticcall IERC20(_vaultToken).balanceOf(self))\n    assetAmountReceived: uint256 = extcall Erc4626Interface(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log FluidWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log FluidFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log FluidLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log FluidActivated(isActivated=_shouldActivate)",
            "sha256sum": "dde64d8e43ca3d7bbacdcd8fff5d76193196d107b0d2bf3c3fdc2ae7f7c01580"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoFluid.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "fe5906d0f6b1b5f684ee35fcfbded8fbb1887734c9766c557c30b05766663a8d"
      },
      "args": "0000000000000000000000003af6fbec4a2fe517f56e402c65e3f4c3e18c1d860000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoMoonwell": {
      "address": "0x3890573c04A13d1D982104c7DaDb17F66cb1aE6c",
      "abi": [
        {
          "name": "MoonwellDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MoonwellActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_COMPTROLLER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_moonwellComptroller",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoMoonwell.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface CompoundV2:\n    def redeem(_ctokenAmount: uint256) -> uint256: nonpayable\n    def mint(_amount: uint256) -> uint256: nonpayable\n    def exchangeRateStored() -> uint256: view\n    def totalBorrows() -> uint256: view\n    def totalSupply() -> uint256: view\n    def underlying() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface MoonwellComptroller:\n    def getAllMarkets() -> DynArray[address, MAX_MARKETS]: view\n    def claimReward(_holder: address): nonpayable\n    def rewardDistributor() -> address: view\n\ninterface MoonwellRewardDistributor:\n    def getOutstandingRewardsForUser(_user: address) -> DynArray[RewardWithMToken, MAX_MARKETS]: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface WethContract:\n    def deposit(): payable\n\nstruct RewardWithMToken:\n    mToken: address\n    rewards: DynArray[RewardInfo, MAX_ASSETS]\n\nstruct RewardInfo:\n    emissionToken: address\n    totalAmount: uint256\n    supplySide: uint256\n    borrowSide: uint256\n\nevent MoonwellDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MoonwellWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent MoonwellFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent MoonwellLegoIdSet:\n    legoId: uint256\n\nevent MoonwellActivated:\n    isActivated: bool\n\n# moonwell\nMOONWELL_COMPTROLLER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\nWETH: public(immutable(address))\n\nMAX_MARKETS: constant(uint256) = 50\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(_moonwellComptroller: address, _addyRegistry: address, _wethAddr: address):\n    assert empty(address) not in [_moonwellComptroller, _addyRegistry, _wethAddr] # dev: invalid addrs\n    MOONWELL_COMPTROLLER = _moonwellComptroller\n    ADDY_REGISTRY = _addyRegistry\n    WETH = _wethAddr\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MOONWELL_COMPTROLLER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidCToken(_vaultToken)\n\n\n@view\n@internal\ndef _isValidCToken(_cToken: address) -> bool:\n    compMarkets: DynArray[address, MAX_MARKETS] = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).getAllMarkets()\n    return _cToken in compMarkets\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidCToken(_vaultToken):\n        asset = staticcall CompoundV2(_vaultToken).underlying()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return _vaultTokenAmount * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return _assetAmount * (10 ** 18) // staticcall CompoundV2(_vaultToken).exchangeRateStored()\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV2(_vaultToken).totalSupply() * staticcall CompoundV2(_vaultToken).exchangeRateStored() // (10 ** 18)\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall CompoundV2(_vaultToken).totalBorrows()\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vault).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    assert extcall CompoundV2(_vault).mint(depositAmount) == 0 # dev: could not deposit into moonwell\n\n    # validate received vault tokens, transfer back to user\n    vaultTokenAmountReceived: uint256 = staticcall IERC20(_vault).balanceOf(self) - preLegoVaultBalance\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n    assert extcall IERC20(_vault).transfer(_recipient, vaultTokenAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log MoonwellDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    vaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert vaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, vaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    assert extcall CompoundV2(_vaultToken).redeem(max_value(uint256)) == 0 # dev: could not withdraw from moonwell\n\n    # when withdrawing weth, they give eth\n    if _asset == WETH:\n        extcall WethContract(WETH).deposit(value=self.balance)\n\n    # validate received asset , transfer back to user\n    assetAmountReceived: uint256 = staticcall IERC20(_asset).balanceOf(self) - preLegoBalance\n    assert assetAmountReceived != 0 # dev: no asset amount received\n    assert extcall IERC20(_asset).transfer(_recipient, assetAmountReceived, default_return_value=True) # dev: transfer failed\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log MoonwellWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    extcall MoonwellComptroller(MOONWELL_COMPTROLLER).claimReward(_user)\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    rewardDistributor: address = staticcall MoonwellComptroller(MOONWELL_COMPTROLLER).rewardDistributor()\n    rewardsWithMToken: DynArray[RewardWithMToken, MAX_MARKETS] = staticcall MoonwellRewardDistributor(rewardDistributor).getOutstandingRewardsForUser(_user)\n    for i: uint256 in range(len(rewardsWithMToken), bound=MAX_MARKETS):\n        rewardsInfo: DynArray[RewardInfo, MAX_ASSETS] = rewardsWithMToken[i].rewards\n        for j: uint256 in range(len(rewardsInfo), bound=MAX_ASSETS):\n            if rewardsInfo[j].totalAmount > 0:\n                return True\n    return False\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid vault and/or asset\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log MoonwellFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log MoonwellLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log MoonwellActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "7f6a247c62ef24164abbed5c8a28dab9faa7fd747713e8f4cc43b57966165fbc"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoMoonwell.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "5bf2f0822a2b553b46fd71e655a4ee4901212327ef291a3bf89fc71370f57956"
      },
      "args": "000000000000000000000000fbb21d0380bee3312b33c4353c8936a0f13ef26c0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae0000000000000000000000004200000000000000000000000000000000000006"
    },
    "LegoMorpho": {
      "address": "0x825309418B066603C2732fdA08d39A79CAA5CC8e",
      "abi": [
        {
          "name": "MorphoDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoRewardsAddrSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MorphoActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAssetOpportunity",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssetOpportunities",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultToAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMorphoRewardsAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAssetOpportunity",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morphoRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_FACTORY_LEGACY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_morphoFactory",
              "type": "address"
            },
            {
              "name": "_morphoFactoryLegacy",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/YieldLegoData.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\n# asset opportunities\nassetOpportunities: public(HashMap[address, HashMap[uint256, address]]) # asset -> index -> vault token\nindexOfAssetOpportunity: public(HashMap[address, HashMap[address, uint256]]) # asset -> vault token -> index\nnumAssetOpportunities: public(HashMap[address, uint256]) # asset -> number of opportunities\nvaultToAsset: public(HashMap[address, address]) # vault token -> asset\n\n# assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__():\n    pass\n\n\n#########\n# Views #\n#########\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    if numOpportunities == 0:\n        return []\n    opportunities: DynArray[address, MAX_VAULTS] = []\n    for i: uint256 in range(1, numOpportunities, bound=MAX_VAULTS):\n        opportunities.append(self.assetOpportunities[_asset][i])\n    return opportunities\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n############\n# Set Data #\n############\n\n\n@internal\ndef _addAssetOpportunity(_asset: address, _vault: address):\n    assert self.indexOfAssetOpportunity[_asset][_vault] == 0 # dev: asset + vault token already added\n    assert empty(address) not in [_asset, _vault] # dev: invalid addresses\n\n    aid: uint256 = self.numAssetOpportunities[_asset]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assetOpportunities[_asset][aid] = _vault\n    self.indexOfAssetOpportunity[_asset][_vault] = aid\n    self.numAssetOpportunities[_asset] = aid + 1\n    self.vaultToAsset[_vault] = _asset\n\n    # add asset\n    self._addAsset(_asset)\n\n    log AssetOpportunityAdded(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _addAsset(_asset: address):\n    if self.indexOfAsset[_asset] != 0:\n        return\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@internal\ndef _removeAssetOpportunity(_asset: address, _vault: address):\n    targetIndex: uint256 = self.indexOfAssetOpportunity[_asset][_vault]\n    assert targetIndex != 0 # dev: asset + vault token not found\n\n    numOpportunities: uint256 = self.numAssetOpportunities[_asset]\n    assert numOpportunities > 1 # dev: no opportunities to remove\n\n    # update data\n    lastIndex: uint256 = numOpportunities - 1\n    self.numAssetOpportunities[_asset] = lastIndex\n    self.indexOfAssetOpportunity[_asset][_vault] = 0\n    self.vaultToAsset[_vault] = empty(address)\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastVaultToken: address = self.assetOpportunities[_asset][lastIndex]\n        self.assetOpportunities[_asset][targetIndex] = lastVaultToken\n        self.indexOfAssetOpportunity[_asset][lastVaultToken] = targetIndex\n\n    # remove asset\n    if lastIndex <= 1:\n        self._removeAsset(_asset)\n\n    log AssetOpportunityRemoved(asset=_asset, vaultToken=_vault)\n\n\n@internal\ndef _removeAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets <= 1:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # shift to replace the removed one\n    if targetIndex != lastIndex:\n        lastAsset: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastAsset\n        self.indexOfAsset[lastAsset] = targetIndex\n",
            "sha256sum": "2d37964d3d6de34d7c5f607e547e79cc5b2fac1b979af56ef6d82d041a438101"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoMorpho.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: yld\ninitializes: gov\n\nexports: yld.__interface__\nexports: gov.__interface__\n\nimport contracts.modules.YieldLegoData as yld\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface Erc4626Interface:\n    def redeem(_vaultTokenAmount: uint256, _recipient: address, _owner: address) -> uint256: nonpayable\n    def deposit(_assetAmount: uint256, _recipient: address) -> uint256: nonpayable\n    def convertToAssets(_vaultTokenAmount: uint256) -> uint256: view\n    def convertToShares(_assetAmount: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def asset() -> address: view\n\ninterface MorphoRewardsDistributor:\n    def claim(_user: address, _rewardToken: address, _claimable: uint256, _proof: bytes32) -> uint256: nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface MetaMorphoFactory:\n    def isMetaMorpho(_vault: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nevent MorphoDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent MorphoWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent MorphoRewardsAddrSet:\n    addr: address\n\nevent MorphoFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent MorphoLegoIdSet:\n    legoId: uint256\n\nevent MorphoActivated:\n    isActivated: bool\n\n# morpho\nmorphoRewards: public(address)\nMORPHO_FACTORY: public(immutable(address))\nMORPHO_FACTORY_LEGACY: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\n\n@deploy\ndef __init__(_morphoFactory: address, _morphoFactoryLegacy: address, _addyRegistry: address):\n    assert empty(address) not in [_morphoFactory, _morphoFactoryLegacy, _addyRegistry] # dev: invalid addrs\n    MORPHO_FACTORY = _morphoFactory\n    MORPHO_FACTORY_LEGACY = _morphoFactoryLegacy\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n    yld.__init__()\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [MORPHO_FACTORY, MORPHO_FACTORY_LEGACY]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    if yld.vaultToAsset[_vaultToken] != empty(address):\n        return True\n    return self._isValidMorphoVault(_vaultToken)\n\n\n@view\n@internal\ndef _isValidMorphoVault(_vaultToken: address) -> bool:\n    return staticcall MetaMorphoFactory(MORPHO_FACTORY).isMetaMorpho(_vaultToken) or staticcall MetaMorphoFactory(MORPHO_FACTORY_LEGACY).isMetaMorpho(_vaultToken)\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    asset: address = yld.vaultToAsset[_vaultToken]\n    if asset == empty(address) and self._isValidMorphoVault(_vaultToken):\n        asset = staticcall Erc4626Interface(_vaultToken).asset()\n    return asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    return staticcall Erc4626Interface(_vaultToken).convertToAssets(_vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if yld.vaultToAsset[_vaultToken] != _asset:\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).convertToShares(_assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall Erc4626Interface(_vaultToken).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return 0 # TODO\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vault] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # deposit assets into lego partner\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    vaultTokenAmountReceived: uint256 = extcall Erc4626Interface(_vault).deposit(depositAmount, _recipient)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log MorphoDeposit(sender=msg.sender, asset=_asset, vaultToken=_vault, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, _vault, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n    assert yld.indexOfAssetOpportunity[_asset][_vaultToken] != 0 # dev: asset + vault not supported\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n\n    # transfer vaults tokens to this contract\n    transferVaultTokenAmount: uint256 = min(_amount, staticcall IERC20(_vaultToken).balanceOf(msg.sender))\n    assert transferVaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_vaultToken).transferFrom(msg.sender, self, transferVaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # withdraw assets from lego partner\n    vaultTokenAmount: uint256 = min(transferVaultTokenAmount, staticcall IERC20(_vaultToken).balanceOf(self))\n    assetAmountReceived: uint256 = extcall Erc4626Interface(_vaultToken).redeem(vaultTokenAmount, _recipient, self)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(_vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log MorphoWithdrawal(sender=msg.sender, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    morphoRewards: address = self.morphoRewards\n    assert morphoRewards != empty(address) # dev: no morpho rewards addr set\n    extcall MorphoRewardsDistributor(morphoRewards).claim(_user, _rewardToken, _rewardAmount, _proof)\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    # as far as we can tell, this must be done offchain\n    return False\n\n\n# set rewards addr\n\n\n@external\ndef setMorphoRewardsAddr(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _addr != empty(address) # dev: invalid addr\n    self.morphoRewards = _addr\n    log MorphoRewardsAddrSet(addr=_addr)\n    return True\n\n\n##################\n# Asset Registry #\n##################\n\n\n@external\ndef addAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # specific to lego\n    assert self._getUnderlyingAsset(_vault) == _asset # dev: invalid asset or vault\n    assert extcall IERC20(_asset).approve(_vault, max_value(uint256), default_return_value=True) # dev: max approval failed\n\n    yld._addAssetOpportunity(_asset, _vault)\n    return True\n\n\n@external\ndef removeAssetOpportunity(_asset: address, _vault: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    yld._removeAssetOpportunity(_asset, _vault)\n    assert extcall IERC20(_asset).approve(_vault, 0, default_return_value=True) # dev: approval failed\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log MorphoFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log MorphoLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log MorphoActivated(isActivated=_shouldActivate)",
            "sha256sum": "a2c08d0beb503526f6eeb2896107138fc4467b286e694d2c536220069dae4652"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoMorpho.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "5dbd7e38415aaf6cc2ca508142413186985bf8a4724a009f3f22159f87660598"
      },
      "args": "000000000000000000000000ff62a7c278c62ed665133147129245053bbf5918000000000000000000000000a9c3d3a366466fa809d1ae982fb2c46e5fc411010000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoSky": {
      "address": "0x3514536163D5c0c5207A6A1230fc76bEe8CE8506",
      "abi": [
        {
          "name": "SkyDeposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SkyWithdrawal",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetOpportunityRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SkyFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SkyLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SkyActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetOpportunities",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAmount",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValueOfVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBorrows",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "usdc",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "usds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "susds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "SKY_PSM",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_skyPsm",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/yield/LegoSky.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoYield\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\ninterface SkyPsm:\n    def swapExactIn(_assetIn: address, _assetOut: address, _amountIn: uint256, _minAmountOut: uint256, _receiver: address, _referralCode: uint256) -> uint256: nonpayable\n    def convertToAssets(_asset: address, _numShares: uint256) -> uint256: view\n    def convertToShares(_asset: address, _amount: uint256) -> uint256: view\n    def totalAssets() -> uint256: view\n    def susds() -> address: view\n    def usdc() -> address: view\n    def usds() -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nevent SkyDeposit:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    usdValue: uint256\n    vaultTokenAmountReceived: uint256\n    recipient: address\n\nevent SkyWithdrawal:\n    sender: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    usdValue: uint256\n    vaultTokenAmountBurned: uint256\n    recipient: address\n\nevent AssetOpportunityAdded:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent AssetOpportunityRemoved:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n\nevent SkyFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent SkyLegoIdSet:\n    legoId: uint256\n\nevent SkyActivated:\n    isActivated: bool\n\n# sky assets\nusdc: public(address)\nusds: public(address)\nsusds: public(address)\nSKY_PSM: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMIN_SLIPPAGE: constant(uint256) = 2_00 # 2%\nMAX_VAULTS: constant(uint256) = 15\nMAX_ASSETS: constant(uint256) = 25\n\n\n@deploy\ndef __init__(_skyPsm: address, _addyRegistry: address):\n    assert empty(address) not in [_skyPsm, _addyRegistry] # dev: invalid addrs\n    SKY_PSM = _skyPsm\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n    # sky assets\n    usdc: address = staticcall SkyPsm(_skyPsm).usdc()\n    if usdc != empty(address):\n        assert extcall IERC20(usdc).approve(_skyPsm, max_value(uint256), default_return_value=True) # dev: max approval failed\n        self.usdc = usdc\n    usds: address = staticcall SkyPsm(_skyPsm).usds()\n    if usds != empty(address):\n        assert extcall IERC20(usds).approve(_skyPsm, max_value(uint256), default_return_value=True) # dev: max approval failed\n        self.usds = usds\n    susds: address = staticcall SkyPsm(_skyPsm).susds()\n    if susds != empty(address):\n        assert extcall IERC20(susds).approve(_skyPsm, max_value(uint256), default_return_value=True) # dev: max approval failed\n        self.susds = susds\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [SKY_PSM]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n#############\n# Utilities #\n#############\n\n\n# assets and vault tokens\n\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, MAX_VAULTS]:\n    if _asset not in [self.usdc, self.usds]:\n        return []\n    return [self.susds]\n\n\n@view\n@external\ndef getAssets() -> DynArray[address, MAX_ASSETS]:\n    return [self.usdc, self.usds]\n\n\n# underlying asset\n\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    return self._isVaultToken(_vaultToken)\n\n\n@view\n@internal\ndef _isVaultToken(_vaultToken: address) -> bool:\n    return _vaultToken == self.susds\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    return self._getUnderlyingAsset(_vaultToken)\n\n\n@view\n@internal\ndef _getUnderlyingAsset(_vaultToken: address) -> address:\n    if not self._isVaultToken(_vaultToken):\n        return empty(address)\n    return self.usds # treating usds as default underlying asset\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    if not self._isVaultToken(_vaultToken) or _vaultTokenAmount == 0:\n        return 0 # invalid vault token or amount\n    return self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n\n\n@view\n@internal\ndef _getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    # treating usds as default underlying asset\n    return staticcall SkyPsm(SKY_PSM).convertToAssets(self.usds, _vaultTokenAmount)\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if _asset not in [self.usdc, self.usds]:\n        return 0 # invalid asset\n    if _vaultToken != self.susds:\n        return 0 # invalid vault token\n    return staticcall SkyPsm(SKY_PSM).convertToShares(_asset, _assetAmount)\n\n\n# usd value\n\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    return self._getUsdValueOfVaultToken(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> uint256:\n    asset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    usdValue: uint256 = 0\n    asset, underlyingAmount, usdValue = self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n    return usdValue\n\n\n# all underlying data together\n\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    return self._getUnderlyingData(_vaultToken, _vaultTokenAmount, _oracleRegistry)\n\n\n@view\n@internal\ndef _getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address) -> (address, uint256, uint256):\n    if _vaultTokenAmount == 0 or _vaultToken == empty(address):\n        return empty(address), 0, 0 # bad inputs\n    asset: address = self._getUnderlyingAsset(_vaultToken)\n    if asset == empty(address):\n        return empty(address), 0, 0 # invalid vault token\n    underlyingAmount: uint256 = self._getUnderlyingAmount(_vaultToken, _vaultTokenAmount)\n    usdValue: uint256 = self._getUsdValue(asset, underlyingAmount, _oracleRegistry)\n    return asset, underlyingAmount, usdValue\n\n\n@view\n@internal\ndef _getUsdValue(_asset: address, _amount: uint256, _oracleRegistry: address) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    return staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount)\n\n\n# other\n\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    if not self._isVaultToken(_vaultToken):\n        return 0 # invalid vault token\n    return staticcall SkyPsm(SKY_PSM).totalAssets()\n\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    return 0\n\n\n###########\n# Deposit #\n###########\n\n\n@external\ndef depositTokens(\n    _asset: address,\n    _amount: uint256,\n    _vault: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, address, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    assert _asset in [self.usdc, self.usds] # dev: invalid asset\n    vaultToken: address = self.susds\n    if _vault != empty(address):\n        assert vaultToken == _vault # dev: invalid vault\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    preRecipientVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(_recipient)\n\n    # transfer deposit asset to this contract\n    transferAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n\n    # calc min amount out\n    depositAmount: uint256 = min(transferAmount, staticcall IERC20(_asset).balanceOf(self))\n    expectedShares: uint256 = staticcall SkyPsm(SKY_PSM).convertToShares(_asset, depositAmount)\n    minAmountOut: uint256 = expectedShares * (HUNDRED_PERCENT - MIN_SLIPPAGE) // HUNDRED_PERCENT\n\n    # deposit assets into lego partner\n    vaultTokenAmountReceived: uint256 = extcall SkyPsm(SKY_PSM).swapExactIn(_asset, vaultToken, depositAmount, minAmountOut, _recipient, 0)\n    assert vaultTokenAmountReceived != 0 # dev: no vault tokens received\n\n    # refund if full deposit didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_asset).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        depositAmount -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, depositAmount, _oracleRegistry)\n    log SkyDeposit(sender=msg.sender, asset=_asset, vaultToken=vaultToken, assetAmountDeposited=depositAmount, usdValue=usdValue, vaultTokenAmountReceived=vaultTokenAmountReceived, recipient=_recipient)\n    return depositAmount, vaultToken, vaultTokenAmountReceived, refundAssetAmount, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@external\ndef withdrawTokens(\n    _asset: address,\n    _amount: uint256,\n    _vaultToken: address,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    assert _asset in [self.usdc, self.usds] # dev: invalid asset\n    vaultToken: address = self.susds\n    if _vaultToken != empty(address):\n        assert vaultToken == _vaultToken # dev: invalid vault\n\n    # pre balances\n    preLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n    preRecipientAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(_recipient)\n\n    # transfer vaults tokens to this contract\n    transferVaultTokenAmount: uint256 = min(_amount, staticcall IERC20(vaultToken).balanceOf(msg.sender))\n    assert transferVaultTokenAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(vaultToken).transferFrom(msg.sender, self, transferVaultTokenAmount, default_return_value=True) # dev: transfer failed\n\n    # calc min amount out\n    vaultTokenAmount: uint256 = min(transferVaultTokenAmount, staticcall IERC20(vaultToken).balanceOf(self))\n    expectedAssetAmount: uint256 = staticcall SkyPsm(SKY_PSM).convertToAssets(_asset, vaultTokenAmount)\n    minAmountOut: uint256 = expectedAssetAmount * (HUNDRED_PERCENT - MIN_SLIPPAGE) // HUNDRED_PERCENT\n\n    # withdraw assets from lego partner\n    assetAmountReceived: uint256 = extcall SkyPsm(SKY_PSM).swapExactIn(vaultToken, _asset, vaultTokenAmount, minAmountOut, _recipient, 0)\n    assert assetAmountReceived != 0 # dev: no asset amount received\n\n    # refund if full withdrawal didn't happen\n    currentLegoVaultBalance: uint256 = staticcall IERC20(vaultToken).balanceOf(self)\n    refundVaultTokenAmount: uint256 = 0\n    if currentLegoVaultBalance > preLegoVaultBalance:\n        refundVaultTokenAmount = currentLegoVaultBalance - preLegoVaultBalance\n        assert extcall IERC20(vaultToken).transfer(msg.sender, refundVaultTokenAmount, default_return_value=True) # dev: transfer failed\n        vaultTokenAmount -= refundVaultTokenAmount\n\n    usdValue: uint256 = self._getUsdValue(_asset, assetAmountReceived, _oracleRegistry)\n    log SkyWithdrawal(sender=msg.sender, asset=_asset, vaultToken=vaultToken, assetAmountReceived=assetAmountReceived, usdValue=usdValue, vaultTokenAmountBurned=vaultTokenAmount, recipient=_recipient)\n    return assetAmountReceived, vaultTokenAmount, refundVaultTokenAmount, usdValue\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log SkyFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log SkyLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log SkyActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "0619a498c8e1ad01d0a24a86a9ad14e4a2e38b9303dd72bb9ec3049275a8d880"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/yield/LegoSky.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "85a97651c84f3bca16084c5d9403e4d055143c13d270d2159464ddb4b3e4864d"
      },
      "args": "0000000000000000000000001601843c5e9bc251a3272907010afa41fa18347e0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoAeroClassic": {
      "address": "0x61C8D98F01B066fA99eb2cf2E6069a7e5d891313",
      "abi": [
        {
          "name": "AerodromeSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroClassicCoreRouterPoolSet",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroClassicFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AerodromeActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCoreRouterPool",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_ROUTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_aerodromeFactory",
              "type": "address"
            },
            {
              "name": "_aerodromeRouter",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/dexes/LegoAeroClassic.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoDex\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom interfaces import LegoDex\nfrom interfaces import LegoCommon\n\ninterface AeroRouter:\n    def addLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _amountADesired: uint256, _amountBDesired: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _lpAmount: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256): nonpayable\n    def swapExactTokensForTokens(_amountIn: uint256, _amountOutMin: uint256, _path: DynArray[Route, MAX_SWAP_HOPS + 2], _to: address, _deadline: uint256) -> DynArray[uint256, MAX_SWAP_HOPS + 2]: nonpayable \n    def quoteAddLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _factory: address, _amountADesired: uint256, _amountBDesired: uint256) -> (uint256, uint256, uint256): view\n    def quoteRemoveLiquidity(_tokenA: address, _tokenB: address, _isStable: bool, _factory: address, _liquidity: uint256) -> (uint256, uint256): view\n\ninterface AeroClassicPool:\n    def swap(_amount0Out: uint256, _amount1Out: uint256, _recipient: address, _data: Bytes[256]): nonpayable\n    def getAmountOut(_amountIn: uint256, _tokenIn: address) -> uint256: view\n    def getReserves() -> (uint256, uint256, uint256): view\n    def tokens() -> (address, address): view\n    def stable() -> bool: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n\ninterface AeroFactory:\n    def getPool(_tokenA: address, _tokenB: address, _isStable: bool) -> address: view\n    def getFee(_pool: address, _isStable: bool) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n    legoId: uint256\n\nstruct Route:\n    from_: address\n    to: address \n    stable: bool\n    factory: address\n\nevent AerodromeSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent AerodromeLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AerodromeLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroClassicCoreRouterPoolSet:\n    pool: indexed(address)\n\nevent AeroClassicFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent AerodromeLegoIdSet:\n    legoId: uint256\n\nevent AerodromeActivated:\n    isActivated: bool\n\n# aero\ncoreRouterPool: public(address)\nAERODROME_FACTORY: public(immutable(address))\nAERODROME_ROUTER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nMAX_SWAP_HOPS: constant(uint256) = 5\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _aerodromeFactory: address,\n    _aerodromeRouter: address,\n    _addyRegistry: address,\n    _coreRouterPool: address,\n):\n    assert empty(address) not in [_aerodromeFactory, _aerodromeRouter, _addyRegistry, _coreRouterPool] # dev: invalid addrs\n    AERODROME_FACTORY = _aerodromeFactory\n    AERODROME_ROUTER = _aerodromeRouter\n    ADDY_REGISTRY = _addyRegistry\n    self.coreRouterPool = _coreRouterPool\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AERODROME_FACTORY, AERODROME_ROUTER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n########\n# Swap #\n########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    initialAmountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert initialAmountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, initialAmountIn, default_return_value=True) # dev: transfer failed\n    initialAmountIn = min(initialAmountIn, staticcall IERC20(tokenIn).balanceOf(self))\n\n    # transfer initial amount to first pool\n    assert extcall IERC20(tokenIn).transfer(_poolPath[0], initialAmountIn, default_return_value=True) # dev: transfer failed\n\n    aeroFactory: address = AERODROME_FACTORY\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = initialAmountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to next pool (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = _poolPath[i + 1]\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, aeroFactory)\n\n    # final amount\n    toAmount: uint256 = tempAmountIn\n    assert toAmount >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        initialAmountIn -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(tokenIn, initialAmountIn, tokenOut, toAmount, True, _oracleRegistry)\n    log AerodromeSwap(sender=msg.sender, tokenIn=tokenIn, tokenOut=tokenOut, amountIn=initialAmountIn, amountOut=toAmount, usdValue=usdValue, numTokens=numTokens, recipient=_recipient)\n    return initialAmountIn, toAmount, refundAssetAmount, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _aeroFactory: address,\n) -> uint256:\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual aerodrome pool\n    assert staticcall AeroFactory(_aeroFactory).getPool(_tokenIn, _tokenOut, staticcall AeroClassicPool(_pool).stable()) == _pool # dev: invalid pool\n\n    zeroForOne: bool = _tokenIn == token0\n    amountOut: uint256 = staticcall AeroClassicPool(_pool).getAmountOut(_amountIn, _tokenIn)\n    assert amountOut != 0 # dev: no tokens swapped\n\n    # put in correct order\n    amount0Out: uint256 = amountOut\n    amount1Out: uint256 = 0\n    if zeroForOne:\n        amount0Out = 0\n        amount1Out = amountOut\n\n    extcall AeroClassicPool(_pool).swap(amount0Out, amount1Out, _recipient, b\"\")\n    return amountOut\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    transferAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert transferAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, transferAmountA, default_return_value=True) # dev: transfer failed\n    liqAmountA: uint256 = min(transferAmountA, staticcall IERC20(_tokenA).balanceOf(self))\n\n    # token b\n    transferAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert transferAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, transferAmountB, default_return_value=True) # dev: transfer failed\n    liqAmountB: uint256 = min(transferAmountB, staticcall IERC20(_tokenB).balanceOf(self))\n\n    # approvals\n    router: address = AERODROME_ROUTER\n    assert extcall IERC20(_tokenA).approve(router, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    liqAmountA, liqAmountB, lpAmountReceived = extcall AeroRouter(router).addLiquidity(\n        _tokenA,\n        _tokenB,\n        staticcall AeroClassicPool(_pool).stable(),\n        liqAmountA,\n        liqAmountB,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert lpAmountReceived != 0 # dev: no liquidity added\n    if _minLpAmount != 0:\n        assert lpAmountReceived >= _minLpAmount # dev: insufficient liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(router, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, False, _oracleRegistry)\n    log AerodromeLiquidityAdded(sender=msg.sender, tokenA=_tokenA, tokenB=_tokenB, amountA=liqAmountA, amountB=liqAmountB, lpAmountReceived=lpAmountReceived, usdValue=usdValue, recipient=_recipient)\n    return lpAmountReceived, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, 0\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    tokens: address[2] = [token0, token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token\n    transferAmount: uint256 = min(_liqToRemove, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n    lpAmount: uint256 = min(transferAmount, staticcall IERC20(_lpToken).balanceOf(self))\n\n    # approvals\n    router: address = AERODROME_ROUTER\n    assert extcall IERC20(_lpToken).approve(router, lpAmount, default_return_value=True) # dev: approval failed\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = extcall AeroRouter(router).removeLiquidity(\n        _tokenA,\n        _tokenB,\n        staticcall AeroClassicPool(_pool).stable(),\n        lpAmount,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert amountA != 0 # dev: no amountA removed\n    assert amountB != 0 # dev: no amountB removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, False, _oracleRegistry)\n    log AerodromeLiquidityRemoved(sender=msg.sender, pool=_pool, tokenA=_tokenA, tokenB=_tokenB, amountA=amountA, amountB=amountB, lpToken=_lpToken, lpAmountBurned=lpAmount, usdValue=usdValue, recipient=_recipient)\n    return amountA, amountB, usdValue, lpAmount, refundedLpAmount, refundedLpAmount != 0\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # in uniswap v2, the lp token is the pool address\n    return _pool\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # in uniswap v2, the pool is the lp token address\n    return _lpToken\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    factory: address = AERODROME_FACTORY\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n\n    # get pool options\n    stablePool: address = staticcall AeroFactory(factory).getPool(_tokenA, _tokenB, True)\n    volatilePool: address = staticcall AeroFactory(factory).getPool(_tokenA, _tokenB, False)\n\n    # no pools found\n    if stablePool == empty(address) and volatilePool == empty(address):\n        return empty(BestPool)\n\n    # stable pool\n    stableLiquidity: uint256 = 0\n    if stablePool != empty(address):\n        reserve0, reserve1, na = staticcall AeroClassicPool(stablePool).getReserves()\n        stableLiquidity = reserve0 + reserve1\n\n    # volatile pool\n    volatileLiquidity: uint256 = 0\n    if volatilePool != empty(address):\n        reserve0, reserve1, na = staticcall AeroClassicPool(volatilePool).getReserves()\n        volatileLiquidity = reserve0 + reserve1\n\n    # best pool determined by liquidity\n    bestPoolAddr: address = stablePool\n    bestLiquidity: uint256 = stableLiquidity\n    isStable: bool = True\n    if volatileLiquidity > stableLiquidity:\n        bestPoolAddr = volatilePool\n        bestLiquidity = volatileLiquidity\n        isStable = False\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=staticcall AeroFactory(factory).getFee(bestPoolAddr, isStable),\n        liquidity=bestLiquidity,\n        numCoins=2,\n        legoId=self.legoId,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    factory: address = AERODROME_FACTORY\n    stablePool: address = staticcall AeroFactory(factory).getPool(_tokenIn, _tokenOut, True)\n    volatilePool: address = staticcall AeroFactory(factory).getPool(_tokenIn, _tokenOut, False)\n    if stablePool == empty(address) and volatilePool == empty(address):\n        return empty(address), 0\n\n    # stable pool\n    stableAmountOut: uint256 = 0\n    if stablePool != empty(address):\n        stableAmountOut = staticcall AeroClassicPool(stablePool).getAmountOut(_amountIn, _tokenIn)\n\n    # volatile pool\n    volatileAmountOut: uint256 = 0\n    if volatilePool != empty(address):\n        volatileAmountOut = staticcall AeroClassicPool(volatilePool).getAmountOut(_amountIn, _tokenIn)\n\n    if stableAmountOut == 0 and volatileAmountOut == 0:\n        return empty(address), 0\n\n    pool: address = stablePool\n    amountOut: uint256 = stableAmountOut\n    if volatileAmountOut > stableAmountOut:\n        pool = volatilePool\n        amountOut = volatileAmountOut\n\n    return pool, amountOut\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    return staticcall AeroClassicPool(_pool).getAmountOut(_amountIn, _tokenIn)\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    # TODO: implement stable pools\n    pool: address = staticcall AeroFactory(AERODROME_FACTORY).getPool(_tokenIn, _tokenOut, False)\n    if pool == empty(address):\n        return empty(address), max_value(uint256)\n\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(pool).tokens()\n    return pool, self._getAmountInForVolatilePools(pool, token0 == _tokenIn, _amountOut)\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if not staticcall AeroClassicPool(_pool).stable():\n        token0: address = empty(address)\n        token1: address = empty(address)\n        token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n        return self._getAmountInForVolatilePools(_pool, token0 == _tokenIn, _amountOut)\n    else:\n        return max_value(uint256) # TODO: implement stable pools\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    return staticcall AeroRouter(AERODROME_ROUTER).quoteAddLiquidity(_tokenA, _tokenB, staticcall AeroClassicPool(_pool).stable(), AERODROME_FACTORY, _availAmountA, _availAmountB)\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    return staticcall AeroRouter(AERODROME_ROUTER).quoteRemoveLiquidity(_tokenA, _tokenB, staticcall AeroClassicPool(_pool).stable(), AERODROME_FACTORY, _lpAmount)\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    if not staticcall AeroClassicPool(_pool).stable():\n        return self._getPriceUnsafeVolatilePool(_pool, _targetToken, _oracleRegistry)\n    else:\n        return 0 # TODO: implement stable pools\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _isSwap: bool,\n    _oracleRegistry: address,\n) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    usdValueA: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenA, _amountA)\n    usdValueB: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenB, _amountB)\n    if _isSwap:\n        return max(usdValueA, usdValueB)\n    else:\n        return usdValueA + usdValueB\n\n\n@view\n@internal\ndef _getPriceUnsafeVolatilePool(_pool: address, _targetToken: address, _oracleRegistry: address) -> uint256:\n    token0: address = empty(address)\n    token1: address = empty(address)\n    token0, token1 = staticcall AeroClassicPool(_pool).tokens()\n\n    # oracle registry\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token1, False)\n    else:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token0, False)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # reserves\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n    reserve0, reserve1, na = staticcall AeroClassicPool(_pool).getReserves()\n\n    # avoid division by zero\n    if reserve0 == 0 or reserve1 == 0:\n        return 0  \n\n    # price of token0 in token1\n    priceZeroToOne: uint256 = reserve1 * EIGHTEEN_DECIMALS // reserve0\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n@view\n@internal\ndef _getAmountInForVolatilePools(_pool: address, _zeroForOne: bool, _amountOut: uint256) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    reserve0: uint256 = 0\n    reserve1: uint256 = 0\n    na: uint256 = 0\n    reserve0, reserve1, na = staticcall AeroClassicPool(_pool).getReserves()\n    if reserve0 == 0 or reserve1 == 0:\n        return max_value(uint256)\n\n    # determine which token is which\n    reserveIn: uint256 = reserve0\n    reserveOut: uint256 = reserve1\n    if not _zeroForOne:\n        reserveIn = reserve1\n        reserveOut = reserve0\n\n    if _amountOut > reserveOut:\n        return max_value(uint256)\n\n    fee: uint256 = staticcall AeroFactory(AERODROME_FACTORY).getFee(_pool, False)\n    numerator: uint256 = reserveIn * _amountOut * 100_00\n    denominator: uint256 = (reserveOut - _amountOut) * (100_00 - fee)\n    return (numerator // denominator) + 1\n\n\n####################\n# Core Router Pool #\n####################\n\n\n@external\ndef setCoreRouterPool(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.coreRouterPool = _addr\n    log AeroClassicCoreRouterPoolSet(pool=_addr)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AeroClassicFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log AerodromeLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log AerodromeActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "2182d68b6f1f1022a5c308fa0bd93bc91ff0b533fd2b7e695231256bdec5850f"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/LegoAeroClassic.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "9d19247a98fef3c266a3453c8051f0f0ada1914991242df4fb388bc104b640a3"
      },
      "args": "000000000000000000000000420dd381b31aef6683db6b902084cb0ffece40da000000000000000000000000cf77a3ba9a5ca399b7c97c74d54e5b1beb874e430000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae000000000000000000000000cdac0d6c6c59727a65f871236188350531885c43"
    },
    "LegoAeroSlipstream": {
      "address": "0x0891DdE2eC48f9663A1c9a81820c283dD8846594",
      "abi": [
        {
          "name": "AeroSlipStreamSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamCoreRouterPoolSet",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamNftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AeroSlipStreamActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "uniswapV3SwapCallback",
          "inputs": [
            {
              "name": "_amount0Delta",
              "type": "int256"
            },
            {
              "name": "_amount1Delta",
              "type": "int256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCoreRouterPool",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_NFT_MANAGER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERO_SLIPSTREAM_QUOTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_aeroFactory",
              "type": "address"
            },
            {
              "name": "_aeroNftPositionManager",
              "type": "address"
            },
            {
              "name": "_aeroQuoter",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/dexes/LegoAeroSlipstream.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: IUniswapV3Callback\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC721\nfrom ethereum.ercs import IERC20Detailed\nfrom interfaces import LegoCommon\n\n# `getSwapAmountOut()` and `getSwapAmountIn()` cannot be view functions, sadly\n# keeping here to uncomment to test all other functions\n# implements: LegoDex\n# from interfaces import LegoDex\n\ninterface AeroSlipStreamPool:\n    def swap(_recipient: address, _zeroForOne: bool, _amountSpecified: int256, _sqrtPriceLimitX96: uint160, _data: Bytes[256]) -> (int256, int256): nonpayable\n    def slot0() -> (uint160, int24, uint16, uint16, uint16, bool): view\n    def tickSpacing() -> int24: view\n    def liquidity() -> uint128: view\n    def token0() -> address: view\n    def token1() -> address: view\n    def fee() -> uint24: view\n\ninterface AeroNftPositionManager:\n    def increaseLiquidity(_params: IncreaseLiquidityParams) -> (uint128, uint256, uint256): nonpayable\n    def decreaseLiquidity(_params: DecreaseLiquidityParams) -> (uint256, uint256): nonpayable\n    def mint(_params: MintParams) -> (uint256, uint128, uint256, uint256): nonpayable\n    def collect(_params: CollectParams) -> (uint256, uint256): nonpayable\n    def positions(_tokenId: uint256) -> PositionData: view\n    def burn(_tokenId: uint256): nonpayable\n\ninterface AeroQuoter:\n    def quoteExactOutputSingle(_params: QuoteExactOutputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInputSingle(_params: QuoteExactInputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n\ninterface IUniswapV3Callback:\n    def uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]): nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n\ninterface AeroSlipStreamFactory:\n    def getPool(_tokenA: address, _tokenB: address, _tickSpacing: int24) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct PoolSwapData:\n    pool: address\n    tokenIn: address\n    amountIn: uint256\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n    legoId: uint256\n\nstruct QuoteExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    tickSpacing: int24\n    sqrtPriceLimitX96: uint160\n\nstruct QuoteExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amount: uint256\n    tickSpacing: int24\n    sqrtPriceLimitX96: uint160\n\nstruct MintParams:\n    token0: address\n    token1: address\n    tickSpacing: int24\n    tickLower: int24\n    tickUpper: int24\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    recipient: address\n    deadline: uint256\n    sqrtPriceX96: uint160\n\nstruct IncreaseLiquidityParams:\n    tokenId: uint256\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct DecreaseLiquidityParams:\n    tokenId: uint256\n    liquidity: uint128\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct CollectParams:\n    tokenId: uint256\n    recipient: address\n    amount0Max: uint128\n    amount1Max: uint128\n\nstruct PositionData:\n    nonce: uint96\n    operator: address\n    token0: address\n    token1: address\n    tickSpacing: uint24\n    tickLower: int24\n    tickUpper: int24\n    liquidity: uint128\n    feeGrowthInside0LastX128: uint256\n    feeGrowthInside1LastX128: uint256\n    tokensOwed0: uint128\n    tokensOwed1: uint128\n\nevent AeroSlipStreamSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent AeroSlipStreamLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityAdded: uint256\n    nftTokenId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroSlipStreamLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    nftTokenId: uint256\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityRemoved: uint256\n    usdValue: uint256\n    recipient: address\n\nevent AeroSlipStreamCoreRouterPoolSet:\n    pool: indexed(address)\n\nevent AeroSlipStreamFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent AeroSlipStreamNftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\nevent AeroSlipStreamLegoIdSet:\n    legoId: uint256\n\nevent AeroSlipStreamActivated:\n    isActivated: bool\n\n# aero\ncoreRouterPool: public(address)\nAERO_SLIPSTREAM_FACTORY: public(immutable(address))\nAERO_SLIPSTREAM_NFT_MANAGER: public(immutable(address))\nAERO_SLIPSTREAM_QUOTER: public(immutable(address))\n\n# transient\npoolSwapData: transient(PoolSwapData)\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nTICK_SPACING: constant(int24[5]) = [1, 50, 100, 200, 2000]\nMIN_SQRT_RATIO_PLUS_ONE: constant(uint160) = 4295128740\nMAX_SQRT_RATIO_MINUS_ONE: constant(uint160) = 1461446703485210103287273052203988822378723970341\nTICK_LOWER: constant(int24) = -887272\nTICK_UPPER: constant(int24) = 887272\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UnderscoreErc721\"\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nUNISWAP_Q96: constant(uint256) = 2 ** 96  # uniswap's fixed point scaling factor\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _aeroFactory: address,\n    _aeroNftPositionManager: address,\n    _aeroQuoter: address,\n    _addyRegistry: address,\n    _coreRouterPool: address,\n):\n    assert empty(address) not in [_aeroFactory, _aeroNftPositionManager, _aeroQuoter, _addyRegistry, _coreRouterPool] # dev: invalid addrs\n    AERO_SLIPSTREAM_FACTORY = _aeroFactory\n    AERO_SLIPSTREAM_NFT_MANAGER = _aeroNftPositionManager\n    AERO_SLIPSTREAM_QUOTER = _aeroQuoter\n    ADDY_REGISTRY = _addyRegistry\n    self.coreRouterPool = _coreRouterPool\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    assert _data == ERC721_RECEIVE_DATA # dev: did not receive from within Underscore wallet\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [AERO_SLIPSTREAM_FACTORY, AERO_SLIPSTREAM_NFT_MANAGER, AERO_SLIPSTREAM_QUOTER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n########\n# Swap #\n########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    initialAmountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert initialAmountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, initialAmountIn, default_return_value=True) # dev: transfer failed\n    initialAmountIn = min(initialAmountIn, staticcall IERC20(tokenIn).balanceOf(self))\n\n    aeroFactory: address = AERO_SLIPSTREAM_FACTORY\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = initialAmountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, aeroFactory)\n\n    # final amount\n    toAmount: uint256 = tempAmountIn\n    assert toAmount >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        initialAmountIn -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(tokenIn, initialAmountIn, tokenOut, toAmount, True, _oracleRegistry)\n    log AeroSlipStreamSwap(sender=msg.sender, tokenIn=tokenIn, tokenOut=tokenOut, amountIn=initialAmountIn, amountOut=toAmount, usdValue=usdValue, numTokens=numTokens, recipient=_recipient)\n    return initialAmountIn, toAmount, refundAssetAmount, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _aeroFactory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall AeroSlipStreamPool(_pool).token0(), staticcall AeroSlipStreamPool(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual aero pool\n    assert staticcall AeroSlipStreamFactory(_aeroFactory).getPool(_tokenIn, _tokenOut, staticcall AeroSlipStreamPool(_pool).tickSpacing()) == _pool # dev: invalid pool\n\n    # save in transient storage (for use in callback)\n    self.poolSwapData = PoolSwapData(\n        pool=_pool,\n        tokenIn=_tokenIn,\n        amountIn=_amountIn,\n    )\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    sqrtPriceLimitX96: uint160 = MAX_SQRT_RATIO_MINUS_ONE\n    if zeroForOne:\n        sqrtPriceLimitX96 = MIN_SQRT_RATIO_PLUS_ONE\n\n    # perform swap\n    amount0: int256 = 0\n    amount1: int256 = 0\n    amount0, amount1 = extcall AeroSlipStreamPool(_pool).swap(_recipient, zeroForOne, convert(_amountIn, int256), sqrtPriceLimitX96, b\"\")\n\n    # check swap results\n    toAmount: uint256 = 0\n    if zeroForOne:\n        toAmount = convert(-amount1, uint256)\n    else:\n        toAmount = convert(-amount0, uint256)\n\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n# callback\n\n\n@external\ndef uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]):\n    poolSwapData: PoolSwapData = self.poolSwapData\n    assert msg.sender == poolSwapData.pool # dev: no perms\n\n    # transfer tokens to pool\n    assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.pool, poolSwapData.amountIn, default_return_value=True) # dev: transfer failed\n    self.poolSwapData = empty(PoolSwapData)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    tokens: address[2] = [staticcall AeroSlipStreamPool(_pool).token0(), staticcall AeroSlipStreamPool(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    transferAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert transferAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, transferAmountA, default_return_value=True) # dev: transfer failed\n    liqAmountA: uint256 = min(transferAmountA, staticcall IERC20(_tokenA).balanceOf(self))\n\n    # token b\n    transferAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert transferAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, transferAmountB, default_return_value=True) # dev: transfer failed\n    liqAmountB: uint256 = min(transferAmountB, staticcall IERC20(_tokenB).balanceOf(self))\n\n    # approvals\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # organized the index of tokens\n    token0: address = _tokenA\n    token1: address = _tokenB\n    amount0: uint256 = liqAmountA\n    amount1: uint256 = liqAmountB\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if tokens[0] != _tokenA:\n        token0 = _tokenB\n        token1 = _tokenA\n        amount0 = liqAmountB\n        amount1 = liqAmountA\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # add liquidity\n    nftTokenId: uint256 = _nftTokenId\n    liquidityAdded: uint256 = 0\n    liquidityAddedInt128: uint128 = 0\n    if _nftTokenId == 0:\n        nftTokenId, liquidityAddedInt128, amount0, amount1 = self._mintNewPosition(nftPositionManager, _pool, token0, token1, _tickLower, _tickUpper, amount0, amount1, minAmount0, minAmount1, _recipient)\n    else:\n        liquidityAddedInt128, amount0, amount1 = self._increaseExistingPosition(nftPositionManager, _nftTokenId, amount0, amount1, minAmount0, minAmount1, _recipient)\n\n    liquidityAdded = convert(liquidityAddedInt128, uint256)\n    assert liquidityAdded != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    # a/b amounts\n    liqAmountA = amount0\n    liqAmountB = amount1\n    if tokens[0] != _tokenA:\n        liqAmountA = amount1\n        liqAmountB = amount0\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, False, _oracleRegistry)\n    log AeroSlipStreamLiquidityAdded(sender=msg.sender, tokenA=_tokenA, tokenB=_tokenB, amountA=liqAmountA, amountB=liqAmountB, liquidityAdded=liquidityAdded, nftTokenId=nftTokenId, usdValue=usdValue, recipient=_recipient)\n    return liquidityAdded, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, nftTokenId\n\n\n@internal\ndef _mintNewPosition(\n    _nftPositionManager: address,\n    _pool: address,\n    _token0: address,\n    _token1: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint256, uint128, uint256, uint256):\n    tickSpacing: int24 = staticcall AeroSlipStreamPool(_pool).tickSpacing()\n\n    tickLower: int24 = 0\n    tickUpper: int24 = 0\n    tickLower, tickUpper = self._getTicks(tickSpacing, _tickLower, _tickUpper)\n\n    # mint new position\n    params: MintParams = MintParams(\n        token0=_token0,\n        token1=_token1,\n        tickSpacing=tickSpacing,\n        tickLower=tickLower,\n        tickUpper=tickUpper,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        recipient=_recipient,\n        deadline=block.timestamp,\n        sqrtPriceX96=0,\n    )\n    return extcall AeroNftPositionManager(_nftPositionManager).mint(params)\n\n\n@view\n@internal\ndef _getTicks(_tickSpacing: int24, _tickLower: int24, _tickUpper: int24) -> (int24, int24):\n    tickLower: int24 = _tickLower\n    if _tickLower == min_value(int24):\n        tickLower = (TICK_LOWER // _tickSpacing) * _tickSpacing\n\n    tickUpper: int24 = _tickUpper\n    if _tickUpper == max_value(int24):\n        tickUpper = (TICK_UPPER // _tickSpacing) * _tickSpacing\n\n    return tickLower, tickUpper\n\n\n@internal\ndef _increaseExistingPosition(\n    _nftPositionManager: address,\n    _tokenId: uint256,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint128, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_tokenId) == self # dev: nft not here\n\n    liquidityAddedInt128: uint128 = 0\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    params: IncreaseLiquidityParams = IncreaseLiquidityParams(\n        tokenId=_tokenId,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        deadline=block.timestamp,\n    )\n    liquidityAddedInt128, amount0, amount1 = extcall AeroNftPositionManager(_nftPositionManager).increaseLiquidity(params)\n\n    # collect fees (if applicable) -- must be done before transferring nft\n    positionData: PositionData = staticcall AeroNftPositionManager(_nftPositionManager).positions(_tokenId)\n    self._collectFees(_nftPositionManager, _tokenId, _recipient, positionData)\n\n    # transfer nft to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _tokenId)\n\n    return liquidityAddedInt128, amount0, amount1\n\n\n@internal\ndef _collectFees(_nftPositionManager: address, _tokenId: uint256, _recipient: address, _positionData: PositionData) -> (uint256, uint256):\n    if _positionData.tokensOwed0 == 0 and _positionData.tokensOwed1 == 0:\n        return 0, 0\n\n    params: CollectParams = CollectParams(\n        tokenId=_tokenId,\n        recipient=_recipient,\n        amount0Max=max_value(uint128),\n        amount1Max=max_value(uint128),\n    )\n    return extcall AeroNftPositionManager(_nftPositionManager).collect(params)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    assert self.isActivated # dev: not activated\n\n    # make sure nft is here\n    nftPositionManager: address = AERO_SLIPSTREAM_NFT_MANAGER\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n    originalLiquidity: uint128 = positionData.liquidity\n\n    # validate tokens\n    tokens: address[2] = [positionData.token0, positionData.token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # organized the index of tokens\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if _tokenA != tokens[0]:\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # decrease liquidity\n    liqToRemove: uint256 = min(_liqToRemove, convert(positionData.liquidity, uint256))\n    assert liqToRemove != 0 # dev: no liquidity to remove\n\n    params: DecreaseLiquidityParams = DecreaseLiquidityParams(\n        tokenId=_nftTokenId,\n        liquidity=convert(liqToRemove, uint128),\n        amount0Min=minAmount0,\n        amount1Min=minAmount1,\n        deadline=block.timestamp,\n    )\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = extcall AeroNftPositionManager(nftPositionManager).decreaseLiquidity(params)\n    assert amount0 != 0 and amount1 != 0 # dev: no liquidity removed\n\n    # a/b amounts\n    amountA: uint256 = amount0\n    amountB: uint256 = amount1\n    if _tokenA != tokens[0]:\n        amountA = amount1\n        amountB = amount0\n\n    # get latest position data -- collect withdrawn tokens AND any fees (if applicable)\n    positionData = staticcall AeroNftPositionManager(nftPositionManager).positions(_nftTokenId)\n    self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # burn nft (if applicable)\n    isDepleted: bool = False\n    if positionData.liquidity == 0:\n        isDepleted = True\n        extcall AeroNftPositionManager(nftPositionManager).burn(_nftTokenId)\n\n    # transfer nft to recipient\n    else:\n        extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, False, _oracleRegistry)\n    liquidityRemoved: uint256 = convert(originalLiquidity - positionData.liquidity, uint256)\n    log AeroSlipStreamLiquidityRemoved(sender=msg.sender, pool=_pool, nftTokenId=_nftTokenId, tokenA=_tokenA, tokenB=_tokenB, amountA=amountA, amountB=amountB, liquidityRemoved=liquidityRemoved, usdValue=usdValue, recipient=_recipient)\n    return amountA, amountB, usdValue, liquidityRemoved, 0, isDepleted\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # no lp tokens for aero slipstream (uni v3)\n    return empty(address)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # no lp tokens for aero slipstream (uni v3)\n    return empty(address)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    bestPoolAddr: address = empty(address)\n    na: int24 = 0\n    bestPoolAddr, na = self._getDeepestLiqPool(_tokenA, _tokenB)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    # get token balances\n    tokenABal: uint256 = staticcall IERC20(_tokenA).balanceOf(bestPoolAddr)\n    tokenBBal: uint256 = staticcall IERC20(_tokenB).balanceOf(bestPoolAddr)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=convert(staticcall AeroSlipStreamPool(bestPoolAddr).fee() // 100, uint256), # normalize to have 100_00 denominator\n        liquidity=tokenABal + tokenBBal, # not exactly \"liquidity\" but this comparable to \"reserves\"\n        numCoins=2,\n        legoId=self.legoId,\n    )\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestPoolAddr, bestTickSpacing = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            tickSpacing=bestTickSpacing,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            tickSpacing=staticcall AeroSlipStreamPool(_pool).tickSpacing(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestPoolAddr, bestTickSpacing = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            tickSpacing=bestTickSpacing,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountIn\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall AeroQuoter(AERO_SLIPSTREAM_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            tickSpacing=staticcall AeroSlipStreamPool(_pool).tickSpacing(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountIn\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n\n    # get correct numerator and denominator\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    sqrtPriceX96Squared: uint256 = self._getSqrtPriceX96(_pool) ** 2\n    if _tokenA == token0:\n        numerator = sqrtPriceX96Squared\n        denominator = UNISWAP_Q96 ** 2\n    else:\n        numerator = UNISWAP_Q96 ** 2\n        denominator = sqrtPriceX96Squared\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = _availAmountA * numerator // denominator\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = _availAmountB * denominator // numerator\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n\n    # calculate expected amounts out\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    amount0Out: uint256 = _lpAmount * UNISWAP_Q96 // sqrtPriceX96\n    amount1Out: uint256 = _lpAmount * sqrtPriceX96 // UNISWAP_Q96\n\n    # return amounts out\n    if _tokenA == token0:\n        return amount0Out, amount1Out\n    else:\n        return amount1Out, amount0Out\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    token0: address = staticcall AeroSlipStreamPool(_pool).token0()\n    token1: address = staticcall AeroSlipStreamPool(_pool).token1()\n\n    # oracle registry\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token1, False)\n    else:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token0, False)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # price of token0 in token1\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    numerator: uint256 = sqrtPriceX96 ** 2 * EIGHTEEN_DECIMALS\n    priceZeroToOne: uint256 = numerator // (UNISWAP_Q96 ** 2)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address) -> (address, int24):\n    bestPoolAddr: address = empty(address)\n    bestTickSpacing: int24 = 0\n    bestLiquidity: uint128 = 0\n\n    factory: address = AERO_SLIPSTREAM_FACTORY\n    for i: uint256 in range(5):\n        tickSpacing: int24 = TICK_SPACING[i]\n        pool: address = staticcall AeroSlipStreamFactory(factory).getPool(_tokenA, _tokenB, tickSpacing)\n        if pool == empty(address):\n            continue\n        liquidity: uint128 = staticcall AeroSlipStreamPool(pool).liquidity()\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestTickSpacing = tickSpacing\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestTickSpacing\n\n\n@view\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _isSwap: bool,\n    _oracleRegistry: address,\n) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    usdValueA: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenA, _amountA)\n    usdValueB: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenB, _amountB)\n    if _isSwap:\n        return max(usdValueA, usdValueB)\n    else:\n        return usdValueA + usdValueB\n\n\n@view\n@internal\ndef _getSqrtPriceX96(_pool: address) -> uint256:\n    sqrtPriceX96: uint160 = 0\n    tick: int24 = 0\n    observationIndex: uint16 = 0\n    observationCardinality: uint16 = 0\n    observationCardinalityNext: uint16 = 0\n    unlocked: bool = False\n    sqrtPriceX96, tick, observationIndex, observationCardinality, observationCardinalityNext, unlocked = staticcall AeroSlipStreamPool(_pool).slot0()\n    return convert(sqrtPriceX96, uint256)\n\n\n####################\n# Core Router Pool #\n####################\n\n\n@external\ndef setCoreRouterPool(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.coreRouterPool = _addr\n    log AeroSlipStreamCoreRouterPoolSet(pool=_addr)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AeroSlipStreamFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log AeroSlipStreamNftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log AeroSlipStreamLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log AeroSlipStreamActivated(isActivated=_shouldActivate)",
            "sha256sum": "a460d35ea627100b8ffd415ab39bfd8f63eeefd55b45e84cbc1498e1918e3b15"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/LegoAeroSlipstream.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "b5b0e5d7d0fcb9983e3f335a47064879b0769b3905b791cf24c505a6b0e55010"
      },
      "args": "0000000000000000000000005e7bb104d84c7cb9b682aac2f3d509f5f406809a000000000000000000000000827922686190790b37229fd06084350e74485b72000000000000000000000000254cf9e1e6e233aa1ac962cb9b05b2cfeaae15b00000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae000000000000000000000000b2cc224c1c9fee385f8ad6a55b4d94e92359dc59"
    },
    "LegoCurve": {
      "address": "0x6118D44763a556Cf8d113ebBce853E14a0C67997",
      "abi": [
        {
          "name": "CurveSwap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveLegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurveActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_META_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_REGISTRIES",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "StableSwapNg",
                  "type": "address"
                },
                {
                  "name": "TwoCryptoNg",
                  "type": "address"
                },
                {
                  "name": "TricryptoNg",
                  "type": "address"
                },
                {
                  "name": "TwoCrypto",
                  "type": "address"
                },
                {
                  "name": "MetaPool",
                  "type": "address"
                },
                {
                  "name": "RateProvider",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_curveAddressProvider",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/dexes/LegoCurve.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n# pragma optimize codesize\n\nimplements: LegoDex\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom interfaces import LegoDex\nfrom interfaces import LegoCommon\n\ninterface CurveMetaRegistry:\n    def get_coin_indices(_pool: address, _from: address, _to: address) -> (int128, int128, bool): view\n    def find_pools_for_coins(_from: address, _to: address) -> DynArray[address, MAX_POOLS]: view\n    def get_registry_handlers_from_pool(_pool: address) -> address[10]: view\n    def get_pool_from_lp_token(_lpToken: address) -> address: view\n    def get_base_registry(_addr: address) -> address: view\n    def get_balances(_pool: address) -> uint256[8]: view\n    def get_coins(_pool: address) -> address[8]: view\n    def get_n_coins(_pool: address) -> uint256: view\n    def get_lp_token(_pool: address) -> address: view\n    def is_registered(_pool: address) -> bool: view\n    def is_meta(_pool: address) -> bool: view\n\ninterface TwoCryptoPool:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: nonpayable\n    def exchange(_i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool = False, _receiver: address = msg.sender) -> uint256: payable\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _useEth: bool = False, _recipient: address = msg.sender): nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: payable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[2]) -> uint256: view\n\ninterface TwoCryptoNgPool:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _recipient: address = msg.sender) -> uint256[2]: nonpayable\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, receiver: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[2], _isDeposit: bool) -> uint256: view\n\ninterface StableNgTwo:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: DynArray[uint256, 2], _recipient: address = msg.sender, _claimAdminFees: bool = True) -> DynArray[uint256, 2]: nonpayable\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: int128, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: DynArray[uint256, 2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 2], _isDeposit: bool) -> uint256: view\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: int128) -> uint256: view\n\ninterface TriCryptoPool:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[3], _useEth: bool = False, _recipient: address = msg.sender, _claimAdminFees: bool = True) -> uint256[3]: nonpayable\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: uint256, _minAmountOut: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: uint256[3], _minLpAmount: uint256, _useEth: bool = False, _recipient: address = msg.sender) -> uint256: payable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: uint256) -> uint256: view\n    def calc_token_amount(_amounts: uint256[3], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolTwo:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[2], _recipient: address = msg.sender) -> uint256[2]: nonpayable\n    def add_liquidity(_amounts: uint256[2], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[2], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolThree:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[3], _recipient: address = msg.sender) -> uint256[3]: nonpayable\n    def add_liquidity(_amounts: uint256[3], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[3], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolFour:\n    def remove_liquidity(_lpBurnAmount: uint256, _minAmountsOut: uint256[4], _recipient: address = msg.sender) -> uint256[4]: nonpayable\n    def add_liquidity(_amounts: uint256[4], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: uint256[4], _isDeposit: bool) -> uint256: view\n\ninterface MetaPoolCommon:\n    def remove_liquidity_one_coin(_lpBurnAmount: uint256, _index: int128, _minAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_withdraw_one_coin(_burnAmount: uint256, _index: int128) -> uint256: view\n\ninterface StableNgThree:\n    def add_liquidity(_amounts: DynArray[uint256, 3], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 3], _isDeposit: bool) -> uint256: view\n\ninterface StableNgFour:\n    def add_liquidity(_amounts: DynArray[uint256, 4], _minLpAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def calc_token_amount(_amounts: DynArray[uint256, 4], _isDeposit: bool) -> uint256: view\n\ninterface CommonCurvePool:\n    def exchange(_i: int128, _j: int128, _dx: uint256, _min_dy: uint256, _receiver: address = msg.sender) -> uint256: nonpayable\n    def fee() -> uint256: view\n\ninterface CurveRateProvider:\n    def get_quotes(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> DynArray[Quote, MAX_QUOTES]: view\n    def get_aggregated_rate(_tokenIn: address, _tokenOut: address) -> uint256: view\n\ninterface CryptoLegacyPool:\n    def exchange(_i: uint256, _j: uint256, _dx: uint256, _min_dy: uint256, _use_eth: bool = False) -> uint256: payable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface CurveAddressProvider:\n    def get_address(_id: uint256) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nflag PoolType:\n    STABLESWAP_NG\n    TWO_CRYPTO_NG\n    TRICRYPTO_NG\n    TWO_CRYPTO\n    METAPOOL\n    CRYPTO\n\nstruct Quote:\n    source_token_index: uint256\n    dest_token_index: uint256\n    is_underlying: bool\n    amount_out: uint256\n    pool: address\n    source_token_pool_balance: uint256\n    dest_token_pool_balance: uint256\n    pool_type: uint8\n\nstruct PoolData:\n    pool: address\n    indexTokenA: uint256\n    indexTokenB: uint256\n    poolType: PoolType\n    numCoins: uint256\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n    legoId: uint256\n\nstruct CurveRegistries:\n    StableSwapNg: address\n    TwoCryptoNg: address\n    TricryptoNg: address\n    TwoCrypto: address\n    MetaPool: address\n    RateProvider: address\n\nevent CurveSwap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent CurveLiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent CurveLiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\nevent CurveFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent CurveLegoIdSet:\n    legoId: uint256\n\nevent CurveActivated:\n    isActivated: bool\n\n# curve\nCURVE_META_REGISTRY: public(immutable(address))\nCURVE_REGISTRIES: public(immutable(CurveRegistries))\n\n# curve address provider ids\nMETAPOOL_FACTORY_ID: constant(uint256) = 3\nTWO_CRYPTO_FACTORY_ID: constant(uint256) = 6\nMETA_REGISTRY_ID: constant(uint256) = 7\nTRICRYPTO_NG_FACTORY_ID: constant(uint256) = 11\nSTABLESWAP_NG_FACTORY_ID: constant(uint256) = 12\nTWO_CRYPTO_NG_FACTORY_ID: constant(uint256) = 13\nRATE_PROVIDER_ID: constant(uint256) = 18\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_POOLS: constant(uint256) = 50\nMAX_QUOTES: constant(uint256) = 100\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(_curveAddressProvider: address, _addyRegistry: address):\n    assert empty(address) not in [_curveAddressProvider, _addyRegistry] # dev: invalid addrs\n    ADDY_REGISTRY = _addyRegistry\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n    CURVE_META_REGISTRY = staticcall CurveAddressProvider(_curveAddressProvider).get_address(META_REGISTRY_ID)\n    CURVE_REGISTRIES = CurveRegistries(\n        StableSwapNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(STABLESWAP_NG_FACTORY_ID),\n        TwoCryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_NG_FACTORY_ID),\n        TricryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TRICRYPTO_NG_FACTORY_ID),\n        TwoCrypto= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_FACTORY_ID),\n        MetaPool= staticcall CurveAddressProvider(_curveAddressProvider).get_address(METAPOOL_FACTORY_ID),\n        RateProvider= staticcall CurveAddressProvider(_curveAddressProvider).get_address(RATE_PROVIDER_ID),\n    )\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [CURVE_META_REGISTRY]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n########\n# Swap #\n########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    initialAmountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert initialAmountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, initialAmountIn, default_return_value=True) # dev: transfer failed\n    initialAmountIn = min(initialAmountIn, staticcall IERC20(tokenIn).balanceOf(self))\n\n    curveMetaRegistry: address = CURVE_META_REGISTRY\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = initialAmountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, curveMetaRegistry)\n\n    # final amount\n    toAmount: uint256 = tempAmountIn\n    assert toAmount >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        initialAmountIn -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(tokenIn, initialAmountIn, tokenOut, toAmount, True, _oracleRegistry)\n    log CurveSwap(sender=msg.sender, tokenIn=tokenIn, tokenOut=tokenOut, amountIn=initialAmountIn, amountOut=toAmount, usdValue=usdValue, numTokens=numTokens, recipient=_recipient)\n    return initialAmountIn, toAmount, refundAssetAmount, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _curveMetaRegistry: address,\n) -> uint256:\n    toAmount: uint256 = 0\n    p: PoolData = self._getPoolData(_pool, _tokenIn, _tokenOut, _curveMetaRegistry)\n    assert extcall IERC20(_tokenIn).approve(_pool, _amountIn, default_return_value=True) # dev: approval failed\n\n    # stable ng\n    if p.poolType == PoolType.STABLESWAP_NG:\n        toAmount = extcall CommonCurvePool(_pool).exchange(convert(p.indexTokenA, int128), convert(p.indexTokenB, int128), _amountIn, 0, _recipient)\n\n    # two crypto ng\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        toAmount = extcall TwoCryptoNgPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, _recipient)\n\n    # two crypto + tricrypto ng pools\n    elif p.poolType == PoolType.TRICRYPTO_NG or p.poolType == PoolType.TWO_CRYPTO:\n        toAmount = extcall TwoCryptoPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, False, _recipient)\n\n    # meta pools\n    elif p.poolType == PoolType.METAPOOL:\n        if staticcall CurveMetaRegistry(_curveMetaRegistry).is_meta(_pool):\n            raise \"Not Implemented\"\n        else:\n            toAmount = extcall CommonCurvePool(_pool).exchange(convert(p.indexTokenA, int128), convert(p.indexTokenB, int128), _amountIn, 0, _recipient)\n\n    # crypto v1\n    else:\n        toAmount = extcall CryptoLegacyPool(_pool).exchange(p.indexTokenA, p.indexTokenB, _amountIn, 0, False)\n        if _recipient != self:\n            assert extcall IERC20(_tokenOut).transfer(_recipient, toAmount, default_return_value=True) # dev: transfer failed\n\n    assert extcall IERC20(_tokenIn).approve(_pool, 0, default_return_value=True) # dev: approval failed\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    assert empty(address) not in [_tokenA, _tokenB] # dev: invalid tokens\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    liqAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, liqAmountA, default_return_value=True) # dev: transfer failed\n        liqAmountA = min(liqAmountA, staticcall IERC20(_tokenA).balanceOf(self))\n        assert extcall IERC20(_tokenA).approve(_pool, liqAmountA, default_return_value=True) # dev: approval failed\n\n    # token b\n    liqAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, liqAmountB, default_return_value=True) # dev: transfer failed\n        liqAmountB = min(liqAmountB, staticcall IERC20(_tokenB).balanceOf(self))\n        assert extcall IERC20(_tokenB).approve(_pool, liqAmountB, default_return_value=True) # dev: approval failed\n\n    assert liqAmountA != 0 or liqAmountB != 0 # dev: need at least one token amount\n\n    # pool data\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        lpAmountReceived = self._addLiquidityStableNg(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        lpAmountReceived = self._addLiquidityTwoCryptoNg(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        lpAmountReceived = self._addLiquidityTwoCrypto(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        lpAmountReceived = self._addLiquidityTricrypto(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        lpAmountReceived = self._addLiquidityMetaPool(p, liqAmountA, liqAmountB, _minLpAmount, _recipient)\n    assert lpAmountReceived != 0 # dev: no liquidity added\n\n    # handle token a refunds / approvals\n    refundAssetAmountA: uint256 = 0\n    if liqAmountA != 0:\n        assert extcall IERC20(_tokenA).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n        currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n        if currentLegoBalanceA > preLegoBalanceA:\n            refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n            assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n            liqAmountA -= refundAssetAmountA\n\n    # handle token b refunds / approvals\n    refundAssetAmountB: uint256 = 0\n    if liqAmountB != 0:\n        assert extcall IERC20(_tokenB).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n        currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n        if currentLegoBalanceB > preLegoBalanceB:\n            refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n            assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n            liqAmountB -= refundAssetAmountB\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, False, _oracleRegistry)\n    log CurveLiquidityAdded(sender=msg.sender, tokenA=_tokenA, tokenB=_tokenB, amountA=liqAmountA, amountB=liqAmountB, lpAmountReceived=lpAmountReceived, usdValue=usdValue, recipient=_recipient)\n    return lpAmountReceived, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, 0\n\n\n@internal\ndef _addLiquidityStableNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    lpAmountReceived: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: DynArray[uint256, 2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgTwo(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 3:\n        amounts: DynArray[uint256, 3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgThree(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 4:\n        amounts: DynArray[uint256, 4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall StableNgFour(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    return lpAmountReceived\n\n\n@internal\ndef _addLiquidityTwoCryptoNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TwoCryptoNgPool(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n\n@internal\ndef _addLiquidityTwoCrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TwoCryptoPool(_p.pool).add_liquidity(amounts, _minLpAmount, False, _recipient)\n\n\n@internal\ndef _addLiquidityTricrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    amounts: uint256[3] = [0, 0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return extcall TriCryptoPool(_p.pool).add_liquidity(amounts, _minLpAmount, False, _recipient)\n\n\n@internal\ndef _addLiquidityMetaPool(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n) -> uint256:\n    lpAmountReceived: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: uint256[2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolTwo(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 3:\n        amounts: uint256[3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolThree(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    elif _p.numCoins == 4:\n        amounts: uint256[4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        lpAmountReceived = extcall MetaPoolFour(_p.pool).add_liquidity(amounts, _minLpAmount, _recipient)\n\n    return lpAmountReceived\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    assert self.isActivated # dev: not activated\n\n    # if one of the tokens is empty, it means they only want to remove liquidity for one token\n    assert _tokenA != empty(address) or _tokenB != empty(address) # dev: invalid tokens\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    isEmptyTokenA: bool = _tokenA == empty(address)\n    isOneCoinRemoval: bool = isEmptyTokenA or _tokenB == empty(address)\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token amount\n    lpAmount: uint256 = min(_liqToRemove, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert lpAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, lpAmount, default_return_value=True) # dev: transfer failed\n    lpAmount = min(lpAmount, staticcall IERC20(_lpToken).balanceOf(self))\n\n    # approvals\n    assert extcall IERC20(_lpToken).approve(_pool, lpAmount, default_return_value=True) # dev: approval failed\n\n    # pool data\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityStableNgOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityStableNg(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTwoCryptoNgOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTwoCryptoNg(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTwoCryptoOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTwoCrypto(p, lpAmount, _tokenA, _tokenB, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityTricryptoOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityTricrypto(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        if isOneCoinRemoval:\n            amountA, amountB = self._removeLiquidityMetaPoolOneCoin(p, isEmptyTokenA, lpAmount, _minAmountA, _minAmountB, _recipient)\n        else:\n            amountA, amountB = self._removeLiquidityMetaPool(p, lpAmount, _minAmountA, _minAmountB, _recipient)\n    assert amountA != 0 or amountB != 0 # dev: nothing removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(_pool, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, False, _oracleRegistry)\n    log CurveLiquidityRemoved(sender=msg.sender, pool=_pool, tokenA=_tokenA, tokenB=_tokenB, amountA=amountA, amountB=amountB, lpToken=_lpToken, lpAmountBurned=lpAmount, usdValue=usdValue, recipient=_recipient)\n    return amountA, amountB, usdValue, lpAmount, refundedLpAmount, refundedLpAmount != 0\n\n\n# stable ng\n\n\n@internal\ndef _removeLiquidityStableNgOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall StableNgTwo(_p.pool).remove_liquidity_one_coin(_lpAmount, convert(tokenIndex, int128), minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityStableNg(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools, can't give minAmountsOut for other coins\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    minAmountsOut: DynArray[uint256, 2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    amountsOut: DynArray[uint256, 2] = extcall StableNgTwo(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient, False)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# two crypto ng\n\n\n@internal\ndef _removeLiquidityTwoCryptoNgOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TwoCryptoNgPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTwoCryptoNg(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools, can't give minAmountsOut for other coins\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    minAmountsOut: uint256[2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    amountsOut: uint256[2] = extcall TwoCryptoNgPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# two crypto\n\n\n@internal\ndef _removeLiquidityTwoCryptoOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TwoCryptoPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, False, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTwoCrypto(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _tokenA: address,\n    _tokenB: address,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools\n    assert _p.numCoins == 2 # dev: invalid pool\n\n    # pre balances\n    preBalTokenA: uint256 = staticcall IERC20(_tokenA).balanceOf(_recipient)\n    preBalTokenB: uint256 = staticcall IERC20(_tokenB).balanceOf(_recipient)\n\n    # organize min amounts out\n    minAmountsOut: uint256[2] = [0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # remove liquidity\n    extcall TwoCryptoPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, False, _recipient)\n\n    # get amounts\n    amountA: uint256 = 0\n    postBalTokenA: uint256 = staticcall IERC20(_tokenA).balanceOf(_recipient)\n    if postBalTokenA > preBalTokenA:\n        amountA = postBalTokenA - preBalTokenA\n\n    amountB: uint256 = 0\n    postBalTokenB: uint256 = staticcall IERC20(_tokenB).balanceOf(_recipient)\n    if postBalTokenB > preBalTokenB:\n        amountB = postBalTokenB - preBalTokenB\n\n    return amountA, amountB\n\n\n# tricrypto ng\n\n\n@internal\ndef _removeLiquidityTricryptoOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall TriCryptoPool(_p.pool).remove_liquidity_one_coin(_lpAmount, tokenIndex, minAmountOut, False, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityTricrypto(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    minAmountsOut: uint256[3] = [0, 0, 0]\n    minAmountsOut[_p.indexTokenA] = _minAmountA\n    minAmountsOut[_p.indexTokenB] = _minAmountB\n\n    # NOTE: user can only specify two min amounts out, the third will be set to zero\n\n    # remove liquidity\n    amountsOut: uint256[3] = extcall TriCryptoPool(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, False, _recipient, False)\n    return amountsOut[_p.indexTokenA], amountsOut[_p.indexTokenB]\n\n\n# meta pool\n\n\n@internal\ndef _removeLiquidityMetaPoolOneCoin(\n    _p: PoolData,\n    _isEmptyTokenA: bool,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = 0\n    minAmountOut: uint256 = 0\n    tokenIndex, minAmountOut = self._getTokenIndexAndMinAmountOut(_isEmptyTokenA, _p.indexTokenA, _p.indexTokenB, _minAmountA, _minAmountB)\n    amountOut: uint256 = extcall MetaPoolCommon(_p.pool).remove_liquidity_one_coin(_lpAmount, convert(tokenIndex, int128), minAmountOut, _recipient)\n    return self._getTokenAmounts(_isEmptyTokenA, amountOut)\n\n\n@internal\ndef _removeLiquidityMetaPool(\n    _p: PoolData,\n    _lpAmount: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n) -> (uint256, uint256):\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n\n    # NOTE: user can only specify two min amounts out, the third/fourth will be set to zero\n\n    if _p.numCoins == 2:\n        minAmountsOut: uint256[2] = [0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[2] = extcall MetaPoolTwo(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    elif _p.numCoins == 3:\n        minAmountsOut: uint256[3] = [0, 0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[3] = extcall MetaPoolThree(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    elif _p.numCoins == 4:\n        minAmountsOut: uint256[4] = [0, 0, 0, 0]\n        minAmountsOut[_p.indexTokenA] = _minAmountA\n        minAmountsOut[_p.indexTokenB] = _minAmountB\n        amountsOut: uint256[4] = extcall MetaPoolFour(_p.pool).remove_liquidity(_lpAmount, minAmountsOut, _recipient)\n        amountA = amountsOut[_p.indexTokenA]\n        amountB = amountsOut[_p.indexTokenB]\n\n    else:\n        raise \"meta pool: pools beyond 4-coin are not supported\"\n\n    return amountA, amountB\n\n\n# utils\n\n\n@pure\n@internal\ndef _getTokenIndexAndMinAmountOut(\n    _isEmptyTokenA: bool,\n    _indexTokenA: uint256,\n    _indexTokenB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n) -> (uint256, uint256):\n    tokenIndex: uint256 = _indexTokenA\n    minAmountOut: uint256 = _minAmountA\n    if _isEmptyTokenA:\n        tokenIndex = _indexTokenB\n        minAmountOut = _minAmountB\n    return tokenIndex, minAmountOut\n\n\n@pure\n@internal\ndef _getTokenAmounts(_isEmptyTokenA: bool, _amountOut: uint256) -> (uint256, uint256):\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    if _isEmptyTokenA:\n        amountB = _amountOut\n    else:\n        amountA = _amountOut\n    return amountA, amountB\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    return staticcall CurveMetaRegistry(CURVE_META_REGISTRY).get_lp_token(_pool)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    return staticcall CurveMetaRegistry(CURVE_META_REGISTRY).get_pool_from_lp_token(_lpToken)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return empty(address)\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    metaRegistry: address = CURVE_META_REGISTRY\n\n    # all pools with tokens\n    allPools: DynArray[address, MAX_POOLS] = staticcall CurveMetaRegistry(metaRegistry).find_pools_for_coins(_tokenA, _tokenB)\n    if len(allPools) == 0:\n        return empty(BestPool)\n\n    # get deepest liquidity pool\n    bestPoolAddr: address = empty(address)\n    na1: int128 = 0\n    na2: int128 = 0\n    bestLiquidity: uint256 = 0\n    bestPoolAddr, na1, na2, bestLiquidity = self._getDeepestLiqPool(_tokenA, _tokenB, allPools, metaRegistry)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=staticcall CommonCurvePool(bestPoolAddr).fee() // 1000000, # normalize to have 100_00 denominator\n        liquidity=bestLiquidity,\n        numCoins=staticcall CurveMetaRegistry(metaRegistry).get_n_coins(bestPoolAddr),\n        legoId=self.legoId,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    return self._getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n\n\n@view\n@internal\ndef _getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPool: address = empty(address)\n    bestAmountOut: uint256 = 0\n\n    quotes: DynArray[Quote, MAX_QUOTES] = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_quotes(_tokenIn, _tokenOut, _amountIn)\n    for quote: Quote in quotes:\n        if quote.amount_out > bestAmountOut:\n            bestAmountOut = quote.amount_out\n            bestPool = quote.pool\n\n    return bestPool, bestAmountOut\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    quotes: DynArray[Quote, MAX_QUOTES] = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_quotes(_tokenIn, _tokenOut, _amountIn)\n    bestAmountOut: uint256 = 0\n    for quote: Quote in quotes:\n        if _pool == quote.pool:\n            return quote.amount_out\n    return 0\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    expAmountIn: uint256 = self._getSwapAmountIn(empty(address), _tokenIn, _tokenOut, _amountOut)\n    if expAmountIn == 0:\n        return empty(address), 0\n\n    # NOTE: this isn't perfect, but it's good enough\n\n    bestPool: address = empty(address)\n    na: uint256 = 0\n    bestPool, na = self._getBestSwapAmountOut(_tokenIn, _tokenOut, expAmountIn)\n    return bestPool, expAmountIn\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n    return self._getSwapAmountIn(_pool, _tokenIn, _tokenOut, _amountOut)\n\n\n@view\n@internal\ndef _getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    rate: uint256 = staticcall CurveRateProvider(CURVE_REGISTRIES.RateProvider).get_aggregated_rate(_tokenIn, _tokenOut)\n    if rate == 0:\n        return 0\n    decimalsTokenIn: uint256 = convert(staticcall IERC20Detailed(_tokenIn).decimals(), uint256)\n    return _amountOut * (10 ** decimalsTokenIn) // rate\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    balances: uint256[8] = staticcall CurveMetaRegistry(metaRegistry).get_balances(_pool)\n    reserveA: uint256 = balances[p.indexTokenA]\n    reserveB: uint256 = balances[p.indexTokenB]\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return 0, 0, 0\n\n    # calculate optimal amounts\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = self._getCorrectRatioAmounts(_availAmountA, _availAmountB, reserveA, reserveB)\n\n    expectedLpAmount: uint256 = 0\n    if p.poolType == PoolType.STABLESWAP_NG:\n        expectedLpAmount = self._getAddLiqAmountsInStableNg(p, amountA, amountB)\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        expectedLpAmount = self._getAddLiqAmountsInCryptoNg(p, amountA, amountB)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        expectedLpAmount = self._getAddLiqAmountsInTwoCrypto(p, amountA, amountB)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        expectedLpAmount = self._getAddLiqAmountsInTricrypto(p, amountA, amountB)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        expectedLpAmount = self._getAddLiqAmountsInMetaPool(p, amountA, amountB)\n\n    if expectedLpAmount == 0:\n        return 0, 0, 0\n\n    return amountA, amountB, expectedLpAmount\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    metaRegistry: address = CURVE_META_REGISTRY\n    p: PoolData = self._getPoolData(_pool, _tokenA, _tokenB, metaRegistry)\n\n    # NOTE: in this case, allowing 0x0 for one token, signifying desire to withdraw just one token\n\n    # normal scenario, 2-coin pool\n    if _tokenA != empty(address) and _tokenB != empty(address):\n        return self._getRemoveLiqAmountsOutTwoCoinPool(p, _tokenA, _tokenB, _lpAmount, metaRegistry)\n\n    # withdraw just one token\n    amountOut: uint256 = 0\n    tokenIndex: uint256 = p.indexTokenA\n    if _tokenA == empty(address):\n        tokenIndex = p.indexTokenB\n\n    # perform calculation\n    if p.poolType == PoolType.STABLESWAP_NG:\n        amountOut = staticcall StableNgTwo(p.pool).calc_withdraw_one_coin(_lpAmount, convert(tokenIndex, int128))\n    elif p.poolType == PoolType.TWO_CRYPTO_NG:\n        amountOut = staticcall TwoCryptoNgPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.TWO_CRYPTO:\n        amountOut = staticcall TwoCryptoPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.TRICRYPTO_NG:\n        amountOut = staticcall TriCryptoPool(p.pool).calc_withdraw_one_coin(_lpAmount, tokenIndex)\n    elif p.poolType == PoolType.METAPOOL and not staticcall CurveMetaRegistry(metaRegistry).is_meta(p.pool):\n        amountOut = staticcall MetaPoolCommon(p.pool).calc_withdraw_one_coin(_lpAmount, convert(tokenIndex, int128))\n\n    # get in correct order\n    amountA: uint256 = amountOut\n    amountB: uint256 = 0\n    if _tokenA == empty(address):\n        amountA = 0\n        amountB = amountOut\n\n    return amountA, amountB\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    return 0\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _isSwap: bool,\n    _oracleRegistry: address,\n) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    usdValueA: uint256 = 0\n    if _tokenA != empty(address) and _amountA != 0:\n        usdValueA = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenA, _amountA)\n    usdValueB: uint256 = 0\n    if _tokenB != empty(address) and _amountB != 0:\n        usdValueB = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenB, _amountB)\n    if _isSwap:\n        return max(usdValueA, usdValueB)\n    else:\n        return usdValueA + usdValueB\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address, _allPools: DynArray[address, MAX_POOLS], _metaRegistry: address) -> (address, int128, int128, uint256):\n    bestPoolAddr: address = empty(address)\n    bestTokenAIndex: int128 = 0\n    bestTokenBIndex: int128 = 0\n    bestLiquidity: uint256 = 0\n\n    for i: uint256 in range(len(_allPools), bound=MAX_POOLS):\n        pool: address = _allPools[i]\n        if pool == empty(address):\n            continue\n\n        # balances\n        balances: uint256[8] = staticcall CurveMetaRegistry(_metaRegistry).get_balances(pool)\n        if balances[0] == 0:\n            continue\n\n        # token indexes \n        indexTokenA: int128 = 0\n        indexTokenB: int128 = 0\n        na: bool = False\n        indexTokenA, indexTokenB, na = staticcall CurveMetaRegistry(_metaRegistry).get_coin_indices(pool, _tokenA, _tokenB)\n\n        # compare liquidity\n        liquidity: uint256 = balances[indexTokenA] + balances[indexTokenB]\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestTokenAIndex = indexTokenA\n            bestTokenBIndex = indexTokenB\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestTokenAIndex, bestTokenBIndex, bestLiquidity\n\n\n@view\n@internal\ndef _getPoolData(_pool: address, _tokenA: address, _tokenB: address, _metaRegistry: address) -> PoolData:\n    assert staticcall CurveMetaRegistry(_metaRegistry).is_registered(_pool) # dev: invalid pool\n    coins: address[8] = staticcall CurveMetaRegistry(_metaRegistry).get_coins(_pool)\n\n    # validate tokens\n    if _tokenA != empty(address):\n        assert _tokenA in coins # dev: invalid tokens\n    if _tokenB != empty(address):\n        assert _tokenB in coins # dev: invalid tokens\n\n    # get indices\n    indexTokenA: uint256 = max_value(uint256)\n    indexTokenB: uint256 = max_value(uint256)\n    numCoins: uint256 = 0\n    for coin: address in coins:\n        if coin == empty(address):\n            break\n        if coin == _tokenA:\n            indexTokenA = numCoins\n        elif coin == _tokenB:\n            indexTokenB = numCoins\n        numCoins += 1\n\n    return PoolData(\n        pool=_pool,\n        indexTokenA=indexTokenA,\n        indexTokenB=indexTokenB,\n        poolType=self._getPoolType(_pool, _metaRegistry),\n        numCoins=numCoins,\n    )\n\n\n@view\n@internal\ndef _getPoolType(_pool: address, _metaRegistry: address) -> PoolType:\n    # check what type of pool this is based on where it's registered on Curve\n    registryHandlers: address[10] = staticcall CurveMetaRegistry(_metaRegistry).get_registry_handlers_from_pool(_pool)\n    baseRegistry: address = staticcall CurveMetaRegistry(_metaRegistry).get_base_registry(registryHandlers[0])\n\n    curveRegistries: CurveRegistries = CURVE_REGISTRIES\n    poolType: PoolType = empty(PoolType)\n    if baseRegistry == curveRegistries.StableSwapNg:\n        poolType = PoolType.STABLESWAP_NG\n    elif baseRegistry == curveRegistries.TwoCryptoNg:\n        poolType = PoolType.TWO_CRYPTO_NG\n    elif baseRegistry == curveRegistries.TricryptoNg:\n        poolType = PoolType.TRICRYPTO_NG\n    elif baseRegistry == curveRegistries.TwoCrypto:\n        poolType = PoolType.TWO_CRYPTO\n    elif baseRegistry == curveRegistries.MetaPool:\n        poolType = PoolType.METAPOOL\n    else:\n        poolType = PoolType.CRYPTO\n    return poolType\n\n\n@view\n@internal\ndef _getAddLiqAmountsInStableNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    expLpAmount: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: DynArray[uint256, 2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgTwo(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 3:\n        amounts: DynArray[uint256, 3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgThree(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 4:\n        amounts: DynArray[uint256, 4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall StableNgFour(_p.pool).calc_token_amount(amounts, True)\n\n    return expLpAmount\n\n\n@view\n@internal\ndef _getAddLiqAmountsInCryptoNg(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TwoCryptoNgPool(_p.pool).calc_token_amount(amounts, True)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInTwoCrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[2] = [0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TwoCryptoPool(_p.pool).calc_token_amount(amounts)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInTricrypto(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    amounts: uint256[3] = [0, 0, 0]\n    amounts[_p.indexTokenA] = _liqAmountA\n    amounts[_p.indexTokenB] = _liqAmountB\n    return staticcall TriCryptoPool(_p.pool).calc_token_amount(amounts, True)\n\n\n@view\n@internal\ndef _getAddLiqAmountsInMetaPool(\n    _p: PoolData,\n    _liqAmountA: uint256,\n    _liqAmountB: uint256,\n) -> uint256:\n    expLpAmount: uint256 = 0\n\n    if _p.numCoins == 2:\n        amounts: uint256[2] = [0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolTwo(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 3:\n        amounts: uint256[3] = [0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolThree(_p.pool).calc_token_amount(amounts, True)\n\n    elif _p.numCoins == 4:\n        amounts: uint256[4] = [0, 0, 0, 0]\n        amounts[_p.indexTokenA] = _liqAmountA\n        amounts[_p.indexTokenB] = _liqAmountB\n        expLpAmount = staticcall MetaPoolFour(_p.pool).calc_token_amount(amounts, True)\n\n    return expLpAmount\n\n\n@view\n@internal\ndef _getRemoveLiqAmountsOutTwoCoinPool(\n    _p: PoolData,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n    _metaRegistry: address,\n) -> (uint256, uint256):\n\n    # only supporting 2-coin pools\n    if _p.numCoins > 2:\n        return max_value(uint256), max_value(uint256)\n\n    # get balances\n    balances: uint256[8] = staticcall CurveMetaRegistry(_metaRegistry).get_balances(_p.pool)\n    reserveA: uint256 = balances[_p.indexTokenA]\n    reserveB: uint256 = balances[_p.indexTokenB]\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return max_value(uint256), max_value(uint256)\n\n    # calculate expected amounts out\n    lpToken: address = staticcall CurveMetaRegistry(_metaRegistry).get_lp_token(_p.pool)\n    totalSupply: uint256 = staticcall IERC20(lpToken).totalSupply()\n    expectedAmountA: uint256 = _lpAmount * reserveA // totalSupply\n    expectedAmountB: uint256 = _lpAmount * reserveB // totalSupply\n    return expectedAmountA, expectedAmountB\n\n\n@view\n@internal\ndef _getCorrectRatioAmounts(\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n    _reserveA: uint256,\n    _reserveB: uint256,\n) -> (uint256, uint256):\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = self._quote(_availAmountA, _reserveA, _reserveB)\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = self._quote(_availAmountB, _reserveB, _reserveA)\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB\n\n\n@view\n@internal\ndef _quote(_amountA: uint256, _reserveA: uint256, _reserveB: uint256) -> uint256:\n    return (_amountA * _reserveB) // _reserveA\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log CurveFundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log CurveLegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log CurveActivated(isActivated=_shouldActivate)",
            "sha256sum": "f23aceef5f24e5dad5dd1cd7b86c8aba4e87610e8d5385fb753c324aecf9d1ea"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/LegoCurve.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "4b5fe874e59cc25acb40d039d1b0ac2dfa5965390a0d23dbd680eb197f5e3530"
      },
      "args": "0000000000000000000000005ffe7fb82894076ecb99a30d6a32e969e6e35e980000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae"
    },
    "LegoUniswapV2": {
      "address": "0x9973e271Bd6cAb8Ce1CAEaBAB8a1bEbcB6EdD535",
      "abi": [
        {
          "name": "UniswapV2LiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2LiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "lpAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2Swap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniV2WethCoreRouterPoolSet",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniV2FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2LegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV2Activated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCoreRouterPool",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_ROUTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_uniswapV2Factory",
              "type": "address"
            },
            {
              "name": "_uniswapV2Router",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/dexes/LegoUniswapV2.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: LegoDex\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\nfrom interfaces import LegoDex\nfrom interfaces import LegoCommon\n\ninterface IUniswapV2Pair:\n    def swap(_amount0Out: uint256, _amount1Out: uint256, _recipient: address, _data: Bytes[256]): nonpayable\n    def getReserves() -> (uint112, uint112, uint32): view\n    def token0() -> address: view\n    def token1() -> address: view\n\ninterface UniV2Router:\n    def addLiquidity(_tokenA: address, _tokenB: address, _amountADesired: uint256, _amountBDesired: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_tokenA: address, _tokenB: address, _lpAmount: uint256, _amountAMin: uint256, _amountBMin: uint256, _recipient: address, _deadline: uint256) -> (uint256, uint256): nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n\ninterface UniV2Factory:\n    def getPair(_tokenA: address, _tokenB: address) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n    legoId: uint256\n\nevent UniswapV2LiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpAmountReceived: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV2LiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    lpToken: address\n    lpAmountBurned: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV2Swap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent UniV2WethCoreRouterPoolSet:\n    pool: indexed(address)\n\nevent UniV2FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent UniswapV2LegoIdSet:\n    legoId: uint256\n\nevent UniswapV2Activated:\n    isActivated: bool\n\n# uniswap\ncoreRouterPool: public(address)\nUNISWAP_V2_FACTORY: public(immutable(address))\nUNISWAP_V2_ROUTER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n\n@deploy\ndef __init__(\n    _uniswapV2Factory: address,\n    _uniswapV2Router: address,\n    _addyRegistry: address,\n    _coreRouterPool: address,\n):\n    assert empty(address) not in [_uniswapV2Factory, _uniswapV2Router, _addyRegistry, _coreRouterPool] # dev: invalid addrs\n    UNISWAP_V2_FACTORY = _uniswapV2Factory\n    UNISWAP_V2_ROUTER = _uniswapV2Router\n    ADDY_REGISTRY = _addyRegistry\n    self.coreRouterPool = _coreRouterPool\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [UNISWAP_V2_FACTORY, UNISWAP_V2_ROUTER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n########\n# Swap #\n########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    initialAmountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert initialAmountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, initialAmountIn, default_return_value=True) # dev: transfer failed\n    initialAmountIn = min(initialAmountIn, staticcall IERC20(tokenIn).balanceOf(self))\n\n    # transfer initial amount to first pool\n    assert extcall IERC20(tokenIn).transfer(_poolPath[0], initialAmountIn, default_return_value=True) # dev: transfer failed\n\n    uniswapV2Factory: address = UNISWAP_V2_FACTORY\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = initialAmountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to next pool (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = _poolPath[i + 1]\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, uniswapV2Factory)\n\n    # final amount\n    toAmount: uint256 = tempAmountIn\n    assert toAmount >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        initialAmountIn -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(tokenIn, initialAmountIn, tokenOut, toAmount, True, _oracleRegistry)\n    log UniswapV2Swap(sender=msg.sender, tokenIn=tokenIn, tokenOut=tokenOut, amountIn=initialAmountIn, amountOut=toAmount, usdValue=usdValue, numTokens=numTokens, recipient=_recipient)\n    return initialAmountIn, toAmount, refundAssetAmount, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _uniswapV2Factory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual uniswap v2 pool\n    assert staticcall UniV2Factory(_uniswapV2Factory).getPair(_tokenIn, _tokenOut) == _pool # dev: invalid pool\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    amountOut: uint256 = self._getAmountOut(_pool, zeroForOne, _amountIn)\n    assert amountOut != 0 # dev: no tokens swapped\n\n    # put in correct order\n    amount0Out: uint256 = amountOut\n    amount1Out: uint256 = 0\n    if zeroForOne:\n        amount0Out = 0\n        amount1Out = amountOut\n\n    # perform swap\n    extcall IUniswapV2Pair(_pool).swap(amount0Out, amount1Out, _recipient, b\"\")\n    return amountOut\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    transferAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert transferAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, transferAmountA, default_return_value=True) # dev: transfer failed\n    liqAmountA: uint256 = min(transferAmountA, staticcall IERC20(_tokenA).balanceOf(self))\n\n    # token b\n    transferAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert transferAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, transferAmountB, default_return_value=True) # dev: transfer failed\n    liqAmountB: uint256 = min(transferAmountB, staticcall IERC20(_tokenB).balanceOf(self))\n\n    # approvals\n    router: address = UNISWAP_V2_ROUTER\n    assert extcall IERC20(_tokenA).approve(router, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # add liquidity\n    lpAmountReceived: uint256 = 0\n    liqAmountA, liqAmountB, lpAmountReceived = extcall UniV2Router(router).addLiquidity(\n        _tokenA,\n        _tokenB,\n        liqAmountA,\n        liqAmountB,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert lpAmountReceived != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(router, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, False, _oracleRegistry)\n    log UniswapV2LiquidityAdded(sender=msg.sender, tokenA=_tokenA, tokenB=_tokenB, amountA=liqAmountA, amountB=liqAmountB, lpAmountReceived=lpAmountReceived, usdValue=usdValue, recipient=_recipient)\n    return lpAmountReceived, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, 0\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    tokens: address[2] = [staticcall IUniswapV2Pair(_pool).token0(), staticcall IUniswapV2Pair(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balance\n    preLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n\n    # lp token\n    transferAmount: uint256 = min(_liqToRemove, staticcall IERC20(_lpToken).balanceOf(msg.sender))\n    assert transferAmount != 0 # dev: nothing to transfer\n    assert extcall IERC20(_lpToken).transferFrom(msg.sender, self, transferAmount, default_return_value=True) # dev: transfer failed\n    lpAmount: uint256 = min(transferAmount, staticcall IERC20(_lpToken).balanceOf(self))\n\n    # approvals\n    router: address = UNISWAP_V2_ROUTER\n    assert extcall IERC20(_lpToken).approve(router, lpAmount, default_return_value=True) # dev: approval failed\n\n    # remove liquidity\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    amountA, amountB = extcall UniV2Router(router).removeLiquidity(\n        _tokenA,\n        _tokenB,\n        lpAmount,\n        _minAmountA,\n        _minAmountB,\n        _recipient,\n        block.timestamp,\n    )\n    assert amountA != 0 # dev: no amountA removed\n    assert amountB != 0 # dev: no amountB removed\n\n    # reset approvals\n    assert extcall IERC20(_lpToken).approve(router, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not removed\n    currentLegoBalance: uint256 = staticcall IERC20(_lpToken).balanceOf(self)\n    refundedLpAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundedLpAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(_lpToken).transfer(msg.sender, refundedLpAmount, default_return_value=True) # dev: transfer failed\n        lpAmount -= refundedLpAmount\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, False, _oracleRegistry)\n    log UniswapV2LiquidityRemoved(sender=msg.sender, pool=_pool, tokenA=_tokenA, tokenB=_tokenB, amountA=amountA, amountB=amountB, lpToken=_lpToken, lpAmountBurned=lpAmount, usdValue=usdValue, recipient=_recipient)\n    return amountA, amountB, usdValue, lpAmount, refundedLpAmount, refundedLpAmount != 0\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # in uniswap v2, the lp token is the pool address\n    return _pool\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # in uniswap v2, the pool is the lp token address\n    return _lpToken\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenA, _tokenB)\n    if pool == empty(address):\n        return empty(BestPool)\n\n    # get reserves\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(pool).getReserves()\n\n    return BestPool(\n        pool=pool,\n        fee=30, # 0.3%, denominator is 100_00\n        liquidity=convert(reserve0 + reserve1, uint256),\n        numCoins=2,\n        legoId=self.legoId,\n    )\n\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenIn, _tokenOut)\n    if pool == empty(address):\n        return empty(address), 0\n    token0: address = staticcall IUniswapV2Pair(pool).token0()\n    return pool, self._getAmountOut(pool, _tokenIn == token0, _amountIn)\n\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    return self._getAmountOut(_pool, _tokenIn == token0, _amountIn)\n\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    pool: address = staticcall UniV2Factory(UNISWAP_V2_FACTORY).getPair(_tokenIn, _tokenOut)\n    if pool == empty(address):\n        return empty(address), 0\n    token0: address = staticcall IUniswapV2Pair(pool).token0()\n    return pool, self._getAmountIn(pool, _tokenIn == token0, _amountOut)\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    return self._getAmountIn(_pool, _tokenIn == token0, _amountOut)\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n\n    reserveA: uint256 = 0\n    reserveB: uint256 = 0\n    reserveA, reserveB = self._getReserves(_pool, _tokenA == token0)\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return 0, 0, 0\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = self._quote(_availAmountA, reserveA, reserveB)\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = self._quote(_availAmountB, reserveB, reserveA)\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n\n    reserveA: uint256 = 0\n    reserveB: uint256 = 0\n    reserveA, reserveB = self._getReserves(_pool, _tokenA == token0)\n\n    # insufficient liquidity\n    if reserveA == 0 or reserveB == 0:\n        return max_value(uint256), max_value(uint256)\n\n    # calculate expected amounts out\n    totalSupply: uint256 = staticcall IERC20(_pool).totalSupply()\n    expectedAmountA: uint256 = _lpAmount * reserveA // totalSupply\n    expectedAmountB: uint256 = _lpAmount * reserveB // totalSupply\n    return expectedAmountA, expectedAmountB\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    token0: address = staticcall IUniswapV2Pair(_pool).token0()\n    token1: address = staticcall IUniswapV2Pair(_pool).token1()\n\n    # oracle registry\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token1, False)\n    else:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token0, False)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # reserves\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(_pool).getReserves()\n\n    # avoid division by zero\n    if reserve0 == 0 or reserve1 == 0:\n        return 0  \n\n    # price of token0 in token1\n    priceZeroToOne: uint256 = convert(reserve1, uint256) * EIGHTEEN_DECIMALS // convert(reserve0, uint256)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _isSwap: bool,\n    _oracleRegistry: address,\n) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    usdValueA: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenA, _amountA)\n    usdValueB: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenB, _amountB)\n    if _isSwap:\n        return max(usdValueA, usdValueB)\n    else:\n        return usdValueA + usdValueB\n\n\n@view\n@internal\ndef _quote(_amountA: uint256, _reserveA: uint256, _reserveB: uint256) -> uint256:\n    return (_amountA * _reserveB) // _reserveA\n\n\n@view\n@internal\ndef _getReserves(_pool: address, _isTokenAZeroIndex: bool) -> (uint256, uint256):\n    reserve0: uint112 = 0\n    reserve1: uint112 = 0\n    na: uint32 = 0\n    reserve0, reserve1, na = staticcall IUniswapV2Pair(_pool).getReserves()\n\n    # determine which token is which\n    reserveA: uint256 = convert(reserve0, uint256)\n    reserveB: uint256 = convert(reserve1, uint256)\n    if not _isTokenAZeroIndex:\n        reserveA = convert(reserve1, uint256)\n        reserveB = convert(reserve0, uint256)\n\n    return reserveA, reserveB\n\n\n@view\n@internal\ndef _getAmountOut(\n    _pool: address,\n    _zeroForOne: bool,\n    _amountIn: uint256,\n) -> uint256:\n    if _amountIn == 0:\n        return 0\n\n    # get reserves\n    reserveIn: uint256 = 0\n    reserveOut: uint256 = 0\n    reserveIn, reserveOut = self._getReserves(_pool, _zeroForOne)\n    if reserveIn == 0 or reserveOut == 0:\n        return 0\n\n    # calculate amount out\n    amountInWithFee: uint256 = _amountIn * 997 # 1000 - 3 (0.3% fee)\n    numerator: uint256 = amountInWithFee * reserveOut\n    denominator: uint256 = (reserveIn * 1000) + amountInWithFee\n    return numerator // denominator\n\n\n@view\n@internal\ndef _getAmountIn(_pool: address, _zeroForOne: bool, _amountOut: uint256) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    reserveIn: uint256 = 0\n    reserveOut: uint256 = 0\n    reserveIn, reserveOut = self._getReserves(_pool, _zeroForOne)\n    if reserveIn == 0 or reserveOut == 0:\n        return max_value(uint256)\n\n    if _amountOut > reserveOut:\n        return max_value(uint256)\n\n    numerator: uint256 = reserveIn * _amountOut * 1000\n    denominator: uint256 = (reserveOut - _amountOut) * 997\n    return (numerator // denominator) + 1\n\n\n####################\n# Core Router Pool #\n####################\n\n\n@external\ndef setCoreRouterPool(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.coreRouterPool = _addr\n    log UniV2WethCoreRouterPoolSet(pool=_addr)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log UniV2FundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log UniswapV2LegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log UniswapV2Activated(isActivated=_shouldActivate)",
            "sha256sum": "21260ab9ba6a869d48a6e2d2b6fdaee943438b03df9b931ec3691bd17c1d3b06"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/LegoUniswapV2.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "873b38597f599ae022cfc8031b425c30bb8d6bd2953b07e43bfc961200f1af0d"
      },
      "args": "0000000000000000000000008909dc15e40173ff4699343b6eb8132c65e18ec60000000000000000000000004752ba5dbc23f44d87826276bf6fd6b1c372ad240000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae00000000000000000000000088a43bbdf9d098eec7bceda4e2494615dfd9bb9c"
    },
    "LegoUniswapV3": {
      "address": "0x6bfd82031a968685358DA84ebB797c3C068EC704",
      "abi": [
        {
          "name": "UniswapV3Swap",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3SwapInPool",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": false
            },
            {
              "name": "amountIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LiquidityAdded",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LiquidityRemoved",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "amountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniV3FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniV3CoreRouterPoolSet",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniV3NftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3LegoIdSet",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UniswapV3Activated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeInitiated",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeGovernance",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernanceChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_GOV_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistries",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAccessForLego",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_minAmountOut",
              "type": "uint256"
            },
            {
              "name": "_tokenPath",
              "type": "address[]"
            },
            {
              "name": "_poolPath",
              "type": "address[]"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "uniswapV3SwapCallback",
          "inputs": [
            {
              "name": "_amount0Delta",
              "type": "int256"
            },
            {
              "name": "_amount1Delta",
              "type": "int256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpToken",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasClaimableRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLpToken",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPoolForLpToken",
          "inputs": [
            {
              "name": "_lpToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCoreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeepestLiqPool",
          "inputs": [
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "fee",
                  "type": "uint256"
                },
                {
                  "name": "liquidity",
                  "type": "uint256"
                },
                {
                  "name": "numCoins",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddLiqAmountsIn",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_availAmountA",
              "type": "uint256"
            },
            {
              "name": "_availAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRemoveLiqAmountsOut",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_lpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceUnsafe",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetToken",
              "type": "address"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCoreRouterPool",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "coreRouterPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_FACTORY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_NFT_MANAGER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNIV3_QUOTER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_uniswapV3Factory",
              "type": "address"
            },
            {
              "name": "_uniNftPositionManager",
              "type": "address"
            },
            {
              "name": "_uniV3Quoter",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_coreRouterPool",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def MIN_GOV_CHANGE_DELAY() -> uint256: view\n    def MAX_GOV_CHANGE_DELAY() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeInitiated:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeDelaySet:\n    delayBlocks: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance) # pending governance change\ngovChangeDelay: public(uint256) # num blocks to wait before governance can be changed\n\n# immutable\nMIN_GOV_CHANGE_DELAY: public(immutable(uint256))\nMAX_GOV_CHANGE_DELAY: public(immutable(uint256))\n_addyRegistry: address # ish\n\n\n@deploy\ndef __init__(\n    _initialGov: address,\n    _addyRegistry: address,\n    _minGovChangeDelay: uint256,\n    _maxGovChangeDelay: uint256,\n):\n    # need to have one of the two for this to be valid\n    assert _initialGov != empty(address) or _addyRegistry != empty(address) # dev: invalid gov config\n\n    # set initial governance\n    if _initialGov != empty(address):\n        self.governance = _initialGov\n\n    # if local governance, set addy registry\n    if _addyRegistry != empty(address):\n        self._addyRegistry = _addyRegistry\n\n    # set min and max delay\n    minDelay: uint256 = _minGovChangeDelay\n    maxDelay: uint256 = _maxGovChangeDelay\n    if minDelay == 0 or maxDelay == 0:\n        assert _addyRegistry != empty(address) # dev: need addy registry for local gov\n        minDelay = staticcall AddyRegistry(_addyRegistry).MIN_GOV_CHANGE_DELAY()\n        maxDelay = staticcall AddyRegistry(_addyRegistry).MAX_GOV_CHANGE_DELAY()\n\n    assert minDelay < maxDelay # dev: invalid delay\n    MIN_GOV_CHANGE_DELAY = minDelay\n    MAX_GOV_CHANGE_DELAY = maxDelay\n\n    # Top-level registry (AddyRegistry.vy) has no delay initially during setup\n    if _addyRegistry != empty(address):\n        self.govChangeDelay = minDelay  \n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef canGovern(_address: address) -> bool:\n    \"\"\"\n    @notice Check if an address has governance permissions\n    @dev Checks if the address is either the local governance or the AddyRegistry governance\n    @param _address The address to check for governance permissions\n    @return True if the address has governance permissions, False otherwise\n    \"\"\"\n    return self._canGovern(_address)\n\n\n@view\n@internal\ndef _canGovern(_address: address) -> bool:\n    return _address in self._getGovernors()\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending governance change\n    @return bool True if there is a pending governance change, false otherwise\n    \"\"\"\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    \"\"\"\n    @notice Internal function to get all valid governance addresses\n    @dev Returns a list containing both local governance and AddyRegistry governance (if set)\n    @return Array of addresses that have governance permissions\n    \"\"\"\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # addy registry governance\n    addyRegistry: address = self._addyRegistry\n    if addyRegistry != empty(address):\n        globalGovernance: address = staticcall AddyRegistry(addyRegistry).governance()\n        if globalGovernance != empty(address):\n            governors.append(globalGovernance)\n\n    return governors\n\n\n@view\n@internal\ndef _isAddyRegistryGov() -> bool:\n    \"\"\"\n    @notice Internal function to check if this contract is the AddyRegistry\n    @dev Returns true if _addyRegistry is not set (empty address)\n    @return True if this contract is the AddyRegistry, False otherwise\n    \"\"\"\n    return self._addyRegistry == empty(address)\n\n\n##################\n# Set Governance #\n##################\n\n\n@external\ndef changeGovernance(_newGov: address):\n    \"\"\"\n    @notice Initiates a new governance change\n    @dev Can only be called by current governance\n    @param _newGov The address of new governance\n    \"\"\"\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    assert _newGov not in governors # dev: invalid new governance\n    assert _newGov.is_contract # dev: new governance must be a contract\n    if self._isAddyRegistryGov():\n        assert _newGov != empty(address) # dev: addy registry cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeDelay\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeInitiated(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmGovernanceChange():\n    \"\"\"\n    @notice Confirms the governance change\n    @dev Can only be called by the new governance\n    \"\"\"\n    data: PendingGovernance = self.pendingGov\n    assert data.newGov != empty(address) # dev: no pending governance\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newGov # dev: only new governance can confirm\n\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelGovernanceChange():\n    \"\"\"\n    @notice Cancels the governance change\n    @dev Can only be called by the current governance\n    \"\"\"\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setGovernanceChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the governance change delay\n    @dev Can only be called by current governance\n    @param _numBlocks The number of blocks to wait before governance can be changed\n    \"\"\"\n    assert self.pendingGov.confirmBlock == 0 # dev: cannot set delay if there is a pending change\n    assert self._canGovern(msg.sender) # dev: no perms\n    assert _numBlocks >= MIN_GOV_CHANGE_DELAY and _numBlocks <= MAX_GOV_CHANGE_DELAY # dev: invalid delay\n    self.govChangeDelay = _numBlocks\n    log GovChangeDelaySet(delayBlocks=_numBlocks)",
            "sha256sum": "523cc2f12e81dd860a1365281ee8162ed767f6c51eae0112ccf3b3395ed6f21a"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/legos/dexes/LegoUniswapV3.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nimplements: IUniswapV3Callback\nimplements: LegoCommon\ninitializes: gov\nexports: gov.__interface__\n\nimport contracts.modules.LocalGov as gov\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC721\nfrom ethereum.ercs import IERC20Detailed\nfrom interfaces import LegoCommon\n\n# `getSwapAmountOut()` and `getSwapAmountIn()` cannot be view functions, sadly\n# keeping here to uncomment to test all other functions\n# implements: LegoDex\n# from interfaces import LegoDex\n\ninterface UniV3Pool:\n    def slot0() -> (uint160, int24, uint16, uint16, uint16, uint8, bool): view\n    def swap(_recipient: address, _zeroForOne: bool, _amountSpecified: int256, _sqrtPriceLimitX96: uint160, _data: Bytes[256]) -> (int256, int256): nonpayable\n    def liquidity() -> uint128: view\n    def tickSpacing() -> int24: view\n    def token0() -> address: view\n    def token1() -> address: view\n    def fee() -> uint24: view\n\ninterface UniV3NftPositionManager:\n    def increaseLiquidity(_params: IncreaseLiquidityParams) -> (uint128, uint256, uint256): nonpayable\n    def decreaseLiquidity(_params: DecreaseLiquidityParams) -> (uint256, uint256): nonpayable\n    def mint(_params: MintParams) -> (uint256, uint128, uint256, uint256): nonpayable\n    def collect(_params: CollectParams) -> (uint256, uint256): nonpayable\n    def positions(_tokenId: uint256) -> PositionData: view\n    def burn(_tokenId: uint256): nonpayable\n\ninterface UniV3Quoter:\n    def quoteExactOutputSingle(_params: QuoteExactOutputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInputSingle(_params: QuoteExactInputSingleParams) -> (uint256, uint160, uint32, uint256): nonpayable\n    def quoteExactInput(_path: Bytes[1024], _amountIn: uint256) -> uint256: nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n\ninterface IUniswapV3Callback:\n    def uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]): nonpayable\n\ninterface UniV3Factory:\n    def getPool(_tokenA: address, _tokenB: address, _fee: uint24) -> address: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct QuoteExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    fee: uint24\n    sqrtPriceLimitX96: uint160\n\nstruct QuoteExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    amount: uint256\n    fee: uint24\n    sqrtPriceLimitX96: uint160\n\nstruct BestPool:\n    pool: address\n    fee: uint256\n    liquidity: uint256\n    numCoins: uint256\n    legoId: uint256\n\nstruct MintParams:\n    token0: address\n    token1: address\n    fee: uint24\n    tickLower: int24\n    tickUpper: int24\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    recipient: address\n    deadline: uint256\n\nstruct IncreaseLiquidityParams:\n    tokenId: uint256\n    amount0Desired: uint256\n    amount1Desired: uint256\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct DecreaseLiquidityParams:\n    tokenId: uint256\n    liquidity: uint128\n    amount0Min: uint256\n    amount1Min: uint256\n    deadline: uint256\n\nstruct CollectParams:\n    tokenId: uint256\n    recipient: address\n    amount0Max: uint128\n    amount1Max: uint128\n\nstruct PositionData:\n    nonce: uint96\n    operator: address\n    token0: address\n    token1: address\n    fee: uint24\n    tickLower: int24\n    tickUpper: int24\n    liquidity: uint128\n    feeGrowthInside0LastX128: uint256\n    feeGrowthInside1LastX128: uint256\n    tokensOwed0: uint128\n    tokensOwed1: uint128\n\nstruct PoolSwapData:\n    pool: address\n    tokenIn: address\n    amountIn: uint256\n\nevent UniswapV3Swap:\n    sender: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    numTokens: uint256\n    recipient: address\n\nevent UniswapV3SwapInPool:\n    sender: indexed(address)\n    pool: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: address\n    amountIn: uint256\n    amountOut: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV3LiquidityAdded:\n    sender: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityAdded: uint256\n    nftTokenId: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniswapV3LiquidityRemoved:\n    sender: address\n    pool: indexed(address)\n    nftTokenId: uint256\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    amountA: uint256\n    amountB: uint256\n    liquidityRemoved: uint256\n    usdValue: uint256\n    recipient: address\n\nevent UniV3FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent UniV3CoreRouterPoolSet:\n    pool: indexed(address)\n\nevent UniV3NftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\nevent UniswapV3LegoIdSet:\n    legoId: uint256\n\nevent UniswapV3Activated:\n    isActivated: bool\n\n# transient\ncoreRouterPool: public(address)\npoolSwapData: transient(PoolSwapData)\n\n# uni\nUNIV3_FACTORY: public(immutable(address))\nUNIV3_NFT_MANAGER: public(immutable(address))\nUNIV3_QUOTER: public(immutable(address))\n\n# config\nlegoId: public(uint256)\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\n\nFEE_TIERS: constant(uint24[4]) = [100, 500, 3000, 10000] # 0.01%, 0.05%, 0.3%, 1%\nMIN_SQRT_RATIO_PLUS_ONE: constant(uint160) = 4295128740\nMAX_SQRT_RATIO_MINUS_ONE: constant(uint160) = 1461446703485210103287273052203988822378723970341\nTICK_LOWER: constant(int24) = -887272\nTICK_UPPER: constant(int24) = 887272\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UnderscoreErc721\"\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nUNISWAP_Q96: constant(uint256) = 2 ** 96  # uniswap's fixed point scaling factor\nMAX_TOKEN_PATH: constant(uint256) = 5\n\n@deploy\ndef __init__(\n    _uniswapV3Factory: address,\n    _uniNftPositionManager: address,\n    _uniV3Quoter: address,\n    _addyRegistry: address,\n    _coreRouterPool: address,\n):\n    assert empty(address) not in [_uniswapV3Factory, _uniNftPositionManager, _uniV3Quoter, _addyRegistry, _coreRouterPool] # dev: invalid addrs\n    UNIV3_FACTORY = _uniswapV3Factory\n    UNIV3_NFT_MANAGER = _uniNftPositionManager\n    UNIV3_QUOTER = _uniV3Quoter\n    ADDY_REGISTRY = _addyRegistry\n    self.coreRouterPool = _coreRouterPool\n    self.isActivated = True\n    gov.__init__(empty(address), _addyRegistry, 0, 0)\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    assert _data == ERC721_RECEIVE_DATA # dev: did not receive from within Underscore wallet\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    return [UNIV3_FACTORY, UNIV3_NFT_MANAGER, UNIV3_QUOTER]\n\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    return empty(address), empty(String[64]), 0\n\n\n########\n# Swap #\n########\n\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate inputs\n    numTokens: uint256 = len(_tokenPath)\n    numPools: uint256 = len(_poolPath)\n    assert numTokens >= 2 # dev: invalid path\n    assert numPools == numTokens - 1 # dev: invalid path\n\n    # get first token and last token\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[numTokens - 1]\n\n    # pre balances\n    preLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n\n    # transfer deposit asset to this contract\n    initialAmountIn: uint256 = min(_amountIn, staticcall IERC20(tokenIn).balanceOf(msg.sender))\n    assert initialAmountIn != 0 # dev: nothing to transfer\n    assert extcall IERC20(tokenIn).transferFrom(msg.sender, self, initialAmountIn, default_return_value=True) # dev: transfer failed\n    initialAmountIn = min(initialAmountIn, staticcall IERC20(tokenIn).balanceOf(self))\n\n    uniswapV3Factory: address = UNIV3_FACTORY\n\n    # iterate through swap routes\n    tempAmountIn: uint256 = initialAmountIn\n    for i: uint256 in range(numTokens - 1, bound=MAX_TOKEN_PATH):\n        tempTokenIn: address = _tokenPath[i]\n        tempTokenOut: address = _tokenPath[i + 1]\n        tempPool: address = _poolPath[i]\n\n        # transfer to self (or to recipient if last swap)\n        recipient: address = _recipient\n        if i < numTokens - 2:\n            recipient = self\n\n        # swap\n        tempAmountIn = self._swapTokensInPool(tempPool, tempTokenIn, tempTokenOut, tempAmountIn, recipient, uniswapV3Factory)\n\n    # final amount\n    toAmount: uint256 = tempAmountIn\n    assert toAmount >= _minAmountOut # dev: min amount out not met\n\n    # refund if full swap didn't get through\n    currentLegoBalance: uint256 = staticcall IERC20(tokenIn).balanceOf(self)\n    refundAssetAmount: uint256 = 0\n    if currentLegoBalance > preLegoBalance:\n        refundAssetAmount = currentLegoBalance - preLegoBalance\n        assert extcall IERC20(tokenIn).transfer(msg.sender, refundAssetAmount, default_return_value=True) # dev: transfer failed\n        initialAmountIn -= refundAssetAmount\n\n    usdValue: uint256 = self._getUsdValue(tokenIn, initialAmountIn, tokenOut, toAmount, True, _oracleRegistry)\n    log UniswapV3Swap(sender=msg.sender, tokenIn=tokenIn, tokenOut=tokenOut, amountIn=initialAmountIn, amountOut=toAmount, usdValue=usdValue, numTokens=numTokens, recipient=_recipient)\n    return initialAmountIn, toAmount, refundAssetAmount, usdValue\n\n\n# swap in pool\n\n\n@internal\ndef _swapTokensInPool(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _recipient: address,\n    _uniswapV3Factory: address,\n) -> uint256:\n    tokens: address[2] = [staticcall UniV3Pool(_pool).token0(), staticcall UniV3Pool(_pool).token1()]\n    assert _tokenIn in tokens # dev: invalid tokenIn\n    assert _tokenOut in tokens # dev: invalid tokenOut\n    assert _tokenIn != _tokenOut # dev: invalid tokens\n\n    # verify actual uniswap v3 pool\n    assert staticcall UniV3Factory(_uniswapV3Factory).getPool(_tokenIn, _tokenOut, staticcall UniV3Pool(_pool).fee()) == _pool # dev: invalid pool\n\n    # save in transient storage (for use in callback)\n    self.poolSwapData = PoolSwapData(\n        pool=_pool,\n        tokenIn=_tokenIn,\n        amountIn=_amountIn,\n    )\n\n    zeroForOne: bool = _tokenIn == tokens[0]\n    sqrtPriceLimitX96: uint160 = MAX_SQRT_RATIO_MINUS_ONE\n    if zeroForOne:\n        sqrtPriceLimitX96 = MIN_SQRT_RATIO_PLUS_ONE\n\n    # perform swap\n    amount0: int256 = 0\n    amount1: int256 = 0\n    amount0, amount1 = extcall UniV3Pool(_pool).swap(_recipient, zeroForOne, convert(_amountIn, int256), sqrtPriceLimitX96, b\"\")\n\n    toAmount: uint256 = 0\n    if zeroForOne:\n        toAmount = convert(-amount1, uint256)\n    else:\n        toAmount = convert(-amount0, uint256)\n\n    assert toAmount != 0 # dev: no tokens swapped\n    return toAmount\n\n\n# callback\n\n\n@external\ndef uniswapV3SwapCallback(_amount0Delta: int256, _amount1Delta: int256, _data: Bytes[256]):\n    poolSwapData: PoolSwapData = self.poolSwapData\n    assert msg.sender == poolSwapData.pool # dev: no perms\n\n    # transfer tokens to pool\n    assert extcall IERC20(poolSwapData.tokenIn).transfer(poolSwapData.pool, poolSwapData.amountIn, default_return_value=True) # dev: transfer failed\n    self.poolSwapData = empty(PoolSwapData)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@external\ndef addLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amountA: uint256,\n    _amountB: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _minLpAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    assert self.isActivated # dev: not activated\n\n    # validate tokens\n    tokens: address[2] = [staticcall UniV3Pool(_pool).token0(), staticcall UniV3Pool(_pool).token1()]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # pre balances\n    preLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    preLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n\n    # token a\n    transferAmountA: uint256 = min(_amountA, staticcall IERC20(_tokenA).balanceOf(msg.sender))\n    assert transferAmountA != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenA).transferFrom(msg.sender, self, transferAmountA, default_return_value=True) # dev: transfer failed\n    liqAmountA: uint256 = min(transferAmountA, staticcall IERC20(_tokenA).balanceOf(self))\n\n    # token b\n    transferAmountB: uint256 = min(_amountB, staticcall IERC20(_tokenB).balanceOf(msg.sender))\n    assert transferAmountB != 0 # dev: nothing to transfer\n    assert extcall IERC20(_tokenB).transferFrom(msg.sender, self, transferAmountB, default_return_value=True) # dev: transfer failed\n    liqAmountB: uint256 = min(transferAmountB, staticcall IERC20(_tokenB).balanceOf(self))\n\n    # approvals\n    nftPositionManager: address = UNIV3_NFT_MANAGER\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, liqAmountA, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, liqAmountB, default_return_value=True) # dev: approval failed\n\n    # organized the index of tokens\n    token0: address = _tokenA\n    token1: address = _tokenB\n    amount0: uint256 = liqAmountA\n    amount1: uint256 = liqAmountB\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if tokens[0] != _tokenA:\n        token0 = _tokenB\n        token1 = _tokenA\n        amount0 = liqAmountB\n        amount1 = liqAmountA\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # add liquidity\n    nftTokenId: uint256 = _nftTokenId\n    liquidityAdded: uint256 = 0\n    liquidityAddedInt128: uint128 = 0\n    if _nftTokenId == 0:\n        nftTokenId, liquidityAddedInt128, amount0, amount1 = self._mintNewPosition(nftPositionManager, _pool, token0, token1, _tickLower, _tickUpper, amount0, amount1, minAmount0, minAmount1, _recipient)\n    else:\n        liquidityAddedInt128, amount0, amount1 = self._increaseExistingPosition(nftPositionManager, _nftTokenId, amount0, amount1, minAmount0, minAmount1, _recipient)\n\n    liquidityAdded = convert(liquidityAddedInt128, uint256)\n    assert liquidityAdded != 0 # dev: no liquidity added\n\n    # reset approvals\n    assert extcall IERC20(_tokenA).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n    assert extcall IERC20(_tokenB).approve(nftPositionManager, 0, default_return_value=True) # dev: approval failed\n\n    # refund if full liquidity was not added\n    currentLegoBalanceA: uint256 = staticcall IERC20(_tokenA).balanceOf(self)\n    refundAssetAmountA: uint256 = 0\n    if currentLegoBalanceA > preLegoBalanceA:\n        refundAssetAmountA = currentLegoBalanceA - preLegoBalanceA\n        assert extcall IERC20(_tokenA).transfer(msg.sender, refundAssetAmountA, default_return_value=True) # dev: transfer failed\n\n    currentLegoBalanceB: uint256 = staticcall IERC20(_tokenB).balanceOf(self)\n    refundAssetAmountB: uint256 = 0\n    if currentLegoBalanceB > preLegoBalanceB:\n        refundAssetAmountB = currentLegoBalanceB - preLegoBalanceB\n        assert extcall IERC20(_tokenB).transfer(msg.sender, refundAssetAmountB, default_return_value=True) # dev: transfer failed\n\n    # a/b amounts\n    liqAmountA = amount0\n    liqAmountB = amount1\n    if tokens[0] != _tokenA:\n        liqAmountA = amount1\n        liqAmountB = amount0\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, liqAmountA, _tokenB, liqAmountB, False, _oracleRegistry)\n    log UniswapV3LiquidityAdded(sender=msg.sender, tokenA=_tokenA, tokenB=_tokenB, amountA=liqAmountA, amountB=liqAmountB, liquidityAdded=liquidityAdded, nftTokenId=nftTokenId, usdValue=usdValue, recipient=_recipient)\n    return liquidityAdded, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, nftTokenId\n\n\n@internal\ndef _mintNewPosition(\n    _nftPositionManager: address,\n    _pool: address,\n    _token0: address,\n    _token1: address,\n    _tickLower: int24,\n    _tickUpper: int24,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint256, uint128, uint256, uint256):\n    tickLower: int24 = 0\n    tickUpper: int24 = 0\n    tickLower, tickUpper = self._getTicks(_pool, _tickLower, _tickUpper)\n\n    # mint new position\n    params: MintParams = MintParams(\n        token0=_token0,\n        token1=_token1,\n        fee=staticcall UniV3Pool(_pool).fee(),\n        tickLower=tickLower,\n        tickUpper=tickUpper,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        recipient=_recipient,\n        deadline=block.timestamp,\n    )\n    return extcall UniV3NftPositionManager(_nftPositionManager).mint(params)\n\n\n@view\n@internal\ndef _getTicks(_pool: address, _tickLower: int24, _tickUpper: int24) -> (int24, int24):\n    tickSpacing: int24 = 0\n    if _tickLower == min_value(int24) or _tickUpper == max_value(int24):\n        tickSpacing = staticcall UniV3Pool(_pool).tickSpacing()\n\n    tickLower: int24 = _tickLower\n    if _tickLower == min_value(int24):\n        tickLower = (TICK_LOWER // tickSpacing) * tickSpacing\n\n    tickUpper: int24 = _tickUpper\n    if _tickUpper == max_value(int24):\n        tickUpper = (TICK_UPPER // tickSpacing) * tickSpacing\n\n    return tickLower, tickUpper\n\n\n@internal\ndef _increaseExistingPosition(\n    _nftPositionManager: address,\n    _tokenId: uint256,\n    _amount0: uint256,\n    _amount1: uint256,\n    _minAmount0: uint256,\n    _minAmount1: uint256,\n    _recipient: address,\n) -> (uint128, uint256, uint256):\n    assert staticcall IERC721(_nftPositionManager).ownerOf(_tokenId) == self # dev: nft not here\n\n    liquidityAddedInt128: uint128 = 0\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    params: IncreaseLiquidityParams = IncreaseLiquidityParams(\n        tokenId=_tokenId,\n        amount0Desired=_amount0,\n        amount1Desired=_amount1,\n        amount0Min=_minAmount0,\n        amount1Min=_minAmount1,\n        deadline=block.timestamp,\n    )\n    liquidityAddedInt128, amount0, amount1 = extcall UniV3NftPositionManager(_nftPositionManager).increaseLiquidity(params)\n\n    # collect fees (if applicable) -- must be done before transferring nft\n    positionData: PositionData = staticcall UniV3NftPositionManager(_nftPositionManager).positions(_tokenId)\n    self._collectFees(_nftPositionManager, _tokenId, _recipient, positionData)\n\n    # transfer nft to recipient\n    extcall IERC721(_nftPositionManager).safeTransferFrom(self, _recipient, _tokenId)\n\n    return liquidityAddedInt128, amount0, amount1\n\n\n@internal\ndef _collectFees(_nftPositionManager: address, _tokenId: uint256, _recipient: address, _positionData: PositionData) -> (uint256, uint256):\n    if _positionData.tokensOwed0 == 0 and _positionData.tokensOwed1 == 0:\n        return 0, 0\n\n    params: CollectParams = CollectParams(\n        tokenId=_tokenId,\n        recipient=_recipient,\n        amount0Max=max_value(uint128),\n        amount1Max=max_value(uint128),\n    )\n    return extcall UniV3NftPositionManager(_nftPositionManager).collect(params)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@external\ndef removeLiquidity(\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpToken: address,\n    _liqToRemove: uint256,\n    _minAmountA: uint256,\n    _minAmountB: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    assert self.isActivated # dev: not activated\n\n    # make sure nft is here\n    nftPositionManager: address = UNIV3_NFT_MANAGER\n    assert staticcall IERC721(nftPositionManager).ownerOf(_nftTokenId) == self # dev: nft not here\n\n    # get position data\n    positionData: PositionData = staticcall UniV3NftPositionManager(nftPositionManager).positions(_nftTokenId)\n    originalLiquidity: uint128 = positionData.liquidity\n\n    # validate tokens\n    tokens: address[2] = [positionData.token0, positionData.token1]\n    assert _tokenA in tokens # dev: invalid tokenA\n    assert _tokenB in tokens # dev: invalid tokenB\n    assert _tokenA != _tokenB # dev: invalid tokens\n\n    # organized the index of tokens\n    minAmount0: uint256 = _minAmountA\n    minAmount1: uint256 = _minAmountB\n    if _tokenA != tokens[0]:\n        minAmount0 = _minAmountB\n        minAmount1 = _minAmountA\n\n    # decrease liquidity\n    liqToRemove: uint256 = min(_liqToRemove, convert(positionData.liquidity, uint256))\n    assert liqToRemove != 0 # dev: no liquidity to remove\n\n    params: DecreaseLiquidityParams = DecreaseLiquidityParams(\n        tokenId=_nftTokenId,\n        liquidity=convert(liqToRemove, uint128),\n        amount0Min=minAmount0,\n        amount1Min=minAmount1,\n        deadline=block.timestamp,\n    )\n    amount0: uint256 = 0\n    amount1: uint256 = 0\n    amount0, amount1 = extcall UniV3NftPositionManager(nftPositionManager).decreaseLiquidity(params)\n    assert amount0 != 0 and amount1 != 0 # dev: no liquidity removed\n\n    # a/b amounts\n    amountA: uint256 = amount0\n    amountB: uint256 = amount1\n    if _tokenA != tokens[0]:\n        amountA = amount1\n        amountB = amount0\n\n    # get latest position data -- collect withdrawn tokens AND any fees (if applicable)\n    positionData = staticcall UniV3NftPositionManager(nftPositionManager).positions(_nftTokenId)\n    self._collectFees(nftPositionManager, _nftTokenId, _recipient, positionData)\n\n    # burn nft (if applicable)\n    isDepleted: bool = False\n    if positionData.liquidity == 0:\n        isDepleted = True\n        extcall UniV3NftPositionManager(nftPositionManager).burn(_nftTokenId)\n\n    # transfer nft to recipient\n    else:\n        extcall IERC721(nftPositionManager).safeTransferFrom(self, _recipient, _nftTokenId)\n\n    usdValue: uint256 = self._getUsdValue(_tokenA, amountA, _tokenB, amountB, False, _oracleRegistry)\n    liquidityRemoved: uint256 = convert(originalLiquidity - positionData.liquidity, uint256)\n    log UniswapV3LiquidityRemoved(sender=msg.sender, pool=_pool, nftTokenId=_nftTokenId, tokenA=_tokenA, tokenB=_tokenB, amountA=amountA, amountB=amountB, liquidityRemoved=liquidityRemoved, usdValue=usdValue, recipient=_recipient)\n    return amountA, amountB, usdValue, liquidityRemoved, 0, isDepleted\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    pass\n\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    return False\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    # no lp tokens for uniswap v3\n    return empty(address)\n\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    # no lp tokens for uniswap v3\n    return empty(address)\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    return self.coreRouterPool\n\n\n@view\n@external\ndef getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenA, _tokenB)\n\n    if bestPoolAddr == empty(address):\n        return empty(BestPool)\n\n    # get token balances\n    tokenABal: uint256 = staticcall IERC20(_tokenA).balanceOf(bestPoolAddr)\n    tokenBBal: uint256 = staticcall IERC20(_tokenB).balanceOf(bestPoolAddr)\n\n    return BestPool(\n        pool=bestPoolAddr,\n        fee=convert(bestFeeTier // 100, uint256), # normalize to have 100_00 denominator\n        liquidity=tokenABal + tokenBBal, # not exactly \"liquidity\" but this comparable to \"reserves\"\n        numCoins=2,\n        legoId=self.legoId,\n    )\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            fee=bestFeeTier,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    amountOut: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountOut, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactInputSingle(\n        QuoteExactInputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amountIn=_amountIn,\n            fee=staticcall UniV3Pool(_pool).fee(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountOut\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return empty(address), max_value(uint256)\n\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestPoolAddr, bestFeeTier = self._getDeepestLiqPool(_tokenIn, _tokenOut)\n    if bestPoolAddr == empty(address):\n        return empty(address), 0\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            fee=bestFeeTier,\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return bestPoolAddr, amountIn\n\n\n# annoying that this cannot be view function, thanks uni v3\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    if _amountOut == 0 or _amountOut == max_value(uint256):\n        return max_value(uint256)\n\n    amountIn: uint256 = 0\n    na1: uint160 = 0\n    na2: uint32 = 0\n    na3: uint256 = 0\n    amountIn, na1, na2, na3 = extcall UniV3Quoter(UNIV3_QUOTER).quoteExactOutputSingle(\n        QuoteExactOutputSingleParams(\n            tokenIn=_tokenIn,\n            tokenOut=_tokenOut,\n            amount=_amountOut,\n            fee=staticcall UniV3Pool(_pool).fee(),\n            sqrtPriceLimitX96=0,\n        )\n    )\n    return amountIn\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    token0: address = staticcall UniV3Pool(_pool).token0()\n\n    # get correct numerator and denominator\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    sqrtPriceX96Squared: uint256 = self._getSqrtPriceX96(_pool) ** 2\n    if _tokenA == token0:\n        numerator = sqrtPriceX96Squared\n        denominator = UNISWAP_Q96 ** 2\n    else:\n        numerator = UNISWAP_Q96 ** 2\n        denominator = sqrtPriceX96Squared\n\n    # calculate optimal amounts\n    amountA: uint256 = _availAmountA\n    amountB: uint256 = _availAmountA * numerator // denominator\n    if amountB > _availAmountB:\n        maybeAmountA: uint256 = _availAmountB * denominator // numerator\n        if maybeAmountA <= _availAmountA:\n            amountA = maybeAmountA\n            amountB = _availAmountB\n    return amountA, amountB, 0\n\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    token0: address = staticcall UniV3Pool(_pool).token0()\n\n    # calculate expected amounts out\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    amount0Out: uint256 = _lpAmount * UNISWAP_Q96 // sqrtPriceX96\n    amount1Out: uint256 = _lpAmount * sqrtPriceX96 // UNISWAP_Q96\n\n    # return amounts out\n    if _tokenA == token0:\n        return amount0Out, amount1Out\n    else:\n        return amount1Out, amount0Out\n\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    token0: address = staticcall UniV3Pool(_pool).token0()\n    token1: address = staticcall UniV3Pool(_pool).token1()\n\n    # oracle registry\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n\n    # alt price\n    altPrice: uint256 = 0\n    if _targetToken == token0:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token1, False)\n    else:\n        altPrice = staticcall OracleRegistry(oracleRegistry).getPrice(token0, False)\n\n    # return early if no alt price\n    if altPrice == 0:\n        return 0\n\n    # price of token0 in token1\n    sqrtPriceX96: uint256 = self._getSqrtPriceX96(_pool)\n    numerator: uint256 = sqrtPriceX96 ** 2 * EIGHTEEN_DECIMALS\n    priceZeroToOne: uint256 = numerator // (UNISWAP_Q96 ** 2)\n\n    # adjust for decimals: price should be in 18 decimals\n    decimals0: uint256 = convert(staticcall IERC20Detailed(token0).decimals(), uint256)\n    decimals1: uint256 = convert(staticcall IERC20Detailed(token1).decimals(), uint256)\n    if decimals0 > decimals1:\n        scaleFactor: uint256 = 10 ** (decimals0 - decimals1)\n        priceZeroToOne = priceZeroToOne * scaleFactor\n    elif decimals1 > decimals0:\n        scaleFactor: uint256 = 10 ** (decimals1 - decimals0)\n        priceZeroToOne = priceZeroToOne // scaleFactor\n\n    # if _targetToken is token1, make price inverse\n    priceToOther: uint256 = priceZeroToOne\n    if _targetToken == token1:\n        priceToOther = EIGHTEEN_DECIMALS * EIGHTEEN_DECIMALS // priceZeroToOne\n\n    return altPrice * priceToOther // EIGHTEEN_DECIMALS\n\n\n# internal utils\n\n\n@view\n@internal\ndef _getDeepestLiqPool(_tokenA: address, _tokenB: address) -> (address, uint24):\n    bestPoolAddr: address = empty(address)\n    bestFeeTier: uint24 = 0\n    bestLiquidity: uint128 = 0\n\n    factory: address = UNIV3_FACTORY\n    for i: uint256 in range(4):\n        fee: uint24 = FEE_TIERS[i]\n        pool: address = staticcall UniV3Factory(factory).getPool(_tokenA, _tokenB, fee)\n        if pool == empty(address):\n            continue\n        liquidity: uint128 = staticcall UniV3Pool(pool).liquidity()\n        if liquidity > bestLiquidity:\n            bestPoolAddr = pool\n            bestFeeTier = fee\n            bestLiquidity = liquidity\n\n    return bestPoolAddr, bestFeeTier\n\n\n@view\n@internal\ndef _getUsdValue(\n    _tokenA: address,\n    _amountA: uint256,\n    _tokenB: address,\n    _amountB: uint256,\n    _isSwap: bool,\n    _oracleRegistry: address,\n) -> uint256:\n    oracleRegistry: address = _oracleRegistry\n    if _oracleRegistry == empty(address):\n        oracleRegistry = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n    usdValueA: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenA, _amountA)\n    usdValueB: uint256 = staticcall OracleRegistry(oracleRegistry).getUsdValue(_tokenB, _amountB)\n    if _isSwap:\n        return max(usdValueA, usdValueB)\n    else:\n        return usdValueA + usdValueB\n\n\n@view\n@internal\ndef _getSqrtPriceX96(_pool: address) -> uint256:\n    sqrtPriceX96: uint160 = 0\n    tick: int24 = 0\n    observationIndex: uint16 = 0\n    observationCardinality: uint16 = 0\n    observationCardinalityNext: uint16 = 0\n    feeProtocol: uint8 = 0\n    unlocked: bool = False\n    sqrtPriceX96, tick, observationIndex, observationCardinality, observationCardinalityNext, feeProtocol, unlocked = staticcall UniV3Pool(_pool).slot0()\n    return convert(sqrtPriceX96, uint256)\n\n\n####################\n# Core Router Pool #\n####################\n\n\n@external\ndef setCoreRouterPool(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.coreRouterPool = _addr\n    log UniV3CoreRouterPoolSet(pool=_addr)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log UniV3FundsRecovered(asset=_asset, recipient=_recipient, amount=balance)\n    return True\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log UniV3NftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n###########\n# Lego Id #\n###########\n\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    assert msg.sender == staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2) # dev: no perms\n    prevLegoId: uint256 = self.legoId\n    assert prevLegoId == 0 or prevLegoId == _legoId # dev: invalid lego id\n    self.legoId = _legoId\n    log UniswapV3LegoIdSet(legoId=_legoId)\n    return True\n\n\n@external\ndef activate(_shouldActivate: bool):\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log UniswapV3Activated(isActivated=_shouldActivate)",
            "sha256sum": "1c6523375075e1e5ae62c9ee255d8fe7a987cb283e7a719fb597d8979aea3286"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/dexes/LegoUniswapV3.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "031430350ef8b4279dac99146fed234d6c6f28a3a31de46d7d036e6461005e28"
      },
      "args": "00000000000000000000000033128a8fc17869897dce68ed026d694621f6fdfd00000000000000000000000003a520b32c04bf3beef7beb72e919cf822ed34f10000000000000000000000003d4e44eb1374240ce5f1b871ab261cd16335b76a0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae000000000000000000000000d0b53d9277642d899df5c87a3966a349a798f224"
    },
    "LegoHelper": {
      "address": "0xF80b87DD1096f9E68739f55B9807Df1CB21422E3",
      "abi": [
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aaveV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aaveV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "compoundV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "euler",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "eulerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fluid",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fluidId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "moonwell",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "moonwellId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morpho",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "morphoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "sky",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "skyId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV2",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV2Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV3",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "uniswapV3Id",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodrome",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeSlipstream",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "aerodromeSlipstreamId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curve",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curveId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultTokenAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetAmount",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoFromVaultToken",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "legoAddr",
                  "type": "address"
                },
                {
                  "name": "legoDesc",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_amountInAvailable",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getRoutesAndSwapInstructionsAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_amountInAvailable",
              "type": "uint256"
            },
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "prepareSwapInstructionsAmountOut",
          "inputs": [
            {
              "name": "_slippage",
              "type": "uint256"
            },
            {
              "name": "_routes",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountOut",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountOutSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOutViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountOutViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountIn",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapRoutesAmountIn",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInWithRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getBestSwapAmountInSinglePool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountInViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "getSwapAmountInViaRouterPool",
          "inputs": [
            {
              "name": "_tokenIn",
              "type": "address"
            },
            {
              "name": "_tokenOut",
              "type": "address"
            },
            {
              "name": "_amountOut",
              "type": "uint256"
            },
            {
              "name": "_includeLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "name": "tokenOut",
                  "type": "address"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "amountOut",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ROUTER_TOKENA",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ROUTER_TOKENB",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AAVE_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "COMPOUND_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "EULER_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "FLUID_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MOONWELL_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MORPHO_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "SKY_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V2_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "UNISWAP_V3_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "AERODROME_SLIPSTREAM_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_ID",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_routerTokenA",
              "type": "address"
            },
            {
              "name": "_routerTokenB",
              "type": "address"
            },
            {
              "name": "_aaveV3Id",
              "type": "uint256"
            },
            {
              "name": "_compoundV3Id",
              "type": "uint256"
            },
            {
              "name": "_eulerId",
              "type": "uint256"
            },
            {
              "name": "_fluidId",
              "type": "uint256"
            },
            {
              "name": "_moonwellId",
              "type": "uint256"
            },
            {
              "name": "_morphoId",
              "type": "uint256"
            },
            {
              "name": "_skyId",
              "type": "uint256"
            },
            {
              "name": "_uniswapV2Id",
              "type": "uint256"
            },
            {
              "name": "_uniswapV3Id",
              "type": "uint256"
            },
            {
              "name": "_aerodromeId",
              "type": "uint256"
            },
            {
              "name": "_aerodromeSlipstreamId",
              "type": "uint256"
            },
            {
              "name": "_curveId",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "contracts/modules/Registry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nstruct AddyInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddy:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddyDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddyPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddyConfirmed:\n    addr: indexed(address)\n    addyId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewPendingAddyCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdatePending:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyUpdateConfirmed:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyUpdateCancelled:\n    addyId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisablePending:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyDisableConfirmed:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddyDisableCancelled:\n    addyId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddyChangeDelaySet:\n    delayBlocks: uint256\n    registry: String[28]\n\n# core registry\naddyInfo: public(HashMap[uint256, AddyInfo])\naddyToId: public(HashMap[address, uint256])\nnumAddys: public(uint256)\n\n# pending changes\npendingNewAddy: public(HashMap[address, PendingNewAddy]) # addr -> pending new addy\npendingAddyUpdate: public(HashMap[uint256, PendingAddyUpdate]) # addyId -> pending addy update\npendingAddyDisable: public(HashMap[uint256, PendingAddyDisable]) # addyId -> pending addy disable\naddyChangeDelay: public(uint256)\n\nMIN_ADDY_CHANGE_DELAY: public(immutable(uint256))\nMAX_ADDY_CHANGE_DELAY: public(immutable(uint256))\nREGISTRY_STR: public(immutable(String[28]))\n\n\n@deploy\ndef __init__(_minAddyChangeDelay: uint256, _maxAddyChangeDelay: uint256, _registryStr: String[28]):\n    assert _minAddyChangeDelay < _maxAddyChangeDelay # dev: invalid delay\n    MIN_ADDY_CHANGE_DELAY = _minAddyChangeDelay\n    MAX_ADDY_CHANGE_DELAY = _maxAddyChangeDelay\n\n    REGISTRY_STR = _registryStr\n\n    # start at 1 index\n    self.numAddys = 1\n\n\n############\n# New Addy #\n############\n\n\n@view\n@external\ndef isValidNewAddy(_addr: address) -> bool:\n    return self._isValidNewAddy(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddy(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addyToId[_addr] == 0\n\n\n@internal\ndef _registerNewAddy(_addr: address, _description: String[64]) -> bool:\n    \"\"\"\n    @notice Initiates the registration process for a new address in the registry\n    @dev This function sets up a pending registration that requires confirmation after a delay period\n    @param _addr The address to be registered\n    @param _description A short description of the address (max 64 characters)\n    @return True if the registration was successfully initiated, False if the address is invalid\n    \"\"\"\n    if not self._isValidNewAddy(_addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingNewAddy[_addr] = PendingNewAddy(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddyPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmNewAddy(_addr: address) -> uint256:\n    \"\"\"\n    @notice Confirms a pending address registration after the required delay period\n    @dev This function finalizes the registration by assigning an ID and storing the address info\n    @param _addr The address to confirm registration for\n    @return The assigned ID for the registered address, or 0 if confirmation fails\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    if not self._isValidNewAddy(_addr):\n        self.pendingNewAddy[_addr] = empty(PendingNewAddy) # clear pending\n        return 0\n\n    # register new addy\n    addyId: uint256 = self.numAddys\n    self.addyToId[_addr] = addyId\n    self.numAddys = addyId + 1\n    self.addyInfo[addyId] = AddyInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n\n    log NewAddyConfirmed(addr=_addr, addyId=addyId, description=data.description, registry=REGISTRY_STR)\n    return addyId\n\n\n@internal\ndef _cancelPendingNewAddy(_addr: address) -> bool:\n    \"\"\"\n    @notice Cancels a pending address registration\n    @dev This function removes the pending registration and emits a cancellation event\n    @param _addr The address whose pending registration should be cancelled\n    @return True if the cancellation was successful, reverts if no pending registration exists\n    \"\"\"\n    data: PendingNewAddy = self.pendingNewAddy[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddy[_addr] = empty(PendingNewAddy)\n    log NewPendingAddyCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n###############\n# Update Addy #\n###############\n\n\n@view\n@external\ndef isValidAddyUpdate(_addyId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddyUpdate(_addyId, _newAddr, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyUpdate(_addyId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    if not self._isValidNewAddy(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@internal\ndef _updateAddyAddr(_addyId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Initiates an address update for an existing registered address\n    @dev This function sets up a pending update that requires confirmation after a delay period\n    @param _addyId The ID of the address to update\n    @param _newAddr The new address to set\n    @return True if the update was successfully initiated, False if the update is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyUpdate(_addyId, _newAddr, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyUpdate[_addyId] = PendingAddyUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyUpdatePending(addyId=_addyId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address update after the required delay period\n    @dev This function finalizes the update by updating the address info and version\n    @param _addyId The ID of the address to confirm update for\n    @return True if the update was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyUpdate(_addyId, pendingData.newAddr, prevAddr):\n        self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = pendingData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[pendingData.newAddr] = _addyId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n\n    log AddyUpdateConfirmed(addyId=_addyId, description=data.description, newAddr=pendingData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyUpdate(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address update\n    @dev This function removes the pending update and emits a cancellation event\n    @param _addyId The ID of the address whose pending update should be cancelled\n    @return True if the cancellation was successful, reverts if no pending update exists\n    \"\"\"\n    pendingData: PendingAddyUpdate = self.pendingAddyUpdate[_addyId]\n    assert pendingData.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyUpdate[_addyId] = empty(PendingAddyUpdate)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyUpdateCancelled(addyId=_addyId, description=prevData.description, newAddr=pendingData.newAddr, prevAddr=prevData.addr, initiatedBlock=pendingData.initiatedBlock, confirmBlock=pendingData.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Disable Addy #\n################\n\n\n@view\n@external\ndef isValidAddyDisable(_addyId: uint256) -> bool:\n    return self._isValidAddyDisable(_addyId, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyDisable(_addyId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@internal\ndef _disableAddyAddr(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Initiates the disable process for an existing registered address\n    @dev This function sets up a pending disable that requires confirmation after a delay period\n    @param _addyId The ID of the address to disable\n    @return True if the disable was successfully initiated, False if the disable is invalid\n    \"\"\"\n    data: AddyInfo = self.addyInfo[_addyId]\n    if not self._isValidAddyDisable(_addyId, data.addr):\n        return False\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.addyChangeDelay\n    self.pendingAddyDisable[_addyId] = PendingAddyDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddyDisablePending(addyId=_addyId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _confirmAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Confirms a pending address disable after the required delay period\n    @dev This function finalizes the disable by clearing the address and updating version\n    @param _addyId The ID of the address to confirm disable for\n    @return True if the disable was successfully confirmed, False if confirmation fails\n    \"\"\"\n    pendingData: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert pendingData.confirmBlock != 0 and block.number >= pendingData.confirmBlock # dev: time delay not reached\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddyDisable(_addyId, prevAddr):\n        self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n\n    log AddyDisableConfirmed(addyId=_addyId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n@internal\ndef _cancelPendingAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Cancels a pending address disable\n    @dev This function removes the pending disable and emits a cancellation event\n    @param _addyId The ID of the address whose pending disable should be cancelled\n    @return True if the cancellation was successful, reverts if no pending disable exists\n    \"\"\"\n    data: PendingAddyDisable = self.pendingAddyDisable[_addyId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddyDisable[_addyId] = empty(PendingAddyDisable)\n    prevData: AddyInfo = self.addyInfo[_addyId]\n    log AddyDisableCancelled(addyId=_addyId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n################\n# Change Delay #\n################\n\n\n@internal\ndef _setAddyChangeDelay(_numBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Sets the delay period required for address changes\n    @dev The delay must be between MIN_ADDY_CHANGE_DELAY and MAX_ADDY_CHANGE_DELAY\n    @param _numBlocks The number of blocks to set as the delay period\n    @return True if the delay was successfully set, reverts if delay is invalid\n    \"\"\"\n    assert _numBlocks >= MIN_ADDY_CHANGE_DELAY and _numBlocks <= MAX_ADDY_CHANGE_DELAY # dev: invalid delay\n    self.addyChangeDelay = _numBlocks\n    log AddyChangeDelaySet(delayBlocks=_numBlocks, registry=REGISTRY_STR)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidAddyAddr(_addr: address) -> bool:\n    return self._isValidAddyAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddyAddr(_addr: address) -> bool:\n    return self.addyToId[_addr] != 0\n\n\n@view\n@external\ndef isValidAddyId(_addyId: uint256) -> bool:\n    return self._isValidAddyId(_addyId)\n\n\n@view\n@internal\ndef _isValidAddyId(_addyId: uint256) -> bool:\n    return _addyId != 0 and _addyId < self.numAddys\n\n\n# addy getters\n\n\n@view\n@external\ndef getAddyId(_addr: address) -> uint256:\n    return self._getAddyId(_addr)\n\n\n@view\n@internal\ndef _getAddyId(_addr: address) -> uint256:\n    return self.addyToId[_addr]\n\n\n@view\n@external\ndef getAddy(_addyId: uint256) -> address:\n    return self._getAddy(_addyId)\n\n\n@view\n@internal\ndef _getAddy(_addyId: uint256) -> address:\n    return self.addyInfo[_addyId].addr\n\n\n@view\n@external\ndef getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self._getAddyInfo(_addyId)\n\n\n@view\n@internal\ndef _getAddyInfo(_addyId: uint256) -> AddyInfo:\n    return self.addyInfo[_addyId]\n\n\n@view\n@external\ndef getAddyDescription(_addyId: uint256) -> String[64]:\n    return self._getAddyDescription(_addyId)\n\n\n@view\n@internal\ndef _getAddyDescription(_addyId: uint256) -> String[64]:\n    return self.addyInfo[_addyId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumAddys() -> uint256:\n    return self._getNumAddys()\n\n\n@view\n@internal\ndef _getNumAddys() -> uint256:\n    return self.numAddys - 1\n\n\n@view\n@external\ndef getLastAddyAddr() -> address:\n    return self._getLastAddyAddr()\n\n\n@view\n@internal\ndef _getLastAddyAddr() -> address:\n    lastIndex: uint256 = self.numAddys - 1\n    return self.addyInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastAddyId() -> uint256:\n    return self._getLastAddyId()\n\n\n@view\n@internal\ndef _getLastAddyId() -> uint256:\n    return self.numAddys - 1\n",
            "sha256sum": "460d2db094c5b32c0788cc51d7e857c0e7e2f223f570937c46cb97599441b29e"
          },
          "contracts/legos/LegoHelper.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nfrom interfaces import LegoYield\nfrom interfaces import LegoDex\nfrom ethereum.ercs import IERC20\nimport contracts.modules.Registry as registry\n\ninterface LegoRegistry:\n    def getLegoAddr(_legoId: uint256) -> address: view\n    def isValidLegoId(_legoId: uint256) -> bool: view\n    def legoIdToType(_legoId: uint256) -> LegoType: view\n    def getLegoInfo(_legoId: uint256) -> registry.AddyInfo: view\n    def numLegosRaw() -> uint256: view\n\ninterface LegoDexNonStandard:\n    def getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256): nonpayable\n    def getSwapAmountOut(_pool: address, _tokenIn: address, _tokenOut: address, _amountIn: uint256) -> uint256: nonpayable\n    def getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256): nonpayable\n    def getSwapAmountIn(_pool: address, _tokenIn: address, _tokenOut: address, _amountOut: uint256) -> uint256: nonpayable\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nflag LegoType:\n    YIELD_OPP\n    DEX\n\nstruct SwapRoute:\n    legoId: uint256\n    pool: address\n    tokenIn: address\n    tokenOut: address\n    amountIn: uint256\n    amountOut: uint256\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct UnderlyingData:\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    legoDesc: String[64]\n\nADDY_REGISTRY: public(immutable(address))\n\n# key router tokens\nROUTER_TOKENA: public(immutable(address))\nROUTER_TOKENB: public(immutable(address))\n\n# yield lego ids\nAAVE_V3_ID: public(immutable(uint256))\nCOMPOUND_V3_ID: public(immutable(uint256))\nEULER_ID: public(immutable(uint256))\nFLUID_ID: public(immutable(uint256))\nMOONWELL_ID: public(immutable(uint256))\nMORPHO_ID: public(immutable(uint256))\nSKY_ID: public(immutable(uint256))\n\n# dex lego ids\nUNISWAP_V2_ID: public(immutable(uint256))\nUNISWAP_V3_ID: public(immutable(uint256))\nAERODROME_ID: public(immutable(uint256))\nAERODROME_SLIPSTREAM_ID: public(immutable(uint256))\nCURVE_ID: public(immutable(uint256))\n\nMAX_ROUTES: constant(uint256) = 10\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_LEGOS: constant(uint256) = 20\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\n\n\n@deploy\ndef __init__(\n    _addyRegistry: address,\n    _routerTokenA: address,\n    _routerTokenB: address,\n    # yield lego ids\n    _aaveV3Id: uint256,\n    _compoundV3Id: uint256,\n    _eulerId: uint256,\n    _fluidId: uint256,\n    _moonwellId: uint256,\n    _morphoId: uint256,\n    _skyId: uint256,\n    # dex lego ids\n    _uniswapV2Id: uint256,\n    _uniswapV3Id: uint256,\n    _aerodromeId: uint256,\n    _aerodromeSlipstreamId: uint256,\n    _curveId: uint256,\n):\n    assert empty(address) not in [_addyRegistry, _routerTokenA, _routerTokenB] # dev: invalid address\n    ADDY_REGISTRY = _addyRegistry\n    ROUTER_TOKENA = _routerTokenA\n    ROUTER_TOKENB = _routerTokenB\n\n    # yield lego ids\n    legoRegistry: address = staticcall AddyRegistry(_addyRegistry).getAddy(2)\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_aaveV3Id) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_compoundV3Id) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_eulerId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_fluidId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_moonwellId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_morphoId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_skyId) # dev: invalid id\n\n    AAVE_V3_ID = _aaveV3Id\n    COMPOUND_V3_ID = _compoundV3Id\n    EULER_ID = _eulerId\n    FLUID_ID = _fluidId\n    MOONWELL_ID = _moonwellId\n    MORPHO_ID = _morphoId\n    SKY_ID = _skyId\n\n    # dex lego ids\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_uniswapV2Id) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_uniswapV3Id) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_aerodromeId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_aerodromeSlipstreamId) # dev: invalid id\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_curveId) # dev: invalid id\n\n    UNISWAP_V2_ID = _uniswapV2Id\n    UNISWAP_V3_ID = _uniswapV3Id\n    AERODROME_ID = _aerodromeId\n    AERODROME_SLIPSTREAM_ID = _aerodromeSlipstreamId\n    CURVE_ID = _curveId\n\n\n###############\n# Yield Legos #\n###############\n\n\n@view\n@external\ndef aaveV3() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(AAVE_V3_ID)\n\n\n@view\n@external\ndef aaveV3Id() -> uint256:\n    return AAVE_V3_ID\n\n\n@view\n@external\ndef compoundV3() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(COMPOUND_V3_ID)\n\n\n@view\n@external\ndef compoundV3Id() -> uint256:\n    return COMPOUND_V3_ID\n\n\n@view\n@external\ndef euler() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(EULER_ID)\n\n\n@view\n@external\ndef eulerId() -> uint256:\n    return EULER_ID\n\n\n@view\n@external\ndef fluid() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(FLUID_ID)\n\n\n@view\n@external\ndef fluidId() -> uint256:\n    return FLUID_ID\n\n\n@view\n@external\ndef moonwell() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(MOONWELL_ID)\n\n\n@view\n@external\ndef moonwellId() -> uint256:\n    return MOONWELL_ID\n\n\n@view\n@external\ndef morpho() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(MORPHO_ID)\n\n\n@view\n@external\ndef morphoId() -> uint256:\n    return MORPHO_ID\n\n\n@view\n@external\ndef sky() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(SKY_ID)\n\n\n@view\n@external\ndef skyId() -> uint256:\n    return SKY_ID\n\n\n#############\n# DEX Legos #\n#############\n\n\n@view\n@external\ndef uniswapV2() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(UNISWAP_V2_ID)\n\n\n@view\n@external\ndef uniswapV2Id() -> uint256:\n    return UNISWAP_V2_ID\n\n\n@view\n@external\ndef uniswapV3() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(UNISWAP_V3_ID)\n\n\n@view\n@external\ndef uniswapV3Id() -> uint256:\n    return UNISWAP_V3_ID\n\n\n@view\n@external\ndef aerodrome() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(AERODROME_ID)\n\n\n@view\n@external\ndef aerodromeId() -> uint256:\n    return AERODROME_ID\n\n\n@view\n@external\ndef aerodromeSlipstream() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(AERODROME_SLIPSTREAM_ID)\n\n\n@view\n@external\ndef aerodromeSlipstreamId() -> uint256:\n    return AERODROME_SLIPSTREAM_ID\n\n\n@view\n@external\ndef curve() -> address:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    return staticcall LegoRegistry(legoRegistry).getLegoAddr(CURVE_ID)\n\n\n@view\n@external\ndef curveId() -> uint256:\n    return CURVE_ID\n\n\n#################\n# Yield Helpers #\n#################\n\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    if _assetAmount == 0 or _asset == empty(address) or _vaultToken == empty(address):\n        return 0\n\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = staticcall LegoRegistry(legoRegistry).legoIdToType(i)\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoAddr: address = staticcall LegoRegistry(legoRegistry).getLegoAddr(i)\n        vaultTokenAmount: uint256 = staticcall LegoYield(legoAddr).getVaultTokenAmount(_asset, _assetAmount, _vaultToken)\n        if vaultTokenAmount != 0:\n            return vaultTokenAmount\n\n    return 0\n\n\n@view\n@external\ndef getLegoFromVaultToken(_vaultToken: address) -> (uint256, address, String[64]):\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = staticcall LegoRegistry(legoRegistry).legoIdToType(i)\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoInfo: registry.AddyInfo = staticcall LegoRegistry(legoRegistry).getLegoInfo(i)\n        if staticcall LegoYield(legoInfo.addr).isVaultToken(_vaultToken):\n            return i, legoInfo.addr, legoInfo.description\n    return 0, empty(address), \"\"\n\n\n@view\n@external\ndef getUnderlyingData(_asset: address, _amount: uint256) -> UnderlyingData:\n    if _amount == 0 or _asset == empty(address):\n        return empty(UnderlyingData)\n\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    oracleRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(4)\n\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoType: LegoType = staticcall LegoRegistry(legoRegistry).legoIdToType(i)\n        if legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoInfo: registry.AddyInfo = staticcall LegoRegistry(legoRegistry).getLegoInfo(i)\n        asset: address = empty(address)\n        underlyingAmount: uint256 = 0\n        usdValue: uint256 = 0\n        asset, underlyingAmount, usdValue = staticcall LegoYield(legoInfo.addr).getUnderlyingData(_asset, _amount, oracleRegistry)\n        if asset != empty(address):\n            return UnderlyingData(\n                asset=asset,\n                amount=underlyingAmount,\n                usdValue=usdValue,\n                legoId=i,\n                legoAddr=legoInfo.addr,\n                legoDesc=legoInfo.description,\n            )\n\n    return UnderlyingData(\n        asset=_asset,\n        amount=_amount,\n        usdValue=staticcall OracleRegistry(oracleRegistry).getUsdValue(_asset, _amount),\n        legoId=0,\n        legoAddr=empty(address),\n        legoDesc=\"\",\n    )\n\n\n########################\n# Dex: Swap High Level #\n########################\n\n\n@external\ndef getRoutesAndSwapInstructionsAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _slippage: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    routes: DynArray[SwapRoute, MAX_ROUTES] = self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, _amountIn, _includeLegoIds)\n    return self._prepareSwapInstructionsAmountOut(_slippage, routes)\n\n\n@external\ndef getRoutesAndSwapInstructionsAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _amountInAvailable: uint256,\n    _slippage: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    routes: DynArray[SwapRoute, MAX_ROUTES] = self._getBestSwapRoutesAmountIn(_tokenIn, _tokenOut, _amountOut, _includeLegoIds)\n    if len(routes) == 0:\n        return []\n\n    # let's re-run the routes with amountIn as input (this is more accurate, for example, Aerodrome doesn't have getAmountIn for stable pools\n    amountIn: uint256 = min(_amountInAvailable, routes[0].amountIn)\n    routes = self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, amountIn, _includeLegoIds)\n    return self._prepareSwapInstructionsAmountOut(_slippage, routes)\n\n\n########################\n# Dex: Swap Amount Out #\n########################\n\n\n# prepare swap instructions (amountIn as input)\n\n\n@external\ndef prepareSwapInstructionsAmountOut(_slippage: uint256, _routes: DynArray[SwapRoute, MAX_ROUTES]) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    return self._prepareSwapInstructionsAmountOut(_slippage, _routes)\n\n\n@internal\ndef _prepareSwapInstructionsAmountOut(_slippage: uint256, _routes: DynArray[SwapRoute, MAX_ROUTES]) -> DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]:\n    if len(_routes) == 0:\n        return []\n\n    instructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS] = []\n\n    # start with first route\n    prevRoute: SwapRoute = _routes[0]\n    prevInstruction: SwapInstruction = self._createNewInstruction(prevRoute, _slippage)\n\n    # iterate thru swap routes, skip first\n    for i: uint256 in range(1, len(_routes), bound=MAX_ROUTES):\n        newRoute: SwapRoute = _routes[i]\n        assert prevRoute.tokenOut == newRoute.tokenIn # dev: invalid route\n\n        # add to previous instruction\n        if prevRoute.legoId == newRoute.legoId:\n            prevInstruction.minAmountOut = newRoute.amountOut * (HUNDRED_PERCENT - _slippage) // HUNDRED_PERCENT\n            prevInstruction.tokenPath.append(newRoute.tokenOut)\n            prevInstruction.poolPath.append(newRoute.pool)\n\n        # create new instruction\n        else:\n            instructions.append(prevInstruction)\n            prevInstruction = self._createNewInstruction(newRoute, _slippage)\n\n        # set previous item\n        prevRoute = newRoute\n\n    # add last instruction\n    instructions.append(prevInstruction)\n    return instructions\n\n\n@view\n@internal\ndef _createNewInstruction(_route: SwapRoute, _slippage: uint256) -> SwapInstruction:\n    return SwapInstruction(\n        legoId=_route.legoId,\n        amountIn=_route.amountIn,\n        minAmountOut=_route.amountOut * (HUNDRED_PERCENT - _slippage) // HUNDRED_PERCENT,\n        tokenPath=[_route.tokenIn, _route.tokenOut],\n        poolPath=[_route.pool],\n    )\n\n\n# best swap routes (amountIn as input)\n\n\n@external\ndef getBestSwapRoutesAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    return self._getBestSwapRoutesAmountOut(_tokenIn, _tokenOut, _amountIn, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapRoutesAmountOut(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    if _tokenIn == _tokenOut or _amountIn == 0 or empty(address) in [_tokenIn, _tokenOut]:\n        return []\n\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n\n    # required data\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    routerTokenA: address = ROUTER_TOKENA\n    routerTokenB: address = ROUTER_TOKENB\n\n    # direct swap route\n    directSwapRoute: SwapRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _tokenOut, _amountIn, numLegos, legoRegistry, _includeLegoIds)\n\n    # check with router pools\n    withRouterHopAmountOut: uint256 = 0\n    withHopRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    withRouterHopAmountOut, withHopRoutes = self._getBestSwapAmountOutWithRouterPool(routerTokenA, routerTokenB, _tokenIn, _tokenOut, _amountIn, numLegos, legoRegistry, _includeLegoIds)\n\n    # compare direct swap route with hop routes\n    if directSwapRoute.amountOut > withRouterHopAmountOut:\n        bestSwapRoutes = [directSwapRoute]\n\n    # update router token pool (if possible)\n    elif withRouterHopAmountOut != 0:\n        bestSwapRoutes = withHopRoutes\n\n    return bestSwapRoutes\n\n\n# check various routes via core router pools\n\n\n@external\ndef getBestSwapAmountOutWithRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    return self._getBestSwapAmountOutWithRouterPool(ROUTER_TOKENA, ROUTER_TOKENB, _tokenIn, _tokenOut, _amountIn, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountOutWithRouterPool(\n    _routerTokenA: address,\n    _routerTokenB: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n\n    # nothing to do, already have router pool to use\n    if self._isRouterPool(_tokenIn, _tokenOut, _routerTokenA, _routerTokenB):\n        return 0, []\n\n    isMultiHop: bool = False\n    finalAmountOut: uint256 = 0\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    firstRoute: SwapRoute = empty(SwapRoute)\n    secondRoute: SwapRoute = empty(SwapRoute)\n\n    # usdc -> weth -> tokenOut\n    if _tokenIn == _routerTokenA:\n        firstRoute = self._getSwapAmountOutViaRouterPool(_routerTokenA, _routerTokenB, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getBestSwapAmountOutSinglePool(_routerTokenB, _tokenOut, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> weth -> usdc\n    elif _tokenOut == _routerTokenA:\n        firstRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _routerTokenB, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getSwapAmountOutViaRouterPool(_routerTokenB, _routerTokenA, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # weth -> usdc -> tokenOut\n    elif _tokenIn == _routerTokenB:\n        firstRoute = self._getSwapAmountOutViaRouterPool(_routerTokenB, _routerTokenA, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getBestSwapAmountOutSinglePool(_routerTokenA, _tokenOut, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> usdc -> weth\n    elif _tokenOut == _routerTokenB:\n        firstRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _routerTokenA, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n        secondRoute = self._getSwapAmountOutViaRouterPool(_routerTokenA, _routerTokenB, firstRoute.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # let's try multi hop routes\n    else:\n        isMultiHop = True\n\n        # router token A as starting point\n        viaRouterTokenAAmountOut: uint256 = 0\n        viaRouterTokenARoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenAAmountOut, viaRouterTokenARoutes = self._checkRouterPoolForMiddleSwapAmountOut(_routerTokenA, _routerTokenB, _tokenIn, _tokenOut, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # router token B as starting point\n        viaRouterTokenBAmountOut: uint256 = 0\n        viaRouterTokenBRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenBAmountOut, viaRouterTokenBRoutes = self._checkRouterPoolForMiddleSwapAmountOut(_routerTokenB, _routerTokenA, _tokenIn, _tokenOut, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # compare\n        if viaRouterTokenAAmountOut > viaRouterTokenBAmountOut:\n            finalAmountOut = viaRouterTokenAAmountOut\n            bestSwapRoutes = viaRouterTokenARoutes\n        elif viaRouterTokenBAmountOut != 0:\n            finalAmountOut = viaRouterTokenBAmountOut\n            bestSwapRoutes = viaRouterTokenBRoutes\n\n    if not isMultiHop:\n        finalAmountOut = secondRoute.amountOut\n        bestSwapRoutes = [firstRoute, secondRoute]\n\n    return finalAmountOut, bestSwapRoutes\n\n\n@internal\ndef _checkRouterPoolForMiddleSwapAmountOut(\n    _firstRouterTokenHop: address,\n    _secondRouterTokenHop: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    secondHopToTokenOut: SwapRoute = empty(SwapRoute)\n\n    # tokenIn -> first Router Token\n    tokenInToFirstHop: SwapRoute = self._getBestSwapAmountOutSinglePool(_tokenIn, _firstRouterTokenHop, _amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n    if tokenInToFirstHop.amountOut == 0:\n        return 0, []\n\n    # first Router Token -> tokenOut\n    firstHopToTokenOut: SwapRoute = self._getBestSwapAmountOutSinglePool(_firstRouterTokenHop, _tokenOut, tokenInToFirstHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # first Router Token -> second Router Token -- this will always happen in router pools (i.e. usdc <-> weth)\n    firstHopToSecondHop: SwapRoute = self._getSwapAmountOutViaRouterPool(_firstRouterTokenHop, _secondRouterTokenHop, tokenInToFirstHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # second Router Token -> tokenOut\n    if firstHopToSecondHop.amountOut != 0:\n        secondHopToTokenOut = self._getBestSwapAmountOutSinglePool(_secondRouterTokenHop, _tokenOut, firstHopToSecondHop.amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # compare routes\n    if firstHopToTokenOut.amountOut > secondHopToTokenOut.amountOut:\n        return firstHopToTokenOut.amountOut, [tokenInToFirstHop, firstHopToTokenOut]\n    elif secondHopToTokenOut.amountOut != 0:\n        return secondHopToTokenOut.amountOut, [tokenInToFirstHop, firstHopToSecondHop, secondHopToTokenOut]\n    return 0, []\n\n\n# single pool\n\n\n@external\ndef getBestSwapAmountOutSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    return self._getBestSwapAmountOutSinglePool(_tokenIn, _tokenOut, _amountIn, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountOutSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=_amountIn,\n        amountOut=0,\n    )\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego info\n        legoType: LegoType = staticcall LegoRegistry(_legoRegistry).legoIdToType(i)\n        if legoType != LegoType.DEX:\n            continue\n\n        legoAddr: address = staticcall LegoRegistry(_legoRegistry).getLegoAddr(i)\n        pool: address = empty(address)\n        amountOut: uint256 = 0\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            pool, amountOut = extcall LegoDexNonStandard(legoAddr).getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n        else:\n            pool, amountOut = staticcall LegoDex(legoAddr).getBestSwapAmountOut(_tokenIn, _tokenOut, _amountIn)\n\n        # compare best\n        if pool != empty(address) and amountOut > bestRoute.amountOut:\n            bestRoute.pool = pool\n            bestRoute.amountOut = amountOut\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n# router pool only\n\n\n@external\ndef getSwapAmountOutViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    return self._getSwapAmountOutViaRouterPool(_tokenIn, _tokenOut, _amountIn, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getSwapAmountOutViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    # NOTE: _tokenIn and _tokenOut need to be ROUTER_TOKENA/ROUTER_TOKENB -- in the `getCoreRouterPool()` pool\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=_amountIn,\n        amountOut=0,\n    )\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        # get lego info\n        legoType: LegoType = staticcall LegoRegistry(_legoRegistry).legoIdToType(i)\n        if legoType != LegoType.DEX:\n            continue\n\n        # get router pool\n        legoAddr: address = staticcall LegoRegistry(_legoRegistry).getLegoAddr(i)\n        pool: address = staticcall LegoDex(legoAddr).getCoreRouterPool()\n        if pool == empty(address):\n            continue\n\n        amountOut: uint256 = 0\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            amountOut = extcall LegoDexNonStandard(legoAddr).getSwapAmountOut(pool, _tokenIn, _tokenOut, _amountIn)\n        else:\n            amountOut = staticcall LegoDex(legoAddr).getSwapAmountOut(pool, _tokenIn, _tokenOut, _amountIn)\n\n        # compare best\n        if amountOut > bestRoute.amountOut:\n            bestRoute.pool = pool\n            bestRoute.amountOut = amountOut\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n#######################\n# Dex: Swap Amount In #\n#######################\n\n\n# best swap routes (amountOut as input)\n\n\n@external\ndef getBestSwapRoutesAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    return self._getBestSwapRoutesAmountIn(_tokenIn, _tokenOut, _amountOut, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapRoutesAmountIn(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> DynArray[SwapRoute, MAX_ROUTES]:\n    if _tokenIn == _tokenOut or _amountOut == 0 or empty(address) in [_tokenIn, _tokenOut]:\n        return []\n\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n\n    # required data\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    routerTokenA: address = ROUTER_TOKENA\n    routerTokenB: address = ROUTER_TOKENB\n\n    # direct swap route\n    directSwapRoute: SwapRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _tokenOut, _amountOut, numLegos, legoRegistry, _includeLegoIds)\n\n    # check with router pools\n    withRouterHopAmountIn: uint256 = 0\n    withHopRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    withRouterHopAmountIn, withHopRoutes = self._getBestSwapAmountInWithRouterPool(routerTokenA, routerTokenB, _tokenIn, _tokenOut, _amountOut, numLegos, legoRegistry, _includeLegoIds)\n\n    # compare direct swap route with hop routes\n    if directSwapRoute.amountIn < withRouterHopAmountIn:\n        bestSwapRoutes = [directSwapRoute]\n\n    # update router token pool (if possible)\n    elif withRouterHopAmountIn != max_value(uint256):\n        bestSwapRoutes = withHopRoutes\n\n    return bestSwapRoutes\n\n\n# check various routes via core router pools\n\n\n@external\ndef getBestSwapAmountInWithRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    return self._getBestSwapAmountInWithRouterPool(ROUTER_TOKENA, ROUTER_TOKENB, _tokenIn, _tokenOut, _amountOut, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountInWithRouterPool(\n    _routerTokenA: address,\n    _routerTokenB: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n\n    # nothing to do, already have router pool to use\n    if self._isRouterPool(_tokenIn, _tokenOut, _routerTokenA, _routerTokenB):\n        return max_value(uint256), []\n\n    isMultiHop: bool = False\n    finalAmountIn: uint256 = max_value(uint256)\n    bestSwapRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n    firstRoute: SwapRoute = empty(SwapRoute)\n    secondRoute: SwapRoute = empty(SwapRoute)\n\n    # usdc -> weth -> tokenOut\n    if _tokenIn == _routerTokenA:\n        secondRoute = self._getBestSwapAmountInSinglePool(_routerTokenB, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getSwapAmountInViaRouterPool(_routerTokenA, _routerTokenB, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> weth -> usdc\n    elif _tokenOut == _routerTokenA:\n        secondRoute = self._getSwapAmountInViaRouterPool(_routerTokenB, _routerTokenA, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _routerTokenB, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # weth -> usdc -> tokenOut\n    elif _tokenIn == _routerTokenB:\n        secondRoute = self._getBestSwapAmountInSinglePool(_routerTokenA, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getSwapAmountInViaRouterPool(_routerTokenB, _routerTokenA, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> usdc -> weth\n    elif _tokenOut == _routerTokenB:\n        secondRoute = self._getSwapAmountInViaRouterPool(_routerTokenA, _routerTokenB, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n        firstRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _routerTokenA, secondRoute.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # let's try multi hop routes\n    else:\n        isMultiHop = True\n\n        # router token A as starting point\n        viaRouterTokenAAmountIn: uint256 = 0\n        viaRouterTokenARoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenAAmountIn, viaRouterTokenARoutes = self._checkRouterPoolForMiddleSwapAmountIn(_routerTokenA, _routerTokenB, _tokenIn, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # router token B as starting point\n        viaRouterTokenBAmountIn: uint256 = 0\n        viaRouterTokenBRoutes: DynArray[SwapRoute, MAX_ROUTES] = []\n        viaRouterTokenBAmountIn, viaRouterTokenBRoutes = self._checkRouterPoolForMiddleSwapAmountIn(_routerTokenB, _routerTokenA, _tokenIn, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n\n        # compare\n        if viaRouterTokenAAmountIn < viaRouterTokenBAmountIn:\n            finalAmountIn = viaRouterTokenAAmountIn\n            bestSwapRoutes = viaRouterTokenARoutes\n        elif viaRouterTokenBAmountIn != max_value(uint256):\n            finalAmountIn = viaRouterTokenBAmountIn\n            bestSwapRoutes = viaRouterTokenBRoutes\n\n    if not isMultiHop:\n        finalAmountIn = firstRoute.amountIn\n        bestSwapRoutes = [firstRoute, secondRoute]\n\n    return finalAmountIn, bestSwapRoutes\n\n\n@internal\ndef _checkRouterPoolForMiddleSwapAmountIn(\n    _firstRouterToken: address,\n    _secondRouterToken: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (uint256, DynArray[SwapRoute, MAX_ROUTES]):\n    tokenInToFirstHop: SwapRoute = empty(SwapRoute)\n    tokenInToFirstHop.amountIn = max_value(uint256)\n\n    # second Router Token -> tokenOut\n    secondHopToTokenOut: SwapRoute = self._getBestSwapAmountInSinglePool(_secondRouterToken, _tokenOut, _amountOut, _numLegos, _legoRegistry, _includeLegoIds)\n    if secondHopToTokenOut.amountIn == max_value(uint256):\n        return max_value(uint256), []\n\n    # tokenIn -> second Router Token\n    tokenInToSecondHop: SwapRoute = self._getBestSwapAmountInSinglePool(_tokenIn, _secondRouterToken, secondHopToTokenOut.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # first Router Token -> second Router Token -- this will always happen in router pools (i.e. usdc <-> weth)\n    firstHopToSecondHop: SwapRoute = self._getSwapAmountInViaRouterPool(_firstRouterToken, _secondRouterToken, secondHopToTokenOut.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # tokenIn -> first Router Token\n    if firstHopToSecondHop.amountIn != max_value(uint256):\n        tokenInToFirstHop = self._getBestSwapAmountInSinglePool(_tokenIn, _firstRouterToken, firstHopToSecondHop.amountIn, _numLegos, _legoRegistry, _includeLegoIds)\n\n    # compare routes\n    if tokenInToSecondHop.amountIn < tokenInToFirstHop.amountIn:\n        return tokenInToSecondHop.amountIn, [tokenInToSecondHop, secondHopToTokenOut]\n    elif tokenInToFirstHop.amountIn != max_value(uint256):\n        return tokenInToFirstHop.amountIn, [tokenInToFirstHop, firstHopToSecondHop, secondHopToTokenOut]\n    return max_value(uint256), []\n\n\n# single pool\n\n\n@external\ndef getBestSwapAmountInSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    return self._getBestSwapAmountInSinglePool(_tokenIn, _tokenOut, _amountOut, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getBestSwapAmountInSinglePool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=max_value(uint256),\n        amountOut=_amountOut,\n    )\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        legoType: LegoType = staticcall LegoRegistry(_legoRegistry).legoIdToType(i)\n        if legoType != LegoType.DEX:\n            continue\n\n        pool: address = empty(address)\n        amountIn: uint256 = max_value(uint256)\n        legoAddr: address = staticcall LegoRegistry(_legoRegistry).getLegoAddr(i)\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            pool, amountIn = extcall LegoDexNonStandard(legoAddr).getBestSwapAmountIn(_tokenIn, _tokenOut, _amountOut)\n        else:\n            pool, amountIn = staticcall LegoDex(legoAddr).getBestSwapAmountIn(_tokenIn, _tokenOut, _amountOut)\n\n        # compare best\n        if pool != empty(address) and amountIn != 0 and amountIn < bestRoute.amountIn:\n            bestRoute.pool = pool\n            bestRoute.amountIn = amountIn\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n# router pool only\n\n\n@external\ndef getSwapAmountInViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n) -> SwapRoute:\n    legoRegistry: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(2)\n    numLegos: uint256 = staticcall LegoRegistry(legoRegistry).numLegosRaw()\n    return self._getSwapAmountInViaRouterPool(_tokenIn, _tokenOut, _amountOut, numLegos, legoRegistry, _includeLegoIds)\n\n\n@internal\ndef _getSwapAmountInViaRouterPool(\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n    _numLegos: uint256,\n    _legoRegistry: address,\n    _includeLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> SwapRoute:\n\n    # NOTE: _tokenIn and _tokenOut need to be ROUTER_TOKENA/ROUTER_TOKENB -- in the `getCoreRouterPool()` pool\n\n    bestRoute: SwapRoute = SwapRoute(\n        legoId=0,\n        pool=empty(address),\n        tokenIn=_tokenIn,\n        tokenOut=_tokenOut,\n        amountIn=max_value(uint256),\n        amountOut=_amountOut,\n    )\n\n    shouldCheckLegoIds: bool = len(_includeLegoIds) != 0\n    for i: uint256 in range(1, _numLegos, bound=max_value(uint256)):\n\n        # skip if we should check lego ids and it's not in the list\n        if shouldCheckLegoIds and i not in _includeLegoIds:\n            continue\n\n        legoType: LegoType = staticcall LegoRegistry(_legoRegistry).legoIdToType(i)\n        if legoType != LegoType.DEX:\n            continue\n\n        # get router pool\n        legoAddr: address = staticcall LegoRegistry(_legoRegistry).getLegoAddr(i)\n        pool: address = staticcall LegoDex(legoAddr).getCoreRouterPool()\n        if pool == empty(address):\n            continue\n\n        amountIn: uint256 = max_value(uint256)\n        if i in [UNISWAP_V3_ID, AERODROME_SLIPSTREAM_ID]:\n            amountIn = extcall LegoDexNonStandard(legoAddr).getSwapAmountIn(pool, _tokenIn, _tokenOut, _amountOut)\n        else:\n            amountIn = staticcall LegoDex(legoAddr).getSwapAmountIn(pool, _tokenIn, _tokenOut, _amountOut)\n\n        # compare best\n        if amountIn != 0 and amountIn < bestRoute.amountIn:\n            bestRoute.pool = pool\n            bestRoute.amountIn = amountIn\n            bestRoute.legoId = i\n\n    return bestRoute\n\n\n@view\n@internal\ndef _isRouterPool(_tokenIn: address, _tokenOut: address, _routerTokenA: address, _routerTokenB: address) -> bool:\n    return _tokenIn in [_routerTokenA, _routerTokenB] and _tokenOut in [_routerTokenA, _routerTokenB]\n",
            "sha256sum": "3e0d3e6d8744efa0acaa2071b7de7e7de79a404ca99b219c269e28a0509103b4"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/legos/LegoHelper.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "f8410b5e1f7bfa6c00a4564b72134c8496d55fb17e9264303079f9d2def9fe99"
      },
      "args": "0000000000000000000000007bcd6d471d1a068012a79347c7a944d1df01a1ae000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda0291300000000000000000000000042000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a"
    }
  }
}