{
  "contracts": {
    "AddyRegistry": {
      "address": "0x49B08551e452cA99da7dE9B3a60E39e5f10C13CD",
      "abi": [
        {
          "name": "NewAddyRegistered",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyIdUpdated",
          "inputs": [
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyIdDisabled",
          "inputs": [
            {
              "name": "prevAddy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addyId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddyRegistryGovernorSet",
          "inputs": [
            {
              "name": "governor",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddy",
          "inputs": [
            {
              "name": "_addy",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewAddy",
          "inputs": [
            {
              "name": "_addy",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyUpdate",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            },
            {
              "name": "_newAddy",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateAddy",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            },
            {
              "name": "_newAddy",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyDisable",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableAddy",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddy",
          "inputs": [
            {
              "name": "_addy",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddyId",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyId",
          "inputs": [
            {
              "name": "_addy",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddy",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyInfo",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddyDescription",
          "inputs": [
            {
              "name": "_addyId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddy",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddyId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyToId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_governor",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/core/AddyRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nstruct AddyInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nevent NewAddyRegistered:\n    addr: indexed(address)\n    addyId: uint256\n    description: String[64]\n\nevent AddyIdUpdated:\n    newAddr: indexed(address)\n    prevAddy: indexed(address)\n    addyId: uint256\n    version: uint256\n    description: String[64]\n\nevent AddyIdDisabled:\n    prevAddy: indexed(address)\n    addyId: uint256\n    version: uint256\n    description: String[64]\n\nevent AddyRegistryGovernorSet:\n    governor: indexed(address)\n\n# core\naddyInfo: public(HashMap[uint256, AddyInfo])\naddyToId: public(HashMap[address, uint256])\nnumAddys: public(uint256)\n\n# config\ngovernor: public(address)\n\n\n@deploy\ndef __init__(_governor: address):\n    assert _governor != empty(address) # dev: invalid governor\n    self.governor = _governor\n\n    # start at 1 index\n    self.numAddys = 1\n\n\n#################\n# Register Addy #\n#################\n\n\n@view\n@external\ndef isValidNewAddy(_addy: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be registered as a new core contract\n    @dev Validates address is non-zero, is a contract, and hasn't been registered before\n    @param _addy The address to validate\n    @return True if address can be registered as new core contract, False otherwise\n    \"\"\"\n    return self._isValidNewAddy(_addy)\n\n\n@view\n@internal\ndef _isValidNewAddy(_addy: address) -> bool:\n    if _addy == empty(address) or not _addy.is_contract:\n        return False\n    return self.addyToId[_addy] == 0\n\n\n@external\ndef registerNewAddy(_addy: address, _description: String[64]) -> uint256:\n    \"\"\"\n    @notice Register a new core contract address in the registry\n    @dev Only callable by governor\n    @param _addy The address of the contract to register\n    @param _description A brief description of the contract's functionality\n    @return The assigned ID if registration successful, 0 if failed\n    \"\"\"\n    assert msg.sender == self.governor # dev: no perms\n\n    if not self._isValidNewAddy(_addy):\n        return 0\n\n    data: AddyInfo = AddyInfo(\n        addr=_addy,\n        version=1,\n        lastModified=block.timestamp,\n        description=_description,\n    )\n\n    addyId: uint256 = self.numAddys\n    self.addyToId[_addy] = addyId\n    self.numAddys = addyId + 1\n    self.addyInfo[addyId] = data\n\n    log NewAddyRegistered(addr=_addy, addyId=addyId, description=_description)\n    return addyId\n\n\n###############\n# Update Addy #\n###############\n\n\n@view\n@external\ndef isValidAddyUpdate(_addyId: uint256, _newAddy: address) -> bool:\n    \"\"\"\n    @notice Check if a core contract update operation would be valid\n    @dev Validates ID exists and new address is valid\n    @param _addyId The ID of the contract to update\n    @param _newAddy The proposed new address for the contract\n    @return True if update would be valid, False otherwise\n    \"\"\"\n    return self._isValidAddyUpdate(_addyId, _newAddy, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyUpdate(_addyId: uint256, _newAddy: address, _prevAddy: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    if not self._isValidNewAddy(_newAddy):\n        return False\n    return _newAddy != _prevAddy\n\n\n@external\ndef updateAddy(_addyId: uint256, _newAddy: address) -> bool:\n    \"\"\"\n    @notice Update the address of an existing core contract\n    @dev Only callable by governor. Updates version and timestamp.\n    @param _addyId The ID of the contract to update\n    @param _newAddy The new address for the contract\n    @return True if update successful, False otherwise\n    \"\"\"\n    assert msg.sender == self.governor # dev: no perms\n\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddy: address = data.addr # needed for later\n\n    if not self._isValidAddyUpdate(_addyId, _newAddy, prevAddy):\n        return False\n\n    # save new data\n    data.addr = _newAddy\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[_newAddy] = _addyId\n\n    # handle previous addr\n    if prevAddy != empty(address):\n        self.addyToId[prevAddy] = 0\n\n    log AddyIdUpdated(newAddr=_newAddy, prevAddy=prevAddy, addyId=_addyId, version=data.version, description=data.description)\n    return True\n\n\n################\n# Disable Addy #\n################\n\n\n@view\n@external\ndef isValidAddyDisable(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Check if a core contract can be disabled\n    @dev Validates ID exists and has a non-empty address\n    @param _addyId The ID of the contract to check\n    @return True if contract can be disabled, False otherwise\n    \"\"\"\n    return self._isValidAddyDisable(_addyId, self.addyInfo[_addyId].addr)\n\n\n@view\n@internal\ndef _isValidAddyDisable(_addyId: uint256, _prevAddy: address) -> bool:\n    if not self._isValidAddyId(_addyId):\n        return False\n    return _prevAddy != empty(address)\n\n\n@external\ndef disableAddy(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Disable a core contract by setting its address to empty\n    @dev Only callable by governor. Updates version and timestamp.\n    @param _addyId The ID of the contract to disable\n    @return True if disable successful, False otherwise\n    \"\"\"\n    assert msg.sender == self.governor # dev: no perms\n\n    data: AddyInfo = self.addyInfo[_addyId]\n    prevAddy: address = data.addr # needed for later\n\n    if not self._isValidAddyDisable(_addyId, prevAddy):\n        return False\n\n    # save new data\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addyInfo[_addyId] = data\n    self.addyToId[prevAddy] = 0\n\n    log AddyIdDisabled(prevAddy=prevAddy, addyId=_addyId, version=data.version, description=data.description)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidAddy(_addy: address) -> bool:\n    \"\"\"\n    @notice Check if an address is a registered core contract\n    @dev Returns true if address has a non-zero ID\n    @param _addy The address to check\n    @return True if address is a registered core contract, False otherwise\n    \"\"\"\n    return self.addyToId[_addy] != 0\n\n\n@view\n@external\ndef isValidAddyId(_addyId: uint256) -> bool:\n    \"\"\"\n    @notice Check if a core contract ID is valid\n    @dev ID must be non-zero and less than total number of contracts\n    @param _addyId The ID to check\n    @return True if ID is valid, False otherwise\n    \"\"\"\n    return self._isValidAddyId(_addyId)\n\n\n@view\n@internal\ndef _isValidAddyId(_addyId: uint256) -> bool:\n    return _addyId != 0 and _addyId < self.numAddys\n\n\n# addy getters\n\n\n@view\n@external\ndef getAddyId(_addy: address) -> uint256:\n    \"\"\"\n    @notice Get the ID of a core contract from its address\n    @dev Returns 0 if address is not registered\n    @param _addy The address to query\n    @return The ID associated with the address\n    \"\"\"\n    return self.addyToId[_addy]\n\n\n@view\n@external\ndef getAddy(_addyId: uint256) -> address:\n    \"\"\"\n    @notice Get the address of a core contract from its ID\n    @dev Returns empty address if ID is invalid or contract is disabled\n    @param _addyId The ID to query\n    @return The address associated with the ID\n    \"\"\"\n    return self.addyInfo[_addyId].addr\n\n\n@view\n@external\ndef getAddyInfo(_addyId: uint256) -> AddyInfo:\n    \"\"\"\n    @notice Get all information about a core contract\n    @dev Returns complete AddyInfo struct including address, version, timestamp and description\n    @param _addyId The ID to query\n    @return AddyInfo struct containing all contract information\n    \"\"\"\n    return self.addyInfo[_addyId]\n\n\n@view\n@external\ndef getAddyDescription(_addyId: uint256) -> String[64]:\n    \"\"\"\n    @notice Get the description of a core contract\n    @dev Returns empty string if ID is invalid\n    @param _addyId The ID to query\n    @return The description associated with the ID\n    \"\"\"\n    return self.addyInfo[_addyId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumAddys() -> uint256:\n    \"\"\"\n    @notice Get the total number of registered core contracts\n    @dev Returns number of contracts minus 1 since indexing starts at 1\n    @return The total number of registered core contracts\n    \"\"\"\n    return self.numAddys - 1\n\n\n@view\n@external\ndef getLastAddy() -> address:\n    \"\"\"\n    @notice Get the address of the most recently registered core contract\n    @dev Returns the address at index (numAddys - 1)\n    @return The address of the last registered contract\n    \"\"\"\n    lastIndex: uint256 = self.numAddys - 1\n    return self.addyInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastAddyId() -> uint256:\n    \"\"\"\n    @notice Get the ID of the most recently registered core contract\n    @dev Returns numAddys - 1 since indexing starts at 1\n    @return The ID of the last registered contract\n    \"\"\"\n    return self.numAddys - 1\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidGovernor(_newGovernor: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be set as the new governor\n    @dev Address must be a contract and different from current governor\n    @param _newGovernor The address to validate\n    @return True if address can be set as governor, False otherwise\n    \"\"\"\n    return self._isValidGovernor(_newGovernor)\n\n\n@view\n@internal \ndef _isValidGovernor(_newGovernor: address) -> bool:\n    if not _newGovernor.is_contract or _newGovernor == empty(address):\n        return False\n    return _newGovernor != self.governor\n\n\n@external\ndef setGovernor(_newGovernor: address) -> bool:\n    \"\"\"\n    @notice Set a new governor address\n    @dev Only callable by current governor\n    @param _newGovernor The address to set as governor\n    @return True if governor was set successfully, False otherwise\n    \"\"\"\n    assert msg.sender == self.governor # dev: no perms\n    if not self._isValidGovernor(_newGovernor):\n        return False\n    self.governor = _newGovernor\n    log AddyRegistryGovernorSet(governor=_newGovernor)\n    return True\n",
            "sha256sum": "3a96b5fd118694a0e1f2c141faa5bb0f6fa6cb1320f5e4401b2ff064a00f1848"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AddyRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "49d726d6ff01eea4ad00f2a10f6a684326bf28cc29dcc3b90cef375bea420226"
      },
      "args": "0000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7"
    },
    "WalletFunds": {
      "address": "0x6A5263B0645c7dFd2788eF46f95f210E947e0743",
      "abi": [
        {
          "name": "UserWalletDeposit",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletWithdrawal",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundVaultTokenAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletSwap",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "swapAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "toAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletBorrow",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "borrowAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "borrowAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletRepayDebt",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "paymentAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "paymentAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "remainingDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletLiquidityAdded",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "liqAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletLiquidityRemoved",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": false
            },
            {
              "name": "removedAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "removedAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "refundedLpAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletFundsTransferred",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletRewardsClaimed",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": false
            },
            {
              "name": "market",
              "type": "address",
              "indexed": false
            },
            {
              "name": "rewardToken",
              "type": "address",
              "indexed": false
            },
            {
              "name": "rewardAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "proof",
              "type": "bytes32",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletEthConvertedToWeth",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "paidEth",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "weth",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletWethConvertedToEth",
          "inputs": [
            {
              "name": "signer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "weth",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isSignerAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletSubscriptionPaid",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "paidThroughBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isAgent",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTransactionFeePaid",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "fee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "action",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTrialFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountRecovered",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "remainingAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletNftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initialize",
          "inputs": [
            {
              "name": "_walletConfig",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_trialFundsAsset",
              "type": "address"
            },
            {
              "name": "_trialFundsInitialAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverTrialFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverTrialFunds",
          "inputs": [
            {
              "name": "_opportunities",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "walletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsAsset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsInitialAmount",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyRegistry",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "wethAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "initialized",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/LegoDex.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# core dex\n\n@external\ndef swapTokens(\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, 5],\n    _poolPath: DynArray[address, 4],\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getLpToken(_pool: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getPoolForLpToken(_lpToken: address) -> address:\n    ...\n\n@view\n@external\ndef getSwapAmountOut(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountIn: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getSwapAmountIn(\n    _pool: address,\n    _tokenIn: address,\n    _tokenOut: address,\n    _amountOut: uint256,\n) -> uint256:\n    ...\n\n\n@view\n@external\ndef getAddLiqAmountsIn(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _availAmountA: uint256,\n    _availAmountB: uint256,\n) -> (uint256, uint256, uint256):\n    ...\n\n@view\n@external\ndef getRemoveLiqAmountsOut(\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _lpAmount: uint256,\n) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getPriceUnsafe(_pool: address, _targetToken: address, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getBestSwapAmountOut(_tokenIn: address, _tokenOut: address, _amountIn: uint256) -> (address, uint256):\n    ...\n\n@view\n@external\ndef getBestSwapAmountIn(_tokenIn: address, _tokenOut: address, _amountOut: uint256) -> (address, uint256):\n    ...\n\n\n@view\n@external\ndef getCoreRouterPool() -> address:\n    ...\n\n\n# @view\n# @external\n# def getDeepestLiqPool(_tokenA: address, _tokenB: address) -> BestPool:\n#     ...",
            "sha256sum": "4f0a294060dd27664988ab6bf95c9670c1c3870d9115b747877a1412c53230c1"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "interfaces/LegoCredit.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n@external\ndef borrow(\n    _borrowAsset: address,\n    _amount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (address, uint256, uint256):\n    ...\n\n@external\ndef repayDebt(\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _recipient: address,\n    _oracleRegistry: address = empty(address),\n) -> (address, uint256, uint256, uint256):\n    ...\n",
            "sha256sum": "d7579ab6500e6022fa9cb561479c40d062438d29e002dcc5f66036eea7dc0856"
          },
          "interfaces/UserWalletInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n# struct SwapInstruction:\n#     legoId: uint256\n#     amountIn: uint256\n#     minAmountOut: uint256\n#     tokenPath: DynArray[address, 5]\n#     poolPath: DynArray[address, 5 - 1]\n\n\n# @external\n# def swapTokens(_swapInstructions: DynArray[SwapInstruction, 5]) -> (uint256, uint256, uint256):\n#     ...\n\n\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    ...\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    ...\n\n\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    ...\n\n\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    ...\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    ...\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    ...\n",
            "sha256sum": "b6f85ddff061e77069cceb9d110c05c679a6ea34b68f3ff69c95c1b07d83c453"
          },
          "contracts/core/WalletFunds.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n# pragma optimize codesize\n\nimplements: UserWalletInterface\nfrom interfaces import LegoDex\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\nfrom interfaces import LegoCredit\nfrom interfaces import UserWalletInterface\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC721\n\ninterface WalletConfig:\n    def handleSubscriptionsAndPermissions(_agent: address, _action: ActionType, _assets: DynArray[address, MAX_ASSETS], _legoIds: DynArray[uint256, MAX_LEGOS], _cd: CoreData) -> (SubPaymentInfo, SubPaymentInfo): nonpayable\n    def getAvailableTxAmount(_asset: address, _wantedAmount: uint256, _shouldCheckTrialFunds: bool, _cd: CoreData = empty(CoreData)) -> uint256: view\n    def canTransferToRecipient(_recipient: address) -> bool: view\n    def owner() -> address: view\n\ninterface LegoRegistry:\n    def getUnderlyingForUser(_user: address, _asset: address) -> uint256: view\n    def getUnderlyingAsset(_vaultToken: address) -> address: view\n    def getLegoAddr(_legoId: uint256) -> address: view\n\ninterface OracleRegistry:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getEthUsdValue(_amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface WethContract:\n    def withdraw(_amount: uint256): nonpayable\n    def deposit(): payable\n\ninterface PriceSheets:\n    def getTransactionFeeData(_user: address, _action: ActionType) -> (uint256, address): view\n\ninterface AgentFactory:\n    def agentBlacklist(_agentAddr: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct CoreData:\n    owner: address\n    wallet: address\n    walletConfig: address\n    addyRegistry: address\n    legoRegistry: address\n    priceSheets: address\n    oracleRegistry: address\n    trialFundsAsset: address\n    trialFundsInitialAmount: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct TrialFundsOpp:\n    legoId: uint256\n    vaultToken: address\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nevent UserWalletDeposit:\n    signer: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    vaultTokenAmountReceived: uint256\n    refundAssetAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletWithdrawal:\n    signer: indexed(address)\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountReceived: uint256\n    vaultTokenAmountBurned: uint256\n    refundVaultTokenAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletSwap:\n    signer: indexed(address)\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    swapAmount: uint256\n    toAmount: uint256\n    refundAssetAmount: uint256\n    usdValue: uint256\n    numTokens: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletBorrow:\n    signer: indexed(address)\n    borrowAsset: indexed(address)\n    borrowAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletRepayDebt:\n    signer: indexed(address)\n    paymentAsset: indexed(address)\n    paymentAmount: uint256\n    usdValue: uint256\n    remainingDebt: uint256\n    legoId: uint256\n    legoAddr: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletLiquidityAdded:\n    signer: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    liqAmountA: uint256\n    liqAmountB: uint256\n    liquidityAdded: uint256\n    pool: address\n    usdValue: uint256\n    refundAssetAmountA: uint256\n    refundAssetAmountB: uint256\n    nftTokenId: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletLiquidityRemoved:\n    signer: indexed(address)\n    tokenA: indexed(address)\n    tokenB: address\n    removedAmountA: uint256\n    removedAmountB: uint256\n    usdValue: uint256\n    isDepleted: bool\n    liquidityRemoved: uint256\n    lpToken: indexed(address)\n    refundedLpAmount: uint256\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletFundsTransferred:\n    signer: indexed(address)\n    recipient: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    usdValue: uint256\n    isSignerAgent: bool\n\nevent UserWalletRewardsClaimed:\n    signer: address\n    market: address\n    rewardToken: address\n    rewardAmount: uint256\n    usdValue: uint256\n    proof: bytes32\n    legoId: uint256\n    legoAddr: address\n    isSignerAgent: bool\n\nevent UserWalletEthConvertedToWeth:\n    signer: indexed(address)\n    amount: uint256\n    paidEth: uint256\n    weth: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletWethConvertedToEth:\n    signer: indexed(address)\n    amount: uint256\n    weth: indexed(address)\n    isSignerAgent: bool\n\nevent UserWalletSubscriptionPaid:\n    recipient: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    isAgent: bool\n\nevent UserWalletTransactionFeePaid:\n    recipient: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    fee: uint256\n    action: ActionType\n\nevent UserWalletTrialFundsRecovered:\n    asset: indexed(address)\n    amountRecovered: uint256\n    remainingAmount: uint256\n\nevent UserWalletNftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    owner: indexed(address)\n\n# core\nwalletConfig: public(address)\n\n# trial funds info\ntrialFundsAsset: public(address)\ntrialFundsInitialAmount: public(uint256)\n\n# config\naddyRegistry: public(address)\nwethAddr: public(address)\ninitialized: public(bool)\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\nLEGO_REGISTRY_ID: constant(uint256) = 2\nPRICE_SHEETS_ID: constant(uint256) = 3\nORACLE_REGISTRY_ID: constant(uint256) = 4\n\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_ASSETS: constant(uint256) = 25\nMAX_LEGOS: constant(uint256) = 20\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UnderscoreErc721\"\nAPI_VERSION: constant(String[28]) = \"0.0.1\"\n\n\n@deploy\ndef __init__():\n    # make sure original reference contract can't be initialized\n    self.initialized = True\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n@external\ndef initialize(\n    _walletConfig: address,\n    _addyRegistry: address,\n    _wethAddr: address,\n    _trialFundsAsset: address,\n    _trialFundsInitialAmount: uint256,\n) -> bool:\n    \"\"\"\n    @notice Sets up the initial state of the wallet template\n    @dev Can only be called once and sets core contract parameters\n    @param _walletConfig The address of the wallet config contract\n    @param _addyRegistry The address of the core registry contract\n    @param _wethAddr The address of the WETH contract\n    @param _trialFundsAsset The address of the gift asset\n    @param _trialFundsInitialAmount The amount of the gift asset\n    @return bool True if initialization was successful\n    \"\"\"\n    assert not self.initialized # dev: can only initialize once\n    self.initialized = True\n\n    assert empty(address) not in [_walletConfig, _addyRegistry, _wethAddr] # dev: invalid addrs\n    self.walletConfig = _walletConfig\n    self.addyRegistry = _addyRegistry\n    self.wethAddr = _wethAddr\n\n    # trial funds info\n    if _trialFundsAsset != empty(address) and _trialFundsInitialAmount != 0:   \n        self.trialFundsAsset = _trialFundsAsset\n        self.trialFundsInitialAmount = _trialFundsInitialAmount\n\n    return True\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    \"\"\"\n    @notice Returns the current API version of the contract\n    @dev Returns a constant string representing the contract version\n    @return String[28] The API version string\n    \"\"\"\n    return API_VERSION\n\n\n###########\n# Deposit #\n###########\n\n\n@nonreentrant\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    \"\"\"\n    @notice Deposits tokens into a specified lego integration and vault\n    @param _legoId The ID of the lego to use for deposit\n    @param _asset The address of the token to deposit\n    @param _vault The target vault address\n    @param _amount The amount to deposit (defaults to max)\n    @return uint256 The amount of assets deposited\n    @return address The vault token address\n    @return uint256 The amount of vault tokens received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.DEPOSIT, [_asset], [_legoId], cd)\n    return self._depositTokens(msg.sender, _legoId, _asset, _vault, _amount, isSignerAgent, True, cd)\n\n\n@internal\ndef _depositTokens(\n    _signer: address,\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256,\n    _isSignerAgent: bool,\n    _shouldChargeFees: bool,\n    _cd: CoreData,\n) -> (uint256, address, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # finalize amount\n    amount: uint256 = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_asset, _amount, False, _cd)\n    assert extcall IERC20(_asset).approve(legoAddr, amount, default_return_value=True) # dev: approval failed\n\n    # deposit into lego partner\n    assetAmountDeposited: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    refundAssetAmount: uint256 = 0\n    usdValue: uint256 = 0\n    assetAmountDeposited, vaultToken, vaultTokenAmountReceived, refundAssetAmount, usdValue = extcall LegoYield(legoAddr).depositTokens(_asset, amount, _vault, self)\n    assert extcall IERC20(_asset).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # handle tx fees\n    if _shouldChargeFees:\n        self._handleTransactionFees(_signer, _isSignerAgent, ActionType.DEPOSIT, vaultToken, vaultTokenAmountReceived, _cd.priceSheets)\n\n    log UserWalletDeposit(signer=_signer, asset=_asset, vaultToken=vaultToken, assetAmountDeposited=assetAmountDeposited, vaultTokenAmountReceived=vaultTokenAmountReceived, refundAssetAmount=refundAssetAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return assetAmountDeposited, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@nonreentrant\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    \"\"\"\n    @notice Withdraws tokens from a specified lego integration and vault\n    @param _legoId The ID of the lego to use for withdrawal\n    @param _asset The address of the token to withdraw\n    @param _vaultToken The vault token address\n    @param _vaultTokenAmount The amount of vault tokens to withdraw (defaults to max)\n    @return uint256 The amount of assets received\n    @return uint256 The amount of vault tokens burned\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.WITHDRAWAL, [_asset], [_legoId], cd)\n    return self._withdrawTokens(msg.sender, _legoId, _asset, _vaultToken, _vaultTokenAmount, isSignerAgent, True, cd)\n\n\n@internal\ndef _withdrawTokens(\n    _signer: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256,\n    _isSignerAgent: bool,\n    _shouldChargeFees: bool,\n    _cd: CoreData,\n) -> (uint256, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # finalize amount, this will look at vault token balance (not always 1:1 with underlying asset)\n    withdrawAmount: uint256 = _vaultTokenAmount\n    if _vaultToken != empty(address):\n        withdrawAmount = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_vaultToken, _vaultTokenAmount, False, _cd)\n\n        # some vault tokens require max value approval (comp v3)\n        assert extcall IERC20(_vaultToken).approve(legoAddr, max_value(uint256), default_return_value=True) # dev: approval failed\n\n    assert withdrawAmount != 0 # dev: nothing to withdraw\n\n    # withdraw from lego partner\n    assetAmountReceived: uint256 = 0\n    vaultTokenAmountBurned: uint256 = 0\n    refundVaultTokenAmount: uint256 = 0\n    usdValue: uint256 = 0\n    assetAmountReceived, vaultTokenAmountBurned, refundVaultTokenAmount, usdValue = extcall LegoYield(legoAddr).withdrawTokens(_asset, withdrawAmount, _vaultToken, self)\n\n    # zero out approvals\n    if _vaultToken != empty(address):\n        assert extcall IERC20(_vaultToken).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # handle tx fees\n    if _shouldChargeFees:\n        self._handleTransactionFees(_signer, _isSignerAgent, ActionType.WITHDRAWAL, _asset, assetAmountReceived, _cd.priceSheets)\n\n    log UserWalletWithdrawal(signer=_signer, asset=_asset, vaultToken=_vaultToken, assetAmountReceived=assetAmountReceived, vaultTokenAmountBurned=vaultTokenAmountBurned, refundVaultTokenAmount=refundVaultTokenAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return assetAmountReceived, vaultTokenAmountBurned, usdValue\n\n\n#############\n# Rebalance #\n#############\n\n\n@nonreentrant\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    \"\"\"\n    @notice Withdraws tokens from one lego and deposits them into another (always same asset)\n    @param _fromLegoId The ID of the source lego\n    @param _fromAsset The address of the token to rebalance\n    @param _fromVaultToken The source vault token address\n    @param _toLegoId The ID of the destination lego\n    @param _toVault The destination vault address\n    @param _fromVaultTokenAmount The vault token amount to rebalance (defaults to max)\n    @return uint256 The amount of assets deposited in the destination vault\n    @return address The destination vault token address\n    @return uint256 The amount of destination vault tokens received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REBALANCE, [_fromAsset], [_fromLegoId, _toLegoId], cd)\n\n    # withdraw from the first lego\n    assetAmountReceived: uint256 = 0\n    na: uint256 = 0\n    withdrawUsdValue: uint256 = 0\n    assetAmountReceived, na, withdrawUsdValue = self._withdrawTokens(msg.sender, _fromLegoId, _fromAsset, _fromVaultToken, _fromVaultTokenAmount, isSignerAgent, False, cd)\n\n    # deposit the received assets into the second lego\n    assetAmountDeposited: uint256 = 0\n    newVaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    depositUsdValue: uint256 = 0\n    assetAmountDeposited, newVaultToken, vaultTokenAmountReceived, depositUsdValue = self._depositTokens(msg.sender, _toLegoId, _fromAsset, _toVault, assetAmountReceived, isSignerAgent, False, cd)\n\n    # handle tx fees\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.REBALANCE, newVaultToken, vaultTokenAmountReceived, cd.priceSheets)\n\n    usdValue: uint256 = max(withdrawUsdValue, depositUsdValue)\n    return assetAmountDeposited, newVaultToken, vaultTokenAmountReceived, usdValue\n\n\n########\n# Swap #\n########\n\n\n@nonreentrant\n@external\ndef swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256):\n    \"\"\"\n    @notice Swaps tokens between lego integrations\n    @param _swapInstructions The instructions for the swaps\n    @return uint256 The amount of assets deposited\n    @return uint256 The amount of assets received\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    numSwapInstructions: uint256 = len(_swapInstructions)\n    assert numSwapInstructions != 0 # dev: no swaps\n\n    cd: CoreData = self._getCoreData()\n\n    # get high level swap info to check permissions\n    tokenIn: address = empty(address)\n    tokenOut: address = empty(address)\n    initialAmountIn: uint256 = 0\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    tokenIn, tokenOut, initialAmountIn, legoIds = self._getHighLevelSwapInfo(numSwapInstructions, _swapInstructions, cd)\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.SWAP, [tokenIn, tokenOut], legoIds, cd)\n\n    # check if swap token is trial funds asset\n    isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(tokenIn, cd.trialFundsAsset, cd.legoRegistry)\n\n    # perform swap instructions\n    amountIn: uint256 = initialAmountIn\n    lastTokenOut: address = empty(address)\n    lastTokenOutAmount: uint256 = 0\n    lastUsdValue: uint256 = 0\n    for j: uint256 in range(numSwapInstructions, bound=MAX_SWAP_INSTRUCTIONS):\n        i: SwapInstruction = _swapInstructions[j]\n\n        # from lego to lego, must follow the same token path\n        if lastTokenOut != empty(address):\n            newTokenIn: address = i.tokenPath[0]\n            assert lastTokenOut == newTokenIn # dev: invalid token path\n            amountIn = min(lastTokenOutAmount, staticcall IERC20(newTokenIn).balanceOf(self))\n\n        lastTokenOut, lastTokenOutAmount, lastUsdValue = self._performSwapInstruction(i.legoId, amountIn, i.minAmountOut, i.tokenPath, i.poolPath, msg.sender, isSignerAgent, cd.legoRegistry, cd.oracleRegistry)\n\n    # make sure they still have enough trial funds\n    self._checkTrialFundsPostTx(isTrialFundsVaultToken, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n\n    # handle tx fees\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.SWAP, lastTokenOut, lastTokenOutAmount, cd.priceSheets)\n    return initialAmountIn, lastTokenOutAmount, lastUsdValue\n\n\n@internal\ndef _performSwapInstruction(\n    _legoId: uint256,\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _signer: address,\n    _isSignerAgent: bool,\n    _legoRegistry: address,\n    _oracleRegistry: address,\n) -> (address, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # get token in and token out\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[len(_tokenPath) - 1]\n\n    # approve token in\n    assert extcall IERC20(tokenIn).approve(legoAddr, _amountIn, default_return_value=True) # dev: approval failed\n\n    # swap assets via lego partner\n    tokenInAmount: uint256 = 0\n    tokenOutAmount: uint256 = 0\n    refundTokenInAmount: uint256 = 0\n    usdValue: uint256 = 0\n    tokenInAmount, tokenOutAmount, refundTokenInAmount, usdValue = extcall LegoDex(legoAddr).swapTokens(_amountIn, _minAmountOut, _tokenPath, _poolPath, self, _oracleRegistry)\n\n    # reset approvals\n    assert extcall IERC20(tokenIn).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log UserWalletSwap(signer=_signer, tokenIn=tokenIn, tokenOut=tokenOut, swapAmount=tokenInAmount, toAmount=tokenOutAmount, refundAssetAmount=refundTokenInAmount, usdValue=usdValue, numTokens=len(_tokenPath), legoId=_legoId, legoAddr=legoAddr, isSignerAgent=_isSignerAgent)\n    return tokenOut, tokenOutAmount, usdValue\n\n\n@view\n@internal\ndef _getHighLevelSwapInfo(\n    _numSwapInstructions: uint256,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _cd: CoreData,\n) -> (address, address, uint256, DynArray[uint256, MAX_LEGOS]):   \n    firstRoutePath: DynArray[address, MAX_TOKEN_PATH] = _swapInstructions[0].tokenPath\n    firstRouteNumTokens: uint256 = len(firstRoutePath)\n    assert firstRouteNumTokens >= 2 # dev: invalid token path\n\n    # finalize token in and token out\n    tokenIn: address = firstRoutePath[0]\n    tokenOut: address = empty(address)\n    if _numSwapInstructions == 1:\n        tokenOut = firstRoutePath[firstRouteNumTokens - 1]\n\n    else:\n        lastRoutePath: DynArray[address, MAX_TOKEN_PATH] = _swapInstructions[_numSwapInstructions - 1].tokenPath\n        lastRouteNumTokens: uint256 = len(lastRoutePath)\n        assert lastRouteNumTokens >= 2 # dev: invalid token path\n        tokenOut = lastRoutePath[lastRouteNumTokens - 1]\n\n    assert empty(address) not in [tokenIn, tokenOut] # dev: invalid token path\n\n    # get lego ids\n    legoIds: DynArray[uint256, MAX_LEGOS] = []\n    for i: uint256 in range(_numSwapInstructions, bound=MAX_SWAP_INSTRUCTIONS):\n        legoId: uint256 = _swapInstructions[i].legoId\n        if legoId not in legoIds:\n            legoIds.append(legoId)\n\n    # finalize amount in\n    amountIn: uint256 = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(tokenIn, _swapInstructions[0].amountIn, True, _cd)\n\n    return tokenIn, tokenOut, amountIn, legoIds\n\n\n##################\n# Borrow + Repay #\n##################\n\n\n# borrow\n\n\n@nonreentrant\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    \"\"\"\n    @notice Borrows an asset from a lego integration\n    @param _legoId The ID of the lego to borrow from\n    @param _borrowAsset The address of the asset to borrow\n    @param _amount The amount of the asset to borrow\n    @return address The address of the asset borrowed\n    @return uint256 The amount of the asset borrowed\n    @return uint256 The usd value of the borrowing\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.BORROW, [_borrowAsset], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego can perform this action\n    self._checkLegoAccessForAction(legoAddr)\n\n    # borrow via lego partner\n    borrowAsset: address = empty(address)\n    borrowAmount: uint256 = 0\n    usdValue: uint256 = 0\n    borrowAsset, borrowAmount, usdValue = extcall LegoCredit(legoAddr).borrow(_borrowAsset, _amount, self, cd.oracleRegistry)\n\n    # handle tx fees\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.BORROW, borrowAsset, borrowAmount, cd.priceSheets)\n\n    log UserWalletBorrow(signer=msg.sender, borrowAsset=borrowAsset, borrowAmount=borrowAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return borrowAsset, borrowAmount, usdValue\n\n\n# repay debt\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    \"\"\"\n    @notice Repays debt for a lego integration\n    @param _legoId The ID of the lego to repay debt for\n    @param _paymentAsset The address of the asset to use for repayment\n    @param _paymentAmount The amount of the asset to use for repayment\n    @return address The address of the asset used for repayment\n    @return uint256 The amount of the asset used for repayment\n    @return uint256 The usd value of the repayment\n    @return uint256 The remaining debt\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REPAY, [_paymentAsset], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego can perform this action\n    self._checkLegoAccessForAction(legoAddr)\n\n    # finalize amount\n    paymentAmount: uint256 = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_paymentAsset, _paymentAmount, True, cd)\n\n    # handle tx fees (before actual repayment)\n    txFee: uint256 = self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.REPAY, _paymentAsset, paymentAmount, cd.priceSheets)\n    paymentAmount -= txFee\n\n    # check if payment asset is trial funds asset\n    isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(_paymentAsset, cd.trialFundsAsset, cd.legoRegistry)\n\n    # repay debt via lego partner\n    paymentAsset: address = empty(address)\n    usdValue: uint256 = 0\n    remainingDebt: uint256 = 0\n    assert extcall IERC20(_paymentAsset).approve(legoAddr, paymentAmount, default_return_value=True) # dev: approval failed\n    paymentAsset, paymentAmount, usdValue, remainingDebt = extcall LegoCredit(legoAddr).repayDebt(_paymentAsset, paymentAmount, self, cd.oracleRegistry)\n    assert extcall IERC20(_paymentAsset).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # make sure they still have enough trial funds\n    self._checkTrialFundsPostTx(isTrialFundsVaultToken, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n\n    log UserWalletRepayDebt(signer=msg.sender, paymentAsset=paymentAsset, paymentAmount=paymentAmount, usdValue=usdValue, remainingDebt=remainingDebt, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return paymentAsset, paymentAmount, usdValue, remainingDebt\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    \"\"\"\n    @notice Claims rewards from a lego integration\n    @param _legoId The lego ID to claim rewards from\n    @param _market The market to claim rewards from\n    @param _rewardToken The reward token to claim\n    @param _rewardAmount The reward amount to claim\n    @param _proof The proof to verify the rewards\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # pass in empty action, lego ids, and assets here\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CLAIM_REWARDS, [_rewardToken], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # make sure lego has access to claim rewards\n    self._checkLegoAccessForAction(legoAddr)\n\n    # pre reward balance\n    preRewardBalance: uint256 = 0\n    if _rewardToken != empty(address):\n        preRewardBalance = staticcall IERC20(_rewardToken).balanceOf(self)\n\n    # claim rewards\n    extcall LegoCommon(legoAddr).claimRewards(self, _market, _rewardToken, _rewardAmount, _proof)\n\n    # post reward balance\n    postRewardBalance: uint256 = 0\n    if _rewardToken != empty(address):\n        postRewardBalance = staticcall IERC20(_rewardToken).balanceOf(self)\n    rewardAmount: uint256 = postRewardBalance - preRewardBalance\n\n    usdValue: uint256 = 0\n    if rewardAmount != 0:\n        usdValue = staticcall OracleRegistry(cd.oracleRegistry).getUsdValue(_rewardToken, rewardAmount)\n\n    # handle tx fees\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.CLAIM_REWARDS, _rewardToken, rewardAmount, cd.priceSheets)\n\n    log UserWalletRewardsClaimed(signer=msg.sender, market=_market, rewardToken=_rewardToken, rewardAmount=rewardAmount, usdValue=usdValue, proof=_proof, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    \"\"\"\n    @notice Adds liquidity to a pool\n    @param _legoId The ID of the lego to use for adding liquidity\n    @param _nftAddr The address of the NFT token contract\n    @param _nftTokenId The ID of the NFT token to use for adding liquidity\n    @param _pool The address of the pool to add liquidity to\n    @param _tokenA The address of the first token to add liquidity\n    @param _tokenB The address of the second token to add liquidity\n    @param _amountA The amount of the first token to add liquidity\n    @param _amountB The amount of the second token to add liquidity\n    @param _tickLower The lower tick of the liquidity range\n    @param _tickUpper The upper tick of the liquidity range\n    @param _minAmountA The minimum amount of the first token to add liquidity\n    @param _minAmountB The minimum amount of the second token to add liquidity\n    @param _minLpAmount The minimum amount of lp token amount to receive\n    @return uint256 The amount of liquidity added\n    @return uint256 The amount of the first token added\n    @return uint256 The amount of the second token added\n    @return uint256 The usd value of the liquidity added\n    @return uint256 The ID of the NFT token used for adding liquidity\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.ADD_LIQ, [_tokenA, _tokenB], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # token a\n    amountA: uint256 = 0\n    isTrialFundsVaultTokenA: bool = False\n    if _amountA != 0:\n        amountA = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_tokenA, _amountA, True, cd)\n\n        # handle tx fee (pre add liquidity)\n        amountAFee: uint256 = self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.ADD_LIQ, _tokenA, amountA, cd.priceSheets)\n        amountA -= amountAFee\n\n        assert extcall IERC20(_tokenA).approve(legoAddr, amountA, default_return_value=True) # dev: approval failed\n        isTrialFundsVaultTokenA = self._isTrialFundsVaultToken(_tokenA, cd.trialFundsAsset, cd.legoRegistry)\n\n    # token b\n    amountB: uint256 = 0\n    isTrialFundsVaultTokenB: bool = False\n    if _amountB != 0:\n        amountB = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(_tokenB, _amountB, True, cd)\n\n        # handle tx fee (pre add liquidity)\n        amountBFee: uint256 = self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.ADD_LIQ, _tokenB, amountB, cd.priceSheets)\n        amountB -= amountBFee\n\n        assert extcall IERC20(_tokenB).approve(legoAddr, amountB, default_return_value=True) # dev: approval failed\n        isTrialFundsVaultTokenB = self._isTrialFundsVaultToken(_tokenB, cd.trialFundsAsset, cd.legoRegistry)\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # add liquidity via lego partner\n    liquidityAdded: uint256 = 0\n    liqAmountA: uint256 = 0\n    liqAmountB: uint256 = 0\n    usdValue: uint256 = 0\n    refundAssetAmountA: uint256 = 0\n    refundAssetAmountB: uint256 = 0\n    nftTokenId: uint256 = 0\n    liquidityAdded, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, nftTokenId = extcall LegoDex(legoAddr).addLiquidity(_nftTokenId, _pool, _tokenA, _tokenB, _tickLower, _tickUpper, amountA, amountB, _minAmountA, _minAmountB, _minLpAmount, self, cd.oracleRegistry)\n\n    # validate the nft came back\n    if hasNftLiqPosition:\n        assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n\n    # token a\n    self._checkTrialFundsPostTx(isTrialFundsVaultTokenA, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n    if amountA != 0:\n        assert extcall IERC20(_tokenA).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # token b\n    self._checkTrialFundsPostTx(isTrialFundsVaultTokenB, cd.trialFundsAsset, cd.trialFundsInitialAmount, cd.legoRegistry)\n    if amountB != 0:\n        assert extcall IERC20(_tokenB).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log UserWalletLiquidityAdded(signer=msg.sender, tokenA=_tokenA, tokenB=_tokenB, liqAmountA=liqAmountA, liqAmountB=liqAmountB, liquidityAdded=liquidityAdded, pool=_pool, usdValue=usdValue, refundAssetAmountA=refundAssetAmountA, refundAssetAmountB=refundAssetAmountB, nftTokenId=nftTokenId, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return liquidityAdded, liqAmountA, liqAmountB, usdValue, nftTokenId\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    \"\"\"\n    @notice Removes liquidity from a pool\n    @param _legoId The ID of the lego to use for removing liquidity\n    @param _nftAddr The address of the NFT token contract\n    @param _nftTokenId The ID of the NFT token to use for removing liquidity\n    @param _pool The address of the pool to remove liquidity from\n    @param _tokenA The address of the first token to remove liquidity\n    @param _tokenB The address of the second token to remove liquidity\n    @param _liqToRemove The amount of liquidity to remove\n    @param _minAmountA The minimum amount of the first token to remove liquidity\n    @param _minAmountB The minimum amount of the second token to remove liquidity\n    @return uint256 The amount of the first token removed\n    @return uint256 The amount of the second token removed\n    @return uint256 The usd value of the liquidity removed\n    @return bool True if the liquidity moved to lego contract was depleted, false otherwise\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.REMOVE_LIQ, [_tokenA, _tokenB], [_legoId], cd)\n\n    # get lego addr\n    legoAddr: address = staticcall LegoRegistry(cd.legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    lpToken: address = empty(address)\n    liqToRemove: uint256 = _liqToRemove\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # handle lp token\n    else:\n        lpToken = staticcall LegoDex(legoAddr).getLpToken(_pool)\n        liqToRemove = staticcall WalletConfig(cd.walletConfig).getAvailableTxAmount(lpToken, liqToRemove, False, cd)\n        assert extcall IERC20(lpToken).approve(legoAddr, liqToRemove, default_return_value=True) # dev: approval failed\n\n    # remove liquidity via lego partner\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    usdValue: uint256 = 0\n    liquidityRemoved: uint256 = 0\n    refundedLpAmount: uint256 = 0\n    isDepleted: bool = False\n    amountA, amountB, usdValue, liquidityRemoved, refundedLpAmount, isDepleted = extcall LegoDex(legoAddr).removeLiquidity(_nftTokenId, _pool, _tokenA, _tokenB, lpToken, liqToRemove, _minAmountA, _minAmountB, self, cd.oracleRegistry)\n\n    # validate the nft came back, reset lp token approvals\n    if hasNftLiqPosition:\n        if not isDepleted:\n            assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n    else:\n        assert extcall IERC20(lpToken).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # handle tx fees\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.REMOVE_LIQ, _tokenA, amountA, cd.priceSheets)\n    self._handleTransactionFees(msg.sender, isSignerAgent, ActionType.REMOVE_LIQ, _tokenB, amountB, cd.priceSheets)\n\n    log UserWalletLiquidityRemoved(signer=msg.sender, tokenA=_tokenA, tokenB=_tokenB, removedAmountA=amountA, removedAmountB=amountB, usdValue=usdValue, isDepleted=isDepleted, liquidityRemoved=liquidityRemoved, lpToken=lpToken, refundedLpAmount=refundedLpAmount, legoId=_legoId, legoAddr=legoAddr, isSignerAgent=isSignerAgent)\n    return amountA, amountB, usdValue, isDepleted\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    \"\"\"\n    @notice Transfers funds to a specified recipient\n    @dev Handles both ETH and token transfers with optional amount specification\n    @param _recipient The address to receive the funds\n    @param _amount The amount to transfer (defaults to max)\n    @param _asset The token address (empty for ETH)\n    @return uint256 The amount of funds transferred\n    @return uint256 The usd value of the transaction\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.TRANSFER, [_asset], [], cd)\n    return self._transferFunds(msg.sender, _recipient, _amount, _asset, isSignerAgent, cd)\n\n\n@internal\ndef _transferFunds(\n    _signer: address,\n    _recipient: address,\n    _amount: uint256,\n    _asset: address,\n    _isSignerAgent: bool,\n    _cd: CoreData,\n) -> (uint256, uint256):\n    transferAmount: uint256 = 0\n    usdValue: uint256 = 0\n\n    # validate recipient\n    if _recipient != _cd.owner:\n        assert staticcall WalletConfig(_cd.walletConfig).canTransferToRecipient(_recipient) # dev: recipient not allowed\n\n    # handle eth\n    if _asset == empty(address):\n        transferAmount = min(_amount, self.balance)\n        assert transferAmount != 0 # dev: nothing to transfer\n        send(_recipient, transferAmount)\n        usdValue = staticcall OracleRegistry(_cd.oracleRegistry).getEthUsdValue(transferAmount)\n\n    # erc20 tokens\n    else:\n\n        # check if vault token of trial funds asset\n        isTrialFundsVaultToken: bool = self._isTrialFundsVaultToken(_asset, _cd.trialFundsAsset, _cd.legoRegistry)\n        transferAmount = staticcall WalletConfig(_cd.walletConfig).getAvailableTxAmount(_asset, _amount, True, _cd)\n\n        # handle tx fees (pre transfer)\n        txFee: uint256 = self._handleTransactionFees(_signer, _isSignerAgent, ActionType.TRANSFER, _asset, transferAmount, _cd.priceSheets)\n        transferAmount -= txFee\n\n        assert extcall IERC20(_asset).transfer(_recipient, transferAmount, default_return_value=True) # dev: transfer failed\n        usdValue = staticcall OracleRegistry(_cd.oracleRegistry).getUsdValue(_asset, transferAmount)\n\n        # make sure they still have enough trial funds\n        self._checkTrialFundsPostTx(isTrialFundsVaultToken, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, _cd.legoRegistry)\n\n    log UserWalletFundsTransferred(signer=_signer, recipient=_recipient, asset=_asset, amount=transferAmount, usdValue=usdValue, isSignerAgent=_isSignerAgent)\n    return transferAmount, usdValue\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@nonreentrant\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    \"\"\"\n    @notice Converts ETH to WETH and optionally deposits into a lego integration and vault\n    @param _amount The amount of ETH to convert (defaults to max)\n    @param _depositLegoId The lego ID to use for deposit (optional)\n    @param _depositVault The vault address for deposit (optional)\n    @return uint256 The amount of assets deposited (if deposit performed)\n    @return address The vault token address (if deposit performed)\n    @return uint256 The amount of vault tokens received (if deposit performed)\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    weth: address = self.wethAddr\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CONVERSION, [weth], [_depositLegoId], cd)\n\n    # convert eth to weth\n    amount: uint256 = min(_amount, self.balance)\n    assert amount != 0 # dev: nothing to convert\n    extcall WethContract(weth).deposit(value=amount)\n    log UserWalletEthConvertedToWeth(signer=msg.sender, amount=amount, paidEth=msg.value, weth=weth, isSignerAgent=isSignerAgent)\n\n    # deposit weth into lego partner\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    if _depositLegoId != 0:\n        depositUsdValue: uint256 = 0\n        amount, vaultToken, vaultTokenAmountReceived, depositUsdValue = self._depositTokens(msg.sender, _depositLegoId, weth, _depositVault, amount, isSignerAgent, True, cd)\n\n    return amount, vaultToken, vaultTokenAmountReceived\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    \"\"\"\n    @notice Converts WETH to ETH and optionally withdraws from a vault first\n    @param _amount The amount of WETH to convert (defaults to max)\n    @param _recipient The address to receive the ETH (optional)\n    @param _withdrawLegoId The lego ID to withdraw from (optional)\n    @param _withdrawVaultToken The vault token to withdraw (optional)\n    @return uint256 The amount of ETH received\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    weth: address = self.wethAddr\n\n    # check permissions / subscription data\n    isSignerAgent: bool = self._checkPermsAndHandleSubs(msg.sender, ActionType.CONVERSION, [weth], [_withdrawLegoId], cd)\n\n    # withdraw weth from lego partner (if applicable)\n    amount: uint256 = _amount\n    usdValue: uint256 = 0\n    if _withdrawLegoId != 0:\n        _na: uint256 = 0\n        amount, _na, usdValue = self._withdrawTokens(msg.sender, _withdrawLegoId, weth, _withdrawVaultToken, _amount, isSignerAgent, True, cd)\n\n    # convert weth to eth\n    amount = min(amount, staticcall IERC20(weth).balanceOf(self))\n    assert amount != 0 # dev: nothing to convert\n    extcall WethContract(weth).withdraw(amount)\n    log UserWalletWethConvertedToEth(signer=msg.sender, amount=amount, weth=weth, isSignerAgent=isSignerAgent)\n\n    # transfer eth to recipient (if applicable)\n    if _recipient != empty(address):\n        amount, usdValue = self._transferFunds(msg.sender, _recipient, amount, empty(address), isSignerAgent, cd)\n\n    return amount\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@internal\ndef _getCoreData() -> CoreData:\n    addyRegistry: address = self.addyRegistry\n    walletConfig: address = self.walletConfig\n    return CoreData(\n        owner=staticcall WalletConfig(walletConfig).owner(),\n        wallet=self,\n        walletConfig=walletConfig,\n        addyRegistry=addyRegistry,\n        legoRegistry=staticcall AddyRegistry(addyRegistry).getAddy(LEGO_REGISTRY_ID),\n        priceSheets=staticcall AddyRegistry(addyRegistry).getAddy(PRICE_SHEETS_ID),\n        oracleRegistry=staticcall AddyRegistry(addyRegistry).getAddy(ORACLE_REGISTRY_ID),\n        trialFundsAsset=self.trialFundsAsset,\n        trialFundsInitialAmount=self.trialFundsInitialAmount,\n    )\n\n\n# payments (subscriptions, transaction fees)\n\n\n@internal\ndef _checkPermsAndHandleSubs(\n    _signer: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n    _cd: CoreData,\n) -> bool:\n    agent: address = _signer\n    if _signer == _cd.owner:\n        agent = empty(address)\n\n    # check if agent is blacklisted\n    if agent != empty(address):\n        agentFactory: address = staticcall AddyRegistry(_cd.addyRegistry).getAddy(AGENT_FACTORY_ID)\n        assert not staticcall AgentFactory(agentFactory).agentBlacklist(agent) # dev: agent is blacklisted\n\n    # handle subscriptions and permissions\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = extcall WalletConfig(_cd.walletConfig).handleSubscriptionsAndPermissions(agent, _action, _assets, _legoIds, _cd)\n\n    # handle protocol subscription payment\n    if protocolSub.amount != 0:\n        assert extcall IERC20(protocolSub.asset).transfer(protocolSub.recipient, protocolSub.amount, default_return_value=True) # dev: protocol subscription payment failed\n        log UserWalletSubscriptionPaid(recipient=protocolSub.recipient, asset=protocolSub.asset, amount=protocolSub.amount, usdValue=protocolSub.usdValue, paidThroughBlock=protocolSub.paidThroughBlock, isAgent=False)\n\n    # handle agent subscription payment\n    if agentSub.amount != 0:\n        assert extcall IERC20(agentSub.asset).transfer(agentSub.recipient, agentSub.amount, default_return_value=True) # dev: agent subscription payment failed\n        log UserWalletSubscriptionPaid(recipient=agent, asset=agentSub.asset, amount=agentSub.amount, usdValue=agentSub.usdValue, paidThroughBlock=agentSub.paidThroughBlock, isAgent=True)\n\n    return agent != empty(address)\n\n\n@internal\ndef _handleTransactionFees(\n    _agent: address,\n    _isSignerAgent: bool,\n    _action: ActionType,\n    _asset: address,\n    _amount: uint256,\n    _priceSheets: address,\n) -> uint256:\n    if not _isSignerAgent or _amount == 0 or _asset == empty(address):\n        return 0\n\n    fee: uint256 = 0\n    recipient: address = empty(address)\n    fee, recipient = staticcall PriceSheets(_priceSheets).getTransactionFeeData(self, _action)\n    if fee == 0 or recipient == empty(address):\n        return 0\n\n    amount: uint256 = min(_amount * fee // HUNDRED_PERCENT, staticcall IERC20(_asset).balanceOf(self))\n    if amount != 0:\n        assert extcall IERC20(_asset).transfer(recipient, amount, default_return_value=True) # dev: protocol tx fee payment failed\n        log UserWalletTransactionFeePaid(recipient=recipient, asset=_asset, amount=amount, fee=fee, action=_action)\n\n    return amount\n\n\n# allow lego to perform action\n\n\n@internal\ndef _checkLegoAccessForAction(_legoAddr: address):\n    targetAddr: address = empty(address)\n    accessAbi: String[64] = empty(String[64])\n    numInputs: uint256 = 0\n    targetAddr, accessAbi, numInputs = staticcall LegoCommon(_legoAddr).getAccessForLego(self)\n\n    # nothing to do here\n    if targetAddr == empty(address):\n        return\n\n    method_abi: bytes4 = convert(slice(keccak256(accessAbi), 0, 4), bytes4)\n    success: bool = False\n    response: Bytes[32] = b\"\"\n\n    # assumes input is: lego addr (operator)\n    if numInputs == 1:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    # assumes input (and order) is: user addr (owner), lego addr (operator)\n    elif numInputs == 2:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    # assumes input (and order) is: user addr (owner), lego addr (operator), allowed bool\n    elif numInputs == 3:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n                convert(True, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    assert success # dev: failed to set operator\n\n\n# trial funds\n\n\n@view\n@internal\ndef _isTrialFundsVaultToken(_asset: address, _trialFundsAsset: address, _legoRegistry: address) -> bool:\n    if _trialFundsAsset == empty(address) or _asset == _trialFundsAsset:\n        return False\n    return _trialFundsAsset == staticcall LegoRegistry(_legoRegistry).getUnderlyingAsset(_asset)\n\n\n@view\n@internal\ndef _checkTrialFundsPostTx(_isTrialFundsVaultToken: bool, _trialFundsAsset: address, _trialFundsInitialAmount: uint256, _legoRegistry: address):\n    if not _isTrialFundsVaultToken:\n        return\n    postUnderlying: uint256 = staticcall LegoRegistry(_legoRegistry).getUnderlyingForUser(self, _trialFundsAsset)\n    assert postUnderlying >= _trialFundsInitialAmount # dev: cannot transfer trial funds vault token\n\n\n@external\ndef recoverTrialFunds(_opportunities: DynArray[TrialFundsOpp, MAX_LEGOS] = []) -> bool:\n    \"\"\"\n    @notice Recovers trial funds from the wallet\n    @param _opportunities Array of trial funds opportunities\n    @return bool True if trial funds were recovered successfully\n    \"\"\"\n    cd: CoreData = self._getCoreData()\n    agentFactory: address = staticcall AddyRegistry(cd.addyRegistry).getAddy(AGENT_FACTORY_ID)\n    assert msg.sender == agentFactory # dev: no perms\n\n    # validation\n    assert cd.trialFundsAsset != empty(address) # dev: no trial funds asset\n    assert cd.trialFundsInitialAmount != 0 # dev: no trial funds amount\n\n    # iterate through clawback data\n    balanceAvail: uint256 = staticcall IERC20(cd.trialFundsAsset).balanceOf(self)\n    for i: uint256 in range(len(_opportunities), bound=MAX_LEGOS):\n        if balanceAvail >= cd.trialFundsInitialAmount:\n            break\n\n        # get vault token data\n        opp: TrialFundsOpp = _opportunities[i]\n        vaultTokenBal: uint256 = staticcall IERC20(opp.vaultToken).balanceOf(self)\n        if vaultTokenBal == 0:\n            continue\n\n        # withdraw from lego partner\n        assetAmountReceived: uint256 = 0\n        na1: uint256 = 0\n        na2: uint256 = 0\n        assetAmountReceived, na1, na2 = self._withdrawTokens(agentFactory, opp.legoId, cd.trialFundsAsset, opp.vaultToken, vaultTokenBal, False, False, cd)\n        balanceAvail += assetAmountReceived\n\n        # deposit any extra balance back lego\n        if balanceAvail > cd.trialFundsInitialAmount:\n            self._depositTokens(agentFactory, opp.legoId, cd.trialFundsAsset, opp.vaultToken, balanceAvail - cd.trialFundsInitialAmount, False, False, cd)\n            break\n\n    # transfer back to agent factory\n    amountRecovered: uint256 = min(cd.trialFundsInitialAmount, staticcall IERC20(cd.trialFundsAsset).balanceOf(self))\n    assert amountRecovered != 0 # dev: no funds to transfer\n    assert extcall IERC20(cd.trialFundsAsset).transfer(agentFactory, amountRecovered, default_return_value=True) # dev: trial funds transfer failed\n\n    # update trial funds data\n    remainingTrialFunds: uint256 = cd.trialFundsInitialAmount - amountRecovered\n    self.trialFundsInitialAmount = remainingTrialFunds\n    if remainingTrialFunds == 0:\n        self.trialFundsAsset = empty(address)\n\n    log UserWalletTrialFundsRecovered(asset=cd.trialFundsAsset, amountRecovered=amountRecovered, remainingAmount=remainingTrialFunds)\n    return True\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256) -> bool:\n    \"\"\"\n    @notice Recovers an NFT from the wallet\n    @param _collection The collection address\n    @param _nftTokenId The token ID of the NFT\n    @return bool True if the NFT was recovered successfully\n    \"\"\"\n    owner: address = staticcall WalletConfig(self.walletConfig).owner()\n    assert msg.sender == owner # dev: no perms\n\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, owner, _nftTokenId)\n    log UserWalletNftRecovered(collection=_collection, nftTokenId=_nftTokenId, owner=owner)\n    return True",
            "sha256sum": "2dc1977d0c193329419e80c83266a8efddfb209b5c60d99e1777b857ea27e127"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/WalletFunds.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "bb3953917698f009367b8a15aecd9323260652ed56c8a9795a931d1b9696fe82"
      },
      "args": ""
    },
    "WalletConfig": {
      "address": "0x45D1a9429Fd603c13Cdab685dc2540f4F57Df464",
      "abi": [
        {
          "name": "AgentAdded",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "allowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "allowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentModified",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "allowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "allowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentDisabled",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAllowedAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevAllowedLegoIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoIdAddedToAgent",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetAddedToAgent",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AllowedActionsModified",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRebalance",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canTransfer",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSwap",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canConvert",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canAddLiq",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRemoveLiq",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canClaimRewards",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canBorrow",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRepay",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrCancelled",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAddrRemoved",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ReserveAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeInitiated",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeConfirmed",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeCancelled",
          "inputs": [
            {
              "name": "cancelledOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initialize",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_initialAgent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgentActive",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canAgentAccess",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            },
            {
              "name": "_legoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentSubscriptionStatus",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getProtocolSubscriptionStatus",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMakeSubscriptionPayments",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "handleSubscriptionsAndPermissions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            },
            {
              "name": "_assets",
              "type": "address[]"
            },
            {
              "name": "_legoIds",
              "type": "uint256[]"
            },
            {
              "name": "_cd",
              "type": "tuple",
              "components": [
                {
                  "name": "owner",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "addyRegistry",
                  "type": "address"
                },
                {
                  "name": "legoRegistry",
                  "type": "address"
                },
                {
                  "name": "priceSheets",
                  "type": "address"
                },
                {
                  "name": "oracleRegistry",
                  "type": "address"
                },
                {
                  "name": "trialFundsAsset",
                  "type": "address"
                },
                {
                  "name": "trialFundsInitialAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailableTxAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_wantedAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldCheckTrialFunds",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailableTxAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_wantedAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldCheckTrialFunds",
              "type": "bool"
            },
            {
              "name": "_cd",
              "type": "tuple",
              "components": [
                {
                  "name": "owner",
                  "type": "address"
                },
                {
                  "name": "wallet",
                  "type": "address"
                },
                {
                  "name": "walletConfig",
                  "type": "address"
                },
                {
                  "name": "addyRegistry",
                  "type": "address"
                },
                {
                  "name": "legoRegistry",
                  "type": "address"
                },
                {
                  "name": "priceSheets",
                  "type": "address"
                },
                {
                  "name": "oracleRegistry",
                  "type": "address"
                },
                {
                  "name": "trialFundsAsset",
                  "type": "address"
                },
                {
                  "name": "trialFundsInitialAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            },
            {
              "name": "_allowedLegoIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addOrModifyAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedAssets",
              "type": "address[]"
            },
            {
              "name": "_allowedLegoIds",
              "type": "uint256[]"
            },
            {
              "name": "_allowedActions",
              "type": "tuple",
              "components": [
                {
                  "name": "isSet",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRebalance",
                  "type": "bool"
                },
                {
                  "name": "canTransfer",
                  "type": "bool"
                },
                {
                  "name": "canSwap",
                  "type": "bool"
                },
                {
                  "name": "canConvert",
                  "type": "bool"
                },
                {
                  "name": "canAddLiq",
                  "type": "bool"
                },
                {
                  "name": "canRemoveLiq",
                  "type": "bool"
                },
                {
                  "name": "canClaimRewards",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLegoIdForAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAssetForAgent",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "modifyAllowedActions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "modifyAllowedActions",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_allowedActions",
              "type": "tuple",
              "components": [
                {
                  "name": "isSet",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRebalance",
                  "type": "bool"
                },
                {
                  "name": "canTransfer",
                  "type": "bool"
                },
                {
                  "name": "canSwap",
                  "type": "bool"
                },
                {
                  "name": "canConvert",
                  "type": "bool"
                },
                {
                  "name": "canAddLiq",
                  "type": "bool"
                },
                {
                  "name": "canRemoveLiq",
                  "type": "bool"
                },
                {
                  "name": "canClaimRewards",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canTransferToRecipient",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeWhitelistAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setReserveAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManyReserveAssets",
          "inputs": [
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingOwnerChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeOwnership",
          "inputs": [
            {
              "name": "_newOwner",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOwnershipChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "wallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "owner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingOwner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newOwner",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ownershipChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolSub",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "installBlock",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "reserveAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentSettings",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "isActive",
                  "type": "bool"
                },
                {
                  "name": "installBlock",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "allowedAssets",
                  "type": "address[]"
                },
                {
                  "name": "allowedLegoIds",
                  "type": "uint256[]"
                },
                {
                  "name": "allowedActions",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "isSet",
                      "type": "bool"
                    },
                    {
                      "name": "canDeposit",
                      "type": "bool"
                    },
                    {
                      "name": "canWithdraw",
                      "type": "bool"
                    },
                    {
                      "name": "canRebalance",
                      "type": "bool"
                    },
                    {
                      "name": "canTransfer",
                      "type": "bool"
                    },
                    {
                      "name": "canSwap",
                      "type": "bool"
                    },
                    {
                      "name": "canConvert",
                      "type": "bool"
                    },
                    {
                      "name": "canAddLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canRemoveLiq",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimRewards",
                      "type": "bool"
                    },
                    {
                      "name": "canBorrow",
                      "type": "bool"
                    },
                    {
                      "name": "canRepay",
                      "type": "bool"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isRecipientAllowed",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingWhitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addyRegistry",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "initialized",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_minOwnerChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxOwnerChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/core/WalletConfig.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n# pragma optimize codesize\n\nfrom ethereum.ercs import IERC20\n\ninterface PriceSheets:\n    def getCombinedSubData(_user: address, _agent: address, _agentPaidThru: uint256, _protocolPaidThru: uint256, _oracleRegistry: address) -> (SubPaymentInfo, SubPaymentInfo): view\n    def getAgentSubPriceData(_agent: address) -> SubscriptionInfo: view\n    def protocolSubPriceData() -> SubscriptionInfo: view\n\ninterface LegoRegistry:\n    def getUnderlyingForUser(_user: address, _asset: address) -> uint256: view\n    def isValidLegoId(_legoId: uint256) -> bool: view\n\ninterface UserWallet:\n    def trialFundsInitialAmount() -> uint256: view\n    def trialFundsAsset() -> address: view\n    def walletConfig() -> address: view\n\ninterface WalletConfig:\n    def hasPendingOwnerChange() -> bool: view\n    def owner() -> address: view\n\ninterface AgentFactory:\n    def isUserWallet(_wallet: address) -> bool: view\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct AgentInfo:\n    isActive: bool\n    installBlock: uint256\n    paidThroughBlock: uint256\n    allowedAssets: DynArray[address, MAX_ASSETS]\n    allowedLegoIds: DynArray[uint256, MAX_LEGOS]\n    allowedActions: AllowedActions\n\nstruct PendingWhitelist:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct CoreData:\n    owner: address\n    wallet: address\n    walletConfig: address\n    addyRegistry: address\n    legoRegistry: address\n    priceSheets: address\n    oracleRegistry: address\n    trialFundsAsset: address\n    trialFundsInitialAmount: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct ProtocolSub:\n    installBlock: uint256\n    paidThroughBlock: uint256\n\nstruct AllowedActions:\n    isSet: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRebalance: bool\n    canTransfer: bool\n    canSwap: bool\n    canConvert: bool\n    canAddLiq: bool\n    canRemoveLiq: bool\n    canClaimRewards: bool\n    canBorrow: bool\n    canRepay: bool\n\nstruct ReserveAsset:\n    asset: address\n    amount: uint256\n\nstruct SubscriptionInfo:\n    asset: address\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nstruct PendingOwner:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentAdded:\n    agent: indexed(address)\n    allowedAssets: uint256\n    allowedLegoIds: uint256\n\nevent AgentModified:\n    agent: indexed(address)\n    allowedAssets: uint256\n    allowedLegoIds: uint256\n\nevent AgentDisabled:\n    agent: indexed(address)\n    prevAllowedAssets: uint256\n    prevAllowedLegoIds: uint256\n\nevent LegoIdAddedToAgent:\n    agent: indexed(address)\n    legoId: indexed(uint256)\n\nevent AssetAddedToAgent:\n    agent: indexed(address)\n    asset: indexed(address)\n\nevent AllowedActionsModified:\n    agent: indexed(address)\n    canDeposit: bool\n    canWithdraw: bool\n    canRebalance: bool\n    canTransfer: bool\n    canSwap: bool\n    canConvert: bool\n    canAddLiq: bool\n    canRemoveLiq: bool\n    canClaimRewards: bool\n    canBorrow: bool\n    canRepay: bool\n\nevent WhitelistAddrPending:\n    addr: indexed(address)\n    confirmBlock: uint256\n\nevent WhitelistAddrConfirmed:\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent WhitelistAddrCancelled:\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent WhitelistAddrRemoved:\n    addr: indexed(address)\n\nevent ReserveAssetSet:\n    asset: indexed(address)\n    amount: uint256\n\nevent OwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent OwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent OwnershipChangeDelaySet:\n    delayBlocks: uint256\n\nevent FundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# core\nwallet: public(address)\n\n# owner\nowner: public(address) # owner of the wallet\npendingOwner: public(PendingOwner) # pending owner of the wallet\nownershipChangeDelay: public(uint256) # num blocks to wait before owner can be changed\n\n# user settings\nprotocolSub: public(ProtocolSub) # subscription info\nreserveAssets: public(HashMap[address, uint256]) # asset -> reserve amount\nagentSettings: public(HashMap[address, AgentInfo]) # agent -> agent info\n\n# transfer whitelist\nisRecipientAllowed: public(HashMap[address, bool]) # recipient -> is allowed\npendingWhitelist: public(HashMap[address, PendingWhitelist]) # addr -> pending whitelist\n\n# config\naddyRegistry: public(address)\ninitialized: public(bool)\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\nLEGO_REGISTRY_ID: constant(uint256) = 2\nPRICE_SHEETS_ID: constant(uint256) = 3\nORACLE_REGISTRY_ID: constant(uint256) = 4\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\n\nMAX_ASSETS: constant(uint256) = 25\nMAX_LEGOS: constant(uint256) = 20\nAPI_VERSION: constant(String[28]) = \"0.0.1\"\n\n\n@deploy\ndef __init__(_minOwnerChangeDelay: uint256, _maxOwnerChangeDelay: uint256):\n    MIN_OWNER_CHANGE_DELAY = _minOwnerChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxOwnerChangeDelay\n\n    # make sure original reference contract can't be initialized\n    self.initialized = True\n\n\n@external\ndef initialize(\n    _wallet: address,\n    _addyRegistry: address,\n    _owner: address,\n    _initialAgent: address,\n) -> bool:\n    \"\"\"\n    @notice Sets up the initial state of the wallet template\n    @dev Can only be called once and sets core contract parameters\n    @param _wallet The address of the wallet contract\n    @param _addyRegistry The address of the core registry contract\n    @param _owner The address that will own this wallet\n    @param _initialAgent The address of the initial AI agent (if any)\n    @return bool True if initialization was successful\n    \"\"\"\n    assert not self.initialized # dev: can only initialize once\n    self.initialized = True\n\n    assert empty(address) not in [_wallet, _addyRegistry, _owner] # dev: invalid addrs\n    assert _initialAgent != _owner # dev: agent cannot be owner\n    self.wallet = _wallet\n    self.addyRegistry = _addyRegistry\n    self.owner = _owner\n    self.ownershipChangeDelay = MIN_OWNER_CHANGE_DELAY\n\n    priceSheets: address = staticcall AddyRegistry(_addyRegistry).getAddy(PRICE_SHEETS_ID)\n\n    # initial agent setup\n    if _initialAgent != empty(address):\n        subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).getAgentSubPriceData(_initialAgent)\n        paidThroughBlock: uint256 = 0\n        if subInfo.usdValue != 0:\n            paidThroughBlock = block.number + subInfo.trialPeriod\n        self.agentSettings[_initialAgent] = AgentInfo(\n            isActive=True,\n            installBlock=block.number,\n            paidThroughBlock=paidThroughBlock,\n            allowedAssets=[],\n            allowedLegoIds=[],\n            allowedActions=empty(AllowedActions),\n        )\n        log AgentAdded(agent=_initialAgent, allowedAssets=0, allowedLegoIds=0)\n\n    # protocol subscription\n    protocolSub: ProtocolSub = empty(ProtocolSub)\n    protocolSub.installBlock = block.number\n    subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).protocolSubPriceData()\n    if subInfo.usdValue != 0:\n        protocolSub.paidThroughBlock = block.number + subInfo.trialPeriod\n    self.protocolSub = protocolSub\n\n    return True\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    \"\"\"\n    @notice Returns the current API version of the contract\n    @dev Returns a constant string representing the contract version\n    @return String[28] The API version string\n    \"\"\"\n    return API_VERSION\n\n\n#####################\n# Agent Permissions #\n#####################\n\n\n@view\n@external\ndef isAgentActive(_agent: address) -> bool:\n    return self.agentSettings[_agent].isActive\n\n\n@view\n@external\ndef canAgentAccess(\n    _agent: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n) -> bool:\n    return self._canAgentAccess(self.agentSettings[_agent], _action, _assets, _legoIds)\n\n\n@view\n@internal\ndef _canAgentAccess(\n    _agent: AgentInfo,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n) -> bool:\n    if not _agent.isActive:\n        return False\n\n    # check allowed actions\n    if not self._canAgentPerformAction(_action, _agent.allowedActions):\n        return False\n\n    # check allowed assets\n    if len(_agent.allowedAssets) != 0:\n        for i: uint256 in range(len(_assets), bound=MAX_ASSETS):\n            asset: address = _assets[i]\n            if asset != empty(address) and asset not in _agent.allowedAssets:\n                return False\n\n    # check allowed lego ids\n    if len(_agent.allowedLegoIds) != 0:\n        for i: uint256 in range(len(_legoIds), bound=MAX_LEGOS):\n            legoId: uint256 = _legoIds[i]\n            if legoId != 0 and legoId not in _agent.allowedLegoIds:\n                return False\n\n    return True\n\n\n@view\n@internal\ndef _canAgentPerformAction(_action: ActionType, _allowedActions: AllowedActions) -> bool:\n    if not _allowedActions.isSet or _action == empty(ActionType):\n        return True\n    if _action == ActionType.DEPOSIT:\n        return _allowedActions.canDeposit\n    elif _action == ActionType.WITHDRAWAL:\n        return _allowedActions.canWithdraw\n    elif _action == ActionType.REBALANCE:\n        return _allowedActions.canRebalance\n    elif _action == ActionType.TRANSFER:\n        return _allowedActions.canTransfer\n    elif _action == ActionType.SWAP:\n        return _allowedActions.canSwap\n    elif _action == ActionType.CONVERSION:\n        return _allowedActions.canConvert\n    elif _action == ActionType.ADD_LIQ:\n        return _allowedActions.canAddLiq\n    elif _action == ActionType.REMOVE_LIQ:\n        return _allowedActions.canRemoveLiq\n    elif _action == ActionType.CLAIM_REWARDS:\n        return _allowedActions.canClaimRewards\n    elif _action == ActionType.BORROW:\n        return _allowedActions.canBorrow\n    elif _action == ActionType.REPAY:\n        return _allowedActions.canRepay\n    else:\n        return True # no action specified\n\n\n##########################\n# Subscription + Tx Fees #\n##########################\n\n\n# subscriptions\n\n\n@view\n@external\ndef getAgentSubscriptionStatus(_agent: address) -> SubPaymentInfo:\n    cd: CoreData = self._getCoreData()\n    na: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    na, agentSub = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, _agent, self.agentSettings[_agent].paidThroughBlock, 0, cd.oracleRegistry)\n    return agentSub\n\n\n@view\n@external\ndef getProtocolSubscriptionStatus() -> SubPaymentInfo:\n    cd: CoreData = self._getCoreData()\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    na: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, na = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, empty(address), 0, self.protocolSub.paidThroughBlock, cd.oracleRegistry)\n    return protocolSub\n\n\n@view\n@external\ndef canMakeSubscriptionPayments(_agent: address) -> (bool, bool):\n    cd: CoreData = self._getCoreData()\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = staticcall PriceSheets(cd.priceSheets).getCombinedSubData(cd.wallet, _agent, self.agentSettings[_agent].paidThroughBlock, self.protocolSub.paidThroughBlock, cd.oracleRegistry)\n    return self._checkIfSufficientFunds(protocolSub.asset, protocolSub.amount, agentSub.asset, agentSub.amount, cd)\n\n\n@external\ndef handleSubscriptionsAndPermissions(\n    _agent: address,\n    _action: ActionType,\n    _assets: DynArray[address, MAX_ASSETS],\n    _legoIds: DynArray[uint256, MAX_LEGOS],\n    _cd: CoreData,\n) -> (SubPaymentInfo, SubPaymentInfo):\n    \"\"\"\n    @notice Handles the subscription and permission data for the given agent and action\n    @param _agent The address of the agent\n    @param _action The action to handle\n    @param _assets The assets to check\n    @param _legoIds The legos to check\n    @param _cd The core data\n    @return protocolSub The protocol subscription data\n    @return agentSub The agent subscription data\n    \"\"\"\n    assert msg.sender == self.wallet # dev: no perms\n\n    # check if agent can perform action with assets and legos\n    userAgentData: AgentInfo = empty(AgentInfo)\n    if _agent != empty(address):\n        userAgentData = self.agentSettings[_agent]\n        assert self._canAgentAccess(userAgentData, _action, _assets, _legoIds) # dev: agent not allowed\n\n    userProtocolData: ProtocolSub = self.protocolSub\n\n    # get latest sub data for agent and protocol\n    protocolSub: SubPaymentInfo = empty(SubPaymentInfo)\n    agentSub: SubPaymentInfo = empty(SubPaymentInfo)\n    protocolSub, agentSub = staticcall PriceSheets(_cd.priceSheets).getCombinedSubData(_cd.wallet, _agent, userAgentData.paidThroughBlock, userProtocolData.paidThroughBlock, _cd.oracleRegistry)\n\n    # check if sufficient funds\n    canPayProtocol: bool = False\n    canPayAgent: bool = False\n    canPayProtocol, canPayAgent = self._checkIfSufficientFunds(protocolSub.asset, protocolSub.amount, agentSub.asset, agentSub.amount, _cd)\n    assert canPayProtocol # dev: insufficient balance for protocol subscription payment\n    assert canPayAgent # dev: insufficient balance for agent subscription payment\n\n    # update and save new data\n    if protocolSub.didChange:\n        userProtocolData.paidThroughBlock = protocolSub.paidThroughBlock\n        self.protocolSub = userProtocolData\n    if agentSub.didChange:\n        userAgentData.paidThroughBlock = agentSub.paidThroughBlock\n        self.agentSettings[_agent] = userAgentData\n\n    # actual payments will happen from wallet\n    return protocolSub, agentSub\n\n\n####################\n# Random Utilities #\n####################\n\n\n@view\n@internal\ndef _getCoreData() -> CoreData:\n    addyRegistry: address = self.addyRegistry\n    wallet: address = self.wallet\n    return CoreData(\n        owner=self.owner,\n        wallet=wallet,\n        walletConfig=self,\n        addyRegistry=addyRegistry,\n        legoRegistry=staticcall AddyRegistry(addyRegistry).getAddy(LEGO_REGISTRY_ID),\n        priceSheets=staticcall AddyRegistry(addyRegistry).getAddy(PRICE_SHEETS_ID),\n        oracleRegistry=staticcall AddyRegistry(addyRegistry).getAddy(ORACLE_REGISTRY_ID),\n        trialFundsAsset=staticcall UserWallet(wallet).trialFundsAsset(),\n        trialFundsInitialAmount=staticcall UserWallet(wallet).trialFundsInitialAmount(),\n    )\n\n\n@view\n@internal\ndef _checkIfSufficientFunds(_protocolAsset: address, _protocolAmount: uint256, _agentAsset: address, _agentAmount: uint256, _cd: CoreData) -> (bool, bool):\n    canPayProtocol: bool = True\n    canPayAgent: bool = True\n\n    # check if any of these assets are also trial funds asset\n    trialFundsCurrentBal: uint256 = 0\n    trialFundsDeployed: uint256 = 0\n    if (_protocolAsset != empty(address) and _protocolAsset == _cd.trialFundsAsset) or (_agentAsset != empty(address) and _agentAsset == _cd.trialFundsAsset):\n        trialFundsCurrentBal = staticcall IERC20(_cd.trialFundsAsset).balanceOf(_cd.wallet)\n        trialFundsDeployed = staticcall LegoRegistry(_cd.legoRegistry).getUnderlyingForUser(_cd.wallet, _cd.trialFundsAsset)\n\n    # check if can make protocol payment\n    if _protocolAmount != 0:\n        availBalForProtocol: uint256 = self._getAvailBalAfterTrialFunds(_protocolAsset, _cd.wallet, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, trialFundsCurrentBal, trialFundsDeployed)\n        canPayProtocol = availBalForProtocol >= _protocolAmount\n\n        # update trial funds balance\n        if _protocolAsset != empty(address) and _protocolAsset == _cd.trialFundsAsset:\n            trialFundsCurrentBal -= _protocolAmount\n\n    # check if can make agent payment\n    if _agentAmount != 0:\n        availBalForAgent: uint256 = self._getAvailBalAfterTrialFunds(_agentAsset, _cd.wallet, _cd.trialFundsAsset, _cd.trialFundsInitialAmount, trialFundsCurrentBal, trialFundsDeployed)\n        canPayAgent = availBalForAgent >= _agentAmount\n\n    return canPayProtocol, canPayAgent\n\n\n@view\n@external\ndef getAvailableTxAmount(\n    _asset: address,\n    _wantedAmount: uint256,\n    _shouldCheckTrialFunds: bool,\n    _cd: CoreData = empty(CoreData),\n) -> uint256:\n    \"\"\"\n    @notice Returns the maximum amount that can be sent from the wallet\n    @param _asset The address of the asset to check\n    @param _wantedAmount The amount of the asset to send\n    @param _shouldCheckTrialFunds Whether to check if the asset is a trial funds asset\n    @param _cd The core data\n    @return amount The maximum amount that can be sent\n    \"\"\"\n    cd: CoreData = _cd\n    if cd.wallet == empty(address):\n        cd = self._getCoreData()\n\n    availableAmount: uint256 = staticcall IERC20(_asset).balanceOf(cd.wallet)\n\n    # check if asset is trial funds asset\n    if _shouldCheckTrialFunds and _asset == cd.trialFundsAsset:\n        trialFundsDeployed: uint256 = staticcall LegoRegistry(cd.legoRegistry).getUnderlyingForUser(cd.wallet, _asset)\n        availableAmount = self._getAvailBalAfterTrialFunds(_asset, cd.wallet, cd.trialFundsAsset, cd.trialFundsInitialAmount, availableAmount, trialFundsDeployed)\n\n    # check if any reserve is set\n    reservedAmount: uint256 = self.reserveAssets[_asset]\n    if reservedAmount != 0:\n        assert availableAmount > reservedAmount # dev: insufficient balance after reserve\n        availableAmount -= reservedAmount\n\n    # return min of wanted amount and available amount\n    availableAmount = min(_wantedAmount, availableAmount)\n    assert availableAmount != 0 # dev: no funds available\n\n    return availableAmount\n\n\n@view\n@internal\ndef _getAvailBalAfterTrialFunds(\n    _asset: address,\n    _wallet: address,\n    _trialFundsAsset: address,\n    _trialFundsInitialAmount: uint256,\n    _trialFundsCurrentBal: uint256,\n    _trialFundsDeployed: uint256,\n) -> uint256:\n    if _asset != _trialFundsAsset:\n        return staticcall IERC20(_asset).balanceOf(_wallet)\n\n    # sufficient trial funds already deployed\n    if _trialFundsDeployed >= _trialFundsInitialAmount:\n        return _trialFundsCurrentBal\n\n    lockedAmount: uint256 = _trialFundsInitialAmount - _trialFundsDeployed\n    availAmount: uint256 = 0\n    if _trialFundsCurrentBal > lockedAmount:\n        availAmount = _trialFundsCurrentBal - lockedAmount\n\n    return availAmount\n\n\n##################\n# Agent Settings #\n##################\n\n\n# add or modify agent settings\n\n\n@nonreentrant\n@external\ndef addOrModifyAgent(\n    _agent: address,\n    _allowedAssets: DynArray[address, MAX_ASSETS] = [],\n    _allowedLegoIds: DynArray[uint256, MAX_LEGOS] = [],\n    _allowedActions: AllowedActions = empty(AllowedActions),\n) -> bool:\n    \"\"\"\n    @notice Adds a new agent or modifies an existing agent's permissions\n        If empty arrays are provided, the agent has access to all assets and lego ids\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to add or modify\n    @param _allowedAssets List of assets the agent can interact with\n    @param _allowedLegoIds List of lego IDs the agent can use\n    @param _allowedActions The actions the agent can perform\n    @return bool True if the agent was successfully added or modified\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner # dev: no perms\n    assert _agent != owner # dev: agent cannot be owner\n    assert _agent != empty(address) # dev: invalid agent\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    agentInfo.isActive = True\n\n    # allowed actions\n    agentInfo.allowedActions = _allowedActions\n    agentInfo.allowedActions.isSet = self._hasAllowedActionsSet(_allowedActions)\n\n    # sanitize other input data\n    agentInfo.allowedAssets, agentInfo.allowedLegoIds = self._sanitizeAgentInputData(_allowedAssets, _allowedLegoIds)\n\n    # get subscription info\n    priceSheets: address = staticcall AddyRegistry(self.addyRegistry).getAddy(PRICE_SHEETS_ID)\n    subInfo: SubscriptionInfo = staticcall PriceSheets(priceSheets).getAgentSubPriceData(_agent)\n    \n    isNewAgent: bool = (agentInfo.installBlock == 0)\n    if isNewAgent:\n        agentInfo.installBlock = block.number\n        if subInfo.usdValue != 0:\n            agentInfo.paidThroughBlock = block.number + subInfo.trialPeriod\n\n    # may not have had sub setup before\n    elif subInfo.usdValue != 0:\n        agentInfo.paidThroughBlock = max(agentInfo.paidThroughBlock, agentInfo.installBlock + subInfo.trialPeriod)\n\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    if isNewAgent:\n        log AgentAdded(agent=_agent, allowedAssets=len(agentInfo.allowedAssets), allowedLegoIds=len(agentInfo.allowedLegoIds))\n    else:\n        log AgentModified(agent=_agent, allowedAssets=len(agentInfo.allowedAssets), allowedLegoIds=len(agentInfo.allowedLegoIds))\n    return True\n\n\n@view\n@internal\ndef _sanitizeAgentInputData(\n    _allowedAssets: DynArray[address, MAX_ASSETS],\n    _allowedLegoIds: DynArray[uint256, MAX_LEGOS],\n) -> (DynArray[address, MAX_ASSETS], DynArray[uint256, MAX_LEGOS]):\n\n    # nothing to do here\n    if len(_allowedAssets) == 0 and len(_allowedLegoIds) == 0:\n        return _allowedAssets, _allowedLegoIds\n\n    # sanitize and dedupe assets\n    cleanAssets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(len(_allowedAssets), bound=MAX_ASSETS):\n        asset: address = _allowedAssets[i]\n        if asset == empty(address):\n            continue\n        if asset not in cleanAssets:\n            cleanAssets.append(asset)\n\n    # validate and dedupe lego ids\n    cleanLegoIds: DynArray[uint256, MAX_LEGOS] = []\n    if len(_allowedLegoIds) != 0:\n        legoRegistry: address = staticcall AddyRegistry(self.addyRegistry).getAddy(LEGO_REGISTRY_ID)\n        for i: uint256 in range(len(_allowedLegoIds), bound=MAX_LEGOS):\n            legoId: uint256 = _allowedLegoIds[i]\n            if not staticcall LegoRegistry(legoRegistry).isValidLegoId(legoId):\n                continue\n            if legoId not in cleanLegoIds:\n                cleanLegoIds.append(legoId)\n\n    return cleanAssets, cleanLegoIds\n\n\n# disable agent\n\n\n@nonreentrant\n@external\ndef disableAgent(_agent: address) -> bool:\n    \"\"\"\n    @notice Disables an existing agent\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to disable\n    @return bool True if the agent was successfully disabled\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n    agentInfo.isActive = False\n    self.agentSettings[_agent] = agentInfo\n\n    log AgentDisabled(agent=_agent, prevAllowedAssets=len(agentInfo.allowedAssets), prevAllowedLegoIds=len(agentInfo.allowedLegoIds))\n    return True\n\n\n# add lego id for agent\n\n\n@nonreentrant\n@external\ndef addLegoIdForAgent(_agent: address, _legoId: uint256) -> bool:\n    \"\"\"\n    @notice Adds a lego ID to an agent's allowed legos\n    @dev Can only be called by the owner\n    @param _agent The address of the agent\n    @param _legoId The lego ID to add\n    @return bool True if the lego ID was successfully added\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    legoRegistry: address = staticcall AddyRegistry(self.addyRegistry).getAddy(LEGO_REGISTRY_ID)\n    assert staticcall LegoRegistry(legoRegistry).isValidLegoId(_legoId)\n    assert _legoId not in agentInfo.allowedLegoIds # dev: lego id already saved\n\n    # save data\n    agentInfo.allowedLegoIds.append(_legoId)\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    log LegoIdAddedToAgent(agent=_agent, legoId=_legoId)\n    return True\n\n\n# add asset for agent\n\n\n@nonreentrant\n@external\ndef addAssetForAgent(_agent: address, _asset: address) -> bool:\n    \"\"\"\n    @notice Adds an asset to an agent's allowed assets\n    @dev Can only be called by the owner\n    @param _agent The address of the agent\n    @param _asset The asset address to add\n    @return bool True if the asset was successfully added\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    assert _asset != empty(address) # dev: invalid asset\n    assert _asset not in agentInfo.allowedAssets # dev: asset already saved\n\n    # save data\n    agentInfo.allowedAssets.append(_asset)\n    self.agentSettings[_agent] = agentInfo\n\n    # log event\n    log AssetAddedToAgent(agent=_agent, asset=_asset)\n    return True\n\n\n# modify allowed actions\n\n\n@nonreentrant\n@external\ndef modifyAllowedActions(_agent: address, _allowedActions: AllowedActions = empty(AllowedActions)) -> bool:\n    \"\"\"\n    @notice Modifies the allowed actions for an agent\n    @dev Can only be called by the owner\n    @param _agent The address of the agent to modify\n    @param _allowedActions The new allowed actions\n    @return bool True if the allowed actions were successfully modified\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n\n    agentInfo: AgentInfo = self.agentSettings[_agent]\n    assert agentInfo.isActive # dev: agent not active\n\n    agentInfo.allowedActions = _allowedActions\n    agentInfo.allowedActions.isSet = self._hasAllowedActionsSet(_allowedActions)\n    self.agentSettings[_agent] = agentInfo\n\n    log AllowedActionsModified(agent=_agent, canDeposit=_allowedActions.canDeposit, canWithdraw=_allowedActions.canWithdraw, canRebalance=_allowedActions.canRebalance, canTransfer=_allowedActions.canTransfer, canSwap=_allowedActions.canSwap, canConvert=_allowedActions.canConvert, canAddLiq=_allowedActions.canAddLiq, canRemoveLiq=_allowedActions.canRemoveLiq, canClaimRewards=_allowedActions.canClaimRewards, canBorrow=_allowedActions.canBorrow, canRepay=_allowedActions.canRepay)\n    return True\n\n\n@view\n@internal\ndef _hasAllowedActionsSet(_actions: AllowedActions) -> bool:\n    return _actions.canDeposit or _actions.canWithdraw or _actions.canRebalance or _actions.canTransfer or _actions.canSwap or _actions.canConvert\n\n\n######################\n# Transfer Whitelist #\n######################\n\n\n@view\n@external\ndef canTransferToRecipient(_recipient: address) -> bool:\n    \"\"\"\n    @notice Checks if a transfer to a recipient is allowed\n    @param _recipient The address of the recipient\n    @return bool True if the transfer is allowed, false otherwise\n    \"\"\"\n    isAllowed: bool = self.isRecipientAllowed[_recipient]\n    if isAllowed:\n        return True\n\n    # pending ownership change, don't even check if recipient is Underscore wallet\n    if self.pendingOwner.initiatedBlock != 0:\n        return False\n\n    # check if recipient is Underscore wallet, if owner is same (no pending ownership changes), transfer is allowed\n    agentFactory: address = staticcall AddyRegistry(self.addyRegistry).getAddy(AGENT_FACTORY_ID)\n    if staticcall AgentFactory(agentFactory).isUserWallet(_recipient):\n        walletConfig: address = staticcall UserWallet(_recipient).walletConfig()\n        if not staticcall WalletConfig(walletConfig).hasPendingOwnerChange():\n            isAllowed = self.owner == staticcall WalletConfig(walletConfig).owner()\n\n    return isAllowed\n\n\n@nonreentrant\n@external\ndef addWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Adds an address to the whitelist\n    @dev Can only be called by the owner\n    @param _addr The address to add to the whitelist\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner # dev: only owner can add whitelist\n\n    assert _addr != empty(address) # dev: invalid addr\n    assert _addr != owner # dev: owner cannot be whitelisted\n    assert _addr != self # dev: wallet cannot be whitelisted\n    assert not self.isRecipientAllowed[_addr] # dev: already whitelisted\n    assert self.pendingWhitelist[_addr].initiatedBlock == 0 # dev: pending whitelist already exists\n\n    # this uses same delay as ownership change\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingWhitelist[_addr] = PendingWhitelist(\n        initiatedBlock = block.number,\n        confirmBlock = confirmBlock,\n    )\n    log WhitelistAddrPending(addr=_addr, confirmBlock=confirmBlock)\n\n\n@nonreentrant\n@external\ndef confirmWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Confirms a whitelist address\n    @dev Can only be called by the owner\n    @param _addr The address to confirm\n    \"\"\"\n    assert msg.sender == self.owner # dev: only owner can confirm\n\n    data: PendingWhitelist = self.pendingWhitelist[_addr]\n    assert data.initiatedBlock != 0 # dev: no pending whitelist\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n\n    self.pendingWhitelist[_addr] = empty(PendingWhitelist)\n    self.isRecipientAllowed[_addr] = True\n    log WhitelistAddrConfirmed(addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@nonreentrant\n@external\ndef cancelPendingWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Cancels a pending whitelist address\n    @dev Can only be called by the owner\n    @param _addr The address to cancel\n    \"\"\"\n    assert msg.sender == self.owner # dev: only owner can cancel\n    data: PendingWhitelist = self.pendingWhitelist[_addr]\n    assert data.initiatedBlock != 0 # dev: no pending whitelist\n    self.pendingWhitelist[_addr] = empty(PendingWhitelist)\n    log WhitelistAddrCancelled(addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@nonreentrant\n@external\ndef removeWhitelistAddr(_addr: address):\n    \"\"\"\n    @notice Removes an address from the whitelist\n    @dev Can only be called by the owner\n    @param _addr The address to remove from the whitelist\n    \"\"\"\n    assert msg.sender == self.owner # dev: only owner can remove whitelist\n    assert self.isRecipientAllowed[_addr] # dev: not on whitelist\n\n    self.isRecipientAllowed[_addr] = False\n    log WhitelistAddrRemoved(addr=_addr)\n\n\n##################\n# Reserve Assets #\n##################\n\n\n@nonreentrant\n@external\ndef setReserveAsset(_asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Sets a reserve asset\n    @dev Can only be called by the owner\n    @param _asset The address of the asset to set\n    @param _amount The amount of the asset to set\n    @return bool True if the reserve asset was successfully set\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _asset != empty(address) # dev: invalid asset\n    self.reserveAssets[_asset] = _amount\n    log ReserveAssetSet(asset=_asset, amount=_amount)\n    return True\n\n\n@nonreentrant\n@external\ndef setManyReserveAssets(_assets: DynArray[ReserveAsset, MAX_ASSETS]) -> bool:\n    \"\"\"\n    @notice Sets multiple reserve assets\n    @dev Can only be called by the owner\n    @param _assets The array of reserve assets to set\n    @return bool True if the reserve assets were successfully set\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert len(_assets) != 0 # dev: invalid array length\n    for i: uint256 in range(len(_assets), bound=MAX_ASSETS):\n        asset: address = _assets[i].asset\n        amount: uint256 = _assets[i].amount\n        assert asset != empty(address) # dev: invalid asset\n        self.reserveAssets[asset] = amount\n        log ReserveAssetSet(asset=asset, amount=amount)\n\n    return True\n\n\n####################\n# Ownership Change #\n####################\n\n\n@view\n@external\ndef hasPendingOwnerChange() -> bool:\n    \"\"\"\n    @notice Checks if there is a pending ownership change\n    @return bool True if there is a pending ownership change, false otherwise\n    \"\"\"\n    return self.pendingOwner.initiatedBlock != 0\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    \"\"\"\n    @notice Initiates a new ownership change\n    @dev Can only be called by the current owner\n    @param _newOwner The address of the new owner\n    \"\"\"\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingOwner = PendingOwner(\n        newOwner= _newOwner,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log OwnershipChangeInitiated(prevOwner=currentOwner, newOwner=_newOwner, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmOwnershipChange():\n    \"\"\"\n    @notice Confirms the ownership change\n    @dev Can only be called by the new owner\n    \"\"\"\n    data: PendingOwner = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeConfirmed(prevOwner=prevOwner, newOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelOwnershipChange():\n    \"\"\"\n    @notice Cancels the ownership change\n    @dev Can only be called by the current owner\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    data: PendingOwner = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwner)\n    log OwnershipChangeCancelled(cancelledOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setOwnershipChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the ownership change delay\n    @dev Can only be called by the owner\n    @param _numBlocks The number of blocks to wait before ownership can be changed\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNER_CHANGE_DELAY and _numBlocks <= MAX_OWNER_CHANGE_DELAY # dev: invalid delay\n    self.ownershipChangeDelay = _numBlocks\n    log OwnershipChangeDelaySet(delayBlocks=_numBlocks)\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address) -> bool:\n    \"\"\"\n    @notice transfers funds from the config contract to the main wallet\n    @dev anyone can call this!\n    @param _asset The address of the asset to recover\n    @return bool True if the funds were recovered successfully\n    \"\"\"\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    wallet: address = self.wallet\n    if empty(address) in [wallet, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(wallet, balance, default_return_value=True) # dev: recovery failed\n    log FundsRecovered(asset=_asset, recipient=wallet, balance=balance)\n    return True\n",
            "sha256sum": "7e501c44e89b2559af05bb002e41d8ad632d45d8b37900ccd654705570d93130"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/WalletConfig.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "f54297f47cac46e34ebf3d53385916be58a5777c6dc04beab57d79804b45d987"
      },
      "args": "00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "AgentTemplate": {
      "address": "0x70418b3AAa1044eC8bFF6a461B4E43460bb5699E",
      "abi": [
        {
          "name": "AgentOwnershipChangeInitiated",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentOwnershipChangeConfirmed",
          "inputs": [
            {
              "name": "prevOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentOwnershipChangeCancelled",
          "inputs": [
            {
              "name": "cancelledOwner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentOwnershipChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initialize",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "pure",
          "type": "function",
          "name": "apiVersion",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            },
            {
              "name": "_vaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultToken",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVault",
              "type": "address"
            },
            {
              "name": "_fromVaultTokenAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSwapActionHash",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            },
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultToken",
              "type": "address"
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performBatchActions",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performBatchActions",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_sig",
              "type": "tuple",
              "components": [
                {
                  "name": "signature",
                  "type": "bytes"
                },
                {
                  "name": "signer",
                  "type": "address"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBatchActionHash",
          "inputs": [
            {
              "name": "_userWallet",
              "type": "address"
            },
            {
              "name": "_instructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "usePrevAmountOut",
                  "type": "bool"
                },
                {
                  "name": "action",
                  "type": "uint256"
                },
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vault",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "altLegoId",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altVault",
                  "type": "address"
                },
                {
                  "name": "altAmount",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "proof",
                  "type": "bytes32"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "isWethToEthConversion",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "changeOwnership",
          "inputs": [
            {
              "name": "_newOwner",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOwnershipChangeDelay",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "initialized",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "usedSignatures",
          "inputs": [
            {
              "name": "arg0",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "owner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingOwner",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newOwner",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ownershipChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_OWNER_CHANGE_DELAY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_minOwnerChangeDelay",
              "type": "uint256"
            },
            {
              "name": "_maxOwnerChangeDelay",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/UserWalletInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n# struct SwapInstruction:\n#     legoId: uint256\n#     amountIn: uint256\n#     minAmountOut: uint256\n#     tokenPath: DynArray[address, 5]\n#     poolPath: DynArray[address, 5 - 1]\n\n\n# @external\n# def swapTokens(_swapInstructions: DynArray[SwapInstruction, 5]) -> (uint256, uint256, uint256):\n#     ...\n\n\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    ...\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    ...\n\n\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    ...\n\n\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    ...\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    ...\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    ...\n",
            "sha256sum": "b6f85ddff061e77069cceb9d110c05c679a6ea34b68f3ff69c95c1b07d83c453"
          },
          "contracts/core/AgentTemplate.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nfrom interfaces import UserWalletInterface\nfrom ethereum.ercs import IERC20\n\ninterface UserWalletCustom:\n    def swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256): nonpayable\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct Signature:\n    signature: Bytes[65]\n    signer: address\n    expiration: uint256\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct ActionInstruction:\n    usePrevAmountOut: bool\n    action: ActionType\n    legoId: uint256\n    asset: address\n    vault: address\n    amount: uint256\n    altLegoId: uint256\n    altAsset: address\n    altVault: address\n    altAmount: uint256\n    minAmountOut: uint256\n    pool: address\n    proof: bytes32\n    nftAddr: address\n    nftTokenId: uint256\n    tickLower: int24\n    tickUpper: int24\n    minAmountA: uint256\n    minAmountB: uint256\n    minLpAmount: uint256\n    liqToRemove: uint256\n    recipient: address\n    isWethToEthConversion: bool\n\nstruct PendingOwner:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeDelaySet:\n    delayBlocks: uint256\n\nevent AgentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\ninitialized: public(bool)\nusedSignatures: public(HashMap[Bytes[65], bool])\n\n# owner\nowner: public(address) # owner of the wallet\npendingOwner: public(PendingOwner) # pending owner of the wallet\nownershipChangeDelay: public(uint256) # num blocks to wait before owner can be changed\n\n# eip-712\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\nDEPOSIT_TYPE_HASH: constant(bytes32) = keccak256('Deposit(address userWallet,uint256 legoId,address asset,address vault,uint256 amount,uint256 expiration)')\nWITHDRAWAL_TYPE_HASH: constant(bytes32) = keccak256('Withdrawal(address userWallet,uint256 legoId,address asset,address vaultToken,uint256 vaultTokenAmount,uint256 expiration)')\nREBALANCE_TYPE_HASH: constant(bytes32) = keccak256('Rebalance(address userWallet,uint256 fromLegoId,address fromAsset,address fromVaultToken,uint256 toLegoId,address toVault,uint256 fromVaultTokenAmount,uint256 expiration)')\nSWAP_ACTION_TYPE_HASH: constant(bytes32) =  keccak256('Swap(address userWallet,SwapInstruction[] swapInstructions,uint256 expiration)')\nSWAP_INSTRUCTION_TYPE_HASH: constant(bytes32) = keccak256('SwapInstruction(uint256 legoId,uint256 amountIn,uint256 minAmountOut,address[] tokenPath,address[] poolPath)')\nADD_LIQ_TYPE_HASH: constant(bytes32) = keccak256('AddLiquidity(address userWallet,uint256 legoId,address nftAddr,uint256 nftTokenId,address pool,address tokenA,address tokenB,uint256 amountA,uint256 amountB,int24 tickLower,int24 tickUpper,uint256 minAmountA,uint256 minAmountB,uint256 minLpAmount,uint256 expiration)')\nREMOVE_LIQ_TYPE_HASH: constant(bytes32) = keccak256('RemoveLiquidity(address userWallet,uint256 legoId,address nftAddr,uint256 nftTokenId,address pool,address tokenA,address tokenB,uint256 liqToRemove,uint256 minAmountA,uint256 minAmountB,uint256 expiration)')\nTRANSFER_TYPE_HASH: constant(bytes32) = keccak256('Transfer(address userWallet,address recipient,uint256 amount,address asset,uint256 expiration)')\nETH_TO_WETH_TYPE_HASH: constant(bytes32) = keccak256('EthToWeth(address userWallet,uint256 amount,uint256 depositLegoId,address depositVault,uint256 expiration)')\nWETH_TO_ETH_TYPE_HASH: constant(bytes32) = keccak256('WethToEth(address userWallet,uint256 amount,address recipient,uint256 withdrawLegoId,address withdrawVaultToken,uint256 expiration)')\nCLAIM_REWARDS_TYPE_HASH: constant(bytes32) = keccak256('ClaimRewards(address userWallet,uint256 legoId,address market,address rewardToken,uint256 rewardAmount,bytes32 proof,uint256 expiration)')\nBORROW_TYPE_HASH: constant(bytes32) = keccak256('Borrow(address userWallet,uint256 legoId,address borrowAsset,uint256 amount,uint256 expiration)')\nREPAY_TYPE_HASH: constant(bytes32) = keccak256('Repay(address userWallet,uint256 legoId,address paymentAsset,uint256 paymentAmount,uint256 expiration)')\nBATCH_ACTIONS_TYPE_HASH: constant(bytes32) =  keccak256('BatchActions(address userWallet,ActionInstruction[] instructions,uint256 expiration)')\nACTION_INSTRUCTION_TYPE_HASH: constant(bytes32) = keccak256('ActionInstruction(bool usePrevAmountOut,uint256 action,uint256 legoId,address asset,address vault,uint256 amount,uint256 altLegoId,address altAsset,address altVault,uint256 altAmount,uint256 minAmountOut,address pool,bytes32 proof,address nftAddr,uint256 nftTokenId,int24 tickLower,int24 tickUpper,uint256 minAmountA,uint256 minAmountB,uint256 minLpAmount,uint256 liqToRemove,address recipient,bool isWethToEthConversion)')\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_INSTRUCTIONS: constant(uint256) = 20\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\n\nAPI_VERSION: constant(String[28]) = \"0.0.1\"\n\n\n@deploy\ndef __init__(_minOwnerChangeDelay: uint256, _maxOwnerChangeDelay: uint256):\n    MIN_OWNER_CHANGE_DELAY = _minOwnerChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxOwnerChangeDelay\n\n    # make sure original reference contract can't be initialized\n    self.initialized = True\n\n\n@external\ndef initialize(_owner: address) -> bool:\n    assert not self.initialized # dev: can only initialize once\n    self.initialized = True\n\n    assert empty(address) not in [_owner] # dev: invalid addr\n    self.owner = _owner\n    self.ownershipChangeDelay = MIN_OWNER_CHANGE_DELAY\n\n    return True\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    return API_VERSION\n\n\n###########\n# Deposit #\n###########\n\n\n@nonreentrant\n@external\ndef depositTokens(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(DEPOSIT_TYPE_HASH, _userWallet, _legoId, _asset, _vault, _amount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).depositTokens(_legoId, _asset, _vault, _amount)\n\n\n############\n# Withdraw #\n############\n\n\n@nonreentrant\n@external\ndef withdrawTokens(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(WITHDRAWAL_TYPE_HASH, _userWallet, _legoId, _asset, _vaultToken, _vaultTokenAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).withdrawTokens(_legoId, _asset, _vaultToken, _vaultTokenAmount)\n\n\n#############\n# Rebalance #\n#############\n\n\n@nonreentrant\n@external\ndef rebalance(\n    _userWallet: address,\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REBALANCE_TYPE_HASH, _userWallet, _fromLegoId, _fromAsset, _fromVaultToken, _toLegoId, _toVault, _fromVaultTokenAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).rebalance(_fromLegoId, _fromAsset, _fromVaultToken, _toLegoId, _toVault, _fromVaultTokenAmount)\n\n\n########\n# Swap #\n########\n\n\n@nonreentrant\n@external\ndef swapTokens(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSwapSignature(self._hashSwapInstructions(_userWallet, _swapInstructions, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletCustom(_userWallet).swapTokens(_swapInstructions)\n\n\n@view\n@internal\ndef _encodeSwapInstruction(_instruction: SwapInstruction) -> Bytes[544]:\n    # Just encode, no hash\n    return abi_encode(\n        SWAP_INSTRUCTION_TYPE_HASH,\n        _instruction.legoId,\n        _instruction.amountIn,\n        _instruction.minAmountOut,\n        _instruction.tokenPath,\n        _instruction.poolPath\n    )\n\n\n@view\n@internal\ndef _encodeSwapInstructions(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> Bytes[2720]:\n    concatenated: Bytes[2720] = empty(Bytes[2720]) # max size for 5 instructions - 5*544\n    for i: uint256 in range(len(_swapInstructions), bound=MAX_SWAP_INSTRUCTIONS):\n        concatenated = convert(\n            concat(\n                concatenated, \n                self._encodeSwapInstruction(_swapInstructions[i])\n            ),\n            Bytes[2720]\n        )\n    return concatenated\n\n\n@view\n@internal\ndef _hashSwapInstructions(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _expiration: uint256,\n) -> Bytes[2880]:\n    # Now we encode everything and hash only once at the end\n    return abi_encode(\n        SWAP_ACTION_TYPE_HASH,\n        _userWallet,\n        self._encodeSwapInstructions(_swapInstructions),\n        _expiration\n    )\n\n\n@internal\ndef _isValidSwapSignature(_encodedValue: Bytes[2880], _sig: Signature):\n    encoded_hash: bytes32 = keccak256(_encodedValue)\n    domain_sep: bytes32 = self._domainSeparator()\n    \n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', domain_sep, encoded_hash))\n    \n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n    \n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n    \n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n    \n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n@view\n@external\ndef getSwapActionHash(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _expiration: uint256,\n) -> bytes32:\n    encodedValue: Bytes[2880] = self._hashSwapInstructions(_userWallet, _swapInstructions, _expiration)\n    encoded_hash: bytes32 = keccak256(encodedValue)\n    return keccak256(concat(b'\\x19\\x01', self._domainSeparator(), encoded_hash))\n\n\n##################\n# Borrow + Repay #\n##################\n\n\n@nonreentrant\n@external\ndef borrow(\n    _userWallet: address,\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(BORROW_TYPE_HASH, _userWallet, _legoId, _borrowAsset, _amount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).borrow(_legoId, _borrowAsset, _amount)\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _userWallet: address,\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REPAY_TYPE_HASH, _userWallet, _legoId, _paymentAsset, _paymentAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).repayDebt(_legoId, _paymentAsset, _paymentAmount)\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _userWallet: address,\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(CLAIM_REWARDS_TYPE_HASH, _userWallet, _legoId, _market, _rewardToken, _rewardAmount, _proof, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    extcall UserWalletInterface(_userWallet).claimRewards(_legoId, _market, _rewardToken, _rewardAmount, _proof)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(ADD_LIQ_TYPE_HASH, _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).addLiquidity(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, bool):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REMOVE_LIQ_TYPE_HASH, _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).removeLiquidity(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB)\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _userWallet: address,\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(TRANSFER_TYPE_HASH, _userWallet, _recipient, _amount, _asset, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).transferFunds(_recipient, _amount, _asset)\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@nonreentrant\n@external\ndef convertEthToWeth(\n    _userWallet: address,\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(ETH_TO_WETH_TYPE_HASH, _userWallet, _amount, _depositLegoId, _depositVault, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).convertEthToWeth(_amount, _depositLegoId, _depositVault)\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(\n    _userWallet: address,\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> uint256:\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(WETH_TO_ETH_TYPE_HASH, _userWallet, _amount, _recipient, _withdrawLegoId, _withdrawVaultToken, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).convertWethToEth(_amount, _recipient, _withdrawLegoId, _withdrawVaultToken)\n\n\n#################\n# Batch Actions #\n#################\n\n\n@nonreentrant\n@external\ndef performBatchActions(\n    _userWallet: address,\n    _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> bool:\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidBatchSignature(self._hashBatchActions(_userWallet, _instructions, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n\n    assert len(_instructions) != 0 # dev: no instructions\n    prevAmountReceived: uint256 = 0\n\n    # not using these vars\n    naAddyA: address = empty(address)\n    naValueA: uint256 = 0\n    naValueB: uint256 = 0\n    naValueC: uint256 = 0\n    naValueD: uint256 = 0\n    naBool: bool = False\n\n    # iterate through instructions\n    for j: uint256 in range(len(_instructions), bound=MAX_INSTRUCTIONS):\n        i: ActionInstruction = _instructions[j]\n\n        # deposit\n        if i.action == ActionType.DEPOSIT:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).depositTokens(i.legoId, i.asset, i.vault, amount)\n\n        # withdraw\n        elif i.action == ActionType.WITHDRAWAL:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            prevAmountReceived, naValueA, naValueB = extcall UserWalletInterface(_userWallet).withdrawTokens(i.legoId, i.asset, i.vault, amount)\n\n        # rebalance\n        elif i.action == ActionType.REBALANCE:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).rebalance(i.legoId, i.asset, i.vault, i.altLegoId, i.altVault, amount)\n\n        # borrow\n        elif i.action == ActionType.BORROW:\n            naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).borrow(i.legoId, i.asset, i.amount)\n\n        # repay debt\n        elif i.action == ActionType.REPAY:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            extcall UserWalletInterface(_userWallet).repayDebt(i.legoId, i.asset, amount)\n            prevAmountReceived = 0\n\n        # claim rewards\n        elif i.action == ActionType.CLAIM_REWARDS:\n            extcall UserWalletInterface(_userWallet).claimRewards(i.legoId, i.asset, i.altAsset, i.amount, i.proof)\n            prevAmountReceived = 0\n\n        # add liquidity\n        elif i.action == ActionType.ADD_LIQ:\n            amount: uint256 = i.amount # this only goes towards token A amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            prevAmountReceived, naValueA, naValueB, naValueC, naValueD = extcall UserWalletInterface(_userWallet).addLiquidity(i.legoId, i.nftAddr, i.nftTokenId, i.pool, i.asset, i.altAsset, amount, i.altAmount, i.tickLower, i.tickUpper, i.minAmountA, i.minAmountB, i.minLpAmount)\n\n        # remove liquidity\n        elif i.action == ActionType.REMOVE_LIQ:\n            amount: uint256 = i.liqToRemove # this only goes to `_liqToRemove`\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naValueB, naValueC, naBool = extcall UserWalletInterface(_userWallet).removeLiquidity(i.legoId, i.nftAddr, i.nftTokenId, i.pool, i.asset, i.altAsset, amount, i.minAmountA, i.minAmountB)\n            prevAmountReceived = 0\n\n        # transfer\n        elif i.action == ActionType.TRANSFER:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            extcall UserWalletInterface(_userWallet).transferFunds(i.recipient, amount, i.asset)\n            prevAmountReceived = 0\n\n        # conversion\n        elif i.action == ActionType.CONVERSION:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            if i.isWethToEthConversion:\n                prevAmountReceived = extcall UserWalletInterface(_userWallet).convertWethToEth(amount, i.recipient, i.legoId, i.vault)\n            else:\n                prevAmountReceived, naAddyA, naValueB = extcall UserWalletInterface(_userWallet).convertEthToWeth(amount, i.legoId, i.vault)\n                if naValueB != 0:\n                    prevAmountReceived = naValueB\n\n    return True\n\n\n@view\n@internal\ndef _encodeBatchActionInstruction(_instr: ActionInstruction) -> Bytes[768]:\n    # Just encode, no hash\n    return abi_encode(\n        ACTION_INSTRUCTION_TYPE_HASH,\n        _instr.usePrevAmountOut,\n        _instr.action,\n        _instr.legoId,\n        _instr.asset,\n        _instr.vault,\n        _instr.amount,\n        _instr.altLegoId,\n        _instr.altAsset,\n        _instr.altVault,\n        _instr.altAmount,\n        _instr.minAmountOut,\n        _instr.pool,\n        _instr.proof,\n        _instr.nftAddr,\n        _instr.nftTokenId,\n        _instr.tickLower,\n        _instr.tickUpper,\n        _instr.minAmountA,\n        _instr.minAmountB,\n        _instr.minLpAmount,\n        _instr.liqToRemove,\n        _instr.recipient,\n        _instr.isWethToEthConversion\n    )\n\n\n@view\n@internal\ndef _encodeBatchInstructions(_instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS]) -> Bytes[15360]:\n    concatenated: Bytes[15360] = empty(Bytes[15360]) # max size for 20 instructions - 20*768\n    for i: uint256 in range(len(_instructions), bound=MAX_INSTRUCTIONS):\n        concatenated = convert(\n            concat(\n                concatenated, \n                self._encodeBatchActionInstruction(_instructions[i])\n            ),\n            Bytes[15360]\n        )\n    return concatenated\n\n\n@view\n@internal\ndef _hashBatchActions(_userWallet: address, _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS], _expiration: uint256) -> Bytes[15520]:\n    # Now we encode everything and hash only once at the end\n    return abi_encode(\n        BATCH_ACTIONS_TYPE_HASH,\n        _userWallet,\n        self._encodeBatchInstructions(_instructions),\n        _expiration\n    )\n\n\n@internal\ndef _isValidBatchSignature(_encodedValue: Bytes[15520], _sig: Signature):\n    encoded_hash: bytes32 = keccak256(_encodedValue)\n    domain_sep: bytes32 = self._domainSeparator()\n    \n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', domain_sep, encoded_hash))\n    \n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n    \n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n    \n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n    \n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n@view\n@external\ndef getBatchActionHash(_userWallet: address, _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS], _expiration: uint256) -> bytes32:\n    encodedValue: Bytes[15520] = self._hashBatchActions(_userWallet, _instructions, _expiration)\n    encoded_hash: bytes32 = keccak256(encodedValue)\n    return keccak256(concat(b'\\x19\\x01', self._domainSeparator(), encoded_hash))\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    return keccak256(\n        concat(\n            DOMAIN_TYPE_HASH,\n            keccak256('UnderscoreAgent'),\n            keccak256(API_VERSION),\n            abi_encode(chain.id, self)\n        )\n    )\n\n\n@internal\ndef _isValidSignature(_encodedValue: Bytes[736], _sig: Signature):\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n    \n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', self._domainSeparator(), keccak256(_encodedValue)))\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n    \n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n    \n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n####################\n# Ownership Change #\n####################\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    \"\"\"\n    @notice Initiates a new ownership change\n    @dev Can only be called by the current owner\n    @param _newOwner The address of the new owner\n    \"\"\"\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingOwner = PendingOwner(\n        newOwner= _newOwner,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log AgentOwnershipChangeInitiated(prevOwner=currentOwner, newOwner=_newOwner, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmOwnershipChange():\n    \"\"\"\n    @notice Confirms the ownership change\n    @dev Can only be called by the new owner\n    \"\"\"\n    data: PendingOwner = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwner)\n    log AgentOwnershipChangeConfirmed(prevOwner=prevOwner, newOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelOwnershipChange():\n    \"\"\"\n    @notice Cancels the ownership change\n    @dev Can only be called by the current owner\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    data: PendingOwner = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwner)\n    log AgentOwnershipChangeCancelled(cancelledOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setOwnershipChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the ownership change delay\n    @dev Can only be called by the owner\n    @param _numBlocks The number of blocks to wait before ownership can be changed\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNER_CHANGE_DELAY and _numBlocks <= MAX_OWNER_CHANGE_DELAY # dev: invalid delay\n    self.ownershipChangeDelay = _numBlocks\n    log AgentOwnershipChangeDelaySet(delayBlocks=_numBlocks)\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address) -> bool:\n    \"\"\"\n    @notice transfers funds from the agent wallet to the owner\n    @dev anyone can call this!\n    @param _asset The address of the asset to recover\n    @return bool True if the funds were recovered successfully\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner # dev: no perms\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [owner, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(owner, balance, default_return_value=True) # dev: recovery failed\n    log AgentFundsRecovered(asset=_asset, recipient=owner, balance=balance)\n    return True\n",
            "sha256sum": "2fe48accc65b60fc1e9675a4d0b52db0892400ba62d4ee0f0c200042c0a79304"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AgentTemplate.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "da270e870b1a2e37fac534ea17d9ffa3f84cbaad3890b08122eff90e2c9928f2"
      },
      "args": "00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "AgentFactory": {
      "address": "0x7bA5A18b88fFc9bB569d5A7e311c1607a0737a25",
      "abi": [
        {
          "name": "UserWalletCreated",
          "inputs": [
            {
              "name": "mainAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "configAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "agent",
              "type": "address",
              "indexed": false
            },
            {
              "name": "creator",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentCreated",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "creator",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletTemplateSet",
          "inputs": [
            {
              "name": "template",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserWalletConfigTemplateSet",
          "inputs": [
            {
              "name": "template",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentTemplateSet",
          "inputs": [
            {
              "name": "template",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TrialFundsDataSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "shouldWhitelist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NumUserWalletsAllowedSet",
          "inputs": [
            {
              "name": "numAllowed",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NumAgentsAllowedSet",
          "inputs": [
            {
              "name": "numAllowed",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldEnforceWhitelistSet",
          "inputs": [
            {
              "name": "shouldEnforce",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentBlacklistSet",
          "inputs": [
            {
              "name": "agentAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldBlacklist",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentFactoryFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentFactoryActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "currentUserWalletTemplate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "currentUserWalletConfigTemplate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "currentAgentTemplate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidUserWalletSetup",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createUserWallet",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidUserWalletTemplate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserWalletTemplate",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidUserWalletConfigTemplate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserWalletConfigTemplate",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAgentSetup",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createAgent",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createAgent",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAgentTemplate",
          "inputs": [
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentTemplate",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidTrialFundsData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setTrialFundsData",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWhitelist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldWhitelist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldEnforceWhitelist",
          "inputs": [
            {
              "name": "_shouldEnforce",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumUserWalletsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumUserWalletsAllowed",
          "inputs": [
            {
              "name": "_numAllowed",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumAgentsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumAgentsAllowed",
          "inputs": [
            {
              "name": "_numAllowed",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentBlacklist",
          "inputs": [
            {
              "name": "_agentAddr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverTrialFunds",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverTrialFunds",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_opportunities",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "trialFundsData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userWalletTemplate",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userWalletConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserWallet",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserWallets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentTemplateInfo",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgent",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAgents",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentBlacklist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserWalletsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAgentsAllowed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "whitelist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "shouldEnforceWhitelist",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH_ADDR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_userWalletTemplate",
              "type": "address"
            },
            {
              "name": "_userConfigTemplate",
              "type": "address"
            },
            {
              "name": "_agentTemplate",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "contracts/core/AgentFactory.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\nimport contracts.modules.Governable as gov\nfrom ethereum.ercs import IERC20\n\ninterface MainWallet:\n    def initialize(_walletConfig: address, _addyRegistry: address, _wethAddr: address, _trialFundsAsset: address, _trialFundsInitialAmount: uint256) -> bool: nonpayable\n    def recoverTrialFunds(_opportunities: DynArray[TrialFundsOpp, MAX_LEGOS]) -> bool: nonpayable\n\ninterface WalletConfig:\n    def initialize(_wallet: address, _addyRegistry: address, _owner: address, _initialAgent: address) -> bool: nonpayable\n\ninterface Agent:\n    def initialize(_owner: address) -> bool: nonpayable\n\nstruct TemplateInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n\nstruct TrialFundsData:\n    asset: address\n    amount: uint256\n\nstruct TrialFundsOpp:\n    legoId: uint256\n    vaultToken: address\n\nevent UserWalletCreated:\n    mainAddr: indexed(address)\n    configAddr: indexed(address)\n    owner: indexed(address)\n    agent: address\n    creator: address\n\nevent AgentCreated:\n    agent: indexed(address)\n    owner: indexed(address)\n    creator: address\n\nevent UserWalletTemplateSet:\n    template: indexed(address)\n    version: uint256\n\nevent UserWalletConfigTemplateSet:\n    template: indexed(address)\n    version: uint256\n\nevent AgentTemplateSet:\n    template: indexed(address)\n    version: uint256\n\nevent TrialFundsDataSet:\n    asset: indexed(address)\n    amount: uint256\n\nevent WhitelistSet:\n    addr: address\n    shouldWhitelist: bool\n\nevent NumUserWalletsAllowedSet:\n    numAllowed: uint256\n\nevent NumAgentsAllowedSet:\n    numAllowed: uint256\n\nevent ShouldEnforceWhitelistSet:\n    shouldEnforce: bool\n\nevent AgentBlacklistSet:\n    agentAddr: indexed(address)\n    shouldBlacklist: bool\n\nevent AgentFactoryFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent AgentFactoryActivated:\n    isActivated: bool\n\ntrialFundsData: public(TrialFundsData)\n\n# user wallets\nuserWalletTemplate: public(TemplateInfo)\nuserWalletConfig: public(TemplateInfo)\nisUserWallet: public(HashMap[address, bool])\nnumUserWallets: public(uint256)\n\n# agents\nagentTemplateInfo: public(TemplateInfo)\nisAgent: public(HashMap[address, bool])\nnumAgents: public(uint256)\n\n# limits / controls\nagentBlacklist: public(HashMap[address, bool])\nnumUserWalletsAllowed: public(uint256)\nnumAgentsAllowed: public(uint256)\nwhitelist: public(HashMap[address, bool])\nshouldEnforceWhitelist: public(bool)\n\n# config\nisActivated: public(bool)\nADDY_REGISTRY: public(immutable(address))\nWETH_ADDR: public(immutable(address))\n\nMAX_LEGOS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(\n    _addyRegistry: address,\n    _wethAddr: address,\n    _userWalletTemplate: address,\n    _userConfigTemplate: address,\n    _agentTemplate: address,\n):\n    assert empty(address) not in [_addyRegistry, _wethAddr] # dev: invalid addrs\n    ADDY_REGISTRY = _addyRegistry\n    WETH_ADDR = _wethAddr\n    gov.__init__(_addyRegistry)\n    self.isActivated = True\n\n    # set agent template\n    if self._isValidUserWalletTemplate(_userWalletTemplate) and self._isValidUserWalletConfigTemplate(_userConfigTemplate):\n        self._setUserWalletTemplate(_userWalletTemplate)\n        self._setUserWalletConfigTemplate(_userConfigTemplate)\n\n    # set agent template\n    if self._isValidAgentTemplate(_agentTemplate):\n        self._setAgentTemplate(_agentTemplate)\n\n\n@view\n@external\ndef currentUserWalletTemplate() -> address:\n    \"\"\"\n    @notice Get the current wallet template address being used by the factory\n    @dev This is a simple getter for the current template address stored in userWalletTemplate\n    @return The address of the current wallet template\n    \"\"\"\n    return self.userWalletTemplate.addr\n\n\n@view\n@external\ndef currentUserWalletConfigTemplate() -> address:\n    \"\"\"\n    @notice Get the current wallet config template address being used by the factory\n    @dev This is a simple getter for the current template address stored in userWalletConfig\n    @return The address of the current wallet config template\n    \"\"\"\n    return self.userWalletConfig.addr\n\n\n@view\n@external\ndef currentAgentTemplate() -> address:\n    \"\"\"\n    @notice Get the current agent template address being used by the factory\n    @dev This is a simple getter for the current template address stored in agentTemplateInfo\n    @return The address of the current agent template\n    \"\"\"\n    return self.agentTemplateInfo.addr\n\n\n######################\n# Create User Wallet #\n######################\n\n\n@view\n@external \ndef isValidUserWalletSetup(_owner: address, _agent: address) -> bool:\n    \"\"\"\n    @notice Check if the provided owner and agent addresses form a valid wallet setup\n    @dev Validates that both templates exist and owner/agent combination is valid\n    @param _owner The address that will own the wallet\n    @param _agent The address that will be the agent (can be empty)\n    @return True if the setup is valid, False otherwise\n    \"\"\"\n    return self._isValidUserWalletSetup(self.userWalletTemplate.addr, self.userWalletConfig.addr, _owner, _agent)\n\n\n@view\n@internal \ndef _isValidUserWalletSetup(_mainTemplate: address, _configTemplate: address, _owner: address, _agent: address) -> bool:\n    if _mainTemplate == empty(address) or _configTemplate == empty(address):\n        return False\n    return _owner != empty(address) and _owner != _agent\n\n\n@external\ndef createUserWallet(_owner: address = msg.sender, _agent: address = empty(address)) -> address:\n    \"\"\"\n    @notice Create a new User Wallet with specified owner and optional agent\n    @dev Creates a minimal proxy of the current template and initializes it\n    @param _owner The address that will own the wallet (defaults to msg.sender)\n    @param _agent The address that will be the agent (defaults to empty address, can add this later)\n    @return The address of the newly created wallet, or empty address if setup is invalid\n    \"\"\"\n    assert self.isActivated # dev: not activated\n\n    mainWalletTemplate: address = self.userWalletTemplate.addr\n    walletConfigTemplate: address = self.userWalletConfig.addr\n    if not self._isValidUserWalletSetup(mainWalletTemplate, walletConfigTemplate, _owner, _agent):\n        return empty(address)\n\n    # check limits\n    if self.shouldEnforceWhitelist and not self.whitelist[msg.sender]:\n        return empty(address)\n    if self.numUserWallets >= self.numUserWalletsAllowed:\n        return empty(address)\n\n    # create both contracts (main wallet and wallet config)\n    mainWalletAddr: address = create_minimal_proxy_to(mainWalletTemplate)\n    walletConfigAddr: address = create_minimal_proxy_to(walletConfigTemplate)\n\n    # initial trial funds asset + amount\n    trialFundsData: TrialFundsData = self.trialFundsData\n    if trialFundsData.asset != empty(address):\n        trialFundsData.amount = min(trialFundsData.amount, staticcall IERC20(trialFundsData.asset).balanceOf(self))\n\n    # initalize main wallet and wallet config\n    assert extcall MainWallet(mainWalletAddr).initialize(walletConfigAddr, ADDY_REGISTRY, WETH_ADDR, trialFundsData.asset, trialFundsData.amount) # dev: could not initialize main wallet\n    assert extcall WalletConfig(walletConfigAddr).initialize(mainWalletAddr, ADDY_REGISTRY, _owner, _agent) # dev: could not initialize wallet config\n\n    # transfer after initialization\n    if trialFundsData.amount != 0:\n        assert extcall IERC20(trialFundsData.asset).transfer(mainWalletAddr, trialFundsData.amount, default_return_value=True) # dev: gift transfer failed\n\n    # update data\n    self.isUserWallet[mainWalletAddr] = True\n    self.numUserWallets += 1\n\n    log UserWalletCreated(mainAddr=mainWalletAddr, configAddr=walletConfigAddr, owner=_owner, agent=_agent, creator=msg.sender)\n    return mainWalletAddr\n\n\n#########################\n# User Wallet Templates #\n#########################\n\n\n# main user wallet\n\n\n@view\n@external \ndef isValidUserWalletTemplate(_newAddr: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is valid to be used as a new user wallet template\n    @dev Validates the address is a contract and different from current template\n    @param _newAddr The address to validate as a potential new template\n    @return True if the address can be used as a template, False otherwise\n    \"\"\"\n    return self._isValidUserWalletTemplate(_newAddr)\n\n\n@view\n@internal \ndef _isValidUserWalletTemplate(_newAddr: address) -> bool:\n    if not _newAddr.is_contract or _newAddr == empty(address):\n        return False\n    return _newAddr != self.userWalletTemplate.addr\n\n\n@external\ndef setUserWalletTemplate(_addr: address) -> bool:\n    \"\"\"\n    @notice Set a new main wallet template address for future wallet deployments\n    @dev Only callable by the governor, updates template info and emits event\n    @param _addr The address of the new template to use\n    @return True if template was successfully updated, False if invalid address\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidUserWalletTemplate(_addr):\n        return False\n    return self._setUserWalletTemplate(_addr)\n\n\n@internal\ndef _setUserWalletTemplate(_addr: address) -> bool:   \n    prevData: TemplateInfo = self.userWalletTemplate\n    newData: TemplateInfo = TemplateInfo(\n        addr=_addr,\n        version=prevData.version + 1,\n        lastModified=block.timestamp,\n    )\n    self.userWalletTemplate = newData\n    log UserWalletTemplateSet(template=_addr, version=newData.version)\n    return True\n\n\n# user config\n\n\n@view\n@external \ndef isValidUserWalletConfigTemplate(_newAddr: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is valid to be used as a new user wallet config template\n    @dev Validates the address is a contract and different from current template\n    @param _newAddr The address to validate as a potential new template\n    @return True if the address can be used as a template, False otherwise\n    \"\"\"\n    return self._isValidUserWalletConfigTemplate(_newAddr)\n\n\n@view\n@internal \ndef _isValidUserWalletConfigTemplate(_newAddr: address) -> bool:\n    if not _newAddr.is_contract or _newAddr == empty(address):\n        return False\n    return _newAddr != self.userWalletConfig.addr\n\n\n@external\ndef setUserWalletConfigTemplate(_addr: address) -> bool:\n    \"\"\"\n    @notice Set a new user wallet config template address for future wallet deployments\n    @dev Only callable by the governor, updates template info and emits event\n    @param _addr The address of the new template to use\n    @return True if template was successfully updated, False if invalid address\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidUserWalletConfigTemplate(_addr):\n        return False\n    return self._setUserWalletConfigTemplate(_addr)\n\n\n@internal\ndef _setUserWalletConfigTemplate(_addr: address) -> bool:   \n    prevData: TemplateInfo = self.userWalletConfig\n    newData: TemplateInfo = TemplateInfo(\n        addr=_addr,\n        version=prevData.version + 1,\n        lastModified=block.timestamp,\n    )\n    self.userWalletConfig = newData\n    log UserWalletConfigTemplateSet(template=_addr, version=newData.version)\n    return True\n\n\n################\n# Create Agent #\n################\n\n\n@view\n@external \ndef isValidAgentSetup(_owner: address) -> bool:\n    \"\"\"\n    @notice Check if the provided owner address forms a valid agent setup\n    @dev Validates that the template exists and owner is not empty\n    @param _owner The address that will own the agent\n    @return True if the setup is valid, False otherwise\n    \"\"\"\n    return self._isValidAgentSetup(self.agentTemplateInfo.addr, _owner)\n\n\n@view\n@internal \ndef _isValidAgentSetup(_agentTemplateInfo: address, _owner: address) -> bool:\n    if _agentTemplateInfo == empty(address):\n        return False\n    return _owner != empty(address)\n\n\n@external\ndef createAgent(_owner: address = msg.sender) -> address:\n    \"\"\"\n    @notice Create a new Agent with specified owner\n    @dev Creates a minimal proxy of the current template and initializes it\n    @param _owner The address that will own the agent (defaults to msg.sender)\n    @return The address of the newly created agent, or empty address if setup is invalid\n    \"\"\"\n    assert self.isActivated # dev: not activated\n\n    agentTemplateInfo: address = self.agentTemplateInfo.addr\n    if not self._isValidAgentSetup(agentTemplateInfo, _owner):\n        return empty(address)\n\n    # check limits\n    if self.shouldEnforceWhitelist and not self.whitelist[msg.sender]:\n        return empty(address)\n    if self.numAgents >= self.numAgentsAllowed:\n        return empty(address)\n\n    # create agent contract\n    agentAddr: address = create_minimal_proxy_to(agentTemplateInfo)\n    assert extcall Agent(agentAddr).initialize(_owner) # dev: could not initialize agent\n\n    # update data\n    self.isAgent[agentAddr] = True\n    self.numAgents += 1\n\n    log AgentCreated(agent=agentAddr, owner=_owner, creator=msg.sender)\n    return agentAddr\n\n\n# agent template\n\n\n@view\n@external \ndef isValidAgentTemplate(_newAddr: address) -> bool:\n    \"\"\"\n    @notice Check if a given address is valid to be used as a new agent template\n    @dev Validates the address is a contract and different from current template\n    @param _newAddr The address to validate as a potential new template\n    @return True if the address can be used as a template, False otherwise\n    \"\"\"\n    return self._isValidAgentTemplate(_newAddr)\n\n\n@view\n@internal \ndef _isValidAgentTemplate(_newAddr: address) -> bool:\n    if not _newAddr.is_contract or _newAddr == empty(address):\n        return False\n    return _newAddr != self.agentTemplateInfo.addr\n\n\n@external\ndef setAgentTemplate(_addr: address) -> bool:\n    \"\"\"\n    @notice Set a new agent template address for future agent deployments\n    @dev Only callable by the governor, updates template info and emits event\n    @param _addr The address of the new template to use\n    @return True if template was successfully updated, False if invalid address\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidAgentTemplate(_addr):\n        return False\n    return self._setAgentTemplate(_addr)\n\n\n@internal\ndef _setAgentTemplate(_addr: address) -> bool:   \n    prevData: TemplateInfo = self.agentTemplateInfo\n    newData: TemplateInfo = TemplateInfo(\n        addr=_addr,\n        version=prevData.version + 1,\n        lastModified=block.timestamp,\n    )\n    self.agentTemplateInfo = newData\n    log AgentTemplateSet(template=_addr, version=newData.version)\n    return True\n\n\n###############\n# Trial Funds #\n###############\n\n\n@view\n@external \ndef isValidTrialFundsData(_asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Check if the provided asset and amount form a valid trial funds setup\n    @dev Validates that the asset is a contract and amount is not zero\n    @param _asset The address of the asset to validate\n    @param _amount The amount of the asset to validate\n    @return True if the setup is valid, False otherwise\n    \"\"\"\n    return self._isValidTrialFundsData(_asset, _amount)\n\n\n@view\n@internal \ndef _isValidTrialFundsData(_asset: address, _amount: uint256) -> bool:\n    if not _asset.is_contract or _asset == empty(address):\n        return False\n    return _amount != 0\n\n\n@external\ndef setTrialFundsData(_asset: address, _amount: uint256) -> bool:\n    \"\"\"\n    @notice Set the trial funds asset and amount for future wallet deployments\n    @dev Only callable by the governor, updates the trial funds data\n    @param _asset The address of the asset to set\n    @param _amount The amount of the asset to set\n    @return True if the data was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidTrialFundsData(_asset, _amount):\n        return False\n\n    self.trialFundsData = TrialFundsData(\n        asset=_asset,\n        amount=_amount,\n    )\n    log TrialFundsDataSet(asset=_asset, amount=_amount)\n    return True\n\n\n########################\n# Whitelist and Limits #\n########################\n\n\n@external\ndef setWhitelist(_addr: address, _shouldWhitelist: bool) -> bool:\n    \"\"\"\n    @notice Set the whitelist status for a given address\n    @dev Only callable by the governor, updates the whitelist state\n    @param _addr The address to set the whitelist status for\n    @param _shouldWhitelist True to whitelist, False to unwhitelist\n    @return True if the whitelist status was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.whitelist[_addr] = _shouldWhitelist\n    log WhitelistSet(addr=_addr, shouldWhitelist=_shouldWhitelist)\n    return True\n\n\n@external\ndef setShouldEnforceWhitelist(_shouldEnforce: bool) -> bool:\n    \"\"\"\n    @notice Set whether to enforce the whitelist for agent/wallet creation\n    @dev Only callable by the governor, updates the whitelist enforcement state\n    @param _shouldEnforce True to enforce whitelist, False to disable\n    @return True if the whitelist enforcement state was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.shouldEnforceWhitelist = _shouldEnforce\n    log ShouldEnforceWhitelistSet(shouldEnforce=_shouldEnforce)\n    return True\n\n\n@external\ndef setNumUserWalletsAllowed(_numAllowed: uint256 = max_value(uint256)) -> bool:\n    \"\"\"\n    @notice Set the maximum number of user wallets allowed\n    @dev Only callable by the governor, updates the maximum number of user wallets\n    @param _numAllowed The new maximum number of user wallets allowed\n    @return True if the maximum number was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.numUserWalletsAllowed = _numAllowed\n    log NumUserWalletsAllowedSet(numAllowed=_numAllowed)\n    return True\n\n\n@external\ndef setNumAgentsAllowed(_numAllowed: uint256 = max_value(uint256)) -> bool:\n    \"\"\"\n    @notice Set the maximum number of agents allowed\n    @dev Only callable by the governor, updates the maximum number of agents\n    @param _numAllowed The new maximum number of agents allowed\n    @return True if the maximum number was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.numAgentsAllowed = _numAllowed\n    log NumAgentsAllowedSet(numAllowed=_numAllowed)\n    return True\n\n\n###################\n# Agent Blacklist #\n###################\n\n\n@external\ndef setAgentBlacklist(_agentAddr: address, _shouldBlacklist: bool) -> bool:\n    \"\"\"\n    @notice Set the blacklist status for a given agent address\n    @dev Only callable by the governor, updates the blacklist state\n    @param _agentAddr The address to set the blacklist status for\n    @param _shouldBlacklist True to blacklist, False to unblacklist\n    @return True if the blacklist status was successfully updated, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.agentBlacklist[_agentAddr] = _shouldBlacklist\n    log AgentBlacklistSet(agentAddr=_agentAddr, shouldBlacklist=_shouldBlacklist)\n    return True\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    \"\"\"\n    @notice Recover funds from the factory\n    @dev Only callable by the governor, transfers funds to the recipient\n    @param _asset The address of the asset to recover\n    @param _recipient The address to send the funds to\n    @return True if the funds were successfully recovered, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [_recipient, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log AgentFactoryFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n    return True\n\n\n@external\ndef recoverTrialFunds(_wallet: address, _opportunities: DynArray[TrialFundsOpp, MAX_LEGOS] = []) -> bool:\n    \"\"\"\n    @notice Recover trial funds from a wallet\n    @dev Only callable by the governor, transfers funds back here\n    @param _wallet The address of the wallet to recover funds from\n    @param _opportunities The list of opportunities to recover funds for\n    @return True if the funds were successfully recovered, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    return extcall MainWallet(_wallet).recoverTrialFunds(_opportunities)\n\n\n############\n# Activate #\n############\n\n\n@external\ndef activate(_shouldActivate: bool):\n    \"\"\"\n    @notice Enable or disable the factory's ability to create new wallets\n    @dev Only callable by the governor, toggles isActivated state\n    @param _shouldActivate True to activate the factory, False to deactivate\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    self.isActivated = _shouldActivate\n    log AgentFactoryActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "b01321a023b578eb66baa299a3ebfa10ba76291003920a8ce78e3f5893f83a5e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AgentFactory.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "1034e89b55f9abbc35b9f4aaedcde2f01ef371c56064004dd3d24dbdc4b58e87"
      },
      "args": "00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd00000000000000000000000042000000000000000000000000000000000000060000000000000000000000006a5263b0645c7dfd2788ef46f95f210e947e074300000000000000000000000045d1a9429fd603c13cdab685dc2540f4f57df46400000000000000000000000070418b3aaa1044ec8bff6a461b4e43460bb5699e"
    },
    "LegoRegistry": {
      "address": "0x590504539913411CeF7fc1b3Fa49b06FE970c759",
      "abi": [
        {
          "name": "NewLegoRegistered",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "legoType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoAddrUpdated",
          "inputs": [
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "legoType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoAddrDisabled",
          "inputs": [
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "legoType",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LegoHelperSet",
          "inputs": [
            {
              "name": "helperAddr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewLego",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            },
            {
              "name": "_legoType",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoUpdate",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoDisable",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoId",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoAddr",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoInfo",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "legoType",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLegoDescription",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumLegos",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastLegoAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastLegoId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingAsset",
          "inputs": [
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLegoHelper",
          "inputs": [
            {
              "name": "_helperAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLegoHelper",
          "inputs": [
            {
              "name": "_helperAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoHelper",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "legoType",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "legoAddrToId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numLegos",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "interfaces/LegoYield.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n# yield opportunities\n\n@external\ndef depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256):\n    ...\n\n@external\ndef withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n# used in smart contracts\n\n@view\n@external\ndef getAssetOpportunities(_asset: address) -> DynArray[address, 15]:\n    ...\n\n@view\n@external\ndef getUnderlyingAmount(_vaultToken: address, _vaultTokenAmount: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    ...\n\n# helper functions for server\n\n@view\n@external\ndef getAssets() -> DynArray[address, 25]:\n    ...\n\n@view\n@external\ndef isVaultToken(_vaultToken: address) -> bool:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef getUsdValueOfVaultToken(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getUnderlyingData(_vaultToken: address, _vaultTokenAmount: uint256, _oracleRegistry: address = empty(address)) -> (address, uint256, uint256):\n    ...\n\n@view\n@external\ndef totalAssets(_vaultToken: address) -> uint256:\n    ...\n\n@view\n@external\ndef totalBorrows(_vaultToken: address) -> uint256:\n    ...\n",
            "sha256sum": "72838901991ac97326e31d942c6b7982934d6dccaf7d0bb49cb5f7bae06b14cc"
          },
          "interfaces/LegoCommon.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getRegistries() -> DynArray[address, 10]:\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address) -> (address, String[64], uint256):\n    ...\n\n# rewards\n\n@external\ndef claimRewards(\n    _user: address,\n    _market: address,\n    _rewardToken: address,\n    _rewardAmount: uint256,\n    _proof: bytes32,\n):\n    ...\n\n# config\n\n@external\ndef recoverFunds(_asset: address, _recipient: address) -> bool:\n    ...\n\n@view\n@external\ndef legoId() -> uint256:\n    ...\n\n@external\ndef setLegoId(_legoId: uint256) -> bool:\n    ...\n\n\n# used by server\n\n@view\n@external\ndef hasClaimableRewards(_user: address) -> bool:\n    ...\n",
            "sha256sum": "b38ecbae249c08406509348832e1242f57aadac0d38fafd2a02653ff2e76f829"
          },
          "contracts/core/LegoRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\n\nfrom ethereum.ercs import IERC20\nimport contracts.modules.Governable as gov\nfrom interfaces import LegoYield\nfrom interfaces import LegoCommon\n\nflag LegoType:\n    YIELD_OPP\n    DEX\n\nstruct LegoInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n    legoType: LegoType\n\nevent NewLegoRegistered:\n    addr: indexed(address)\n    legoId: uint256\n    description: String[64]\n    legoType: LegoType\n\nevent LegoAddrUpdated:\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    legoId: uint256\n    version: uint256\n    description: String[64]\n    legoType: LegoType\n\nevent LegoAddrDisabled:\n    prevAddr: indexed(address)\n    legoId: uint256\n    version: uint256\n    description: String[64]\n    legoType: LegoType\n\nevent LegoHelperSet:\n    helperAddr: indexed(address)\n\n# other\nlegoHelper: public(address)\n\n# registry core\nlegoInfo: public(HashMap[uint256, LegoInfo])\nlegoAddrToId: public(HashMap[address, uint256])\nnumLegos: public(uint256)\n\n# config\nADDY_REGISTRY: public(immutable(address))\n\nMAX_VAULTS: constant(uint256) = 15\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    gov.__init__(_addyRegistry)\n    ADDY_REGISTRY = _addyRegistry\n\n    # start at 1 index\n    self.numLegos = 1\n\n\n#################\n# Register Lego #\n#################\n\n\n@view\n@external\ndef isValidNewLegoAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be registered as a new Lego integration\n    @dev Validates address is non-zero, is a contract, and hasn't been registered before\n    @param _addr The address to validate\n    @return True if address can be registered as new Lego, False otherwise\n    \"\"\"\n    return self._isValidNewLegoAddr(_addr)\n\n\n@view\n@internal\ndef _isValidNewLegoAddr(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.legoAddrToId[_addr] == 0\n\n\n@external\ndef registerNewLego(_addr: address, _description: String[64], _legoType: LegoType) -> uint256:\n    \"\"\"\n    @notice Register a new Lego integration contract in the registry\n    @dev Only callable by governor. Sets Lego ID on the contract.\n    @param _addr The address of the Lego contract to register\n    @param _description A brief description of the Lego integration's functionality\n    @param _legoType The type of Lego integration\n    @return The assigned Lego ID if registration successful, 0 if failed\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidNewLegoAddr(_addr):\n        return 0\n\n    data: LegoInfo = LegoInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=_description,\n        legoType=_legoType,\n    )\n\n    legoId: uint256 = self.numLegos\n    self.legoAddrToId[_addr] = legoId\n    self.numLegos = legoId + 1\n    self.legoInfo[legoId] = data\n    assert extcall LegoCommon(_addr).setLegoId(legoId) # dev: set id failed\n\n    log NewLegoRegistered(addr=_addr, legoId=legoId, description=_description, legoType=_legoType)\n    return legoId\n\n\n###############\n# Update Lego #\n###############\n\n\n@view\n@external\ndef isValidLegoUpdate(_legoId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Check if a Lego integration update operation would be valid\n    @dev Validates Lego ID exists and new address is valid\n    @param _legoId The ID of the Lego integration to update\n    @param _newAddr The proposed new address for the Lego integration\n    @return True if update would be valid, False otherwise\n    \"\"\"\n    return self._isValidLegoUpdate(_legoId, _newAddr, self.legoInfo[_legoId].addr)\n\n\n@view\n@internal\ndef _isValidLegoUpdate(_legoId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidLegoId(_legoId):\n        return False\n    if not self._isValidNewLegoAddr(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@external\ndef updateLegoAddr(_legoId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Update the address of an existing Lego\n    @dev Only callable by governor. Updates version and timestamp.\n    @param _legoId The ID of the Lego to update\n    @param _newAddr The new address for the Lego\n    @return True if update successful, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    data: LegoInfo = self.legoInfo[_legoId]\n    prevAddr: address = data.addr # needed for later\n\n    if not self._isValidLegoUpdate(_legoId, _newAddr, prevAddr):\n        return False\n\n    # save new data\n    data.addr = _newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.legoInfo[_legoId] = data\n    self.legoAddrToId[_newAddr] = _legoId\n    assert extcall LegoCommon(_newAddr).setLegoId(_legoId) # dev: set id failed\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.legoAddrToId[prevAddr] = 0\n\n    log LegoAddrUpdated(newAddr=_newAddr, prevAddr=prevAddr, legoId=_legoId, version=data.version, description=data.description, legoType=data.legoType)\n    return True\n\n\n################\n# Disable Lego #\n################\n\n\n@view\n@external\ndef isValidLegoDisable(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Check if a Lego can be disabled\n    @dev Validates Lego ID exists and has a non-empty address\n    @param _legoId The ID of the Lego to check\n    @return True if Lego can be disabled, False otherwise\n    \"\"\"\n    return self._isValidLegoDisable(_legoId, self.legoInfo[_legoId].addr)\n\n\n@view\n@internal\ndef _isValidLegoDisable(_legoId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidLegoId(_legoId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@external\ndef disableLegoAddr(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Disable a Lego by setting its address to empty\n    @dev Only callable by governor. Updates version and timestamp.\n    @param _legoId The ID of the Lego to disable\n    @return True if disable successful, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    data: LegoInfo = self.legoInfo[_legoId]\n    prevAddr: address = data.addr # needed for later\n\n    if not self._isValidLegoDisable(_legoId, prevAddr):\n        return False\n\n    # save new data\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.legoInfo[_legoId] = data\n    self.legoAddrToId[prevAddr] = 0\n\n    log LegoAddrDisabled(prevAddr=prevAddr, legoId=_legoId, version=data.version, description=data.description, legoType=data.legoType)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidLegoAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address is a registered Lego integration\n    @dev Returns true if address has a non-zero Lego ID\n    @param _addr The address to check\n    @return True if address is a registered Lego integration, False otherwise\n    \"\"\"\n    return self.legoAddrToId[_addr] != 0\n\n\n@view\n@external\ndef isValidLegoId(_legoId: uint256) -> bool:\n    \"\"\"\n    @notice Check if a Lego ID is valid\n    @dev ID must be non-zero and less than total number of Legos\n    @param _legoId The ID to check\n    @return True if ID is valid, False otherwise\n    \"\"\"\n    return self._isValidLegoId(_legoId)\n\n\n@view\n@internal\ndef _isValidLegoId(_legoId: uint256) -> bool:\n    return _legoId != 0 and _legoId < self.numLegos\n\n\n# lego getters\n\n\n@view\n@external\ndef getLegoId(_addr: address) -> uint256:\n    \"\"\"\n    @notice Get the ID of a Lego from its address\n    @dev Returns 0 if address is not registered\n    @param _addr The address to query\n    @return The Lego ID associated with the address\n    \"\"\"\n    return self.legoAddrToId[_addr]\n\n\n@view\n@external\ndef getLegoAddr(_legoId: uint256) -> address:\n    \"\"\"\n    @notice Get the address of a Lego from its ID\n    @dev Returns empty address if ID is invalid or Lego is disabled\n    @param _legoId The ID to query\n    @return The address associated with the Lego ID\n    \"\"\"\n    return self.legoInfo[_legoId].addr\n\n\n@view\n@external\ndef getLegoInfo(_legoId: uint256) -> LegoInfo:\n    \"\"\"\n    @notice Get all information about a Lego\n    @dev Returns complete LegoInfo struct including address, version, timestamp and description\n    @param _legoId The ID to query\n    @return LegoInfo struct containing all Lego information\n    \"\"\"\n    return self.legoInfo[_legoId]\n\n\n@view\n@external\ndef getLegoDescription(_legoId: uint256) -> String[64]:\n    \"\"\"\n    @notice Get the description of a Lego\n    @dev Returns empty string if ID is invalid\n    @param _legoId The ID to query\n    @return The description associated with the Lego ID\n    \"\"\"\n    return self.legoInfo[_legoId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumLegos() -> uint256:\n    \"\"\"\n    @notice Get the total number of registered Legos\n    @dev Returns number of Legos minus 1 since indexing starts at 1\n    @return The total number of registered Legos\n    \"\"\"\n    return self.numLegos - 1\n\n\n@view\n@external\ndef getLastLegoAddr() -> address:\n    \"\"\"\n    @notice Get the address of the most recently registered Lego\n    @dev Returns the address at index (numLegos - 1)\n    @return The address of the last registered Lego\n    \"\"\"\n    lastIndex: uint256 = self.numLegos - 1\n    return self.legoInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastLegoId() -> uint256:\n    \"\"\"\n    @notice Get the ID of the most recently registered Lego\n    @dev Returns numLegos - 1 since indexing starts at 1\n    @return The ID of the last registered Lego\n    \"\"\"\n    return self.numLegos - 1\n\n\n# underlying asset\n\n\n@view\n@external\ndef getUnderlyingAsset(_vaultToken: address) -> address:\n    \"\"\"\n    @notice Get the underlying asset for a vault token\n    @dev Returns empty address if vault token is not registered\n    @param _vaultToken The address of the vault token to query\n    @return The underlying asset address\n    \"\"\"\n    if _vaultToken == empty(address):\n        return empty(address)\n\n    numLegos: uint256 = self.numLegos\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: LegoInfo = self.legoInfo[i]\n        if legoInfo.legoType != LegoType.YIELD_OPP:\n            continue\n\n        asset: address = staticcall LegoYield(legoInfo.addr).getUnderlyingAsset(_vaultToken)\n        if asset != empty(address):\n            return asset\n\n    return empty(address)\n\n\n@view\n@external\ndef getUnderlyingForUser(_user: address, _asset: address) -> uint256:\n    \"\"\"\n    @notice Get the total underlying amount for a user in a given asset\n    @dev Returns 0 if user or asset is empty\n    @param _user The address of the user to query\n    @param _asset The address of the asset to query\n    \"\"\"\n    if empty(address) in [_user, _asset]:\n        return 0\n\n    totalDeposited: uint256 = 0\n    numLegos: uint256 = self.numLegos\n    for i: uint256 in range(1, numLegos, bound=max_value(uint256)):\n        legoInfo: LegoInfo = self.legoInfo[i]\n        if legoInfo.legoType != LegoType.YIELD_OPP:\n            continue\n\n        legoVaultTokens: DynArray[address, MAX_VAULTS] = staticcall LegoYield(legoInfo.addr).getAssetOpportunities(_asset)\n        if len(legoVaultTokens) == 0:\n            continue\n\n        for vaultToken: address in legoVaultTokens:\n            if vaultToken == empty(address):\n                continue\n            vaultTokenBal: uint256 = staticcall IERC20(vaultToken).balanceOf(_user)\n            if vaultTokenBal != 0:\n                totalDeposited += staticcall LegoYield(legoInfo.addr).getUnderlyingAmount(vaultToken, vaultTokenBal)\n\n    return totalDeposited\n\n\n###############\n# Lego Helper #\n###############\n\n\n@view\n@external \ndef isValidLegoHelper(_helperAddr: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be set as the Lego helper\n    @dev Address must be a contract and different from current helper\n    @param _helperAddr The address to validate\n    @return True if address can be set as helper, False otherwise\n    \"\"\"\n    return self._isValidLegoHelper(_helperAddr)\n\n\n@view\n@internal \ndef _isValidLegoHelper(_helperAddr: address) -> bool:\n    if not _helperAddr.is_contract or _helperAddr == empty(address):\n        return False\n    return _helperAddr != self.legoHelper\n\n\n@external\ndef setLegoHelper(_helperAddr: address) -> bool:\n    \"\"\"\n    @notice Set a new Lego helper address\n    @dev Only callable by governor\n    @param _helperAddr The address to set as helper\n    @return True if helper was set successfully, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidLegoHelper(_helperAddr):\n        return False\n    self.legoHelper = _helperAddr\n    log LegoHelperSet(helperAddr=_helperAddr)\n    return True\n\n",
            "sha256sum": "819f09f47f6151e40d99f13be567a0ca38ba2f2e236ecdc324e67d8449044f0a"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/LegoRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "4ed23b01ff8fab15c00e137230ef340b2c1014f684b8845f930bc00d88f3a42a"
      },
      "args": "00000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "OracleRegistry": {
      "address": "0xc56add9377Bc3a39f1B928Abc7440E43B6b10e1f",
      "abi": [
        {
          "name": "NewOraclePartnerRegistered",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "oraclePartnerId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OraclePartnerAddrUpdated",
          "inputs": [
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "oraclePartnerId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OraclePartnerAddrDisabled",
          "inputs": [
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "oraclePartnerId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriorityOraclePartnerIdsModified",
          "inputs": [
            {
              "name": "numIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StaleTimeSet",
          "inputs": [
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewOraclePartnerAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "registerNewOraclePartner",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerUpdate",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerDisable",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disableOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriorityOraclePartnerIds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "areValidPriorityOraclePartnerIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityOraclePartnerIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidStaleTime",
          "inputs": [
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStaleTime",
          "inputs": [
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidOraclePartnerId",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerAddr",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerInfo",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getOraclePartnerDescription",
          "inputs": [
            {
              "name": "_oracleId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumOraclePartners",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastOraclePartnerAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastOraclePartnerId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "oraclePartnerAddrToId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numOraclePartners",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priorityOraclePartnerIds",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "staleTime",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_STALE_TIME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_STALE_TIME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_minStaleTime",
              "type": "uint256"
            },
            {
              "name": "_maxStaleTime",
              "type": "uint256"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/OraclePartnerInterface.vyi": {
            "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n# config\n\n@view\n@external\ndef oraclePartnerId() -> uint256:\n    ...\n\n@external\ndef setOraclePartnerId(_oracleId: uint256) -> bool:\n    ...\n\n@view\n@external\ndef getConfiguredAssets() -> DynArray[address, 50]:\n    ...\n",
            "sha256sum": "fcaef4c5618d9e5654f8854e35cd5b7ab6a4b7761017a03d678991334c78474b"
          },
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "contracts/core/OracleRegistry.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\n\nfrom ethereum.ercs import IERC20Detailed\nimport interfaces.OraclePartnerInterface as OraclePartner\nimport contracts.modules.Governable as gov\n\nstruct OraclePartnerInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nevent NewOraclePartnerRegistered:\n    addr: indexed(address)\n    oraclePartnerId: uint256\n    description: String[64]\n\nevent OraclePartnerAddrUpdated:\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    oraclePartnerId: uint256\n    version: uint256\n    description: String[64]\n\nevent OraclePartnerAddrDisabled:\n    prevAddr: indexed(address)\n    oraclePartnerId: uint256\n    version: uint256\n    description: String[64]\n\nevent PriorityOraclePartnerIdsModified:\n    numIds: uint256\n\nevent StaleTimeSet:\n    staleTime: uint256\n\n# registry core\noraclePartnerInfo: public(HashMap[uint256, OraclePartnerInfo])\noraclePartnerAddrToId: public(HashMap[address, uint256])\nnumOraclePartners: public(uint256)\n\n# custom config\npriorityOraclePartnerIds: public(DynArray[uint256, MAX_PRIORITY_PARTNERS])\nstaleTime: public(uint256)\n\n# config\nADDY_REGISTRY: public(immutable(address))\n\nETH: public(immutable(address))\nMIN_STALE_TIME: public(immutable(uint256))\nMAX_STALE_TIME: public(immutable(uint256))\n\nMAX_PRIORITY_PARTNERS: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_ethAddr: address, _minStaleTime: uint256, _maxStaleTime: uint256, _addyRegistry: address):\n    assert empty(address) not in [_ethAddr, _addyRegistry] # dev: invalid addy registry\n    gov.__init__(_addyRegistry)\n\n    ETH = _ethAddr\n    MIN_STALE_TIME = _minStaleTime\n    MAX_STALE_TIME = _maxStaleTime\n    ADDY_REGISTRY = _addyRegistry\n\n    # start at 1 index\n    self.numOraclePartners = 1\n\n\n#########\n# Price #\n#########\n\n\n@view\n@external\ndef getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Get the USD price of an asset from registered oracle partners\n    @dev Checks priority partners first, then others. Returns 0 if no valid price found.\n    @param _asset The address of the asset to get price for\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The asset price in USD with 18 decimals\n    \"\"\"\n    if _asset == empty(address):\n        return 0\n    return self._getPrice(_asset, _shouldRaise)\n\n\n@view\n@internal\ndef _getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    price: uint256 = 0\n    hasFeedConfig: bool = False\n    alreadyLooked: DynArray[uint256, MAX_PRIORITY_PARTNERS] = []\n    staleTime: uint256 = self.staleTime\n\n    # go thru priority partners first\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self.priorityOraclePartnerIds\n    for i: uint256 in range(len(priorityIds), bound=MAX_PRIORITY_PARTNERS):\n        pid: uint256 = priorityIds[i]\n        hasFeed: bool = False\n        price, hasFeed = self._getPriceFromOraclePartner(pid, _asset, staleTime)\n        if price != 0:\n            break\n        if hasFeed:\n            hasFeedConfig = True\n        alreadyLooked.append(pid)\n\n    # go thru rest of oracle partners\n    if price == 0:\n        numSources: uint256 = self.numOraclePartners\n        for id: uint256 in range(1, numSources, bound=max_value(uint256)):\n            if id in alreadyLooked:\n                continue\n            hasFeed: bool = False\n            price, hasFeed = self._getPriceFromOraclePartner(id, _asset, staleTime)\n            if price != 0:\n                break\n            if hasFeed:\n                hasFeedConfig = True\n\n    # raise exception if feed exists but no price\n    if price == 0 and hasFeedConfig and _shouldRaise:\n        raise \"has price config, no price\"\n\n    return price\n\n\n@view\n@internal\ndef _getPriceFromOraclePartner(_pid: uint256, _asset: address, _staleTime: uint256) -> (uint256, bool):\n    oraclePartner: address = self.oraclePartnerInfo[_pid].addr\n    if oraclePartner == empty(address):\n        return 0, False\n    return staticcall OraclePartner(oraclePartner).getPriceAndHasFeed(_asset, _staleTime, self)\n\n\n# other utils\n\n\n@view\n@external\ndef getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the USD value of a given amount of an asset\n    @dev Accounts for asset decimals in calculation. Returns 0 if no valid price.\n    @param _asset The address of the asset\n    @param _amount The amount of the asset\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The USD value with 18 decimals\n    \"\"\"\n    if _amount == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return price * _amount // (10 ** decimals)\n\n\n@view\n@external\ndef getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the amount of an asset worth a given USD value\n    @dev Accounts for asset decimals in calculation. Returns 0 if no valid price.\n    @param _asset The address of the asset\n    @param _usdValue The USD value to convert to asset amount (18 decimals)\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The amount of the asset\n    \"\"\"\n    if _usdValue == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return _usdValue * (10 ** decimals) // price\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    \"\"\"\n    @notice Check if any oracle partner has a price feed for the asset\n    @dev Iterates through all registered oracle partners\n    @param _asset The address of the asset to check\n    @return True if a price feed exists, False otherwise\n    \"\"\"\n    numSources: uint256 = self.numOraclePartners\n    for id: uint256 in range(1, numSources, bound=max_value(uint256)):\n        oraclePartner: address = self.oraclePartnerInfo[id].addr\n        if oraclePartner == empty(address):\n            continue\n        if staticcall OraclePartner(oraclePartner).hasPriceFeed(_asset):\n            return True\n    return False\n\n\n@view\n@external\ndef getEthUsdValue(_amount: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the USD value of a given amount of ETH\n    @dev Uses ETH price feed. Returns 0 if no valid price.\n    @param _amount The amount of ETH in wei\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The USD value with 18 decimals\n    \"\"\"\n    if _amount == 0:\n        return 0\n    return self._getPrice(ETH, _shouldRaise) * _amount // (10 ** 18)\n\n\n@view\n@external\ndef getEthAmount(_usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    \"\"\"\n    @notice Calculate the amount of ETH worth a given USD value\n    @dev Uses ETH price feed. Returns 0 if no valid price.\n    @param _usdValue The USD value to convert to ETH amount (18 decimals)\n    @param _shouldRaise If True, raises an error when price feed exists but returns no price\n    @return The amount of ETH in wei\n    \"\"\"\n    if _usdValue == 0:\n        return 0\n    price: uint256 = self._getPrice(ETH, _shouldRaise)\n    if price == 0:\n        return 0\n    return _usdValue * (10 ** 18) // price\n\n\n###########################\n# Register Oracle Partner #\n###########################\n\n\n@view\n@external\ndef isValidNewOraclePartnerAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address can be registered as a new oracle partner\n    @dev Validates address is non-zero, is a contract, and hasn't been registered before\n    @param _addr The address to validate\n    @return True if address can be registered as new oracle partner, False otherwise\n    \"\"\"\n    return self._isValidNewOraclePartnerAddr(_addr)\n\n\n@view\n@internal\ndef _isValidNewOraclePartnerAddr(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.oraclePartnerAddrToId[_addr] == 0\n\n\n@external\ndef registerNewOraclePartner(_addr: address, _description: String[64]) -> uint256:\n    \"\"\"\n    @notice Register a new oracle partner contract in the registry\n    @dev Sets oracle partner ID on the contract.\n    @param _addr The address of the oracle partner contract to register\n    @param _description A brief description of the oracle partner's functionality\n    @return The assigned oracle partner ID if registration successful, 0 if failed\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidNewOraclePartnerAddr(_addr):\n        return 0\n\n    data: OraclePartnerInfo = OraclePartnerInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=_description,\n    )\n\n    oraclePartnerId: uint256 = self.numOraclePartners\n    self.oraclePartnerAddrToId[_addr] = oraclePartnerId\n    self.numOraclePartners = oraclePartnerId + 1\n    self.oraclePartnerInfo[oraclePartnerId] = data\n    assert extcall OraclePartner(_addr).setOraclePartnerId(oraclePartnerId) # dev: set id failed\n\n    log NewOraclePartnerRegistered(addr=_addr, oraclePartnerId=oraclePartnerId, description=_description)\n    return oraclePartnerId\n\n\n#########################\n# Update Oracle Partner #\n#########################\n\n\n@view\n@external\ndef isValidOraclePartnerUpdate(_oracleId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Check if an oracle partner update operation would be valid\n    @dev Validates oracle ID exists and new address is valid\n    @param _oracleId The ID of the oracle partner to update\n    @param _newAddr The proposed new address for the oracle partner\n    @return True if update would be valid, False otherwise\n    \"\"\"\n    return self._isValidOraclePartnerUpdate(_oracleId, _newAddr, self.oraclePartnerInfo[_oracleId].addr)\n\n\n@view\n@internal\ndef _isValidOraclePartnerUpdate(_oracleId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidOraclePartnerId(_oracleId):\n        return False\n    if not self._isValidNewOraclePartnerAddr(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n@external\ndef updateOraclePartnerAddr(_oracleId: uint256, _newAddr: address) -> bool:\n    \"\"\"\n    @notice Update the address of an existing oracle partner\n    @dev Updates version and timestamp.\n    @param _oracleId The ID of the oracle partner to update\n    @param _newAddr The new address for the oracle partner\n    @return True if update successful, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    data: OraclePartnerInfo = self.oraclePartnerInfo[_oracleId]\n    prevAddr: address = data.addr # needed for later\n\n    if not self._isValidOraclePartnerUpdate(_oracleId, _newAddr, prevAddr):\n        return False\n\n    # save new data\n    data.addr = _newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.oraclePartnerInfo[_oracleId] = data\n    self.oraclePartnerAddrToId[_newAddr] = _oracleId\n    assert extcall OraclePartner(_newAddr).setOraclePartnerId(_oracleId) # dev: set id failed\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.oraclePartnerAddrToId[prevAddr] = 0\n\n    log OraclePartnerAddrUpdated(newAddr=_newAddr, prevAddr=prevAddr, oraclePartnerId=_oracleId, version=data.version, description=data.description)\n    return True\n\n\n##########################\n# Disable Oracle Partner #\n##########################\n\n\n@view\n@external\ndef isValidOraclePartnerDisable(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Check if an oracle partner can be disabled\n    @dev Validates oracle ID exists and has a non-empty address\n    @param _oracleId The ID of the oracle partner to check\n    @return True if oracle partner can be disabled, False otherwise\n    \"\"\"\n    return self._isValidOraclePartnerDisable(_oracleId, self.oraclePartnerInfo[_oracleId].addr)\n\n\n@view\n@internal\ndef _isValidOraclePartnerDisable(_oracleId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidOraclePartnerId(_oracleId):\n        return False\n    return _prevAddr != empty(address)\n\n\n@external\ndef disableOraclePartnerAddr(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Disable an oracle partner by setting its address to empty\n    @dev Updates version and timestamp.\n    @param _oracleId The ID of the oracle partner to disable\n    @return True if disable successful, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    data: OraclePartnerInfo = self.oraclePartnerInfo[_oracleId]\n    prevAddr: address = data.addr # needed for later\n\n    if not self._isValidOraclePartnerDisable(_oracleId, prevAddr):\n        return False\n\n    # save new data\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.oraclePartnerInfo[_oracleId] = data\n    self.oraclePartnerAddrToId[prevAddr] = 0\n\n    log OraclePartnerAddrDisabled(prevAddr=prevAddr, oraclePartnerId=_oracleId, version=data.version, description=data.description)\n    return True\n\n\n############################\n# Priority Oracle Partners #\n############################\n\n\n@view \n@external \ndef getPriorityOraclePartnerIds() -> DynArray[uint256, MAX_PRIORITY_PARTNERS]:\n    \"\"\"\n    @notice Get the list of priority oracle partner IDs\n    @dev Returns ordered list of IDs that are checked first for prices\n    @return Array of oracle partner IDs in priority order\n    \"\"\"\n    return self.priorityOraclePartnerIds\n\n\n@view\n@internal\ndef _sanitizePriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> DynArray[uint256, MAX_PRIORITY_PARTNERS]:\n    sanitizedIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = []\n    for i: uint256 in range(len(_priorityIds), bound=MAX_PRIORITY_PARTNERS):\n        pid: uint256 = _priorityIds[i]\n        if not self._isValidOraclePartnerId(pid):\n            continue\n        if pid in sanitizedIds:\n            continue\n        sanitizedIds.append(pid)\n    return sanitizedIds\n\n\n@view\n@external\ndef areValidPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    \"\"\"\n    @notice Check if a list of priority oracle partner IDs is valid\n    @dev Validates IDs exist and are not duplicated\n    @param _priorityIds Array of oracle partner IDs to validate\n    @return True if all IDs are valid, False otherwise\n    \"\"\"\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self._sanitizePriorityOraclePartnerIds(_priorityIds)\n    return self._areValidPriorityOraclePartnerIds(priorityIds)\n\n\n@view\n@internal\ndef _areValidPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    return len(_priorityIds) != 0\n\n\n@external\ndef setPriorityOraclePartnerIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS]) -> bool:\n    \"\"\"\n    @notice Set the list of priority oracle partner IDs\n    @dev Only callable by governor when registry is activated\n    @param _priorityIds Array of oracle partner IDs in desired priority order\n    @return True if priority list was set successfully, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PARTNERS] = self._sanitizePriorityOraclePartnerIds(_priorityIds)\n    if not self._areValidPriorityOraclePartnerIds(priorityIds):\n        return False\n\n    self.priorityOraclePartnerIds = priorityIds\n    log PriorityOraclePartnerIdsModified(numIds=len(priorityIds))\n    return True\n\n\n##############\n# Stale Time #\n##############\n\n\n@view\n@external\ndef isValidStaleTime(_staleTime: uint256) -> bool:\n    \"\"\"\n    @notice Check if a stale time value is valid\n    @dev Validates against minimum and maximum allowed stale times\n    @param _staleTime The stale time in seconds to validate\n    @return True if stale time is valid, False otherwise\n    \"\"\"\n    return self._isValidStaleTime(_staleTime)\n\n\n@view\n@internal\ndef _isValidStaleTime(_staleTime: uint256) -> bool:\n    return _staleTime >= MIN_STALE_TIME and _staleTime <= MAX_STALE_TIME\n\n\n@external\ndef setStaleTime(_staleTime: uint256) -> bool:\n    \"\"\"\n    @notice Set the stale time for price feeds\n    @dev Only callable by governor when registry is activated\n    @param _staleTime The stale time in seconds\n    @return True if stale time was set successfully, False otherwise\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    if not self._isValidStaleTime(_staleTime):\n        return False\n\n    self.staleTime = _staleTime\n    log StaleTimeSet(staleTime=_staleTime)\n    return True\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid\n\n\n@view\n@external\ndef isValidOraclePartnerAddr(_addr: address) -> bool:\n    \"\"\"\n    @notice Check if an address is a registered oracle partner\n    @dev Returns true if address has a non-zero oracle partner ID\n    @param _addr The address to check\n    @return True if address is a registered oracle partner, False otherwise\n    \"\"\"\n    return self.oraclePartnerAddrToId[_addr] != 0\n\n\n@view\n@external\ndef isValidOraclePartnerId(_oracleId: uint256) -> bool:\n    \"\"\"\n    @notice Check if an oracle partner ID is valid\n    @dev ID must be non-zero and less than total number of oracle partners\n    @param _oracleId The ID to check\n    @return True if ID is valid, False otherwise\n    \"\"\"\n    return self._isValidOraclePartnerId(_oracleId)\n\n\n@view\n@internal\ndef _isValidOraclePartnerId(_oracleId: uint256) -> bool:\n    return _oracleId != 0 and _oracleId < self.numOraclePartners\n\n\n# oracle partner getters\n\n\n@view\n@external\ndef getOraclePartnerId(_addr: address) -> uint256:\n    \"\"\"\n    @notice Get the ID of an oracle partner from its address\n    @dev Returns 0 if address is not registered\n    @param _addr The address to query\n    @return The oracle partner ID associated with the address\n    \"\"\"\n    return self.oraclePartnerAddrToId[_addr]\n\n\n@view\n@external\ndef getOraclePartnerAddr(_oracleId: uint256) -> address:\n    \"\"\"\n    @notice Get the address of an oracle partner from its ID\n    @dev Returns empty address if ID is invalid or partner is disabled\n    @param _oracleId The ID to query\n    @return The address associated with the oracle partner ID\n    \"\"\"\n    return self.oraclePartnerInfo[_oracleId].addr\n\n\n@view\n@external\ndef getOraclePartnerInfo(_oracleId: uint256) -> OraclePartnerInfo:\n    \"\"\"\n    @notice Get all information about an oracle partner\n    @dev Returns complete OraclePartnerInfo struct including address, version, timestamp and description\n    @param _oracleId The ID to query\n    @return OraclePartnerInfo struct containing all oracle partner information\n    \"\"\"\n    return self.oraclePartnerInfo[_oracleId]\n\n\n@view\n@external\ndef getOraclePartnerDescription(_oracleId: uint256) -> String[64]:\n    \"\"\"\n    @notice Get the description of an oracle partner\n    @dev Returns empty string if ID is invalid\n    @param _oracleId The ID to query\n    @return The description associated with the oracle partner ID\n    \"\"\"\n    return self.oraclePartnerInfo[_oracleId].description\n\n\n# high level\n\n\n@view\n@external\ndef getNumOraclePartners() -> uint256:\n    \"\"\"\n    @notice Get the total number of registered oracle partners\n    @dev Returns number of partners minus 1 since indexing starts at 1\n    @return The total number of registered oracle partners\n    \"\"\"\n    return self.numOraclePartners - 1\n\n\n@view\n@external\ndef getLastOraclePartnerAddr() -> address:\n    \"\"\"\n    @notice Get the address of the most recently registered oracle partner\n    @dev Returns the address at index (numOraclePartners - 1)\n    @return The address of the last registered oracle partner\n    \"\"\"\n    lastIndex: uint256 = self.numOraclePartners - 1\n    return self.oraclePartnerInfo[lastIndex].addr\n\n\n@view\n@external\ndef getLastOraclePartnerId() -> uint256:\n    \"\"\"\n    @notice Get the ID of the most recently registered oracle partner\n    @dev Returns numOraclePartners - 1 since indexing starts at 1\n    @return The ID of the last registered oracle partner\n    \"\"\"\n    return self.numOraclePartners - 1\n",
            "sha256sum": "5e6257673fe9c79579ab16e6fb577b16d3ad54de66ae3f2dd6f0bada3596e068"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/OracleRegistry.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "30535505afc697c84fd4cf9c27fce356aec5b3c378da45073bdb23c2399bffec"
      },
      "args": "000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000003f48000000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    },
    "PriceSheets": {
      "address": "0x59918c90eD44a3D7a72375f60C0148Ae18001ADC",
      "abi": [
        {
          "name": "AgentSubPriceSet",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAgentSubPriceSet",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "effectiveBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolSubPriceSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentSubPriceRemoved",
          "inputs": [
            {
              "name": "agent",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolSubPriceRemoved",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "trialPeriod",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "payPeriod",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AgentSubPricingEnabled",
          "inputs": [
            {
              "name": "isEnabled",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolTxPriceSheetSet",
          "inputs": [
            {
              "name": "depositFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "withdrawalFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rebalanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "transferFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "addLiqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "removeLiqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimRewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "borrowFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "repayFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolTxPriceSheetRemoved",
          "inputs": [
            {
              "name": "depositFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "withdrawalFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "rebalanceFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "transferFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "swapFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "addLiqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "removeLiqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimRewardsFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "borrowFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "repayFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ProtocolRecipientSet",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceChangeDelaySet",
          "inputs": [
            {
              "name": "delayBlocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSheetsActivated",
          "inputs": [
            {
              "name": "isActivated",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LocalGovernorSet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isGovernor",
          "inputs": [
            {
              "name": "_address",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLocalGovernor",
          "inputs": [
            {
              "name": "_newGovernor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "localGovernor",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCombinedSubData",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_agentPaidThru",
              "type": "uint256"
            },
            {
              "name": "_protocolPaidThru",
              "type": "uint256"
            },
            {
              "name": "_oracleRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "paidThroughBlock",
                  "type": "uint256"
                },
                {
                  "name": "didChange",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAgentSubPriceData",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidSubPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finalizePendingAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAgentSubPrice",
          "inputs": [
            {
              "name": "_agent",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAgentSubPricingEnabled",
          "inputs": [
            {
              "name": "_isEnabled",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolSubPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_trialPeriod",
              "type": "uint256"
            },
            {
              "name": "_payPeriod",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeProtocolSubPrice",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTransactionFeeData",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_action",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidTxPriceSheet",
          "inputs": [
            {
              "name": "_depositFee",
              "type": "uint256"
            },
            {
              "name": "_withdrawalFee",
              "type": "uint256"
            },
            {
              "name": "_rebalanceFee",
              "type": "uint256"
            },
            {
              "name": "_transferFee",
              "type": "uint256"
            },
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_addLiqFee",
              "type": "uint256"
            },
            {
              "name": "_removeLiqFee",
              "type": "uint256"
            },
            {
              "name": "_claimRewardsFee",
              "type": "uint256"
            },
            {
              "name": "_borrowFee",
              "type": "uint256"
            },
            {
              "name": "_repayFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolTxPriceSheet",
          "inputs": [
            {
              "name": "_depositFee",
              "type": "uint256"
            },
            {
              "name": "_withdrawalFee",
              "type": "uint256"
            },
            {
              "name": "_rebalanceFee",
              "type": "uint256"
            },
            {
              "name": "_transferFee",
              "type": "uint256"
            },
            {
              "name": "_swapFee",
              "type": "uint256"
            },
            {
              "name": "_addLiqFee",
              "type": "uint256"
            },
            {
              "name": "_removeLiqFee",
              "type": "uint256"
            },
            {
              "name": "_claimRewardsFee",
              "type": "uint256"
            },
            {
              "name": "_borrowFee",
              "type": "uint256"
            },
            {
              "name": "_repayFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeProtocolTxPriceSheet",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setProtocolRecipient",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriceChangeDelay",
          "inputs": [
            {
              "name": "_delayBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "activate",
          "inputs": [
            {
              "name": "_shouldActivate",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolRecipient",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolTxPriceData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "depositFee",
                  "type": "uint256"
                },
                {
                  "name": "withdrawalFee",
                  "type": "uint256"
                },
                {
                  "name": "rebalanceFee",
                  "type": "uint256"
                },
                {
                  "name": "transferFee",
                  "type": "uint256"
                },
                {
                  "name": "swapFee",
                  "type": "uint256"
                },
                {
                  "name": "addLiqFee",
                  "type": "uint256"
                },
                {
                  "name": "removeLiqFee",
                  "type": "uint256"
                },
                {
                  "name": "claimRewardsFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowFee",
                  "type": "uint256"
                },
                {
                  "name": "repayFee",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "protocolSubPriceData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isAgentSubPricingEnabled",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "agentSubPriceData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "usdValue",
                  "type": "uint256"
                },
                {
                  "name": "trialPeriod",
                  "type": "uint256"
                },
                {
                  "name": "payPeriod",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAgentSubPrices",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "subInfo",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "asset",
                      "type": "address"
                    },
                    {
                      "name": "usdValue",
                      "type": "uint256"
                    },
                    {
                      "name": "trialPeriod",
                      "type": "uint256"
                    },
                    {
                      "name": "payPeriod",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "effectiveBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priceChangeDelay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ADDY_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isActivated",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_TRIAL_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_TRIAL_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_PAY_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_PAY_PERIOD",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_PRICE_CHANGE_BUFFER",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_minTrialPeriod",
              "type": "uint256"
            },
            {
              "name": "_maxTrialPeriod",
              "type": "uint256"
            },
            {
              "name": "_minPayPeriod",
              "type": "uint256"
            },
            {
              "name": "_maxPayPeriod",
              "type": "uint256"
            },
            {
              "name": "_minPriceChangeBuffer",
              "type": "uint256"
            },
            {
              "name": "_addyRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Governable.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninterface AddyRegistry:\n    def governor() -> address: view\n\nevent LocalGovernorSet:\n    addr: indexed(address)\n\nlocalGovernor: public(address)\nADDY_REGISTRY: immutable(address)\n\n\n@deploy\ndef __init__(_addyRegistry: address):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    ADDY_REGISTRY = _addyRegistry\n\n\n#############\n# Utilities #\n#############\n\n\n@view\n@external\ndef isGovernor(_address: address) -> bool:\n    return self._isGovernor(_address)\n\n\n@view\n@internal\ndef _isGovernor(_address: address) -> bool:\n    return _address in [self.localGovernor, staticcall AddyRegistry(ADDY_REGISTRY).governor()]\n\n\n################\n# Set Governor #\n################\n\n\n@view\n@external \ndef isValidLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    return self._isValidLocalGovernor(_newGovernor, mainGovernor)\n\n\n@view\n@internal \ndef _isValidLocalGovernor(_newGovernor: address, _mainGovernor: address) -> bool:\n    if _newGovernor == _mainGovernor:\n        return False\n    if _newGovernor != empty(address) and not _newGovernor.is_contract:\n        return False\n    return _newGovernor != self.localGovernor\n\n\n@external\ndef setLocalGovernor(_newGovernor: address) -> bool:\n    mainGovernor: address = staticcall AddyRegistry(ADDY_REGISTRY).governor()\n    assert msg.sender == mainGovernor # dev: no perms\n    if not self._isValidLocalGovernor(_newGovernor, mainGovernor):\n        return False\n    self.localGovernor = _newGovernor\n    log LocalGovernorSet(addr=_newGovernor)\n    return True",
            "sha256sum": "ea0a278c869c598026d8e8edd3bda98f4e8efd29df66b6679613a145d52324f7"
          },
          "contracts/core/PriceSheets.vy": {
            "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\ninitializes: gov\nexports: gov.__interface__\nimport contracts.modules.Governable as gov\n\ninterface AddyRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n    def governor() -> address: view\n\ninterface OracleRegistry:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface AgentFactory:\n    def isAgent(_agent: address) -> bool: view\n\ninterface Agent:\n    def owner() -> address: view\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct TxPriceSheet:\n    depositFee: uint256\n    withdrawalFee: uint256\n    rebalanceFee: uint256\n    transferFee: uint256\n    swapFee: uint256\n    addLiqFee: uint256\n    removeLiqFee: uint256\n    claimRewardsFee: uint256\n    borrowFee: uint256\n    repayFee: uint256\n\nstruct SubscriptionInfo:\n    asset: address\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nstruct SubPaymentInfo:\n    recipient: address\n    asset: address\n    amount: uint256\n    usdValue: uint256\n    paidThroughBlock: uint256\n    didChange: bool\n\nstruct PendingSubPrice:\n    subInfo: SubscriptionInfo\n    effectiveBlock: uint256\n\nevent AgentSubPriceSet:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent PendingAgentSubPriceSet:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n    effectiveBlock: uint256\n\nevent ProtocolSubPriceSet:\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent AgentSubPriceRemoved:\n    agent: indexed(address)\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent ProtocolSubPriceRemoved:\n    asset: indexed(address)\n    usdValue: uint256\n    trialPeriod: uint256\n    payPeriod: uint256\n\nevent AgentSubPricingEnabled:\n    isEnabled: bool\n\nevent ProtocolTxPriceSheetSet:\n    depositFee: uint256\n    withdrawalFee: uint256\n    rebalanceFee: uint256\n    transferFee: uint256\n    swapFee: uint256\n    addLiqFee: uint256\n    removeLiqFee: uint256\n    claimRewardsFee: uint256\n    borrowFee: uint256\n    repayFee: uint256\n\nevent ProtocolTxPriceSheetRemoved:\n    depositFee: uint256\n    withdrawalFee: uint256\n    rebalanceFee: uint256\n    transferFee: uint256\n    swapFee: uint256\n    addLiqFee: uint256\n    removeLiqFee: uint256\n    claimRewardsFee: uint256\n    borrowFee: uint256\n    repayFee: uint256\n\nevent ProtocolRecipientSet:\n    recipient: indexed(address)\n\nevent PriceChangeDelaySet:\n    delayBlocks: uint256\n\nevent PriceSheetsActivated:\n    isActivated: bool\n\n# protocol pricing\nprotocolRecipient: public(address) # protocol recipient\nprotocolTxPriceData: public(TxPriceSheet) # protocol transaction pricing\nprotocolSubPriceData: public(SubscriptionInfo) # protocol subscription pricing\n\n# agent pricing\nisAgentSubPricingEnabled: public(bool)\nagentSubPriceData: public(HashMap[address, SubscriptionInfo]) # agent -> subscription pricing\n\n# pending price changes\npendingAgentSubPrices: public(HashMap[address, PendingSubPrice])\npriceChangeDelay: public(uint256) # number of blocks that must pass before price changes take effect\n\n# config\nADDY_REGISTRY: public(immutable(address))\nisActivated: public(bool)\n\n# registry ids\nAGENT_FACTORY_ID: constant(uint256) = 1\n\nMIN_TRIAL_PERIOD: public(immutable(uint256))\nMAX_TRIAL_PERIOD: public(immutable(uint256))\nMIN_PAY_PERIOD: public(immutable(uint256))\nMAX_PAY_PERIOD: public(immutable(uint256))\nMIN_PRICE_CHANGE_BUFFER: public(immutable(uint256))\n\nMAX_TX_FEE: constant(uint256) = 10_00 # 10.00%\n\n\n@deploy\ndef __init__(\n    _minTrialPeriod: uint256,\n    _maxTrialPeriod: uint256,\n    _minPayPeriod: uint256,\n    _maxPayPeriod: uint256,\n    _minPriceChangeBuffer: uint256,\n    _addyRegistry: address,\n):\n    assert _addyRegistry != empty(address) # dev: invalid addy registry\n    gov.__init__(_addyRegistry)\n    self.protocolRecipient = staticcall AddyRegistry(_addyRegistry).governor()\n    self.isActivated = True\n\n    ADDY_REGISTRY = _addyRegistry\n    MIN_TRIAL_PERIOD = _minTrialPeriod\n    MAX_TRIAL_PERIOD = _maxTrialPeriod\n    MIN_PAY_PERIOD = _minPayPeriod\n    MAX_PAY_PERIOD = _maxPayPeriod\n    MIN_PRICE_CHANGE_BUFFER = _minPriceChangeBuffer\n\n\n@view\n@internal\ndef _isRegisteredAgent(_agent: address) -> bool:\n    agentFactory: address = staticcall AddyRegistry(ADDY_REGISTRY).getAddy(AGENT_FACTORY_ID)\n    return staticcall AgentFactory(agentFactory).isAgent(_agent)\n\n\n######################\n# Subscription Utils #\n######################\n\n\n@view\n@external\ndef getCombinedSubData(_user: address, _agent: address, _agentPaidThru: uint256, _protocolPaidThru: uint256, _oracleRegistry: address) -> (SubPaymentInfo, SubPaymentInfo):\n    \"\"\"\n    @notice Get combined subscription data for an agent and protocol\n    @dev Returns a struct containing payment amounts and paid through blocks for both agent and protocol\n    @param _user The address of the user\n    @param _agent The address of the agent\n    @param _agentPaidThru The paid through block for the agent\n    @param _protocolPaidThru The paid through block for the protocol\n    @param _oracleRegistry The address of the oracle registry\n    @return protocolData struct containing payment amounts and paid through blocks for the protocol\n    @return agentData struct containing payment amounts and paid through blocks for the agent\n    \"\"\"\n    # NOTE: in future, we may have different pricing tiers depending on the `_user`\n\n    # protocol sub info\n    protocolData: SubPaymentInfo = self._updatePaidThroughBlock(_protocolPaidThru, self.protocolSubPriceData, _oracleRegistry)\n    if protocolData.amount != 0:\n        protocolData.recipient = self.protocolRecipient\n\n    # agent sub info\n    agentData: SubPaymentInfo = empty(SubPaymentInfo)\n    if _agent != empty(address):\n        agentData = self._updatePaidThroughBlock(_agentPaidThru, self.agentSubPriceData[_agent], _oracleRegistry)\n        agentData.recipient = _agent\n\n    return protocolData, agentData\n\n\n@view\n@internal\ndef _updatePaidThroughBlock(_paidThroughBlock: uint256, _subData: SubscriptionInfo, _oracleRegistry: address) -> SubPaymentInfo:\n    data: SubPaymentInfo = empty(SubPaymentInfo)\n    data.paidThroughBlock = _paidThroughBlock\n\n    # subscription was added (since last checked)\n    if _paidThroughBlock == 0 and _subData.usdValue != 0:\n        data.paidThroughBlock = block.number + _subData.trialPeriod\n        data.didChange = True\n\n    # subscription was removed (since last checked)\n    elif _paidThroughBlock != 0 and _subData.usdValue == 0:\n        data.paidThroughBlock = 0\n        data.didChange = True\n\n    # check if subscription needs to be paid\n    if data.paidThroughBlock != 0 and block.number > data.paidThroughBlock:\n        data.amount = staticcall OracleRegistry(_oracleRegistry).getAssetAmount(_subData.asset, _subData.usdValue)\n\n        # if something fails with price feed, allow transaction through.\n        # it's on agent developer to make sure price feed is working, so they can get paid\n        if data.amount != 0:\n            data.paidThroughBlock = block.number + _subData.payPeriod\n            data.usdValue = _subData.usdValue\n            data.asset = _subData.asset\n            data.didChange = True\n\n    return data\n\n\n######################\n# Agent Subscription #\n######################\n\n\n@view\n@external\ndef getAgentSubPriceData(_agent: address) -> SubscriptionInfo:\n    \"\"\"\n    @notice Get the subscription pricing data for a specific agent\n    @dev Returns empty SubscriptionInfo if agent subscription pricing is disabled\n    @param _agent The address of the agent to query\n    @return SubscriptionInfo struct containing subscription details\n    \"\"\"\n    if not self.isAgentSubPricingEnabled:\n        return empty(SubscriptionInfo)\n    return self.agentSubPriceData[_agent]\n\n\n# set agent sub price\n\n\n@view\n@external\ndef isValidSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Check if subscription price parameters are valid\n    @dev Validates asset, USD value, trial period, and pay period against constraints\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if all parameters are valid\n    \"\"\"\n    return self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod)\n\n\n@view\n@internal\ndef _isValidSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    if _asset == empty(address):\n        return False\n\n    if _payPeriod < MIN_PAY_PERIOD or _payPeriod > MAX_PAY_PERIOD:\n        return False\n\n    if _trialPeriod < MIN_TRIAL_PERIOD or _trialPeriod > MAX_TRIAL_PERIOD:\n        return False\n\n    return _usdValue != 0\n\n\n@external\ndef setAgentSubPrice(_agent: address, _asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Set subscription pricing for a specific agent\n    @dev Creates a pending subscription price change that can be finalized after priceChangeDelay blocks\n    @param _agent The address of the agent\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if pending subscription price was set successfully\n    \"\"\"\n    assert self._isRegisteredAgent(_agent) # dev: agent not registered\n    isAgentOwner: bool = staticcall Agent(_agent).owner() == msg.sender\n    assert isAgentOwner or gov._isGovernor(msg.sender) # dev: no perms\n\n    if isAgentOwner:\n        assert self.isActivated # dev: not active\n\n    # validation\n    assert _agent != empty(address) # dev: invalid agent\n    if not self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod):\n        return False\n\n    # create pending subscription price\n    subInfo: SubscriptionInfo = SubscriptionInfo(\n        asset=_asset,\n        usdValue=_usdValue,\n        trialPeriod=_trialPeriod,\n        payPeriod=_payPeriod,\n    )\n\n    # set price change immediately if delay is 0\n    priceChangeDelay: uint256 = self.priceChangeDelay\n    if priceChangeDelay == 0:\n        self._setAgentSubPrice(_agent, subInfo)\n        return True\n\n    # set pending price change\n    effectiveBlock: uint256 = block.number + priceChangeDelay\n    self.pendingAgentSubPrices[_agent] = PendingSubPrice(subInfo=subInfo, effectiveBlock=effectiveBlock)\n    log PendingAgentSubPriceSet(agent=_agent, asset=_asset, usdValue=_usdValue, trialPeriod=_trialPeriod, payPeriod=_payPeriod, effectiveBlock=effectiveBlock)\n\n    return True\n\n\n# finalize agent sub price\n\n\n@external\ndef finalizePendingAgentSubPrice(_agent: address) -> bool:\n    \"\"\"\n    @notice Finalize a pending subscription price for an agent\n    @dev Can only be called after priceChangeDelay blocks have passed since the pending change was created\n    @param _agent The address of the agent\n    @return bool True if subscription price was finalized successfully\n    \"\"\"\n    assert self.isActivated # dev: not active\n\n    pendingPrice: PendingSubPrice = self.pendingAgentSubPrices[_agent]\n    assert pendingPrice.effectiveBlock != 0 and block.number >= pendingPrice.effectiveBlock # dev: time delay not reached\n    self.pendingAgentSubPrices[_agent] = empty(PendingSubPrice)\n\n    # apply pending subscription price\n    self._setAgentSubPrice(_agent, pendingPrice.subInfo)\n    return True\n\n\n@internal\ndef _setAgentSubPrice(_agent: address, _subInfo: SubscriptionInfo):\n    self.agentSubPriceData[_agent] = _subInfo\n    log AgentSubPriceSet(agent=_agent, asset=_subInfo.asset, usdValue=_subInfo.usdValue, trialPeriod=_subInfo.trialPeriod, payPeriod=_subInfo.payPeriod)\n\n\n# removing agent sub price\n\n\n@external\ndef removeAgentSubPrice(_agent: address) -> bool:\n    \"\"\"\n    @notice Remove subscription pricing for a specific agent\n    @dev Only callable by governor\n    @param _agent The address of the agent\n    @return bool True if agent subscription price was removed successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    assert self._isRegisteredAgent(_agent) # dev: agent not registered\n\n    prevInfo: SubscriptionInfo = self.agentSubPriceData[_agent]\n    if empty(address) in [prevInfo.asset, _agent]:\n        return False\n\n    self.agentSubPriceData[_agent] = empty(SubscriptionInfo)\n    log AgentSubPriceRemoved(agent=_agent, asset=prevInfo.asset, usdValue=prevInfo.usdValue, trialPeriod=prevInfo.trialPeriod, payPeriod=prevInfo.payPeriod)\n    return True\n\n\n# enable / disable agent sub pricing\n\n\n@external\ndef setAgentSubPricingEnabled(_isEnabled: bool) -> bool:\n    \"\"\"\n    @notice Enable or disable agent subscription pricing\n    @dev Only callable by governor\n    @param _isEnabled True to enable, False to disable\n    @return bool True if agent subscription pricing state was changed successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    assert _isEnabled != self.isAgentSubPricingEnabled # dev: no change\n    self.isAgentSubPricingEnabled = _isEnabled\n    log AgentSubPricingEnabled(isEnabled=_isEnabled)\n    return True\n\n\n#########################\n# Protocol Subscription #\n#########################\n\n\n# set protocol sub price\n\n\n@external\ndef setProtocolSubPrice(_asset: address, _usdValue: uint256, _trialPeriod: uint256, _payPeriod: uint256) -> bool:\n    \"\"\"\n    @notice Set subscription pricing for the protocol\n    @dev Only callable by governor\n    @param _asset The token address for subscription payments\n    @param _usdValue The USD value of the subscription\n    @param _trialPeriod The trial period in blocks\n    @param _payPeriod The payment period in blocks\n    @return bool True if protocol subscription price was set successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    # validation\n    if not self._isValidSubPrice(_asset, _usdValue, _trialPeriod, _payPeriod):\n        return False\n\n    # save data\n    self.protocolSubPriceData = SubscriptionInfo(\n        asset=_asset,\n        usdValue=_usdValue,\n        trialPeriod=_trialPeriod,\n        payPeriod=_payPeriod,\n    )\n\n    log ProtocolSubPriceSet(asset=_asset, usdValue=_usdValue, trialPeriod=_trialPeriod, payPeriod=_payPeriod)\n    return True\n\n\n# removing protocol sub price\n\n\n@external\ndef removeProtocolSubPrice() -> bool:\n    \"\"\"\n    @notice Remove subscription pricing for the protocol\n    @dev Only callable by governor\n    @return bool True if protocol subscription price was removed successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    prevInfo: SubscriptionInfo = self.protocolSubPriceData\n    if prevInfo.asset == empty(address):\n        return False\n\n    self.protocolSubPriceData = empty(SubscriptionInfo)\n    log ProtocolSubPriceRemoved(asset=prevInfo.asset, usdValue=prevInfo.usdValue, trialPeriod=prevInfo.trialPeriod, payPeriod=prevInfo.payPeriod)\n    return True\n\n\n####################\n# Protocol Tx Fees #\n####################\n\n\n# utilities\n\n\n@view\n@external\ndef getTransactionFeeData(_user: address, _action: ActionType) -> (uint256, address):\n    \"\"\"\n    @notice Get transaction fee data for the protocol\n    @dev Returns a tuple containing the fee amount and recipient address for the protocol\n    @param _user The address of the user\n    @param _action The type of action being performed\n    @return feeAmount The fee amount for the action\n    @return recipient The recipient address for the fee\n    \"\"\"\n    # NOTE: in future, we may have different pricing tiers depending on the `_user`\n    return self._getTxFeeForAction(_action, self.protocolTxPriceData), self.protocolRecipient\n\n\n@view\n@internal\ndef _getTxFeeForAction(_action: ActionType, _prices: TxPriceSheet) -> uint256:\n    if _action == ActionType.DEPOSIT:\n        return _prices.depositFee\n    elif _action == ActionType.WITHDRAWAL:\n        return _prices.withdrawalFee\n    elif _action == ActionType.REBALANCE:\n        return _prices.rebalanceFee\n    elif _action == ActionType.TRANSFER:\n        return _prices.transferFee\n    elif _action == ActionType.SWAP:\n        return _prices.swapFee\n    elif _action == ActionType.ADD_LIQ:\n        return _prices.addLiqFee\n    elif _action == ActionType.REMOVE_LIQ:\n        return _prices.removeLiqFee\n    elif _action == ActionType.CLAIM_REWARDS:\n        return _prices.claimRewardsFee\n    elif _action == ActionType.BORROW:\n        return _prices.borrowFee\n    elif _action == ActionType.REPAY:\n        return _prices.repayFee\n    else:\n        return 0\n\n\n# set protocol tx price sheet\n\n\n@view\n@external\ndef isValidTxPriceSheet(\n    _depositFee: uint256,\n    _withdrawalFee: uint256,\n    _rebalanceFee: uint256,\n    _transferFee: uint256,\n    _swapFee: uint256,\n    _addLiqFee: uint256,\n    _removeLiqFee: uint256,\n    _claimRewardsFee: uint256,\n    _borrowFee: uint256,\n    _repayFee: uint256,\n) -> bool:\n    \"\"\"\n    @notice Check if transaction price sheet parameters are valid\n    @dev Validates fee percentages against constraints\n    @param _depositFee The fee percentage for deposits\n    @param _withdrawalFee The fee percentage for withdrawals\n    @param _rebalanceFee The fee percentage for rebalances\n    @param _transferFee The fee percentage for transfers\n    @param _swapFee The fee percentage for swaps\n    @param _addLiqFee The fee percentage for adding liquidity\n    @param _removeLiqFee The fee percentage for removing liquidity\n    @param _claimRewardsFee The fee percentage for claiming rewards\n    @param _borrowFee The fee percentage for borrowing\n    @param _repayFee The fee percentage for repaying\n    @return bool True if all parameters are valid\n    \"\"\"\n    return self._isValidTxPriceSheet(_depositFee, _withdrawalFee, _rebalanceFee, _transferFee, _swapFee, _addLiqFee, _removeLiqFee, _claimRewardsFee, _borrowFee, _repayFee)\n\n\n@view\n@internal\ndef _isValidTxPriceSheet(\n    _depositFee: uint256,\n    _withdrawalFee: uint256,\n    _rebalanceFee: uint256,\n    _transferFee: uint256,\n    _swapFee: uint256,\n    _addLiqFee: uint256,\n    _removeLiqFee: uint256,\n    _claimRewardsFee: uint256,\n    _borrowFee: uint256,\n    _repayFee: uint256,\n) -> bool:\n    return _depositFee <= MAX_TX_FEE and _withdrawalFee <= MAX_TX_FEE and _rebalanceFee <= MAX_TX_FEE and _transferFee <= MAX_TX_FEE and _swapFee <= MAX_TX_FEE and _addLiqFee <= MAX_TX_FEE and _removeLiqFee <= MAX_TX_FEE and _claimRewardsFee <= MAX_TX_FEE and _borrowFee <= MAX_TX_FEE and _repayFee <= MAX_TX_FEE\n\n\n@external\ndef setProtocolTxPriceSheet(\n    _depositFee: uint256,\n    _withdrawalFee: uint256,\n    _rebalanceFee: uint256,\n    _transferFee: uint256,\n    _swapFee: uint256,\n    _addLiqFee: uint256,\n    _removeLiqFee: uint256,\n    _claimRewardsFee: uint256,\n    _borrowFee: uint256,\n    _repayFee: uint256,\n) -> bool:\n    \"\"\"\n    @notice Set transaction price sheet for the protocol\n    @dev Only callable by governor\n    @param _depositFee The fee percentage for deposits\n    @param _withdrawalFee The fee percentage for withdrawals\n    @param _rebalanceFee The fee percentage for rebalances\n    @param _transferFee The fee percentage for transfers\n    @param _swapFee The fee percentage for swaps\n    @param _addLiqFee The fee percentage for adding liquidity\n    @param _removeLiqFee The fee percentage for removing liquidity\n    @param _claimRewardsFee The fee percentage for claiming rewards\n    @param _borrowFee The fee percentage for borrowing\n    @param _repayFee The fee percentage for repaying\n    @return bool True if protocol price sheet was set successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    # validation\n    if not self._isValidTxPriceSheet(_depositFee, _withdrawalFee, _rebalanceFee, _transferFee, _swapFee, _addLiqFee, _removeLiqFee, _claimRewardsFee, _borrowFee, _repayFee):\n        return False\n\n    # save data\n    self.protocolTxPriceData = TxPriceSheet(\n        depositFee=_depositFee,\n        withdrawalFee=_withdrawalFee,\n        rebalanceFee=_rebalanceFee,\n        transferFee=_transferFee,\n        swapFee=_swapFee,\n        addLiqFee=_addLiqFee,\n        removeLiqFee=_removeLiqFee,\n        claimRewardsFee=_claimRewardsFee,\n        borrowFee=_borrowFee,\n        repayFee=_repayFee,\n    )\n\n    log ProtocolTxPriceSheetSet(depositFee=_depositFee, withdrawalFee=_withdrawalFee, rebalanceFee=_rebalanceFee, transferFee=_transferFee, swapFee=_swapFee, addLiqFee=_addLiqFee, removeLiqFee=_removeLiqFee, claimRewardsFee=_claimRewardsFee, borrowFee=_borrowFee, repayFee=_repayFee)\n    return True\n\n\n# remove protocol tx price sheet\n\n\n@external\ndef removeProtocolTxPriceSheet() -> bool:\n    \"\"\"\n    @notice Remove transaction price sheet for the protocol\n    @dev Only callable by governor\n    @return bool True if protocol price sheet was removed successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n\n    prevInfo: TxPriceSheet = self.protocolTxPriceData\n    self.protocolTxPriceData = empty(TxPriceSheet)\n    log ProtocolTxPriceSheetRemoved(depositFee=prevInfo.depositFee, withdrawalFee=prevInfo.withdrawalFee, rebalanceFee=prevInfo.rebalanceFee, transferFee=prevInfo.transferFee, swapFee=prevInfo.swapFee, addLiqFee=prevInfo.addLiqFee, removeLiqFee=prevInfo.removeLiqFee, claimRewardsFee=prevInfo.claimRewardsFee, borrowFee=prevInfo.borrowFee, repayFee=prevInfo.repayFee)\n    return True\n\n\n######################\n# Protocol Recipient #\n######################\n\n\n@external\ndef setProtocolRecipient(_recipient: address) -> bool:\n    \"\"\"\n    @notice Set the recipient address for protocol fees\n    @dev Only callable by governor\n    @param _recipient The address to receive protocol fees\n    @return bool True if protocol recipient was set successfully\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    assert _recipient != empty(address) # dev: invalid recipient\n    self.protocolRecipient = _recipient\n    log ProtocolRecipientSet(recipient=_recipient)\n    return True\n\n\n######################\n# Price Change Delay #\n######################\n\n\n@external\ndef setPriceChangeDelay(_delayBlocks: uint256) -> bool:\n    \"\"\"\n    @notice Set the number of blocks required before price changes take effect\n    @dev Only callable by governor\n    @param _delayBlocks The number of blocks to wait before price changes take effect\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    assert _delayBlocks == 0 or _delayBlocks >= MIN_PRICE_CHANGE_BUFFER # dev: invalid delay\n    self.priceChangeDelay = _delayBlocks\n    log PriceChangeDelaySet(delayBlocks=_delayBlocks)\n    return True\n\n\n############\n# Activate #\n############\n\n\n@external\ndef activate(_shouldActivate: bool):\n    \"\"\"\n    @notice Activate or deactivate the price sheets registry\n    @dev Only callable by governor. When deactivated, most functions cannot be called.\n    @param _shouldActivate True to activate, False to deactivate\n    \"\"\"\n    assert gov._isGovernor(msg.sender) # dev: no perms\n    self.isActivated = _shouldActivate\n    log PriceSheetsActivated(isActivated=_shouldActivate)\n",
            "sha256sum": "f5276f291fc4fd02da37ff4210db6d2dc773149a70a72a44cd57453981e8f010"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/PriceSheets.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "5a3332594aa58dcc5fdb91f9a152bebbbfd4636bc202f1cfa3ab9c8a48129acc"
      },
      "args": "000000000000000000000000000000000000000000000000000000000000a8c0000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000000000000000003b8260000000000000000000000000000000000000000000000000000000000000a8c000000000000000000000000049b08551e452ca99da7de9b3a60e39e5f10c13cd"
    }
  }
}