{
  "language": "Vyper",
  "sources": {
    "interfaces/UserWalletInterface.vyi": {
      "content": "# SPDX-License-Identifier: MIT\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/MIT_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\n\n# struct SwapInstruction:\n#     legoId: uint256\n#     amountIn: uint256\n#     minAmountOut: uint256\n#     tokenPath: DynArray[address, 5]\n#     poolPath: DynArray[address, 5 - 1]\n\n\n# @external\n# def swapTokens(_swapInstructions: DynArray[SwapInstruction, 5]) -> (uint256, uint256, uint256):\n#     ...\n\n\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256, uint256):\n    ...\n\n\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    ...\n\n\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    ...\n\n\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    ...\n\n\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    ...\n\n\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n) -> uint256:\n    ...\n\n\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    ...\n\n\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    ...\n\n\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    ...\n",
      "sha256sum": "b6f85ddff061e77069cceb9d110c05c679a6ea34b68f3ff69c95c1b07d83c453"
    },
    "contracts/core/AgentTemplate.vy": {
      "content": "# SPDX-License-Identifier: BUSL-1.1\n# Underscore Protocol License: https://github.com/underscore-finance/underscore/blob/main/licenses/BUSL_LICENSE\n# Underscore Protocol (C) 2025 Hightop Financial, Inc.\n# @version 0.4.1\n\nfrom interfaces import UserWalletInterface\nfrom ethereum.ercs import IERC20\n\ninterface UserWalletCustom:\n    def swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256): nonpayable\n\nflag ActionType:\n    DEPOSIT\n    WITHDRAWAL\n    REBALANCE\n    TRANSFER\n    SWAP\n    CONVERSION\n    ADD_LIQ\n    REMOVE_LIQ\n    CLAIM_REWARDS\n    BORROW\n    REPAY\n\nstruct Signature:\n    signature: Bytes[65]\n    signer: address\n    expiration: uint256\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct ActionInstruction:\n    usePrevAmountOut: bool\n    action: ActionType\n    legoId: uint256\n    asset: address\n    vault: address\n    amount: uint256\n    altLegoId: uint256\n    altAsset: address\n    altVault: address\n    altAmount: uint256\n    minAmountOut: uint256\n    pool: address\n    proof: bytes32\n    nftAddr: address\n    nftTokenId: uint256\n    tickLower: int24\n    tickUpper: int24\n    minAmountA: uint256\n    minAmountB: uint256\n    minLpAmount: uint256\n    liqToRemove: uint256\n    recipient: address\n    isWethToEthConversion: bool\n\nstruct PendingOwner:\n    newOwner: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeInitiated:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeConfirmed:\n    prevOwner: indexed(address)\n    newOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeCancelled:\n    cancelledOwner: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent AgentOwnershipChangeDelaySet:\n    delayBlocks: uint256\n\nevent AgentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\ninitialized: public(bool)\nusedSignatures: public(HashMap[Bytes[65], bool])\n\n# owner\nowner: public(address) # owner of the wallet\npendingOwner: public(PendingOwner) # pending owner of the wallet\nownershipChangeDelay: public(uint256) # num blocks to wait before owner can be changed\n\n# eip-712\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\nDEPOSIT_TYPE_HASH: constant(bytes32) = keccak256('Deposit(address userWallet,uint256 legoId,address asset,address vault,uint256 amount,uint256 expiration)')\nWITHDRAWAL_TYPE_HASH: constant(bytes32) = keccak256('Withdrawal(address userWallet,uint256 legoId,address asset,address vaultToken,uint256 vaultTokenAmount,uint256 expiration)')\nREBALANCE_TYPE_HASH: constant(bytes32) = keccak256('Rebalance(address userWallet,uint256 fromLegoId,address fromAsset,address fromVaultToken,uint256 toLegoId,address toVault,uint256 fromVaultTokenAmount,uint256 expiration)')\nSWAP_ACTION_TYPE_HASH: constant(bytes32) =  keccak256('Swap(address userWallet,SwapInstruction[] swapInstructions,uint256 expiration)')\nSWAP_INSTRUCTION_TYPE_HASH: constant(bytes32) = keccak256('SwapInstruction(uint256 legoId,uint256 amountIn,uint256 minAmountOut,address[] tokenPath,address[] poolPath)')\nADD_LIQ_TYPE_HASH: constant(bytes32) = keccak256('AddLiquidity(address userWallet,uint256 legoId,address nftAddr,uint256 nftTokenId,address pool,address tokenA,address tokenB,uint256 amountA,uint256 amountB,int24 tickLower,int24 tickUpper,uint256 minAmountA,uint256 minAmountB,uint256 minLpAmount,uint256 expiration)')\nREMOVE_LIQ_TYPE_HASH: constant(bytes32) = keccak256('RemoveLiquidity(address userWallet,uint256 legoId,address nftAddr,uint256 nftTokenId,address pool,address tokenA,address tokenB,uint256 liqToRemove,uint256 minAmountA,uint256 minAmountB,uint256 expiration)')\nTRANSFER_TYPE_HASH: constant(bytes32) = keccak256('Transfer(address userWallet,address recipient,uint256 amount,address asset,uint256 expiration)')\nETH_TO_WETH_TYPE_HASH: constant(bytes32) = keccak256('EthToWeth(address userWallet,uint256 amount,uint256 depositLegoId,address depositVault,uint256 expiration)')\nWETH_TO_ETH_TYPE_HASH: constant(bytes32) = keccak256('WethToEth(address userWallet,uint256 amount,address recipient,uint256 withdrawLegoId,address withdrawVaultToken,uint256 expiration)')\nCLAIM_REWARDS_TYPE_HASH: constant(bytes32) = keccak256('ClaimRewards(address userWallet,uint256 legoId,address market,address rewardToken,uint256 rewardAmount,bytes32 proof,uint256 expiration)')\nBORROW_TYPE_HASH: constant(bytes32) = keccak256('Borrow(address userWallet,uint256 legoId,address borrowAsset,uint256 amount,uint256 expiration)')\nREPAY_TYPE_HASH: constant(bytes32) = keccak256('Repay(address userWallet,uint256 legoId,address paymentAsset,uint256 paymentAmount,uint256 expiration)')\nBATCH_ACTIONS_TYPE_HASH: constant(bytes32) =  keccak256('BatchActions(address userWallet,ActionInstruction[] instructions,uint256 expiration)')\nACTION_INSTRUCTION_TYPE_HASH: constant(bytes32) = keccak256('ActionInstruction(bool usePrevAmountOut,uint256 action,uint256 legoId,address asset,address vault,uint256 amount,uint256 altLegoId,address altAsset,address altVault,uint256 altAmount,uint256 minAmountOut,address pool,bytes32 proof,address nftAddr,uint256 nftTokenId,int24 tickLower,int24 tickUpper,uint256 minAmountA,uint256 minAmountB,uint256 minLpAmount,uint256 liqToRemove,address recipient,bool isWethToEthConversion)')\n\nMIN_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_OWNER_CHANGE_DELAY: public(immutable(uint256))\nMAX_INSTRUCTIONS: constant(uint256) = 20\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\n\nAPI_VERSION: constant(String[28]) = \"0.0.1\"\n\n\n@deploy\ndef __init__(_minOwnerChangeDelay: uint256, _maxOwnerChangeDelay: uint256):\n    MIN_OWNER_CHANGE_DELAY = _minOwnerChangeDelay\n    MAX_OWNER_CHANGE_DELAY = _maxOwnerChangeDelay\n\n    # make sure original reference contract can't be initialized\n    self.initialized = True\n\n\n@external\ndef initialize(_owner: address) -> bool:\n    assert not self.initialized # dev: can only initialize once\n    self.initialized = True\n\n    assert empty(address) not in [_owner] # dev: invalid addr\n    self.owner = _owner\n    self.ownershipChangeDelay = MIN_OWNER_CHANGE_DELAY\n\n    return True\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    return API_VERSION\n\n\n###########\n# Deposit #\n###########\n\n\n@nonreentrant\n@external\ndef depositTokens(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(DEPOSIT_TYPE_HASH, _userWallet, _legoId, _asset, _vault, _amount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).depositTokens(_legoId, _asset, _vault, _amount)\n\n\n############\n# Withdraw #\n############\n\n\n@nonreentrant\n@external\ndef withdrawTokens(\n    _userWallet: address,\n    _legoId: uint256,\n    _asset: address,\n    _vaultToken: address,\n    _vaultTokenAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(WITHDRAWAL_TYPE_HASH, _userWallet, _legoId, _asset, _vaultToken, _vaultTokenAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).withdrawTokens(_legoId, _asset, _vaultToken, _vaultTokenAmount)\n\n\n#############\n# Rebalance #\n#############\n\n\n@nonreentrant\n@external\ndef rebalance(\n    _userWallet: address,\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultToken: address,\n    _toLegoId: uint256,\n    _toVault: address,\n    _fromVaultTokenAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REBALANCE_TYPE_HASH, _userWallet, _fromLegoId, _fromAsset, _fromVaultToken, _toLegoId, _toVault, _fromVaultTokenAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).rebalance(_fromLegoId, _fromAsset, _fromVaultToken, _toLegoId, _toVault, _fromVaultTokenAmount)\n\n\n########\n# Swap #\n########\n\n\n@nonreentrant\n@external\ndef swapTokens(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSwapSignature(self._hashSwapInstructions(_userWallet, _swapInstructions, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletCustom(_userWallet).swapTokens(_swapInstructions)\n\n\n@view\n@internal\ndef _encodeSwapInstruction(_instruction: SwapInstruction) -> Bytes[544]:\n    # Just encode, no hash\n    return abi_encode(\n        SWAP_INSTRUCTION_TYPE_HASH,\n        _instruction.legoId,\n        _instruction.amountIn,\n        _instruction.minAmountOut,\n        _instruction.tokenPath,\n        _instruction.poolPath\n    )\n\n\n@view\n@internal\ndef _encodeSwapInstructions(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> Bytes[2720]:\n    concatenated: Bytes[2720] = empty(Bytes[2720]) # max size for 5 instructions - 5*544\n    for i: uint256 in range(len(_swapInstructions), bound=MAX_SWAP_INSTRUCTIONS):\n        concatenated = convert(\n            concat(\n                concatenated, \n                self._encodeSwapInstruction(_swapInstructions[i])\n            ),\n            Bytes[2720]\n        )\n    return concatenated\n\n\n@view\n@internal\ndef _hashSwapInstructions(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _expiration: uint256,\n) -> Bytes[2880]:\n    # Now we encode everything and hash only once at the end\n    return abi_encode(\n        SWAP_ACTION_TYPE_HASH,\n        _userWallet,\n        self._encodeSwapInstructions(_swapInstructions),\n        _expiration\n    )\n\n\n@internal\ndef _isValidSwapSignature(_encodedValue: Bytes[2880], _sig: Signature):\n    encoded_hash: bytes32 = keccak256(_encodedValue)\n    domain_sep: bytes32 = self._domainSeparator()\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', domain_sep, encoded_hash))\n\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n@view\n@external\ndef getSwapActionHash(\n    _userWallet: address,\n    _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS],\n    _expiration: uint256,\n) -> bytes32:\n    encodedValue: Bytes[2880] = self._hashSwapInstructions(_userWallet, _swapInstructions, _expiration)\n    encoded_hash: bytes32 = keccak256(encodedValue)\n    return keccak256(concat(b'\\x19\\x01', self._domainSeparator(), encoded_hash))\n\n\n##################\n# Borrow + Repay #\n##################\n\n\n@nonreentrant\n@external\ndef borrow(\n    _userWallet: address,\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(BORROW_TYPE_HASH, _userWallet, _legoId, _borrowAsset, _amount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).borrow(_legoId, _borrowAsset, _amount)\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _userWallet: address,\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _sig: Signature = empty(Signature),\n) -> (address, uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REPAY_TYPE_HASH, _userWallet, _legoId, _paymentAsset, _paymentAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).repayDebt(_legoId, _paymentAsset, _paymentAmount)\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _userWallet: address,\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n    _sig: Signature = empty(Signature),\n):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(CLAIM_REWARDS_TYPE_HASH, _userWallet, _legoId, _market, _rewardToken, _rewardAmount, _proof, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    extcall UserWalletInterface(_userWallet).claimRewards(_legoId, _market, _rewardToken, _rewardAmount, _proof)\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(ADD_LIQ_TYPE_HASH, _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).addLiquidity(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount)\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _userWallet: address,\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256, uint256, bool):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(REMOVE_LIQ_TYPE_HASH, _userWallet, _legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).removeLiquidity(_legoId, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _liqToRemove, _minAmountA, _minAmountB)\n\n\n##################\n# Transfer Funds #\n##################\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _userWallet: address,\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> (uint256, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(TRANSFER_TYPE_HASH, _userWallet, _recipient, _amount, _asset, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).transferFunds(_recipient, _amount, _asset)\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@nonreentrant\n@external\ndef convertEthToWeth(\n    _userWallet: address,\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> (uint256, address, uint256):\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(ETH_TO_WETH_TYPE_HASH, _userWallet, _amount, _depositLegoId, _depositVault, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).convertEthToWeth(_amount, _depositLegoId, _depositVault)\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(\n    _userWallet: address,\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultToken: address = empty(address),\n    _sig: Signature = empty(Signature),\n) -> uint256:\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidSignature(abi_encode(WETH_TO_ETH_TYPE_HASH, _userWallet, _amount, _recipient, _withdrawLegoId, _withdrawVaultToken, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n    return extcall UserWalletInterface(_userWallet).convertWethToEth(_amount, _recipient, _withdrawLegoId, _withdrawVaultToken)\n\n\n#################\n# Batch Actions #\n#################\n\n\n@nonreentrant\n@external\ndef performBatchActions(\n    _userWallet: address,\n    _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS],\n    _sig: Signature = empty(Signature),\n) -> bool:\n    owner: address = self.owner\n    if msg.sender != owner:\n        self._isValidBatchSignature(self._hashBatchActions(_userWallet, _instructions, _sig.expiration), _sig)\n        assert _sig.signer == owner # dev: invalid signer\n\n    assert len(_instructions) != 0 # dev: no instructions\n    prevAmountReceived: uint256 = 0\n\n    # not using these vars\n    naAddyA: address = empty(address)\n    naValueA: uint256 = 0\n    naValueB: uint256 = 0\n    naValueC: uint256 = 0\n    naValueD: uint256 = 0\n    naBool: bool = False\n\n    # iterate through instructions\n    for j: uint256 in range(len(_instructions), bound=MAX_INSTRUCTIONS):\n        i: ActionInstruction = _instructions[j]\n\n        # deposit\n        if i.action == ActionType.DEPOSIT:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).depositTokens(i.legoId, i.asset, i.vault, amount)\n\n        # withdraw\n        elif i.action == ActionType.WITHDRAWAL:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            prevAmountReceived, naValueA, naValueB = extcall UserWalletInterface(_userWallet).withdrawTokens(i.legoId, i.asset, i.vault, amount)\n\n        # rebalance\n        elif i.action == ActionType.REBALANCE:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).rebalance(i.legoId, i.asset, i.vault, i.altLegoId, i.altVault, amount)\n\n        # borrow\n        elif i.action == ActionType.BORROW:\n            naAddyA, prevAmountReceived, naValueB = extcall UserWalletInterface(_userWallet).borrow(i.legoId, i.asset, i.amount)\n\n        # repay debt\n        elif i.action == ActionType.REPAY:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            extcall UserWalletInterface(_userWallet).repayDebt(i.legoId, i.asset, amount)\n            prevAmountReceived = 0\n\n        # claim rewards\n        elif i.action == ActionType.CLAIM_REWARDS:\n            extcall UserWalletInterface(_userWallet).claimRewards(i.legoId, i.asset, i.altAsset, i.amount, i.proof)\n            prevAmountReceived = 0\n\n        # add liquidity\n        elif i.action == ActionType.ADD_LIQ:\n            amount: uint256 = i.amount # this only goes towards token A amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            prevAmountReceived, naValueA, naValueB, naValueC, naValueD = extcall UserWalletInterface(_userWallet).addLiquidity(i.legoId, i.nftAddr, i.nftTokenId, i.pool, i.asset, i.altAsset, amount, i.altAmount, i.tickLower, i.tickUpper, i.minAmountA, i.minAmountB, i.minLpAmount)\n\n        # remove liquidity\n        elif i.action == ActionType.REMOVE_LIQ:\n            amount: uint256 = i.liqToRemove # this only goes to `_liqToRemove`\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            naValueA, naValueB, naValueC, naBool = extcall UserWalletInterface(_userWallet).removeLiquidity(i.legoId, i.nftAddr, i.nftTokenId, i.pool, i.asset, i.altAsset, amount, i.minAmountA, i.minAmountB)\n            prevAmountReceived = 0\n\n        # transfer\n        elif i.action == ActionType.TRANSFER:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            extcall UserWalletInterface(_userWallet).transferFunds(i.recipient, amount, i.asset)\n            prevAmountReceived = 0\n\n        # conversion\n        elif i.action == ActionType.CONVERSION:\n            amount: uint256 = i.amount\n            if i.usePrevAmountOut and prevAmountReceived != 0:\n                amount = prevAmountReceived\n            if i.isWethToEthConversion:\n                prevAmountReceived = extcall UserWalletInterface(_userWallet).convertWethToEth(amount, i.recipient, i.legoId, i.vault)\n            else:\n                prevAmountReceived, naAddyA, naValueB = extcall UserWalletInterface(_userWallet).convertEthToWeth(amount, i.legoId, i.vault)\n                if naValueB != 0:\n                    prevAmountReceived = naValueB\n\n    return True\n\n\n@view\n@internal\ndef _encodeBatchActionInstruction(_instr: ActionInstruction) -> Bytes[768]:\n    # Just encode, no hash\n    return abi_encode(\n        ACTION_INSTRUCTION_TYPE_HASH,\n        _instr.usePrevAmountOut,\n        _instr.action,\n        _instr.legoId,\n        _instr.asset,\n        _instr.vault,\n        _instr.amount,\n        _instr.altLegoId,\n        _instr.altAsset,\n        _instr.altVault,\n        _instr.altAmount,\n        _instr.minAmountOut,\n        _instr.pool,\n        _instr.proof,\n        _instr.nftAddr,\n        _instr.nftTokenId,\n        _instr.tickLower,\n        _instr.tickUpper,\n        _instr.minAmountA,\n        _instr.minAmountB,\n        _instr.minLpAmount,\n        _instr.liqToRemove,\n        _instr.recipient,\n        _instr.isWethToEthConversion\n    )\n\n\n@view\n@internal\ndef _encodeBatchInstructions(_instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS]) -> Bytes[15360]:\n    concatenated: Bytes[15360] = empty(Bytes[15360]) # max size for 20 instructions - 20*768\n    for i: uint256 in range(len(_instructions), bound=MAX_INSTRUCTIONS):\n        concatenated = convert(\n            concat(\n                concatenated, \n                self._encodeBatchActionInstruction(_instructions[i])\n            ),\n            Bytes[15360]\n        )\n    return concatenated\n\n\n@view\n@internal\ndef _hashBatchActions(_userWallet: address, _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS], _expiration: uint256) -> Bytes[15520]:\n    # Now we encode everything and hash only once at the end\n    return abi_encode(\n        BATCH_ACTIONS_TYPE_HASH,\n        _userWallet,\n        self._encodeBatchInstructions(_instructions),\n        _expiration\n    )\n\n\n@internal\ndef _isValidBatchSignature(_encodedValue: Bytes[15520], _sig: Signature):\n    encoded_hash: bytes32 = keccak256(_encodedValue)\n    domain_sep: bytes32 = self._domainSeparator()\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', domain_sep, encoded_hash))\n\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n@view\n@external\ndef getBatchActionHash(_userWallet: address, _instructions: DynArray[ActionInstruction, MAX_INSTRUCTIONS], _expiration: uint256) -> bytes32:\n    encodedValue: Bytes[15520] = self._hashBatchActions(_userWallet, _instructions, _expiration)\n    encoded_hash: bytes32 = keccak256(encodedValue)\n    return keccak256(concat(b'\\x19\\x01', self._domainSeparator(), encoded_hash))\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    return keccak256(\n        concat(\n            DOMAIN_TYPE_HASH,\n            keccak256('UnderscoreAgent'),\n            keccak256(API_VERSION),\n            abi_encode(chain.id, self)\n        )\n    )\n\n\n@internal\ndef _isValidSignature(_encodedValue: Bytes[736], _sig: Signature):\n    assert not self.usedSignatures[_sig.signature] # dev: signature already used\n    assert _sig.expiration >= block.timestamp # dev: signature expired\n\n    digest: bytes32 = keccak256(concat(b'\\x19\\x01', self._domainSeparator(), keccak256(_encodedValue)))\n\n    # NOTE: signature is packed as r, s, v\n    r: bytes32 = convert(slice(_sig.signature, 0, 32), bytes32)\n    s: bytes32 = convert(slice(_sig.signature, 32, 32), bytes32)\n    v: uint8 = convert(slice(_sig.signature, 64, 1), uint8)\n\n    response: Bytes[32] = raw_call(\n        ECRECOVER_PRECOMPILE,\n        abi_encode(digest, v, r, s),\n        max_outsize=32,\n        is_static_call=True # This is a view function\n    )\n\n    assert len(response) == 32 # dev: invalid ecrecover response length\n    assert abi_decode(response, address) == _sig.signer # dev: invalid signature\n    self.usedSignatures[_sig.signature] = True\n\n\n####################\n# Ownership Change #\n####################\n\n\n@external\ndef changeOwnership(_newOwner: address):\n    \"\"\"\n    @notice Initiates a new ownership change\n    @dev Can only be called by the current owner\n    @param _newOwner The address of the new owner\n    \"\"\"\n    currentOwner: address = self.owner\n    assert msg.sender == currentOwner # dev: no perms\n    assert _newOwner not in [empty(address), currentOwner] # dev: invalid new owner\n\n    confirmBlock: uint256 = block.number + self.ownershipChangeDelay\n    self.pendingOwner = PendingOwner(\n        newOwner= _newOwner,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log AgentOwnershipChangeInitiated(prevOwner=currentOwner, newOwner=_newOwner, confirmBlock=confirmBlock)\n\n\n@external\ndef confirmOwnershipChange():\n    \"\"\"\n    @notice Confirms the ownership change\n    @dev Can only be called by the new owner\n    \"\"\"\n    data: PendingOwner = self.pendingOwner\n    assert data.newOwner != empty(address) # dev: no pending owner\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time delay not reached\n    assert msg.sender == data.newOwner # dev: only new owner can confirm\n\n    prevOwner: address = self.owner\n    self.owner = data.newOwner\n    self.pendingOwner = empty(PendingOwner)\n    log AgentOwnershipChangeConfirmed(prevOwner=prevOwner, newOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef cancelOwnershipChange():\n    \"\"\"\n    @notice Cancels the ownership change\n    @dev Can only be called by the current owner\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    data: PendingOwner = self.pendingOwner\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingOwner = empty(PendingOwner)\n    log AgentOwnershipChangeCancelled(cancelledOwner=data.newOwner, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n@external\ndef setOwnershipChangeDelay(_numBlocks: uint256):\n    \"\"\"\n    @notice Sets the ownership change delay\n    @dev Can only be called by the owner\n    @param _numBlocks The number of blocks to wait before ownership can be changed\n    \"\"\"\n    assert msg.sender == self.owner # dev: no perms\n    assert _numBlocks >= MIN_OWNER_CHANGE_DELAY and _numBlocks <= MAX_OWNER_CHANGE_DELAY # dev: invalid delay\n    self.ownershipChangeDelay = _numBlocks\n    log AgentOwnershipChangeDelaySet(delayBlocks=_numBlocks)\n\n\n#################\n# Recover Funds #\n#################\n\n\n@external\ndef recoverFunds(_asset: address) -> bool:\n    \"\"\"\n    @notice transfers funds from the agent wallet to the owner\n    @dev anyone can call this!\n    @param _asset The address of the asset to recover\n    @return bool True if the funds were recovered successfully\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner # dev: no perms\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if empty(address) in [owner, _asset] or balance == 0:\n        return False\n\n    assert extcall IERC20(_asset).transfer(owner, balance, default_return_value=True) # dev: recovery failed\n    log AgentFundsRecovered(asset=_asset, recipient=owner, balance=balance)\n    return True\n",
      "sha256sum": "b8d4feb4eb5253d5c9ffe64756da40f537f45ddcefb1236b113db0842ac764cf"
    }
  },
  "settings": {
    "outputSelection": {
      "contracts/core/AgentTemplate.vy": [
        "*"
      ]
    },
    "search_paths": [
      "."
    ]
  },
  "compiler_version": "v0.4.1+commit.8a93dd27",
  "integrity": "1362b0186ba8a0156280ea672b4103413f00eb98a1a3b0615646541cc8da5257"
}